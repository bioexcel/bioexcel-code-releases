<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Gromacs: gmx Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Gromacs
   &#160;<span id="projectnumber">2016.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.xhtml"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.xhtml"><span>Modules</span></a></li>
      <li><a href="pages.xhtml"><span>Other&#160;Docs</span></a></li>
      <li class="current"><a href="namespaces.xhtml"><span>Namespaces</span></a></li>
      <li><a href="annotated.xhtml"><span>Classes</span></a></li>
      <li><a href="files.xhtml"><span>Files</span></a></li>
      <li><a href="examples.xhtml"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.xhtml"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.xhtml"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">gmx Namespace Reference<div class="ingroups"><a class="el" href="group__group__publicapi.xhtml">Public API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Generic GROMACS namespace. </p>
<p>Declares the integrator for test particle insertion.</p>
<p>Declares the integrators for energy minimization and NMA.</p>
<p>Convenience macro to help us avoid ifdefs each time we use sysconf.</p>
<dl class="section author"><dt>Author</dt><dd>David van der Spoel <a href="#" onclick="location.href='mai'+'lto:'+'dav'+'id'+'.va'+'nd'+'ers'+'po'+'el@'+'ic'+'m.u'+'u.'+'se'; return false;">david<span style="display: none;">.nosp@m.</span>.van<span style="display: none;">.nosp@m.</span>dersp<span style="display: none;">.nosp@m.</span>oel@<span style="display: none;">.nosp@m.</span>icm.u<span style="display: none;">.nosp@m.</span>u.se</a></dd>
<dd>
Berk Hess <a href="#" onclick="location.href='mai'+'lto:'+'hes'+'s@'+'kth'+'.s'+'e'; return false;">hess@<span style="display: none;">.nosp@m.</span>kth.<span style="display: none;">.nosp@m.</span>se</a> </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AbstractAnalysisData.xhtml">AbstractAnalysisData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for all objects that provide data.  <a href="classgmx_1_1AbstractAnalysisData.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisData.xhtml">AnalysisData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelizable data container for raw data.  <a href="classgmx_1_1AnalysisData.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataHandle.xhtml">AnalysisDataHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle for inserting data into <a class="el" href="classgmx_1_1AnalysisData.xhtml" title="Parallelizable data container for raw data. ">AnalysisData</a>.  <a href="classgmx_1_1AnalysisDataHandle.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AbstractAnalysisArrayData.xhtml">AbstractAnalysisArrayData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for data objects that present in-memory data.  <a href="classgmx_1_1AbstractAnalysisArrayData.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisArrayData.xhtml">AnalysisArrayData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple in-memory data array.  <a href="classgmx_1_1AnalysisArrayData.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataValue.xhtml">AnalysisDataValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type for representing a single value in analysis data objects.  <a href="classgmx_1_1AnalysisDataValue.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataFrameHeader.xhtml">AnalysisDataFrameHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type for storing frame-level information for analysis data.  <a href="classgmx_1_1AnalysisDataFrameHeader.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataPointSetRef.xhtml">AnalysisDataPointSetRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type wrapper for non-mutable access to a set of data column values.  <a href="classgmx_1_1AnalysisDataPointSetRef.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataFrameRef.xhtml">AnalysisDataFrameRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type wrapper for non-mutable access to a data frame.  <a href="classgmx_1_1AnalysisDataFrameRef.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1IAnalysisDataModule.xhtml">IAnalysisDataModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for a module that gets notified whenever data is added.  <a href="classgmx_1_1IAnalysisDataModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataModuleSerial.xhtml">AnalysisDataModuleSerial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience base class for serial analysis data modules.  <a href="classgmx_1_1AnalysisDataModuleSerial.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataModuleParallel.xhtml">AnalysisDataModuleParallel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience base class for parallel analysis data modules.  <a href="classgmx_1_1AnalysisDataModuleParallel.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataAverageModule.xhtml">AnalysisDataAverageModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data module for independently averaging each column in input data.  <a href="classgmx_1_1AnalysisDataAverageModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataFrameAverageModule.xhtml">AnalysisDataFrameAverageModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data module for averaging of columns for each frame.  <a href="classgmx_1_1AnalysisDataFrameAverageModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataDisplacementModule.xhtml">AnalysisDataDisplacementModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data module for calculating displacements.  <a href="classgmx_1_1AnalysisDataDisplacementModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisHistogramSettingsInitializer.xhtml">AnalysisHistogramSettingsInitializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides "named parameter" idiom for constructing histograms.  <a href="classgmx_1_1AnalysisHistogramSettingsInitializer.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisHistogramSettings.xhtml">AnalysisHistogramSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains parameters that specify histogram bin locations.  <a href="classgmx_1_1AnalysisHistogramSettings.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AbstractAverageHistogram.xhtml">AbstractAverageHistogram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for representing histograms averaged over frames.  <a href="classgmx_1_1AbstractAverageHistogram.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataSimpleHistogramModule.xhtml">AnalysisDataSimpleHistogramModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data module for per-frame histograms.  <a href="classgmx_1_1AnalysisDataSimpleHistogramModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataWeightedHistogramModule.xhtml">AnalysisDataWeightedHistogramModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data module for per-frame weighted histograms.  <a href="classgmx_1_1AnalysisDataWeightedHistogramModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataBinAverageModule.xhtml">AnalysisDataBinAverageModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data module for bin averages.  <a href="classgmx_1_1AnalysisDataBinAverageModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataLifetimeModule.xhtml">AnalysisDataLifetimeModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data module for computing lifetime histograms for columns in input data.  <a href="classgmx_1_1AnalysisDataLifetimeModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataPlotSettings.xhtml">AnalysisDataPlotSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common settings for data plots.  <a href="classgmx_1_1AnalysisDataPlotSettings.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AbstractPlotModule.xhtml">AbstractPlotModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract data module for writing data into a file.  <a href="classgmx_1_1AbstractPlotModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataPlotModule.xhtml">AnalysisDataPlotModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting module for straightforward plotting of data.  <a href="classgmx_1_1AnalysisDataPlotModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataVectorPlotModule.xhtml">AnalysisDataVectorPlotModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting module specifically for data consisting of vectors.  <a href="classgmx_1_1AnalysisDataVectorPlotModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1ConstArrayRef.xhtml">ConstArrayRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like container for non-mutable interface to a C array (or part of a std::vector).  <a href="classgmx_1_1ConstArrayRef.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1CommandLineHelpWriter.xhtml">CommandLineHelpWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes help information for <a class="el" href="classgmx_1_1Options.xhtml" title="Collection of options. ">Options</a>.  <a href="classgmx_1_1CommandLineHelpWriter.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1CommandLineModuleSettings.xhtml">CommandLineModuleSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Settings to pass information between a module and the general runner.  <a href="classgmx_1_1CommandLineModuleSettings.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1ICommandLineModule.xhtml">ICommandLineModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module that can be run from command line using CommandLineModuleManager.  <a href="classgmx_1_1ICommandLineModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1ICommandLineOptionsModuleSettings.xhtml">ICommandLineOptionsModuleSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Settings to pass information between a CommandLineOptionsModule and generic code that runs it.  <a href="classgmx_1_1ICommandLineOptionsModuleSettings.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1ICommandLineOptionsModule.xhtml">ICommandLineOptionsModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module that can be run from a command line and uses <a class="el" href="classgmx_1_1Options.xhtml" title="Collection of options. ">gmx::Options</a> for argument processing.  <a href="classgmx_1_1ICommandLineOptionsModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1CommandLineParser.xhtml">CommandLineParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements command-line parsing for <a class="el" href="classgmx_1_1Options.xhtml" title="Collection of options. ">Options</a> objects.  <a href="classgmx_1_1CommandLineParser.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgmx_1_1StaticLog2.xhtml">StaticLog2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate log2(n) for integer n statically at compile time.  <a href="structgmx_1_1StaticLog2.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgmx_1_1StaticLog2_3_011_01_4.xhtml">StaticLog2&lt; 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of StaticLog2&lt;n&gt; for n==1.  <a href="structgmx_1_1StaticLog2_3_011_01_4.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgmx_1_1StaticLog2_3_010_01_4.xhtml">StaticLog2&lt; 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of StaticLog2&lt;n&gt; for n==0.  <a href="structgmx_1_1StaticLog2_3_010_01_4.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1BasicVector.xhtml">BasicVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ class for 3D vectors.  <a href="classgmx_1_1BasicVector.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1ArrayRef.xhtml">ArrayRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like container for an interface to a C array (or part of a std::vector).  <a href="classgmx_1_1ArrayRef.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AbstractOption.xhtml">AbstractOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for specifying option properties.  <a href="classgmx_1_1AbstractOption.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1OptionTemplate.xhtml">OptionTemplate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated base class for constructing concrete option settings classes.  <a href="classgmx_1_1OptionTemplate.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1OptionInfo.xhtml">OptionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives information and allows modifications to an option after creation.  <a href="classgmx_1_1OptionInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1BooleanOption.xhtml">BooleanOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies an option that provides boolean values.  <a href="classgmx_1_1BooleanOption.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1IntegerOption.xhtml">IntegerOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies an option that provides integer values.  <a href="classgmx_1_1IntegerOption.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Int64Option.xhtml">Int64Option</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies an option that provides 64-bit integer values.  <a href="classgmx_1_1Int64Option.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1DoubleOption.xhtml">DoubleOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies an option that provides floating-point (double) values.  <a href="classgmx_1_1DoubleOption.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1FloatOption.xhtml">FloatOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies an option that provides floating-point (float) values.  <a href="classgmx_1_1FloatOption.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1StringOption.xhtml">StringOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies an option that provides string values.  <a href="classgmx_1_1StringOption.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1EnumOption.xhtml">EnumOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies an option that accepts enumerated string values and writes the selected index into an <code>enum</code> variable.  <a href="classgmx_1_1EnumOption.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1BooleanOptionInfo.xhtml">BooleanOptionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for accessing boolean option information.  <a href="classgmx_1_1BooleanOptionInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1IntegerOptionInfo.xhtml">IntegerOptionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for accessing integer option information.  <a href="classgmx_1_1IntegerOptionInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Int64OptionInfo.xhtml">Int64OptionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for accessing 64-bit integer option information.  <a href="classgmx_1_1Int64OptionInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1DoubleOptionInfo.xhtml">DoubleOptionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for accessing floating-point option information.  <a href="classgmx_1_1DoubleOptionInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1FloatOptionInfo.xhtml">FloatOptionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for accessing floating-point option information.  <a href="classgmx_1_1FloatOptionInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1StringOptionInfo.xhtml">StringOptionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for accessing string option information.  <a href="classgmx_1_1StringOptionInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1EnumOptionInfo.xhtml">EnumOptionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for accessing enum option information.  <a href="classgmx_1_1EnumOptionInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1FileNameOption.xhtml">FileNameOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies an option that provides file names.  <a href="classgmx_1_1FileNameOption.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1FileNameOptionInfo.xhtml">FileNameOptionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for accessing file name option information.  <a href="classgmx_1_1FileNameOptionInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1FileNameOptionManager.xhtml">FileNameOptionManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles interaction of file name options with global options.  <a href="classgmx_1_1FileNameOptionManager.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1IOptionsBehavior.xhtml">IOptionsBehavior</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to provide extension points for options parsing.  <a href="classgmx_1_1IOptionsBehavior.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1IOptionsContainer.xhtml">IOptionsContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for adding input options.  <a href="classgmx_1_1IOptionsContainer.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1IOptionManager.xhtml">IOptionManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for option managers.  <a href="classgmx_1_1IOptionManager.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Options.xhtml">Options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of options.  <a href="classgmx_1_1Options.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1TimeUnitManager.xhtml">TimeUnitManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides common functionality for time unit conversions.  <a href="classgmx_1_1TimeUnitManager.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1TimeUnitBehavior.xhtml">TimeUnitBehavior</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgmx_1_1Options.xhtml" title="Collection of options. ">Options</a> behavior to add a time unit option.  <a href="classgmx_1_1TimeUnitBehavior.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1ExponentialDistribution.xhtml">ExponentialDistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponential distribution.  <a href="classgmx_1_1ExponentialDistribution.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1GammaDistribution.xhtml">GammaDistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gamma distribution.  <a href="classgmx_1_1GammaDistribution.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1NormalDistribution.xhtml">NormalDistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal distribution.  <a href="classgmx_1_1NormalDistribution.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1TabulatedNormalDistribution.xhtml">TabulatedNormalDistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tabulated normal random distribution.  <a href="classgmx_1_1TabulatedNormalDistribution.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1ThreeFry2x64General.xhtml">ThreeFry2x64General</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General implementation class for ThreeFry counter-based random engines.  <a href="classgmx_1_1ThreeFry2x64General.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1ThreeFry2x64.xhtml">ThreeFry2x64</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgmx_1_1ThreeFry2x64.xhtml" title="ThreeFry2x64 random engine with 20 iteractions. ">ThreeFry2x64</a> random engine with 20 iteractions.  <a href="classgmx_1_1ThreeFry2x64.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1ThreeFry2x64Fast.xhtml">ThreeFry2x64Fast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgmx_1_1ThreeFry2x64.xhtml" title="ThreeFry2x64 random engine with 20 iteractions. ">ThreeFry2x64</a> random engine with 13 iteractions.  <a href="classgmx_1_1ThreeFry2x64Fast.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1UniformIntDistribution.xhtml">UniformIntDistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform integer distribution.  <a href="classgmx_1_1UniformIntDistribution.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1UniformRealDistribution.xhtml">UniformRealDistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform real distribution.  <a href="classgmx_1_1UniformRealDistribution.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisNeighborhoodPositions.xhtml">AnalysisNeighborhoodPositions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input positions for neighborhood searching.  <a href="classgmx_1_1AnalysisNeighborhoodPositions.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisNeighborhood.xhtml">AnalysisNeighborhood</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighborhood searching for analysis tools.  <a href="classgmx_1_1AnalysisNeighborhood.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisNeighborhoodPair.xhtml">AnalysisNeighborhoodPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type to represent a pair of positions found in neighborhood searching.  <a href="classgmx_1_1AnalysisNeighborhoodPair.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisNeighborhoodSearch.xhtml">AnalysisNeighborhoodSearch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialized neighborhood search with a fixed set of reference positions.  <a href="classgmx_1_1AnalysisNeighborhoodSearch.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisNeighborhoodPairSearch.xhtml">AnalysisNeighborhoodPairSearch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialized neighborhood pair search with a fixed set of positions.  <a href="classgmx_1_1AnalysisNeighborhoodPairSearch.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Selection.xhtml">Selection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to a single selection.  <a href="classgmx_1_1Selection.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1SelectionPosition.xhtml">SelectionPosition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to information about a single selected position.  <a href="classgmx_1_1SelectionPosition.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1SelectionCollection.xhtml">SelectionCollection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of selections.  <a href="classgmx_1_1SelectionCollection.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1SelectionOption.xhtml">SelectionOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies an option that provides selection(s).  <a href="classgmx_1_1SelectionOption.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1SelectionOptionInfo.xhtml">SelectionOptionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for accessing and modifying selection option information.  <a href="classgmx_1_1SelectionOptionInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1ITopologyProvider.xhtml">ITopologyProvider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides topology information to <a class="el" href="classgmx_1_1SelectionOptionBehavior.xhtml" title="Options behavior to allow using SelectionOptions. ">SelectionOptionBehavior</a>.  <a href="classgmx_1_1ITopologyProvider.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1SelectionOptionBehavior.xhtml">SelectionOptionBehavior</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgmx_1_1Options.xhtml" title="Collection of options. ">Options</a> behavior to allow using SelectionOptions.  <a href="classgmx_1_1SelectionOptionBehavior.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1SelectionOptionManager.xhtml">SelectionOptionManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles interaction of selection options with other options and user input.  <a href="classgmx_1_1SelectionOptionManager.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1TrajectoryAnalysisModuleData.xhtml">TrajectoryAnalysisModuleData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for thread-local data storage during trajectory analysis.  <a href="classgmx_1_1TrajectoryAnalysisModuleData.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1TrajectoryAnalysisModule.xhtml">TrajectoryAnalysisModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for trajectory analysis modules.  <a href="classgmx_1_1TrajectoryAnalysisModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1TrajectoryAnalysisSettings.xhtml">TrajectoryAnalysisSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trajectory analysis module configuration object.  <a href="classgmx_1_1TrajectoryAnalysisSettings.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1TopologyInformation.xhtml">TopologyInformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topology information passed to a trajectory analysis module.  <a href="classgmx_1_1TopologyInformation.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1TrajectoryAnalysisCommandLineRunner.xhtml">TrajectoryAnalysisCommandLineRunner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runner for command-line trajectory analysis tools.  <a href="classgmx_1_1TrajectoryAnalysisCommandLineRunner.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgmx_1_1EmptyArrayRef.xhtml">EmptyArrayRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type to initialize empty array references.  <a href="structgmx_1_1EmptyArrayRef.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1PrivateImplPointer.xhtml">PrivateImplPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to manage a pointer to a private implementation class.  <a href="classgmx_1_1PrivateImplPointer.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1DataFileOptions.xhtml">DataFileOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search parameters for <a class="el" href="classgmx_1_1DataFileFinder.xhtml" title="Searches data files from a set of paths. ">DataFileFinder</a>.  <a href="classgmx_1_1DataFileOptions.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgmx_1_1DataFileInfo.xhtml">DataFileInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a data file found by <a class="el" href="classgmx_1_1DataFileFinder.xhtml#a45d2ecd3b688a1432fb94d9632de232a" title="Enumerates files in the data directories. ">DataFileFinder::enumerateFiles()</a>.  <a href="structgmx_1_1DataFileInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1DataFileFinder.xhtml">DataFileFinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches data files from a set of paths.  <a href="classgmx_1_1DataFileFinder.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1ExceptionInfo.xhtml">ExceptionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores additional context information for exceptions.  <a href="classgmx_1_1ExceptionInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1ExceptionInitializer.xhtml">ExceptionInitializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides information for Gromacs exception constructors.  <a href="classgmx_1_1ExceptionInitializer.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1GromacsException.xhtml">GromacsException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all exception objects in Gromacs.  <a href="classgmx_1_1GromacsException.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1FileIOError.xhtml">FileIOError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class for file I/O errors.  <a href="classgmx_1_1FileIOError.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1UserInputError.xhtml">UserInputError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class for user input errors.  <a href="classgmx_1_1UserInputError.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1InvalidInputError.xhtml">InvalidInputError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class for situations where user input cannot be parsed/understood.  <a href="classgmx_1_1InvalidInputError.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1InconsistentInputError.xhtml">InconsistentInputError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class for situations where user input is inconsistent.  <a href="classgmx_1_1InconsistentInputError.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1SimulationInstabilityError.xhtml">SimulationInstabilityError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class for simulation instabilities.  <a href="classgmx_1_1SimulationInstabilityError.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1InternalError.xhtml">InternalError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class for internal errors.  <a href="classgmx_1_1InternalError.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1APIError.xhtml">APIError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class for incorrect use of an API.  <a href="classgmx_1_1APIError.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1NotImplementedError.xhtml">NotImplementedError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class for use of an unimplemented feature.  <a href="classgmx_1_1NotImplementedError.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1FlagsTemplate.xhtml">FlagsTemplate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class for typesafe handling of combination of flags.  <a href="classgmx_1_1FlagsTemplate.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgmx_1_1InstallationPrefixInfo.xhtml">InstallationPrefixInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides information about installation prefix (see <a class="el" href="classgmx_1_1IProgramContext.xhtml#ada732144a05c8faa224b5ad0d904df6f" title="Returns the installation prefix for GROMACS. ">IProgramContext::installationPrefix()</a>).  <a href="structgmx_1_1InstallationPrefixInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1IProgramContext.xhtml">IProgramContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides context information about the program that is calling the library.  <a href="classgmx_1_1IProgramContext.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1StringFormatter.xhtml">StringFormatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object that wraps a call to <a class="el" href="group__module__utility.xhtml#gaed06df18ca6f9fc3f42bad9ea4d7e025" title="Formats a string (snprintf() wrapper). ">formatString()</a> that expects a single conversion argument, for use with algorithms.  <a href="classgmx_1_1StringFormatter.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1IdentityFormatter.xhtml">IdentityFormatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object to implement the same interface as <code><a class="el" href="classgmx_1_1StringFormatter.xhtml" title="Function object that wraps a call to formatString() that expects a single conversion argument...">StringFormatter</a></code> to use with strings that should not be formatted further.  <a href="classgmx_1_1IdentityFormatter.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1TextLineWrapperSettings.xhtml">TextLineWrapperSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores settings for line wrapping.  <a href="classgmx_1_1TextLineWrapperSettings.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1TextLineWrapper.xhtml">TextLineWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps lines to a predefined length.  <a href="classgmx_1_1TextLineWrapper.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aea400e67c2f38e5bacdf8677f38a61cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea400e67c2f38e5bacdf8677f38a61cc"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1IAnalysisDataModule.xhtml">IAnalysisDataModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aea400e67c2f38e5bacdf8677f38a61cc">AnalysisDataModulePointer</a></td></tr>
<tr class="memdesc:aea400e67c2f38e5bacdf8677f38a61cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer for managing a generic analysis data module. <br/></td></tr>
<tr class="separator:aea400e67c2f38e5bacdf8677f38a61cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b2ea776c6775a0c958a3750b42a97e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5b2ea776c6775a0c958a3750b42a97e"></a>
typedef <a class="el" href="classgmx_1_1ConstArrayRef.xhtml">ConstArrayRef</a><br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1AnalysisDataValue.xhtml">AnalysisDataValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ab5b2ea776c6775a0c958a3750b42a97e">AnalysisDataValuesRef</a></td></tr>
<tr class="memdesc:ab5b2ea776c6775a0c958a3750b42a97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for reference to an array of data values. <br/></td></tr>
<tr class="separator:ab5b2ea776c6775a0c958a3750b42a97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e4f5152c736da50dd59275f423a7a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87e4f5152c736da50dd59275f423a7a3"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1AnalysisDataAverageModule.xhtml">AnalysisDataAverageModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a87e4f5152c736da50dd59275f423a7a3">AnalysisDataAverageModulePointer</a></td></tr>
<tr class="memdesc:a87e4f5152c736da50dd59275f423a7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage an <a class="el" href="classgmx_1_1AnalysisDataAverageModule.xhtml" title="Data module for independently averaging each column in input data. ">AnalysisDataAverageModule</a> object. <br/></td></tr>
<tr class="separator:a87e4f5152c736da50dd59275f423a7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad580f7f69fb3536c9cba722587e77e49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad580f7f69fb3536c9cba722587e77e49"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1AnalysisDataFrameAverageModule.xhtml">AnalysisDataFrameAverageModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ad580f7f69fb3536c9cba722587e77e49">AnalysisDataFrameAverageModulePointer</a></td></tr>
<tr class="memdesc:ad580f7f69fb3536c9cba722587e77e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage an <a class="el" href="classgmx_1_1AnalysisDataFrameAverageModule.xhtml" title="Data module for averaging of columns for each frame. ">AnalysisDataFrameAverageModule</a> object. <br/></td></tr>
<tr class="separator:ad580f7f69fb3536c9cba722587e77e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5dd79fb2cd906b55b386b64084543b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5dd79fb2cd906b55b386b64084543b9"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1AnalysisDataDisplacementModule.xhtml">AnalysisDataDisplacementModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa5dd79fb2cd906b55b386b64084543b9">AnalysisDataDisplacementModulePointer</a></td></tr>
<tr class="memdesc:aa5dd79fb2cd906b55b386b64084543b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage an <a class="el" href="classgmx_1_1AnalysisDataDisplacementModule.xhtml" title="Data module for calculating displacements. ">AnalysisDataDisplacementModule</a> object. <br/></td></tr>
<tr class="separator:aa5dd79fb2cd906b55b386b64084543b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c190fcdacd0ca64e4e9026213483cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06c190fcdacd0ca64e4e9026213483cb"></a>
typedef std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1AbstractAverageHistogram.xhtml">AbstractAverageHistogram</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a06c190fcdacd0ca64e4e9026213483cb">AverageHistogramPointer</a></td></tr>
<tr class="memdesc:a06c190fcdacd0ca64e4e9026213483cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage an <a class="el" href="classgmx_1_1AbstractAverageHistogram.xhtml" title="Base class for representing histograms averaged over frames. ">AbstractAverageHistogram</a> object. <br/></td></tr>
<tr class="separator:a06c190fcdacd0ca64e4e9026213483cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c928eedc8925c3c437b5362acf30ccd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c928eedc8925c3c437b5362acf30ccd"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1AnalysisDataSimpleHistogramModule.xhtml">AnalysisDataSimpleHistogramModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2c928eedc8925c3c437b5362acf30ccd">AnalysisDataSimpleHistogramModulePointer</a></td></tr>
<tr class="memdesc:a2c928eedc8925c3c437b5362acf30ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage an <a class="el" href="classgmx_1_1AnalysisDataSimpleHistogramModule.xhtml" title="Data module for per-frame histograms. ">AnalysisDataSimpleHistogramModule</a> object. <br/></td></tr>
<tr class="separator:a2c928eedc8925c3c437b5362acf30ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a619b397ea8b7a9a81406d36f653b4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a619b397ea8b7a9a81406d36f653b4c"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1AnalysisDataWeightedHistogramModule.xhtml">AnalysisDataWeightedHistogramModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a3a619b397ea8b7a9a81406d36f653b4c">AnalysisDataWeightedHistogramModulePointer</a></td></tr>
<tr class="memdesc:a3a619b397ea8b7a9a81406d36f653b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage an <a class="el" href="classgmx_1_1AnalysisDataWeightedHistogramModule.xhtml" title="Data module for per-frame weighted histograms. ">AnalysisDataWeightedHistogramModule</a> object. <br/></td></tr>
<tr class="separator:a3a619b397ea8b7a9a81406d36f653b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2832966f8a1d1e01888448ce10faa595"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2832966f8a1d1e01888448ce10faa595"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1AnalysisDataBinAverageModule.xhtml">AnalysisDataBinAverageModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2832966f8a1d1e01888448ce10faa595">AnalysisDataBinAverageModulePointer</a></td></tr>
<tr class="memdesc:a2832966f8a1d1e01888448ce10faa595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage an <a class="el" href="classgmx_1_1AnalysisDataBinAverageModule.xhtml" title="Data module for bin averages. ">AnalysisDataBinAverageModule</a> object. <br/></td></tr>
<tr class="separator:a2832966f8a1d1e01888448ce10faa595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af036d959995ac12973db1da85b720bf6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af036d959995ac12973db1da85b720bf6"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1AnalysisDataLifetimeModule.xhtml">AnalysisDataLifetimeModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af036d959995ac12973db1da85b720bf6">AnalysisDataLifetimeModulePointer</a></td></tr>
<tr class="memdesc:af036d959995ac12973db1da85b720bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage an <a class="el" href="classgmx_1_1AnalysisDataLifetimeModule.xhtml" title="Data module for computing lifetime histograms for columns in input data. ">AnalysisDataLifetimeModule</a> object. <br/></td></tr>
<tr class="separator:af036d959995ac12973db1da85b720bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38eb9496e0b6e783869001733014b6d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38eb9496e0b6e783869001733014b6d0"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1AnalysisDataPlotModule.xhtml">AnalysisDataPlotModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a38eb9496e0b6e783869001733014b6d0">AnalysisDataPlotModulePointer</a></td></tr>
<tr class="memdesc:a38eb9496e0b6e783869001733014b6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage an <a class="el" href="classgmx_1_1AnalysisDataPlotModule.xhtml" title="Plotting module for straightforward plotting of data. ">AnalysisDataPlotModule</a> object. <br/></td></tr>
<tr class="separator:a38eb9496e0b6e783869001733014b6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd637dfda5b531daec3b8a89f389c10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacd637dfda5b531daec3b8a89f389c10"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1AnalysisDataVectorPlotModule.xhtml">AnalysisDataVectorPlotModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aacd637dfda5b531daec3b8a89f389c10">AnalysisDataVectorPlotModulePointer</a></td></tr>
<tr class="memdesc:aacd637dfda5b531daec3b8a89f389c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage an <a class="el" href="classgmx_1_1AnalysisDataVectorPlotModule.xhtml" title="Plotting module specifically for data consisting of vectors. ">AnalysisDataVectorPlotModule</a> object. <br/></td></tr>
<tr class="separator:aacd637dfda5b531daec3b8a89f389c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f47492bbdb0412052613d0096a20c0b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1f47492bbdb0412052613d0096a20c0b"></a>
typedef std::map&lt; std::string, <br class="typebreak"/>
<a class="el" href="group__module__commandline.xhtml#ga92d17acbe7afad4effeda8d9be200305">CommandLineModulePointer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__commandline.xhtml#ga1f47492bbdb0412052613d0096a20c0b">CommandLineModuleMap</a></td></tr>
<tr class="memdesc:ga1f47492bbdb0412052613d0096a20c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container type for mapping module names to module objects. <br/></td></tr>
<tr class="separator:ga1f47492bbdb0412052613d0096a20c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc9ea6aca3a54c2691284aa39cdd294d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadc9ea6aca3a54c2691284aa39cdd294d"></a>
typedef std::unique_ptr<br class="typebreak"/>
&lt; CommandLineModuleGroupData &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__commandline.xhtml#gadc9ea6aca3a54c2691284aa39cdd294d">CommandLineModuleGroupDataPointer</a></td></tr>
<tr class="memdesc:gadc9ea6aca3a54c2691284aa39cdd294d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer type for managing a CommandLineModuleGroup. <br/></td></tr>
<tr class="separator:gadc9ea6aca3a54c2691284aa39cdd294d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7098a58b563a17889eef62c80fae42bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7098a58b563a17889eef62c80fae42bf"></a>
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="group__module__commandline.xhtml#gadc9ea6aca3a54c2691284aa39cdd294d">CommandLineModuleGroupDataPointer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__commandline.xhtml#ga7098a58b563a17889eef62c80fae42bf">CommandLineModuleGroupList</a></td></tr>
<tr class="memdesc:ga7098a58b563a17889eef62c80fae42bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container type for keeping a list of module groups. <br/></td></tr>
<tr class="separator:ga7098a58b563a17889eef62c80fae42bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92d17acbe7afad4effeda8d9be200305"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga92d17acbe7afad4effeda8d9be200305"></a>
typedef std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1ICommandLineModule.xhtml">ICommandLineModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__commandline.xhtml#ga92d17acbe7afad4effeda8d9be200305">CommandLineModulePointer</a></td></tr>
<tr class="memdesc:ga92d17acbe7afad4effeda8d9be200305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer type for managing a <a class="el" href="classgmx_1_1ICommandLineModule.xhtml" title="Module that can be run from command line using CommandLineModuleManager. ">ICommandLineModule</a>. <br/></td></tr>
<tr class="separator:ga92d17acbe7afad4effeda8d9be200305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682ce4a779fde44ee633b8648eeafe87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a682ce4a779fde44ee633b8648eeafe87"></a>
typedef std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1ICommandLineOptionsModule.xhtml">ICommandLineOptionsModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a682ce4a779fde44ee633b8648eeafe87">ICommandLineOptionsModulePointer</a></td></tr>
<tr class="memdesc:a682ce4a779fde44ee633b8648eeafe87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage an <a class="el" href="classgmx_1_1ICommandLineOptionsModule.xhtml" title="Module that can be run from a command line and uses gmx::Options for argument processing. ">ICommandLineOptionsModule</a>. <br/></td></tr>
<tr class="separator:a682ce4a779fde44ee633b8648eeafe87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac522eb6a6c382e39345834c796201098"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac522eb6a6c382e39345834c796201098"></a>
typedef std::unique_ptr<br class="typebreak"/>
&lt; IExecutableEnvironment &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__commandline.xhtml#gac522eb6a6c382e39345834c796201098">ExecutableEnvironmentPointer</a></td></tr>
<tr class="memdesc:gac522eb6a6c382e39345834c796201098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for a smart pointer to IExecutableEnvironment. <br/></td></tr>
<tr class="separator:gac522eb6a6c382e39345834c796201098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139c1919a9680de4ad1450f42e37d33b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a139c1919a9680de4ad1450f42e37d33b"></a>
typedef <a class="el" href="classgmx_1_1BasicVector.xhtml">BasicVector</a>&lt; <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a139c1919a9680de4ad1450f42e37d33b">RVec</a></td></tr>
<tr class="memdesc:a139c1919a9680de4ad1450f42e37d33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for C++ <code>rvec</code>-equivalent type. <br/></td></tr>
<tr class="separator:a139c1919a9680de4ad1450f42e37d33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8593c4aa4e1f10f3571c8b8f2cd933a8"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a8593c4aa4e1f10f3571c8b8f2cd933a8">integrator_t</a> (FILE *fplog, t_commrec *cr, int nfile, const <a class="el" href="structt__filenm.xhtml">t_filenm</a> fnm[], const gmx_output_env_t *oenv, <a class="el" href="basedefinitions_8h.xhtml#a8fddad319f226e856400d190198d5151">gmx_bool</a> bVerbose, int nstglobalcomm, gmx_vsite_t *vsite, gmx_constr_t constr, int stepout, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, t_state *state_global, <a class="el" href="structt__mdatoms.xhtml">t_mdatoms</a> *mdatoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, t_forcerec *fr, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, gmx_membed_t *membed, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> cpt_period, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> max_hours, int imdport, unsigned long Flags, gmx_walltime_accounting_t walltime_accounting)</td></tr>
<tr class="memdesc:a8593c4aa4e1f10f3571c8b8f2cd933a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrator algorithm implementation.  <a href="#a8593c4aa4e1f10f3571c8b8f2cd933a8">More...</a><br/></td></tr>
<tr class="separator:a8593c4aa4e1f10f3571c8b8f2cd933a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0facebaa27d417dcf4d032f2a5725a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c0facebaa27d417dcf4d032f2a5725a"></a>
typedef std::array<br class="typebreak"/>
&lt; SimulationSignal, eglsNR &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2c0facebaa27d417dcf4d032f2a5725a">SimulationSignals</a></td></tr>
<tr class="memdesc:a2c0facebaa27d417dcf4d032f2a5725a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience typedef for the group of signals used. <br/></td></tr>
<tr class="separator:a2c0facebaa27d417dcf4d032f2a5725a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb455c7711ece592606e70a093ff80b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb455c7711ece592606e70a093ff80b4"></a>
typedef std::unique_ptr<br class="typebreak"/>
&lt; IHelpTopic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#abb455c7711ece592606e70a093ff80b4">HelpTopicPointer</a></td></tr>
<tr class="memdesc:abb455c7711ece592606e70a093ff80b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer type to manage a IHelpTopic object. <br/></td></tr>
<tr class="separator:abb455c7711ece592606e70a093ff80b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdd645721a8da7d18eec7f0bc84efe29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafdd645721a8da7d18eec7f0bc84efe29"></a>
typedef <a class="el" href="classgmx_1_1EnumOption.xhtml">EnumOption</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__options.xhtml#gafdd645721a8da7d18eec7f0bc84efe29">EnumIntOption</a></td></tr>
<tr class="memdesc:gafdd645721a8da7d18eec7f0bc84efe29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for an enumerated option that stores into an <code>int</code> variable. <br/></td></tr>
<tr class="separator:gafdd645721a8da7d18eec7f0bc84efe29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7552279e0ab63edd1e9324c5786e28e7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classgmx_1_1FloatOption.xhtml">FloatOption</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__options.xhtml#ga7552279e0ab63edd1e9324c5786e28e7">RealOption</a></td></tr>
<tr class="memdesc:ga7552279e0ab63edd1e9324c5786e28e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for either <a class="el" href="classgmx_1_1DoubleOption.xhtml" title="Specifies an option that provides floating-point (double) values. ">DoubleOption</a> or <a class="el" href="classgmx_1_1FloatOption.xhtml" title="Specifies an option that provides floating-point (float) values. ">FloatOption</a>, depending on precision.  <a href="group__module__options.xhtml#ga7552279e0ab63edd1e9324c5786e28e7">More...</a><br/></td></tr>
<tr class="separator:ga7552279e0ab63edd1e9324c5786e28e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1c4e0b93e5d22b0c9a534f0235496f5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classgmx_1_1FloatOptionInfo.xhtml">FloatOptionInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__options.xhtml#gab1c4e0b93e5d22b0c9a534f0235496f5">RealOptionInfo</a></td></tr>
<tr class="memdesc:gab1c4e0b93e5d22b0c9a534f0235496f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for either <a class="el" href="classgmx_1_1DoubleOptionInfo.xhtml" title="Wrapper class for accessing floating-point option information. ">DoubleOptionInfo</a> or <a class="el" href="classgmx_1_1FloatOptionInfo.xhtml" title="Wrapper class for accessing floating-point option information. ">FloatOptionInfo</a>, depending on precision.  <a href="group__module__options.xhtml#gab1c4e0b93e5d22b0c9a534f0235496f5">More...</a><br/></td></tr>
<tr class="separator:gab1c4e0b93e5d22b0c9a534f0235496f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059233e5e29d17f821d7f56ef3faa7e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a059233e5e29d17f821d7f56ef3faa7e4"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1IOptionsBehavior.xhtml">IOptionsBehavior</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a059233e5e29d17f821d7f56ef3faa7e4">OptionsBehaviorPointer</a></td></tr>
<tr class="memdesc:a059233e5e29d17f821d7f56ef3faa7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer for behaviors stored in OptionsBehaviorCollection. <br/></td></tr>
<tr class="separator:a059233e5e29d17f821d7f56ef3faa7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac44e2bbcc40f48812b6b756a503ea51"><td class="memItemLeft" align="right" valign="top">typedef std::random_device&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aac44e2bbcc40f48812b6b756a503ea51">RandomDevice</a></td></tr>
<tr class="memdesc:aac44e2bbcc40f48812b6b756a503ea51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random device.  <a href="#aac44e2bbcc40f48812b6b756a503ea51">More...</a><br/></td></tr>
<tr class="separator:aac44e2bbcc40f48812b6b756a503ea51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea21974bdd8acdfa1c344b0945cff1b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classgmx_1_1ThreeFry2x64Fast.xhtml">ThreeFry2x64Fast</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a7ea21974bdd8acdfa1c344b0945cff1b">DefaultRandomEngine</a></td></tr>
<tr class="memdesc:a7ea21974bdd8acdfa1c344b0945cff1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default fast and accurate random engine in Gromacs.  <a href="#a7ea21974bdd8acdfa1c344b0945cff1b">More...</a><br/></td></tr>
<tr class="separator:a7ea21974bdd8acdfa1c344b0945cff1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec46c9561c55f7595677160ee727395d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec46c9561c55f7595677160ee727395d"></a>
typedef std::list<br class="typebreak"/>
&lt; SelectionParserValue &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aec46c9561c55f7595677160ee727395d">SelectionParserValueList</a></td></tr>
<tr class="memdesc:aec46c9561c55f7595677160ee727395d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for a list of SelectionParserValue objects. <br/></td></tr>
<tr class="separator:aec46c9561c55f7595677160ee727395d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043953ace26fa6e1f17f90245e3a29bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a043953ace26fa6e1f17f90245e3a29bd"></a>
typedef std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="namespacegmx.xhtml#aec46c9561c55f7595677160ee727395d">SelectionParserValueList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a043953ace26fa6e1f17f90245e3a29bd">SelectionParserValueListPointer</a></td></tr>
<tr class="memdesc:a043953ace26fa6e1f17f90245e3a29bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer type for managing a SelectionParserValueList. <br/></td></tr>
<tr class="separator:a043953ace26fa6e1f17f90245e3a29bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2000e8454576fcfcd5a8fdc5d060da4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2000e8454576fcfcd5a8fdc5d060da4e"></a>
typedef std::list<br class="typebreak"/>
&lt; SelectionParserParameter &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2000e8454576fcfcd5a8fdc5d060da4e">SelectionParserParameterList</a></td></tr>
<tr class="memdesc:a2000e8454576fcfcd5a8fdc5d060da4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for a list of SelectionParserParameter objects. <br/></td></tr>
<tr class="separator:a2000e8454576fcfcd5a8fdc5d060da4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69a9fb56d051d95e77a90d57a9fa42e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af69a9fb56d051d95e77a90d57a9fa42e"></a>
typedef std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="namespacegmx.xhtml#a2000e8454576fcfcd5a8fdc5d060da4e">SelectionParserParameterList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af69a9fb56d051d95e77a90d57a9fa42e">SelectionParserParameterListPointer</a></td></tr>
<tr class="memdesc:af69a9fb56d051d95e77a90d57a9fa42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer type for managing a SelectionParserParameterList. <br/></td></tr>
<tr class="separator:af69a9fb56d051d95e77a90d57a9fa42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac852a0801cf49723903e23bc77a32163"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac852a0801cf49723903e23bc77a32163"></a>
typedef std::vector&lt; <a class="el" href="classgmx_1_1Selection.xhtml">Selection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ac852a0801cf49723903e23bc77a32163">SelectionList</a></td></tr>
<tr class="memdesc:ac852a0801cf49723903e23bc77a32163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of selections used in public selection interfaces. <br/></td></tr>
<tr class="separator:ac852a0801cf49723903e23bc77a32163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e73e50cc7002a24229fa6650b8ccfc8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e73e50cc7002a24229fa6650b8ccfc8"></a>
typedef std::unique_ptr<br class="typebreak"/>
&lt; internal::SelectionData &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a0e73e50cc7002a24229fa6650b8ccfc8">SelectionDataPointer</a></td></tr>
<tr class="memdesc:a0e73e50cc7002a24229fa6650b8ccfc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer for managing an internal selection data object. <br/></td></tr>
<tr class="separator:a0e73e50cc7002a24229fa6650b8ccfc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5559201ddf8596d12d99a3c3e45e989"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5559201ddf8596d12d99a3c3e45e989"></a>
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="namespacegmx.xhtml#a0e73e50cc7002a24229fa6650b8ccfc8">SelectionDataPointer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ab5559201ddf8596d12d99a3c3e45e989">SelectionDataList</a></td></tr>
<tr class="memdesc:ab5559201ddf8596d12d99a3c3e45e989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for storing a list of selections internally. <br/></td></tr>
<tr class="separator:ab5559201ddf8596d12d99a3c3e45e989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2804c9c82f2a9bd0ec94d3c2f1003f42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2804c9c82f2a9bd0ec94d3c2f1003f42"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; SelectionTreeElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2804c9c82f2a9bd0ec94d3c2f1003f42">SelectionTreeElementPointer</a></td></tr>
<tr class="memdesc:a2804c9c82f2a9bd0ec94d3c2f1003f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer type for selection tree element pointers. <br/></td></tr>
<tr class="separator:a2804c9c82f2a9bd0ec94d3c2f1003f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f05f1bbb0c205deb47822bce1f626e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f05f1bbb0c205deb47822bce1f626e6"></a>
typedef std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1TrajectoryAnalysisModuleData.xhtml">TrajectoryAnalysisModuleData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a6f05f1bbb0c205deb47822bce1f626e6">TrajectoryAnalysisModuleDataPointer</a></td></tr>
<tr class="memdesc:a6f05f1bbb0c205deb47822bce1f626e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage a <a class="el" href="classgmx_1_1TrajectoryAnalysisModuleData.xhtml" title="Base class for thread-local data storage during trajectory analysis. ">TrajectoryAnalysisModuleData</a> object. <br/></td></tr>
<tr class="separator:a6f05f1bbb0c205deb47822bce1f626e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832da3c093109c13cc2369de05e02f3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a832da3c093109c13cc2369de05e02f3b"></a>
typedef std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1TrajectoryAnalysisModule.xhtml">TrajectoryAnalysisModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a832da3c093109c13cc2369de05e02f3b">TrajectoryAnalysisModulePointer</a></td></tr>
<tr class="memdesc:a832da3c093109c13cc2369de05e02f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage a <a class="el" href="classgmx_1_1TrajectoryAnalysisModule.xhtml" title="Base class for trajectory analysis modules. ">TrajectoryAnalysisModule</a>. <br/></td></tr>
<tr class="separator:a832da3c093109c13cc2369de05e02f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga590b36651977793730ea2413906302cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga590b36651977793730ea2413906302cf"></a>
typedef <a class="el" href="classgmx_1_1ExceptionInfo.xhtml">ExceptionInfo</a>&lt; struct <br class="typebreak"/>
ExceptionInfoErrno_, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga590b36651977793730ea2413906302cf">ExceptionInfoErrno</a></td></tr>
<tr class="memdesc:ga590b36651977793730ea2413906302cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores <code>errno</code> value that triggered the exception. <br/></td></tr>
<tr class="separator:ga590b36651977793730ea2413906302cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c8f9c19c0ed36c16770317afc7c69bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3c8f9c19c0ed36c16770317afc7c69bb"></a>
typedef <a class="el" href="classgmx_1_1ExceptionInfo.xhtml">ExceptionInfo</a>&lt; struct <br class="typebreak"/>
ExceptionInfoApiFunc_, const <br class="typebreak"/>
char * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga3c8f9c19c0ed36c16770317afc7c69bb">ExceptionInfoApiFunction</a></td></tr>
<tr class="memdesc:ga3c8f9c19c0ed36c16770317afc7c69bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the function name that returned the <code>errno</code> in ExceptionInfoErrno. <br/></td></tr>
<tr class="separator:ga3c8f9c19c0ed36c16770317afc7c69bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5d3ee620090581599c5762270314897"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab5d3ee620090581599c5762270314897"></a>
typedef <a class="el" href="classgmx_1_1ExceptionInfo.xhtml">ExceptionInfo</a>&lt; struct <br class="typebreak"/>
ExceptionInfoLocation_, <br class="typebreak"/>
ThrowLocation &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gab5d3ee620090581599c5762270314897">ExceptionInfoLocation</a></td></tr>
<tr class="memdesc:gab5d3ee620090581599c5762270314897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the location where the exception was thrown. <br/></td></tr>
<tr class="separator:gab5d3ee620090581599c5762270314897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58ef5153befc109091dcbf8a5b2fb1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af58ef5153befc109091dcbf8a5b2fb1c"></a>
typedef scoped_cptr&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af58ef5153befc109091dcbf8a5b2fb1c">scoped_guard_sfree</a></td></tr>
<tr class="memdesc:af58ef5153befc109091dcbf8a5b2fb1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple guard which calls sfree. See scoped_cptr for details. <br/></td></tr>
<tr class="separator:af58ef5153befc109091dcbf8a5b2fb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbe80608de8e00e55049289ef0148c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fbe80608de8e00e55049289ef0148c1"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; TextInputStream &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2fbe80608de8e00e55049289ef0148c1">TextInputStreamPointer</a></td></tr>
<tr class="memdesc:a2fbe80608de8e00e55049289ef0148c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for a smart pointer to a TextInputStream. <br/></td></tr>
<tr class="separator:a2fbe80608de8e00e55049289ef0148c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdec6c0997f8c033905f1f82f253d25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fdec6c0997f8c033905f1f82f253d25"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; TextOutputStream &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a1fdec6c0997f8c033905f1f82f253d25">TextOutputStreamPointer</a></td></tr>
<tr class="memdesc:a1fdec6c0997f8c033905f1f82f253d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for a smart pointer to a TextOutputStream. <br/></td></tr>
<tr class="separator:a1fdec6c0997f8c033905f1f82f253d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga89f55fd684646bb146f99a8c6c18569b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__options.xhtml#ga89f55fd684646bb146f99a8c6c18569b">OptionFileType</a> { <br/>
&#160;&#160;<b>eftUnknown</b>, 
<b>eftTopology</b>, 
<b>eftTrajectory</b>, 
<b>eftEnergy</b>, 
<br/>
&#160;&#160;<b>eftPDB</b>, 
<b>eftIndex</b>, 
<b>eftPlot</b>, 
<b>eftGenericData</b>, 
<br/>
&#160;&#160;<b>eftOptionFileType_NR</b>
<br/>
 }</td></tr>
<tr class="memdesc:ga89f55fd684646bb146f99a8c6c18569b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Purpose of file(s) provided through an option. <br/></td></tr>
<tr class="separator:ga89f55fd684646bb146f99a8c6c18569b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c22d32956f25d2432d5a6870983d5cb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__publicapi.xhtml#ga1c22d32956f25d2432d5a6870983d5cb">TimeUnit</a> { <br/>
&#160;&#160;<a class="el" href="group__group__publicapi.xhtml#gga1c22d32956f25d2432d5a6870983d5cbaf62491a2d381280231fdb1d87c3788be">TimeUnit_fs</a>, 
<a class="el" href="group__group__publicapi.xhtml#gga1c22d32956f25d2432d5a6870983d5cbaa937a11ed8176ada593733a46cd985dd">TimeUnit_ps</a>, 
<a class="el" href="group__group__publicapi.xhtml#gga1c22d32956f25d2432d5a6870983d5cbaee83c8ee85640f404d1da7f659c74e0b">TimeUnit_ns</a>, 
<a class="el" href="group__group__publicapi.xhtml#gga1c22d32956f25d2432d5a6870983d5cba788b558db3581dbb3c4929e73be61226">TimeUnit_us</a>, 
<br/>
&#160;&#160;<a class="el" href="group__group__publicapi.xhtml#gga1c22d32956f25d2432d5a6870983d5cbac129739439b285acd9608020af58baaf">TimeUnit_ms</a>, 
<a class="el" href="group__group__publicapi.xhtml#gga1c22d32956f25d2432d5a6870983d5cbae96310bb9de653e86c390aa0f081b0ce">TimeUnit_s</a>, 
<a class="el" href="group__group__publicapi.xhtml#gga1c22d32956f25d2432d5a6870983d5cba7c00d373b2fbd17b4236fc8636ed52ce">TimeUnit_Default</a> = TimeUnit_ps
<br/>
 }</td></tr>
<tr class="memdesc:ga1c22d32956f25d2432d5a6870983d5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time values for TimeUnitManager.  <a href="group__group__publicapi.xhtml#ga1c22d32956f25d2432d5a6870983d5cb">More...</a><br/></td></tr>
<tr class="separator:ga1c22d32956f25d2432d5a6870983d5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73202d646d57bcc963d8afd5a16015f0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0">RandomDomain</a> { <br/>
&#160;&#160;<a class="el" href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0a6311ae17c1ee52b36e68aaf4ad066387">RandomDomain::Other</a> = 0x00000000, 
<a class="el" href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0accb9e34a240647891f931e772cad80ef">RandomDomain::MaxwellVelocities</a> = 0x00001000, 
<a class="el" href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0aa42c5450c670a7ecbea5532bde9c0c65">RandomDomain::TestParticleInsertion</a> = 0x00002000, 
<a class="el" href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0a23714d9a49cc46ca81ad32670bde8b5e">RandomDomain::UpdateCoordinates</a> = 0x00003000, 
<br/>
&#160;&#160;<a class="el" href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0ab0634f71dbc527342668f2a63f1b3510">RandomDomain::UpdateConstraints</a> = 0x00004000, 
<a class="el" href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0a91e0b95db0c752d879aebd0ac65a7fb9">RandomDomain::Thermostat</a> = 0x00005000, 
<a class="el" href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0a79248e4db93ba16182fd3bf1c8e2fda7">RandomDomain::Barostat</a> = 0x00006000, 
<a class="el" href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0ada8008568302912872628be09e68fb84">RandomDomain::ReplicaExchange</a> = 0x00007000, 
<br/>
&#160;&#160;<a class="el" href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0a19bd460326d41817323764fa9e4287ff">RandomDomain::ExpandedEnsemble</a> = 0x00008000
<br/>
 }</td></tr>
<tr class="memdesc:a73202d646d57bcc963d8afd5a16015f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated values for fixed part of random seed (domain)  <a href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0">More...</a><br/></td></tr>
<tr class="separator:a73202d646d57bcc963d8afd5a16015f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac92ff9c7f6f5ed5200b3d8d92a4d53e3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gac92ff9c7f6f5ed5200b3d8d92a4d53e3">ErrorCode</a> { <br/>
&#160;&#160;<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3acacaa10fa7070b0494b30fdc97a7a356">eeOK</a>, 
<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a35a82c5a0f04b6255d3f28d6144dd24e">eeOutOfMemory</a>, 
<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a444e88ccfbfc246dc671919d0cf127c1">eeFileNotFound</a>, 
<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3ad0a05315bf704c8457baef6eac42dc4e">eeFileIO</a>, 
<br/>
&#160;&#160;<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a4c2569b29b84eda15a5cf90e28395b21">eeInvalidInput</a>, 
<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a7eb29dbd6ce224f815ba82ddcc3b6f62">eeInconsistentInput</a>, 
<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3ac0b348673979b42ebc8df4562b8ebfa4">eeInstability</a>, 
<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3ae958977bd58e97bcc4fd367324c8b21b">eeNotImplemented</a>, 
<br/>
&#160;&#160;<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a71840645faa70349b0e4bede4da4b6d1">eeInvalidValue</a>, 
<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a40bd4aef44a2ab731b61fb9c9184a3bd">eeInvalidCall</a>, 
<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a90b9f0f24cf026b56ebf63d359c5f422">eeInternalError</a>, 
<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a414167b1bc702c9e8bb7f91078360845">eeAPIError</a>, 
<br/>
&#160;&#160;<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a068d9a3d2c79173f39457344cd60380f">eeRange</a>, 
<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a395dad7e12b144dd6805157e6d92e40f">eeCommunication</a>, 
<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a46578ca340e1c440d5f519569e6884fb">eeUnknownError</a>
<br/>
 }</td></tr>
<tr class="memdesc:gac92ff9c7f6f5ed5200b3d8d92a4d53e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible error return codes from Gromacs functions.  <a href="group__module__utility.xhtml#gac92ff9c7f6f5ed5200b3d8d92a4d53e3">More...</a><br/></td></tr>
<tr class="separator:gac92ff9c7f6f5ed5200b3d8d92a4d53e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaf9a9e69ad91172d5f4fba7148280762"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgmx_1_1AnalysisHistogramSettingsInitializer.xhtml">AnalysisHistogramSettingsInitializer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__publicapi.xhtml#gaaf9a9e69ad91172d5f4fba7148280762">histogramFromRange</a> (<a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> <a class="el" href="namespacegmx.xhtml#aa6d21dccd9a94698363bdb1943f139bb">min</a>, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> <a class="el" href="namespacegmx.xhtml#a35c7b010fbd32f5424afa0de0c70db6f">max</a>)</td></tr>
<tr class="memdesc:gaaf9a9e69ad91172d5f4fba7148280762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a histogram using a range and a bin width.  <a href="group__group__publicapi.xhtml#gaaf9a9e69ad91172d5f4fba7148280762">More...</a><br/></td></tr>
<tr class="separator:gaaf9a9e69ad91172d5f4fba7148280762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73a2213cd82e2f915b9f9d65a4b85212"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgmx_1_1AnalysisHistogramSettingsInitializer.xhtml">AnalysisHistogramSettingsInitializer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__publicapi.xhtml#ga73a2213cd82e2f915b9f9d65a4b85212">histogramFromBins</a> (<a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> start, int nbins, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> binwidth)</td></tr>
<tr class="memdesc:ga73a2213cd82e2f915b9f9d65a4b85212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a histogram using bin width and the number of bins.  <a href="group__group__publicapi.xhtml#ga73a2213cd82e2f915b9f9d65a4b85212">More...</a><br/></td></tr>
<tr class="separator:ga73a2213cd82e2f915b9f9d65a4b85212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c376f5f94bd1a63a3a97e288c4be50d"><td class="memItemLeft" align="right" valign="top">CommandLineProgramContext &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__commandline.xhtml#ga8c376f5f94bd1a63a3a97e288c4be50d">initForCommandLine</a> (int *argc, char ***argv)</td></tr>
<tr class="memdesc:ga8c376f5f94bd1a63a3a97e288c4be50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the GROMACS library for command-line use.  <a href="group__module__commandline.xhtml#ga8c376f5f94bd1a63a3a97e288c4be50d">More...</a><br/></td></tr>
<tr class="separator:ga8c376f5f94bd1a63a3a97e288c4be50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49311a4a4e3f3ec07a9ae925fb63151f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__commandline.xhtml#ga49311a4a4e3f3ec07a9ae925fb63151f">finalizeForCommandLine</a> ()</td></tr>
<tr class="memdesc:ga49311a4a4e3f3ec07a9ae925fb63151f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitializes the GROMACS library after <a class="el" href="group__module__commandline.xhtml#ga8c376f5f94bd1a63a3a97e288c4be50d" title="Initializes the GROMACS library for command-line use. ">initForCommandLine()</a>.  <a href="group__module__commandline.xhtml#ga49311a4a4e3f3ec07a9ae925fb63151f">More...</a><br/></td></tr>
<tr class="separator:ga49311a4a4e3f3ec07a9ae925fb63151f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fe34835a6e197f2731e7d604f28992"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ad8fe34835a6e197f2731e7d604f28992">processExceptionAtExitForCommandLine</a> (const std::exception &amp;ex)</td></tr>
<tr class="memdesc:ad8fe34835a6e197f2731e7d604f28992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles an exception and deinitializes after initForCommandLine.  <a href="#ad8fe34835a6e197f2731e7d604f28992">More...</a><br/></td></tr>
<tr class="separator:ad8fe34835a6e197f2731e7d604f28992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3bc0e66dda7e48091ad129bede7eff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a5a3bc0e66dda7e48091ad129bede7eff">runCommandLineModule</a> (int argc, char *argv[], <a class="el" href="classgmx_1_1ICommandLineModule.xhtml">ICommandLineModule</a> *module)</td></tr>
<tr class="memdesc:a5a3bc0e66dda7e48091ad129bede7eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a <a class="el" href="template_8cpp.xhtml#a0ddf1224851353fc92bfbff6f499fa97" title="The main function for the analysis template. ">main()</a> method that runs a single module.  <a href="#a5a3bc0e66dda7e48091ad129bede7eff">More...</a><br/></td></tr>
<tr class="separator:a5a3bc0e66dda7e48091ad129bede7eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7a039b6fae746686d472d1fcae6fee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a8a7a039b6fae746686d472d1fcae6fee">runCommandLineModule</a> (int argc, char *argv[], const char *name, const char *description, std::function&lt; std::unique_ptr&lt; <a class="el" href="classgmx_1_1ICommandLineOptionsModule.xhtml">ICommandLineOptionsModule</a> &gt;()&gt; factory)</td></tr>
<tr class="memdesc:a8a7a039b6fae746686d472d1fcae6fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a <a class="el" href="template_8cpp.xhtml#a0ddf1224851353fc92bfbff6f499fa97" title="The main function for the analysis template. ">main()</a> method that runs a single module.  <a href="#a8a7a039b6fae746686d472d1fcae6fee">More...</a><br/></td></tr>
<tr class="separator:a8a7a039b6fae746686d472d1fcae6fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af536d7a23a442f3c0876b05ac20d7d40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af536d7a23a442f3c0876b05ac20d7d40">cpuIsX86Nehalem</a> (const CpuInfo &amp;cpuInfo)</td></tr>
<tr class="memdesc:af536d7a23a442f3c0876b05ac20d7d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the CPU is an Intel x86 Nehalem.  <a href="#af536d7a23a442f3c0876b05ac20d7d40">More...</a><br/></td></tr>
<tr class="separator:af536d7a23a442f3c0876b05ac20d7d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b47d79ef735987258c2f601cf2822be"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2b47d79ef735987258c2f601cf2822be">log2I</a> (std::uint32_t x)</td></tr>
<tr class="memdesc:a2b47d79ef735987258c2f601cf2822be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute floor of logarithm to base 2, 32 bit unsigned argument.  <a href="#a2b47d79ef735987258c2f601cf2822be">More...</a><br/></td></tr>
<tr class="separator:a2b47d79ef735987258c2f601cf2822be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa498ec06db6575ec672e5ba847f086ab"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa498ec06db6575ec672e5ba847f086ab">log2I</a> (std::uint64_t x)</td></tr>
<tr class="memdesc:aa498ec06db6575ec672e5ba847f086ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute floor of logarithm to base 2, 64 bit unsigned argument.  <a href="#aa498ec06db6575ec672e5ba847f086ab">More...</a><br/></td></tr>
<tr class="separator:aa498ec06db6575ec672e5ba847f086ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1cadcfe34ba004506db6e0e11f36c95"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ab1cadcfe34ba004506db6e0e11f36c95">log2I</a> (std::int32_t x)</td></tr>
<tr class="memdesc:ab1cadcfe34ba004506db6e0e11f36c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute floor of logarithm to base 2, 32 bit signed argument.  <a href="#ab1cadcfe34ba004506db6e0e11f36c95">More...</a><br/></td></tr>
<tr class="separator:ab1cadcfe34ba004506db6e0e11f36c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfba3f9dd776dc29c1d0a8311ed793f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#afbfba3f9dd776dc29c1d0a8311ed793f">log2I</a> (std::int64_t x)</td></tr>
<tr class="memdesc:afbfba3f9dd776dc29c1d0a8311ed793f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute floor of logarithm to base 2, 64 bit signed argument.  <a href="#afbfba3f9dd776dc29c1d0a8311ed793f">More...</a><br/></td></tr>
<tr class="separator:afbfba3f9dd776dc29c1d0a8311ed793f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a820e81baebe1c30a4190eb2aa2a64"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a87a820e81baebe1c30a4190eb2aa2a64">greatestCommonDivisor</a> (std::int64_t p, std::int64_t q)</td></tr>
<tr class="memdesc:a87a820e81baebe1c30a4190eb2aa2a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find greatest common divisor of two numbers.  <a href="#a87a820e81baebe1c30a4190eb2aa2a64">More...</a><br/></td></tr>
<tr class="separator:a87a820e81baebe1c30a4190eb2aa2a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dad03094a0ea5970a5f0977ce5fee84"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2dad03094a0ea5970a5f0977ce5fee84">erfinv</a> (double x)</td></tr>
<tr class="memdesc:a2dad03094a0ea5970a5f0977ce5fee84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse error function, double precision.  <a href="#a2dad03094a0ea5970a5f0977ce5fee84">More...</a><br/></td></tr>
<tr class="separator:a2dad03094a0ea5970a5f0977ce5fee84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85012c7d3609ac21e4052fc3114125a9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a85012c7d3609ac21e4052fc3114125a9">erfinv</a> (float x)</td></tr>
<tr class="memdesc:a85012c7d3609ac21e4052fc3114125a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse error function, single precision.  <a href="#a85012c7d3609ac21e4052fc3114125a9">More...</a><br/></td></tr>
<tr class="separator:a85012c7d3609ac21e4052fc3114125a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953226d61f6527af6485ea56a8384c85"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a953226d61f6527af6485ea56a8384c85">invsqrt</a> (float x)</td></tr>
<tr class="memdesc:a953226d61f6527af6485ea56a8384c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1.0/sqrt(x) in single precision.  <a href="#a953226d61f6527af6485ea56a8384c85">More...</a><br/></td></tr>
<tr class="separator:a953226d61f6527af6485ea56a8384c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26d0b65eb141c73979c5d2f1d0e13fa"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ae26d0b65eb141c73979c5d2f1d0e13fa">invsqrt</a> (double x)</td></tr>
<tr class="memdesc:ae26d0b65eb141c73979c5d2f1d0e13fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1.0/sqrt(x) in double precision, but single range.  <a href="#ae26d0b65eb141c73979c5d2f1d0e13fa">More...</a><br/></td></tr>
<tr class="separator:ae26d0b65eb141c73979c5d2f1d0e13fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91cb31b7abc3e020022ac8ce0b1b262"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa91cb31b7abc3e020022ac8ce0b1b262">invsqrt</a> (int x)</td></tr>
<tr class="memdesc:aa91cb31b7abc3e020022ac8ce0b1b262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1.0/sqrt(x) for integer x in double precision.  <a href="#aa91cb31b7abc3e020022ac8ce0b1b262">More...</a><br/></td></tr>
<tr class="separator:aa91cb31b7abc3e020022ac8ce0b1b262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabf4874cb58de0554f95f69c1768882"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#acabf4874cb58de0554f95f69c1768882">invcbrt</a> (float x)</td></tr>
<tr class="memdesc:acabf4874cb58de0554f95f69c1768882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate inverse cube root of x in single precision.  <a href="#acabf4874cb58de0554f95f69c1768882">More...</a><br/></td></tr>
<tr class="separator:acabf4874cb58de0554f95f69c1768882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d99226376a495b484eccd203d29c8d"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a08d99226376a495b484eccd203d29c8d">invcbrt</a> (double x)</td></tr>
<tr class="memdesc:a08d99226376a495b484eccd203d29c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate inverse sixth root of x in double precision.  <a href="#a08d99226376a495b484eccd203d29c8d">More...</a><br/></td></tr>
<tr class="separator:a08d99226376a495b484eccd203d29c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d304cf0e3cac1632695e394077fd2d7"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a1d304cf0e3cac1632695e394077fd2d7">invcbrt</a> (int x)</td></tr>
<tr class="memdesc:a1d304cf0e3cac1632695e394077fd2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate inverse sixth root of integer x in double precision.  <a href="#a1d304cf0e3cac1632695e394077fd2d7">More...</a><br/></td></tr>
<tr class="separator:a1d304cf0e3cac1632695e394077fd2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12dcc6af3bf2f769ea1e17ed12921e2c"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a12dcc6af3bf2f769ea1e17ed12921e2c">sixthroot</a> (float x)</td></tr>
<tr class="memdesc:a12dcc6af3bf2f769ea1e17ed12921e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate sixth root of x in single precision.  <a href="#a12dcc6af3bf2f769ea1e17ed12921e2c">More...</a><br/></td></tr>
<tr class="separator:a12dcc6af3bf2f769ea1e17ed12921e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf2628e4b20455d3396e0c2c234b951"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a4cf2628e4b20455d3396e0c2c234b951">sixthroot</a> (double x)</td></tr>
<tr class="memdesc:a4cf2628e4b20455d3396e0c2c234b951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate sixth root of x in double precision.  <a href="#a4cf2628e4b20455d3396e0c2c234b951">More...</a><br/></td></tr>
<tr class="separator:a4cf2628e4b20455d3396e0c2c234b951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02308efcb527a69ce399111550575880"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a02308efcb527a69ce399111550575880">sixthroot</a> (int x)</td></tr>
<tr class="memdesc:a02308efcb527a69ce399111550575880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate sixth root of integer x, return double.  <a href="#a02308efcb527a69ce399111550575880">More...</a><br/></td></tr>
<tr class="separator:a02308efcb527a69ce399111550575880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3aeb9a178f07d4bc64b934555d12842"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ad3aeb9a178f07d4bc64b934555d12842">invsixthroot</a> (float x)</td></tr>
<tr class="memdesc:ad3aeb9a178f07d4bc64b934555d12842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate inverse sixth root of x in single precision.  <a href="#ad3aeb9a178f07d4bc64b934555d12842">More...</a><br/></td></tr>
<tr class="separator:ad3aeb9a178f07d4bc64b934555d12842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8b9b01e7c291a443840d4f7af97c5c"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2f8b9b01e7c291a443840d4f7af97c5c">invsixthroot</a> (double x)</td></tr>
<tr class="memdesc:a2f8b9b01e7c291a443840d4f7af97c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate inverse sixth root of x in double precision.  <a href="#a2f8b9b01e7c291a443840d4f7af97c5c">More...</a><br/></td></tr>
<tr class="separator:a2f8b9b01e7c291a443840d4f7af97c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1604baa1a44d1de7bafa433c9443c395"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a1604baa1a44d1de7bafa433c9443c395">invsixthroot</a> (int x)</td></tr>
<tr class="memdesc:a1604baa1a44d1de7bafa433c9443c395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate inverse sixth root of integer x in double precision.  <a href="#a1604baa1a44d1de7bafa433c9443c395">More...</a><br/></td></tr>
<tr class="separator:a1604baa1a44d1de7bafa433c9443c395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cbcb5324f3eb428189024f020158ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a06cbcb5324f3eb428189024f020158ff"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a06cbcb5324f3eb428189024f020158ff">square</a> (T x)</td></tr>
<tr class="memdesc:a06cbcb5324f3eb428189024f020158ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate x^2  <a href="#a06cbcb5324f3eb428189024f020158ff">More...</a><br/></td></tr>
<tr class="separator:a06cbcb5324f3eb428189024f020158ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda6daf50f5129fb74816db29e411497"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abda6daf50f5129fb74816db29e411497"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#abda6daf50f5129fb74816db29e411497">power3</a> (T x)</td></tr>
<tr class="memdesc:abda6daf50f5129fb74816db29e411497"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate x^3  <a href="#abda6daf50f5129fb74816db29e411497">More...</a><br/></td></tr>
<tr class="separator:abda6daf50f5129fb74816db29e411497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304b15bae3a2a8277f686d4dfc9fa946"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a304b15bae3a2a8277f686d4dfc9fa946"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a304b15bae3a2a8277f686d4dfc9fa946">power4</a> (T x)</td></tr>
<tr class="memdesc:a304b15bae3a2a8277f686d4dfc9fa946"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate x^4  <a href="#a304b15bae3a2a8277f686d4dfc9fa946">More...</a><br/></td></tr>
<tr class="separator:a304b15bae3a2a8277f686d4dfc9fa946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb914d3b8bf083485bb26c88d2b9dda"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4bb914d3b8bf083485bb26c88d2b9dda"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a4bb914d3b8bf083485bb26c88d2b9dda">power5</a> (T x)</td></tr>
<tr class="memdesc:a4bb914d3b8bf083485bb26c88d2b9dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate x^5  <a href="#a4bb914d3b8bf083485bb26c88d2b9dda">More...</a><br/></td></tr>
<tr class="separator:a4bb914d3b8bf083485bb26c88d2b9dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab162c4ba231de5ffbfc62dc3803e8ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aab162c4ba231de5ffbfc62dc3803e8ff"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aab162c4ba231de5ffbfc62dc3803e8ff">power6</a> (T x)</td></tr>
<tr class="memdesc:aab162c4ba231de5ffbfc62dc3803e8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate x^6  <a href="#aab162c4ba231de5ffbfc62dc3803e8ff">More...</a><br/></td></tr>
<tr class="separator:aab162c4ba231de5ffbfc62dc3803e8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800ac84e9ee71a2dc0eedda74bea1513"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a800ac84e9ee71a2dc0eedda74bea1513"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a800ac84e9ee71a2dc0eedda74bea1513">power12</a> (T x)</td></tr>
<tr class="memdesc:a800ac84e9ee71a2dc0eedda74bea1513"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate x^12  <a href="#a800ac84e9ee71a2dc0eedda74bea1513">More...</a><br/></td></tr>
<tr class="separator:a800ac84e9ee71a2dc0eedda74bea1513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d3eb4aaecff5c613995ed4bce22a0a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a92d3eb4aaecff5c613995ed4bce22a0a">series_sinhx</a> (<a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> x)</td></tr>
<tr class="memdesc:a92d3eb4aaecff5c613995ed4bce22a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maclaurin series for sinh(x)/x.  <a href="#a92d3eb4aaecff5c613995ed4bce22a0a">More...</a><br/></td></tr>
<tr class="separator:a92d3eb4aaecff5c613995ed4bce22a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4548b5005dd861681ff13e55e5b6f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2c4548b5005dd861681ff13e55e5b6f9">invertBoxMatrix</a> (const matrix src, matrix dest)</td></tr>
<tr class="memdesc:a2c4548b5005dd861681ff13e55e5b6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert a simulation-box matrix in <code>src</code>, return in <code>dest</code>.  <a href="#a2c4548b5005dd861681ff13e55e5b6f9">More...</a><br/></td></tr>
<tr class="separator:a2c4548b5005dd861681ff13e55e5b6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2824e7adcb69e96942fefcb67809ec5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2824e7adcb69e96942fefcb67809ec5e">invertMatrix</a> (const matrix src, matrix dest)</td></tr>
<tr class="memdesc:a2824e7adcb69e96942fefcb67809ec5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert a general 3x3 matrix in <code>src</code>, return in <code>dest</code>.  <a href="#a2824e7adcb69e96942fefcb67809ec5e">More...</a><br/></td></tr>
<tr class="separator:a2824e7adcb69e96942fefcb67809ec5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28594b0fbe8151cffa0eb0f3db2a2ce9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a28594b0fbe8151cffa0eb0f3db2a2ce9"></a>
template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a28594b0fbe8151cffa0eb0f3db2a2ce9"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classgmx_1_1BasicVector.xhtml">BasicVector</a>&lt; ValueType &gt;<br class="typebreak"/>
::RawArray *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a28594b0fbe8151cffa0eb0f3db2a2ce9">as_vec_array</a> (<a class="el" href="classgmx_1_1BasicVector.xhtml">BasicVector</a>&lt; ValueType &gt; *x)</td></tr>
<tr class="memdesc:a28594b0fbe8151cffa0eb0f3db2a2ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a <a class="el" href="classgmx_1_1BasicVector.xhtml" title="C++ class for 3D vectors. ">gmx::BasicVector</a> array into an equivalent raw C array. <br/></td></tr>
<tr class="separator:a28594b0fbe8151cffa0eb0f3db2a2ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869efe6effe059ca2a9ebe609d2c30ee"><td class="memTemplParams" colspan="2"><a class="anchor" id="a869efe6effe059ca2a9ebe609d2c30ee"></a>
template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a869efe6effe059ca2a9ebe609d2c30ee"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classgmx_1_1BasicVector.xhtml">BasicVector</a><br class="typebreak"/>
&lt; ValueType &gt;::RawArray *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a869efe6effe059ca2a9ebe609d2c30ee">as_vec_array</a> (const <a class="el" href="classgmx_1_1BasicVector.xhtml">BasicVector</a>&lt; ValueType &gt; *x)</td></tr>
<tr class="memdesc:a869efe6effe059ca2a9ebe609d2c30ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a <a class="el" href="classgmx_1_1BasicVector.xhtml" title="C++ class for 3D vectors. ">gmx::BasicVector</a> array into an equivalent raw C array. <br/></td></tr>
<tr class="separator:a869efe6effe059ca2a9ebe609d2c30ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e7b50af65a3361901a37364ad0fa8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5e7b50af65a3361901a37364ad0fa8d"></a>
static rvec *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ac5e7b50af65a3361901a37364ad0fa8d">as_rvec_array</a> (<a class="el" href="namespacegmx.xhtml#a139c1919a9680de4ad1450f42e37d33b">RVec</a> *x)</td></tr>
<tr class="memdesc:ac5e7b50af65a3361901a37364ad0fa8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a <a class="el" href="namespacegmx.xhtml#a139c1919a9680de4ad1450f42e37d33b" title="Shorthand for C++ rvec-equivalent type. ">gmx::RVec</a> array into an <code>rvec</code> array. <br/></td></tr>
<tr class="separator:ac5e7b50af65a3361901a37364ad0fa8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa725d6666d8341042ae4fa3667bf83b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa725d6666d8341042ae4fa3667bf83b1"></a>
static const rvec *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa725d6666d8341042ae4fa3667bf83b1">as_rvec_array</a> (const <a class="el" href="namespacegmx.xhtml#a139c1919a9680de4ad1450f42e37d33b">RVec</a> *x)</td></tr>
<tr class="memdesc:aa725d6666d8341042ae4fa3667bf83b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a <a class="el" href="namespacegmx.xhtml#a139c1919a9680de4ad1450f42e37d33b" title="Shorthand for C++ rvec-equivalent type. ">gmx::RVec</a> array into an <code>rvec</code> array. <br/></td></tr>
<tr class="separator:aa725d6666d8341042ae4fa3667bf83b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b53df1703a70801419ef4f9004454bd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a0b53df1703a70801419ef4f9004454bd">do_cg</a> (FILE *fplog, t_commrec *cr, int nfile, const <a class="el" href="structt__filenm.xhtml">t_filenm</a> fnm[], const gmx_output_env_t *oenv, <a class="el" href="basedefinitions_8h.xhtml#a8fddad319f226e856400d190198d5151">gmx_bool</a> bVerbose, int nstglobalcomm, gmx_vsite_t *vsite, gmx_constr_t constr, int stepout, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, t_state *state_global, <a class="el" href="structt__mdatoms.xhtml">t_mdatoms</a> *mdatoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, t_forcerec *fr, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, gmx_membed_t *membed, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> cpt_period, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> max_hours, int imdport, unsigned long Flags, gmx_walltime_accounting_t walltime_accounting)</td></tr>
<tr class="memdesc:a0b53df1703a70801419ef4f9004454bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do conjugate gradients minimization.  <a href="#a0b53df1703a70801419ef4f9004454bd">More...</a><br/></td></tr>
<tr class="separator:a0b53df1703a70801419ef4f9004454bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaabfc51bc04f2b0de66f075051a610a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#afaabfc51bc04f2b0de66f075051a610a">do_lbfgs</a> (FILE *fplog, t_commrec *cr, int nfile, const <a class="el" href="structt__filenm.xhtml">t_filenm</a> fnm[], const gmx_output_env_t *oenv, <a class="el" href="basedefinitions_8h.xhtml#a8fddad319f226e856400d190198d5151">gmx_bool</a> bVerbose, int nstglobalcomm, gmx_vsite_t *vsite, gmx_constr_t constr, int stepout, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, t_state *state_global, <a class="el" href="structt__mdatoms.xhtml">t_mdatoms</a> *mdatoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, t_forcerec *fr, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, gmx_membed_t *membed, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> cpt_period, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> max_hours, int imdport, unsigned long Flags, gmx_walltime_accounting_t walltime_accounting)</td></tr>
<tr class="memdesc:afaabfc51bc04f2b0de66f075051a610a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do L-BFGS conjugate gradients minimization.  <a href="#afaabfc51bc04f2b0de66f075051a610a">More...</a><br/></td></tr>
<tr class="separator:afaabfc51bc04f2b0de66f075051a610a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae556e926034aab8ae03d4aa73e2bab4b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ae556e926034aab8ae03d4aa73e2bab4b">do_steep</a> (FILE *fplog, t_commrec *cr, int nfile, const <a class="el" href="structt__filenm.xhtml">t_filenm</a> fnm[], const gmx_output_env_t *oenv, <a class="el" href="basedefinitions_8h.xhtml#a8fddad319f226e856400d190198d5151">gmx_bool</a> bVerbose, int nstglobalcomm, gmx_vsite_t *vsite, gmx_constr_t constr, int stepout, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, t_state *state_global, <a class="el" href="structt__mdatoms.xhtml">t_mdatoms</a> *mdatoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, t_forcerec *fr, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, gmx_membed_t *membed, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> cpt_period, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> max_hours, int imdport, unsigned long Flags, gmx_walltime_accounting_t walltime_accounting)</td></tr>
<tr class="memdesc:ae556e926034aab8ae03d4aa73e2bab4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do steepest descents minimization.  <a href="#ae556e926034aab8ae03d4aa73e2bab4b">More...</a><br/></td></tr>
<tr class="separator:ae556e926034aab8ae03d4aa73e2bab4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d0485fabdfa4c15b00267ad27d9a0e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ac8d0485fabdfa4c15b00267ad27d9a0e">do_nm</a> (FILE *fplog, t_commrec *cr, int nfile, const <a class="el" href="structt__filenm.xhtml">t_filenm</a> fnm[], const gmx_output_env_t *oenv, <a class="el" href="basedefinitions_8h.xhtml#a8fddad319f226e856400d190198d5151">gmx_bool</a> bVerbose, int nstglobalcomm, gmx_vsite_t *vsite, gmx_constr_t constr, int stepout, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, t_state *state_global, <a class="el" href="structt__mdatoms.xhtml">t_mdatoms</a> *mdatoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, t_forcerec *fr, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, gmx_membed_t *membed, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> cpt_period, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> max_hours, int imdport, unsigned long Flags, gmx_walltime_accounting_t walltime_accounting)</td></tr>
<tr class="memdesc:ac8d0485fabdfa4c15b00267ad27d9a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do normal modes analysis.  <a href="#ac8d0485fabdfa4c15b00267ad27d9a0e">More...</a><br/></td></tr>
<tr class="separator:ac8d0485fabdfa4c15b00267ad27d9a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861907c530b5abf0554f48167ebdd2e8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a861907c530b5abf0554f48167ebdd2e8">do_tpi</a> (FILE *fplog, t_commrec *cr, int nfile, const <a class="el" href="structt__filenm.xhtml">t_filenm</a> fnm[], const gmx_output_env_t *oenv, <a class="el" href="basedefinitions_8h.xhtml#a8fddad319f226e856400d190198d5151">gmx_bool</a> bVerbose, int nstglobalcomm, gmx_vsite_t *vsite, gmx_constr_t constr, int stepout, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, t_state *state_global, <a class="el" href="structt__mdatoms.xhtml">t_mdatoms</a> *mdatoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, t_forcerec *fr, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, gmx_membed_t *membed, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> cpt_period, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> max_hours, int imdport, unsigned long Flags, gmx_walltime_accounting_t walltime_accounting)</td></tr>
<tr class="memdesc:a861907c530b5abf0554f48167ebdd2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do test particle insertion.  <a href="#a861907c530b5abf0554f48167ebdd2e8">More...</a><br/></td></tr>
<tr class="separator:a861907c530b5abf0554f48167ebdd2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddacc94505a46b63d40a995556cef32"><td class="memItemLeft" align="right" valign="top">gmx_uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a8ddacc94505a46b63d40a995556cef32">makeRandomSeed</a> ()</td></tr>
<tr class="memdesc:a8ddacc94505a46b63d40a995556cef32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 64 random bits from the random device, suitable as seed.  <a href="#a8ddacc94505a46b63d40a995556cef32">More...</a><br/></td></tr>
<tr class="separator:a8ddacc94505a46b63d40a995556cef32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba622deb792fdc881824ce7a36d8440"><td class="memTemplParams" colspan="2">template&lt;class RealType  = real, unsigned int Bits, class Rng &gt; </td></tr>
<tr class="memitem:a7ba622deb792fdc881824ce7a36d8440"><td class="memTemplItemLeft" align="right" valign="top">RealType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a7ba622deb792fdc881824ce7a36d8440">generateCanonical</a> (Rng &amp;g)</td></tr>
<tr class="memdesc:a7ba622deb792fdc881824ce7a36d8440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a floating-point value with specified number of random bits.  <a href="#a7ba622deb792fdc881824ce7a36d8440">More...</a><br/></td></tr>
<tr class="separator:a7ba622deb792fdc881824ce7a36d8440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073963d19e7e6337168de8dc0005b7e4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a073963d19e7e6337168de8dc0005b7e4">simdPrefetch</a> (void *m)</td></tr>
<tr class="memdesc:a073963d19e7e6337168de8dc0005b7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefetch memory at address m.  <a href="#a073963d19e7e6337168de8dc0005b7e4">More...</a><br/></td></tr>
<tr class="separator:a073963d19e7e6337168de8dc0005b7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba56cff453ff9a1f21a11d72358592a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a5ba56cff453ff9a1f21a11d72358592a">store</a> (float *m, float a)</td></tr>
<tr class="memdesc:a5ba56cff453ff9a1f21a11d72358592a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store contents of float variable to aligned memory m.  <a href="#a5ba56cff453ff9a1f21a11d72358592a">More...</a><br/></td></tr>
<tr class="separator:a5ba56cff453ff9a1f21a11d72358592a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a3dcd7322b5b2555938fe1c05be15f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af3a3dcd7322b5b2555938fe1c05be15f">storeU</a> (float *m, float a)</td></tr>
<tr class="memdesc:af3a3dcd7322b5b2555938fe1c05be15f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store contents of float variable to unaligned memory m.  <a href="#af3a3dcd7322b5b2555938fe1c05be15f">More...</a><br/></td></tr>
<tr class="separator:af3a3dcd7322b5b2555938fe1c05be15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183d89182d418bb66a668104978af5bf"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a183d89182d418bb66a668104978af5bf">fma</a> (float a, float b, float c)</td></tr>
<tr class="memdesc:a183d89182d418bb66a668104978af5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float Fused-multiply-add. Result is a*b + c.  <a href="#a183d89182d418bb66a668104978af5bf">More...</a><br/></td></tr>
<tr class="separator:a183d89182d418bb66a668104978af5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad947f51589a3a9eef2f8364ab62c19"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#afad947f51589a3a9eef2f8364ab62c19">fms</a> (float a, float b, float c)</td></tr>
<tr class="memdesc:afad947f51589a3a9eef2f8364ab62c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float Fused-multiply-subtract. Result is a*b - c.  <a href="#afad947f51589a3a9eef2f8364ab62c19">More...</a><br/></td></tr>
<tr class="separator:afad947f51589a3a9eef2f8364ab62c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55183d689ab9328c18c3b3f819bd7266"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a55183d689ab9328c18c3b3f819bd7266">fnma</a> (float a, float b, float c)</td></tr>
<tr class="memdesc:a55183d689ab9328c18c3b3f819bd7266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float Fused-negated-multiply-add. Result is -a*b + c.  <a href="#a55183d689ab9328c18c3b3f819bd7266">More...</a><br/></td></tr>
<tr class="separator:a55183d689ab9328c18c3b3f819bd7266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e6950597f4833fa93b09a94e7b0e16"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa6e6950597f4833fa93b09a94e7b0e16">fnms</a> (float a, float b, float c)</td></tr>
<tr class="memdesc:aa6e6950597f4833fa93b09a94e7b0e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float Fused-negated-multiply-subtract. Result is -a*b - c.  <a href="#aa6e6950597f4833fa93b09a94e7b0e16">More...</a><br/></td></tr>
<tr class="separator:aa6e6950597f4833fa93b09a94e7b0e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0178a127dde331652ab015323ae622f2"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a0178a127dde331652ab015323ae622f2">maskAdd</a> (float a, float b, float m)</td></tr>
<tr class="memdesc:a0178a127dde331652ab015323ae622f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two float variables, masked version.  <a href="#a0178a127dde331652ab015323ae622f2">More...</a><br/></td></tr>
<tr class="separator:a0178a127dde331652ab015323ae622f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3c4084e25d298f95003df8e9aeffa1"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a1e3c4084e25d298f95003df8e9aeffa1">maskzMul</a> (float a, float b, float m)</td></tr>
<tr class="memdesc:a1e3c4084e25d298f95003df8e9aeffa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two float variables, masked version.  <a href="#a1e3c4084e25d298f95003df8e9aeffa1">More...</a><br/></td></tr>
<tr class="separator:a1e3c4084e25d298f95003df8e9aeffa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8151e61ef06e30e360c03bba6fb5e2ab"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a8151e61ef06e30e360c03bba6fb5e2ab">maskzFma</a> (float a, float b, float c, float m)</td></tr>
<tr class="memdesc:a8151e61ef06e30e360c03bba6fb5e2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float fused multiply-add, masked version.  <a href="#a8151e61ef06e30e360c03bba6fb5e2ab">More...</a><br/></td></tr>
<tr class="separator:a8151e61ef06e30e360c03bba6fb5e2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc46e83d110b8c81339683bf748fc81"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a5dc46e83d110b8c81339683bf748fc81">abs</a> (float a)</td></tr>
<tr class="memdesc:a5dc46e83d110b8c81339683bf748fc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float Floating-point <a class="el" href="namespacegmx.xhtml#a5dc46e83d110b8c81339683bf748fc81" title="Float Floating-point abs(). ">abs()</a>.  <a href="#a5dc46e83d110b8c81339683bf748fc81">More...</a><br/></td></tr>
<tr class="separator:a5dc46e83d110b8c81339683bf748fc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c7b010fbd32f5424afa0de0c70db6f"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a35c7b010fbd32f5424afa0de0c70db6f">max</a> (float a, float b)</td></tr>
<tr class="memdesc:a35c7b010fbd32f5424afa0de0c70db6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set each float element to the largest from two variables.  <a href="#a35c7b010fbd32f5424afa0de0c70db6f">More...</a><br/></td></tr>
<tr class="separator:a35c7b010fbd32f5424afa0de0c70db6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d21dccd9a94698363bdb1943f139bb"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa6d21dccd9a94698363bdb1943f139bb">min</a> (float a, float b)</td></tr>
<tr class="memdesc:aa6d21dccd9a94698363bdb1943f139bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set each float element to the smallest from two variables.  <a href="#aa6d21dccd9a94698363bdb1943f139bb">More...</a><br/></td></tr>
<tr class="separator:aa6d21dccd9a94698363bdb1943f139bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0a061335a242530d8d791459a8e2d0"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a1c0a061335a242530d8d791459a8e2d0">round</a> (float a)</td></tr>
<tr class="memdesc:a1c0a061335a242530d8d791459a8e2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float round to nearest integer value (in floating-point format).  <a href="#a1c0a061335a242530d8d791459a8e2d0">More...</a><br/></td></tr>
<tr class="separator:a1c0a061335a242530d8d791459a8e2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4323d38c16cd7ce6b1ae9df62e94ef2a"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a4323d38c16cd7ce6b1ae9df62e94ef2a">trunc</a> (float a)</td></tr>
<tr class="memdesc:a4323d38c16cd7ce6b1ae9df62e94ef2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate float, i.e. round towards zero - common hardware instruction.  <a href="#a4323d38c16cd7ce6b1ae9df62e94ef2a">More...</a><br/></td></tr>
<tr class="separator:a4323d38c16cd7ce6b1ae9df62e94ef2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a37558328ab029203170ad4c6c4d01"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa4a37558328ab029203170ad4c6c4d01">reduce</a> (float a)</td></tr>
<tr class="memdesc:aa4a37558328ab029203170ad4c6c4d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sum of all elements in float variable (i.e., the variable itself).  <a href="#aa4a37558328ab029203170ad4c6c4d01">More...</a><br/></td></tr>
<tr class="separator:aa4a37558328ab029203170ad4c6c4d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec39ef87dbec92292cd5954c922be6d"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aaec39ef87dbec92292cd5954c922be6d">andNot</a> (float a, float b)</td></tr>
<tr class="memdesc:aaec39ef87dbec92292cd5954c922be6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise andnot for two scalar float variables.  <a href="#aaec39ef87dbec92292cd5954c922be6d">More...</a><br/></td></tr>
<tr class="separator:aaec39ef87dbec92292cd5954c922be6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a3628d9b9ddc7900590f963be7bbf0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af6a3628d9b9ddc7900590f963be7bbf0">testBits</a> (float a)</td></tr>
<tr class="memdesc:af6a3628d9b9ddc7900590f963be7bbf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any bits are set in the float variable.  <a href="#af6a3628d9b9ddc7900590f963be7bbf0">More...</a><br/></td></tr>
<tr class="separator:af6a3628d9b9ddc7900590f963be7bbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90cd5d709899e47809553109383299e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af90cd5d709899e47809553109383299e">anyTrue</a> (bool a)</td></tr>
<tr class="memdesc:af90cd5d709899e47809553109383299e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the boolean is true.  <a href="#af90cd5d709899e47809553109383299e">More...</a><br/></td></tr>
<tr class="separator:af90cd5d709899e47809553109383299e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47eb155075f6f9aa99ecca11825b021"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af47eb155075f6f9aa99ecca11825b021">selectByMask</a> (float a, bool mask)</td></tr>
<tr class="memdesc:af47eb155075f6f9aa99ecca11825b021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from single precision variable where boolean is true.  <a href="#af47eb155075f6f9aa99ecca11825b021">More...</a><br/></td></tr>
<tr class="separator:af47eb155075f6f9aa99ecca11825b021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f8ccf8f582242260b4e785ebf48e3a"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a76f8ccf8f582242260b4e785ebf48e3a">selectByNotMask</a> (float a, bool mask)</td></tr>
<tr class="memdesc:a76f8ccf8f582242260b4e785ebf48e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from single precision variable where boolean is false.  <a href="#a76f8ccf8f582242260b4e785ebf48e3a">More...</a><br/></td></tr>
<tr class="separator:a76f8ccf8f582242260b4e785ebf48e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c5db5940f1fed568d8d6a0dbe7ec1a"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a31c5db5940f1fed568d8d6a0dbe7ec1a">blend</a> (float a, float b, float sel)</td></tr>
<tr class="memdesc:a31c5db5940f1fed568d8d6a0dbe7ec1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blend float selection.  <a href="#a31c5db5940f1fed568d8d6a0dbe7ec1a">More...</a><br/></td></tr>
<tr class="separator:a31c5db5940f1fed568d8d6a0dbe7ec1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2136f5684897fc7ea139039eba172629"><td class="memItemLeft" align="right" valign="top">static std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2136f5684897fc7ea139039eba172629">cvtR2I</a> (float a)</td></tr>
<tr class="memdesc:a2136f5684897fc7ea139039eba172629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round single precision floating point to integer.  <a href="#a2136f5684897fc7ea139039eba172629">More...</a><br/></td></tr>
<tr class="separator:a2136f5684897fc7ea139039eba172629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c74ba54abe2627167abfc0df7286f5d"><td class="memItemLeft" align="right" valign="top">static std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a7c74ba54abe2627167abfc0df7286f5d">cvttR2I</a> (float a)</td></tr>
<tr class="memdesc:a7c74ba54abe2627167abfc0df7286f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate single precision floating point to integer.  <a href="#a7c74ba54abe2627167abfc0df7286f5d">More...</a><br/></td></tr>
<tr class="separator:a7c74ba54abe2627167abfc0df7286f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69388fb35cb4b891c7517554e4500615"><td class="memItemLeft" align="right" valign="top">static std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a69388fb35cb4b891c7517554e4500615">cvtI2R</a> (std::int32_t a)</td></tr>
<tr class="memdesc:a69388fb35cb4b891c7517554e4500615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return integer.  <a href="#a69388fb35cb4b891c7517554e4500615">More...</a><br/></td></tr>
<tr class="separator:a69388fb35cb4b891c7517554e4500615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1d0d7a9f81e8e5cac19a3b66f0170e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aea1d0d7a9f81e8e5cac19a3b66f0170e">store</a> (double *m, double a)</td></tr>
<tr class="memdesc:aea1d0d7a9f81e8e5cac19a3b66f0170e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store contents of double variable to aligned memory m.  <a href="#aea1d0d7a9f81e8e5cac19a3b66f0170e">More...</a><br/></td></tr>
<tr class="separator:aea1d0d7a9f81e8e5cac19a3b66f0170e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9644fa777bc5e47ff9d3e2bdde34e0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aea9644fa777bc5e47ff9d3e2bdde34e0">storeU</a> (double *m, double a)</td></tr>
<tr class="memdesc:aea9644fa777bc5e47ff9d3e2bdde34e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store contents of double variable to unaligned memory m.  <a href="#aea9644fa777bc5e47ff9d3e2bdde34e0">More...</a><br/></td></tr>
<tr class="separator:aea9644fa777bc5e47ff9d3e2bdde34e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e2ba07938cafa28c0988ba52874f46"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a79e2ba07938cafa28c0988ba52874f46">fma</a> (double a, double b, double c)</td></tr>
<tr class="memdesc:a79e2ba07938cafa28c0988ba52874f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">double Fused-multiply-add. Result is a*b + c.  <a href="#a79e2ba07938cafa28c0988ba52874f46">More...</a><br/></td></tr>
<tr class="separator:a79e2ba07938cafa28c0988ba52874f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb2c8942d173c6a9964940f90c55b2a"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#abcb2c8942d173c6a9964940f90c55b2a">fms</a> (double a, double b, double c)</td></tr>
<tr class="memdesc:abcb2c8942d173c6a9964940f90c55b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">double Fused-multiply-subtract. Result is a*b - c.  <a href="#abcb2c8942d173c6a9964940f90c55b2a">More...</a><br/></td></tr>
<tr class="separator:abcb2c8942d173c6a9964940f90c55b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf7849c8ce1bbbe3e2fecffedfc05e8"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#adcf7849c8ce1bbbe3e2fecffedfc05e8">fnma</a> (double a, double b, double c)</td></tr>
<tr class="memdesc:adcf7849c8ce1bbbe3e2fecffedfc05e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">double Fused-negated-multiply-add. Result is - a*b + c.  <a href="#adcf7849c8ce1bbbe3e2fecffedfc05e8">More...</a><br/></td></tr>
<tr class="separator:adcf7849c8ce1bbbe3e2fecffedfc05e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bd8328d5cbdb7f6a054b877183f277"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ad9bd8328d5cbdb7f6a054b877183f277">fnms</a> (double a, double b, double c)</td></tr>
<tr class="memdesc:ad9bd8328d5cbdb7f6a054b877183f277"><td class="mdescLeft">&#160;</td><td class="mdescRight">double Fused-negated-multiply-subtract. Result is -a*b - c.  <a href="#ad9bd8328d5cbdb7f6a054b877183f277">More...</a><br/></td></tr>
<tr class="separator:ad9bd8328d5cbdb7f6a054b877183f277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b090d0e3ab5695c508453406ee43c8"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a68b090d0e3ab5695c508453406ee43c8">maskAdd</a> (double a, double b, double m)</td></tr>
<tr class="memdesc:a68b090d0e3ab5695c508453406ee43c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two double variables, masked version.  <a href="#a68b090d0e3ab5695c508453406ee43c8">More...</a><br/></td></tr>
<tr class="separator:a68b090d0e3ab5695c508453406ee43c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4ab8b1ab046ff242d32ab93366bfde"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a7e4ab8b1ab046ff242d32ab93366bfde">maskzMul</a> (double a, double b, double m)</td></tr>
<tr class="memdesc:a7e4ab8b1ab046ff242d32ab93366bfde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two double variables, masked version.  <a href="#a7e4ab8b1ab046ff242d32ab93366bfde">More...</a><br/></td></tr>
<tr class="separator:a7e4ab8b1ab046ff242d32ab93366bfde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cf4eaad108887d2462f5beecd4db62"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa3cf4eaad108887d2462f5beecd4db62">maskzFma</a> (double a, double b, double c, double m)</td></tr>
<tr class="memdesc:aa3cf4eaad108887d2462f5beecd4db62"><td class="mdescLeft">&#160;</td><td class="mdescRight">double fused multiply-add, masked version.  <a href="#aa3cf4eaad108887d2462f5beecd4db62">More...</a><br/></td></tr>
<tr class="separator:aa3cf4eaad108887d2462f5beecd4db62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85ea3af684916aee86e2674a6bd81e5"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ac85ea3af684916aee86e2674a6bd81e5">abs</a> (double a)</td></tr>
<tr class="memdesc:ac85ea3af684916aee86e2674a6bd81e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">double doubleing-point <a class="el" href="namespacegmx.xhtml#a5dc46e83d110b8c81339683bf748fc81" title="Float Floating-point abs(). ">abs()</a>.  <a href="#ac85ea3af684916aee86e2674a6bd81e5">More...</a><br/></td></tr>
<tr class="separator:ac85ea3af684916aee86e2674a6bd81e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f6bf4a20b14262f28168596d5bb8b9"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a16f6bf4a20b14262f28168596d5bb8b9">max</a> (double a, double b)</td></tr>
<tr class="memdesc:a16f6bf4a20b14262f28168596d5bb8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set each double element to the largest from two variables.  <a href="#a16f6bf4a20b14262f28168596d5bb8b9">More...</a><br/></td></tr>
<tr class="separator:a16f6bf4a20b14262f28168596d5bb8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65fb0c7aa84962905d3d78a913c787c3"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a65fb0c7aa84962905d3d78a913c787c3">min</a> (double a, double b)</td></tr>
<tr class="memdesc:a65fb0c7aa84962905d3d78a913c787c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set each double element to the smallest from two variables.  <a href="#a65fb0c7aa84962905d3d78a913c787c3">More...</a><br/></td></tr>
<tr class="separator:a65fb0c7aa84962905d3d78a913c787c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15179b513c1ec4ec0b9090e57b76bac4"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a15179b513c1ec4ec0b9090e57b76bac4">round</a> (double a)</td></tr>
<tr class="memdesc:a15179b513c1ec4ec0b9090e57b76bac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">double round to nearest integer value (in doubleing-point format).  <a href="#a15179b513c1ec4ec0b9090e57b76bac4">More...</a><br/></td></tr>
<tr class="separator:a15179b513c1ec4ec0b9090e57b76bac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d84f65dae98aeb02816975f5045eed"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a00d84f65dae98aeb02816975f5045eed">trunc</a> (double a)</td></tr>
<tr class="memdesc:a00d84f65dae98aeb02816975f5045eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate double, i.e. round towards zero - common hardware instruction.  <a href="#a00d84f65dae98aeb02816975f5045eed">More...</a><br/></td></tr>
<tr class="separator:a00d84f65dae98aeb02816975f5045eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157983d90620412d404e8a77d1ddbd0f"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a157983d90620412d404e8a77d1ddbd0f">reduce</a> (double a)</td></tr>
<tr class="memdesc:a157983d90620412d404e8a77d1ddbd0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sum of all elements in double variable (i.e., the variable itself).  <a href="#a157983d90620412d404e8a77d1ddbd0f">More...</a><br/></td></tr>
<tr class="separator:a157983d90620412d404e8a77d1ddbd0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb0315d31c3c818a738bdc153397365"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aebb0315d31c3c818a738bdc153397365">andNot</a> (double a, double b)</td></tr>
<tr class="memdesc:aebb0315d31c3c818a738bdc153397365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise andnot for two scalar double variables.  <a href="#aebb0315d31c3c818a738bdc153397365">More...</a><br/></td></tr>
<tr class="separator:aebb0315d31c3c818a738bdc153397365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58ba299df96ee6c45043e646a1d01dc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ae58ba299df96ee6c45043e646a1d01dc">testBits</a> (double a)</td></tr>
<tr class="memdesc:ae58ba299df96ee6c45043e646a1d01dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any bits are set in the double variable.  <a href="#ae58ba299df96ee6c45043e646a1d01dc">More...</a><br/></td></tr>
<tr class="separator:ae58ba299df96ee6c45043e646a1d01dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1449de9307a87e0c5946fd9cab43b35"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa1449de9307a87e0c5946fd9cab43b35">selectByMask</a> (double a, bool mask)</td></tr>
<tr class="memdesc:aa1449de9307a87e0c5946fd9cab43b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from double precision variable where boolean is true.  <a href="#aa1449de9307a87e0c5946fd9cab43b35">More...</a><br/></td></tr>
<tr class="separator:aa1449de9307a87e0c5946fd9cab43b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f03ad3380ef6213c5459051c3268ba7"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2f03ad3380ef6213c5459051c3268ba7">selectByNotMask</a> (double a, bool mask)</td></tr>
<tr class="memdesc:a2f03ad3380ef6213c5459051c3268ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from double precision variable where boolean is false.  <a href="#a2f03ad3380ef6213c5459051c3268ba7">More...</a><br/></td></tr>
<tr class="separator:a2f03ad3380ef6213c5459051c3268ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90aa803db2a6a8c9dbb22395dcaf4532"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a90aa803db2a6a8c9dbb22395dcaf4532">blend</a> (double a, double b, double sel)</td></tr>
<tr class="memdesc:a90aa803db2a6a8c9dbb22395dcaf4532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blend double selection.  <a href="#a90aa803db2a6a8c9dbb22395dcaf4532">More...</a><br/></td></tr>
<tr class="separator:a90aa803db2a6a8c9dbb22395dcaf4532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9f420c1d0c099cc58ac3ae5fcb1ace"><td class="memItemLeft" align="right" valign="top">static std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#acc9f420c1d0c099cc58ac3ae5fcb1ace">cvtR2I</a> (double a)</td></tr>
<tr class="memdesc:acc9f420c1d0c099cc58ac3ae5fcb1ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round single precision doubleing point to integer.  <a href="#acc9f420c1d0c099cc58ac3ae5fcb1ace">More...</a><br/></td></tr>
<tr class="separator:acc9f420c1d0c099cc58ac3ae5fcb1ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0fb4318cc5c14075330d52382e6bdd4"><td class="memItemLeft" align="right" valign="top">static std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ac0fb4318cc5c14075330d52382e6bdd4">cvttR2I</a> (double a)</td></tr>
<tr class="memdesc:ac0fb4318cc5c14075330d52382e6bdd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate single precision doubleing point to integer.  <a href="#ac0fb4318cc5c14075330d52382e6bdd4">More...</a><br/></td></tr>
<tr class="separator:ac0fb4318cc5c14075330d52382e6bdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac575d3b81809b71e414755dc8acf3317"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ac575d3b81809b71e414755dc8acf3317">cvtF2D</a> (float a)</td></tr>
<tr class="memdesc:ac575d3b81809b71e414755dc8acf3317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert float to double (mimicks SIMD conversion)  <a href="#ac575d3b81809b71e414755dc8acf3317">More...</a><br/></td></tr>
<tr class="separator:ac575d3b81809b71e414755dc8acf3317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22401779c65549d3061b4fdd5290ef19"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a22401779c65549d3061b4fdd5290ef19">cvtD2F</a> (double a)</td></tr>
<tr class="memdesc:a22401779c65549d3061b4fdd5290ef19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert double to float (mimicks SIMD conversion)  <a href="#a22401779c65549d3061b4fdd5290ef19">More...</a><br/></td></tr>
<tr class="separator:a22401779c65549d3061b4fdd5290ef19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa169afcbfb3992ab9fde1ed5beee8b06"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa169afcbfb3992ab9fde1ed5beee8b06">store</a> (std::int32_t *m, std::int32_t a)</td></tr>
<tr class="memdesc:aa169afcbfb3992ab9fde1ed5beee8b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store contents of integer variable to aligned memory m.  <a href="#aa169afcbfb3992ab9fde1ed5beee8b06">More...</a><br/></td></tr>
<tr class="separator:aa169afcbfb3992ab9fde1ed5beee8b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43354d3d210193bcf5316234dc7d93ae"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a43354d3d210193bcf5316234dc7d93ae">storeU</a> (std::int32_t *m, std::int32_t a)</td></tr>
<tr class="memdesc:a43354d3d210193bcf5316234dc7d93ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store contents of integer variable to unaligned memory m.  <a href="#a43354d3d210193bcf5316234dc7d93ae">More...</a><br/></td></tr>
<tr class="separator:a43354d3d210193bcf5316234dc7d93ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880a42645963c52980a5790f09e3bd18"><td class="memItemLeft" align="right" valign="top">static std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a880a42645963c52980a5790f09e3bd18">andNot</a> (std::int32_t a, std::int32_t b)</td></tr>
<tr class="memdesc:a880a42645963c52980a5790f09e3bd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise andnot for two scalar integer variables.  <a href="#a880a42645963c52980a5790f09e3bd18">More...</a><br/></td></tr>
<tr class="separator:a880a42645963c52980a5790f09e3bd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a03b61db6a3ed3e8c2d5e1b3acc9a8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ae2a03b61db6a3ed3e8c2d5e1b3acc9a8">testBits</a> (std::int32_t a)</td></tr>
<tr class="memdesc:ae2a03b61db6a3ed3e8c2d5e1b3acc9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any bits are set in the integer variable.  <a href="#ae2a03b61db6a3ed3e8c2d5e1b3acc9a8">More...</a><br/></td></tr>
<tr class="separator:ae2a03b61db6a3ed3e8c2d5e1b3acc9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543420229312467871aaa26ea79f5a5d"><td class="memItemLeft" align="right" valign="top">static std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a543420229312467871aaa26ea79f5a5d">selectByMask</a> (std::int32_t a, bool mask)</td></tr>
<tr class="memdesc:a543420229312467871aaa26ea79f5a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from integer variable where boolean is true.  <a href="#a543420229312467871aaa26ea79f5a5d">More...</a><br/></td></tr>
<tr class="separator:a543420229312467871aaa26ea79f5a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c7d81b9ba8302dadcbdded4fcd4399"><td class="memItemLeft" align="right" valign="top">static std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa1c7d81b9ba8302dadcbdded4fcd4399">selectByNotMask</a> (std::int32_t a, bool mask)</td></tr>
<tr class="memdesc:aa1c7d81b9ba8302dadcbdded4fcd4399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from integer variable where boolean is false.  <a href="#aa1c7d81b9ba8302dadcbdded4fcd4399">More...</a><br/></td></tr>
<tr class="separator:aa1c7d81b9ba8302dadcbdded4fcd4399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf33872c1b22ffd9340e77410c693083"><td class="memItemLeft" align="right" valign="top">static std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#acf33872c1b22ffd9340e77410c693083">blend</a> (std::int32_t a, std::int32_t b, float sel)</td></tr>
<tr class="memdesc:acf33872c1b22ffd9340e77410c693083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blend integer selection.  <a href="#acf33872c1b22ffd9340e77410c693083">More...</a><br/></td></tr>
<tr class="separator:acf33872c1b22ffd9340e77410c693083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27254f29caa9fd12a6e774bf7a13502c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a27254f29caa9fd12a6e774bf7a13502c">cvtB2IB</a> (bool a)</td></tr>
<tr class="memdesc:a27254f29caa9fd12a6e774bf7a13502c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just return a boolean (mimicks SIMD real-to-int bool conversions)  <a href="#a27254f29caa9fd12a6e774bf7a13502c">More...</a><br/></td></tr>
<tr class="separator:a27254f29caa9fd12a6e774bf7a13502c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a600fa6a48b5df753c2fcc99c47f3f3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2a600fa6a48b5df753c2fcc99c47f3f3">cvtIB2B</a> (bool a)</td></tr>
<tr class="memdesc:a2a600fa6a48b5df753c2fcc99c47f3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just return a boolean (mimicks SIMD int-to-real bool conversions)  <a href="#a2a600fa6a48b5df753c2fcc99c47f3f3">More...</a><br/></td></tr>
<tr class="separator:a2a600fa6a48b5df753c2fcc99c47f3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef5f6af06e493a4ae2d47109ee0e723"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a8ef5f6af06e493a4ae2d47109ee0e723">copysign</a> (float x, float y)</td></tr>
<tr class="memdesc:a8ef5f6af06e493a4ae2d47109ee0e723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes single value with the magnitude of x and the sign of y.  <a href="#a8ef5f6af06e493a4ae2d47109ee0e723">More...</a><br/></td></tr>
<tr class="separator:a8ef5f6af06e493a4ae2d47109ee0e723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2ac92d9abba8296506e281dc66c47a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aba2ac92d9abba8296506e281dc66c47a">invsqrtPair</a> (float x0, float x1, float *out0, float *out1)</td></tr>
<tr class="memdesc:aba2ac92d9abba8296506e281dc66c47a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for two floats.  <a href="#aba2ac92d9abba8296506e281dc66c47a">More...</a><br/></td></tr>
<tr class="separator:aba2ac92d9abba8296506e281dc66c47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd74be08263227a2b2f4405dee6a359"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a6cd74be08263227a2b2f4405dee6a359">inv</a> (float x)</td></tr>
<tr class="memdesc:a6cd74be08263227a2b2f4405dee6a359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/x for float.  <a href="#a6cd74be08263227a2b2f4405dee6a359">More...</a><br/></td></tr>
<tr class="separator:a6cd74be08263227a2b2f4405dee6a359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa182f9ceead92b3055e6ae5903994651"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa182f9ceead92b3055e6ae5903994651">maskzInvsqrt</a> (float x, bool m)</td></tr>
<tr class="memdesc:aa182f9ceead92b3055e6ae5903994651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for masked entry of float.  <a href="#aa182f9ceead92b3055e6ae5903994651">More...</a><br/></td></tr>
<tr class="separator:aa182f9ceead92b3055e6ae5903994651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582d71ff8e7d51cbd2386e29935e89ef"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a582d71ff8e7d51cbd2386e29935e89ef">maskzInv</a> (float x, bool m)</td></tr>
<tr class="memdesc:a582d71ff8e7d51cbd2386e29935e89ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/x for masked entry of float.  <a href="#a582d71ff8e7d51cbd2386e29935e89ef">More...</a><br/></td></tr>
<tr class="separator:a582d71ff8e7d51cbd2386e29935e89ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0a25f25b649f59d96b67f2d73c8ad8"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a7b0a25f25b649f59d96b67f2d73c8ad8">log</a> (float x)</td></tr>
<tr class="memdesc:a7b0a25f25b649f59d96b67f2d73c8ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float log(x). This is the natural logarithm.  <a href="#a7b0a25f25b649f59d96b67f2d73c8ad8">More...</a><br/></td></tr>
<tr class="separator:a7b0a25f25b649f59d96b67f2d73c8ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7303338070cf13c11a8b765017a182"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aed7303338070cf13c11a8b765017a182">exp2</a> (float x)</td></tr>
<tr class="memdesc:aed7303338070cf13c11a8b765017a182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float 2^x.  <a href="#aed7303338070cf13c11a8b765017a182">More...</a><br/></td></tr>
<tr class="separator:aed7303338070cf13c11a8b765017a182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3a53c1076c47dbbef4e6ec2d3191ce"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a8b3a53c1076c47dbbef4e6ec2d3191ce">exp</a> (float x)</td></tr>
<tr class="memdesc:a8b3a53c1076c47dbbef4e6ec2d3191ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float exp(x).  <a href="#a8b3a53c1076c47dbbef4e6ec2d3191ce">More...</a><br/></td></tr>
<tr class="separator:a8b3a53c1076c47dbbef4e6ec2d3191ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a81ecdda73e384cd4e6896492144529"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a9a81ecdda73e384cd4e6896492144529">erf</a> (float x)</td></tr>
<tr class="memdesc:a9a81ecdda73e384cd4e6896492144529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float erf(x).  <a href="#a9a81ecdda73e384cd4e6896492144529">More...</a><br/></td></tr>
<tr class="separator:a9a81ecdda73e384cd4e6896492144529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad005ed4133f5a01702c63a9440feab7"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aad005ed4133f5a01702c63a9440feab7">erfc</a> (float x)</td></tr>
<tr class="memdesc:aad005ed4133f5a01702c63a9440feab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float erfc(x).  <a href="#aad005ed4133f5a01702c63a9440feab7">More...</a><br/></td></tr>
<tr class="separator:aad005ed4133f5a01702c63a9440feab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3191310c1a122aafe946f0caf2fdf364"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a3191310c1a122aafe946f0caf2fdf364">sincos</a> (float x, float *sinval, float *cosval)</td></tr>
<tr class="memdesc:a3191310c1a122aafe946f0caf2fdf364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float sin &amp; cos.  <a href="#a3191310c1a122aafe946f0caf2fdf364">More...</a><br/></td></tr>
<tr class="separator:a3191310c1a122aafe946f0caf2fdf364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85c54a566c85f916aaa2561d12fa851"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af85c54a566c85f916aaa2561d12fa851">sin</a> (float x)</td></tr>
<tr class="memdesc:af85c54a566c85f916aaa2561d12fa851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float sin.  <a href="#af85c54a566c85f916aaa2561d12fa851">More...</a><br/></td></tr>
<tr class="separator:af85c54a566c85f916aaa2561d12fa851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c6356a58f3d2c2fe6d2f50afc0c686"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a16c6356a58f3d2c2fe6d2f50afc0c686">cos</a> (float x)</td></tr>
<tr class="memdesc:a16c6356a58f3d2c2fe6d2f50afc0c686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float cos.  <a href="#a16c6356a58f3d2c2fe6d2f50afc0c686">More...</a><br/></td></tr>
<tr class="separator:a16c6356a58f3d2c2fe6d2f50afc0c686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7063173231453ec737688c8d91aa0749"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a7063173231453ec737688c8d91aa0749">tan</a> (float x)</td></tr>
<tr class="memdesc:a7063173231453ec737688c8d91aa0749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float tan.  <a href="#a7063173231453ec737688c8d91aa0749">More...</a><br/></td></tr>
<tr class="separator:a7063173231453ec737688c8d91aa0749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5120df9c0bf437e64c806a7cfdad02"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a3d5120df9c0bf437e64c806a7cfdad02">asin</a> (float x)</td></tr>
<tr class="memdesc:a3d5120df9c0bf437e64c806a7cfdad02"><td class="mdescLeft">&#160;</td><td class="mdescRight">float asin.  <a href="#a3d5120df9c0bf437e64c806a7cfdad02">More...</a><br/></td></tr>
<tr class="separator:a3d5120df9c0bf437e64c806a7cfdad02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab102173c68c06e7a340e4eebbf6c3492"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ab102173c68c06e7a340e4eebbf6c3492">acos</a> (float x)</td></tr>
<tr class="memdesc:ab102173c68c06e7a340e4eebbf6c3492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float acos.  <a href="#ab102173c68c06e7a340e4eebbf6c3492">More...</a><br/></td></tr>
<tr class="separator:ab102173c68c06e7a340e4eebbf6c3492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1afbc2ada56f899a8d3dc5c61530e28b"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a1afbc2ada56f899a8d3dc5c61530e28b">atan</a> (float x)</td></tr>
<tr class="memdesc:a1afbc2ada56f899a8d3dc5c61530e28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float atan.  <a href="#a1afbc2ada56f899a8d3dc5c61530e28b">More...</a><br/></td></tr>
<tr class="separator:a1afbc2ada56f899a8d3dc5c61530e28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8336a58abddcdb6afa7835138ecf46"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aed8336a58abddcdb6afa7835138ecf46">atan2</a> (float y, float x)</td></tr>
<tr class="memdesc:aed8336a58abddcdb6afa7835138ecf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float atan2(y,x).  <a href="#aed8336a58abddcdb6afa7835138ecf46">More...</a><br/></td></tr>
<tr class="separator:aed8336a58abddcdb6afa7835138ecf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5b1230d0301fa6760e34d7641ca7e4"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a1e5b1230d0301fa6760e34d7641ca7e4">pmeForceCorrection</a> (float z2)</td></tr>
<tr class="memdesc:a1e5b1230d0301fa6760e34d7641ca7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the force correction due to PME analytically in float.  <a href="#a1e5b1230d0301fa6760e34d7641ca7e4">More...</a><br/></td></tr>
<tr class="separator:a1e5b1230d0301fa6760e34d7641ca7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54e81f11cb53c7d68ff7dab05bd6afd"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ac54e81f11cb53c7d68ff7dab05bd6afd">pmePotentialCorrection</a> (float z2)</td></tr>
<tr class="memdesc:ac54e81f11cb53c7d68ff7dab05bd6afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the potential correction due to PME analytically in float.  <a href="#ac54e81f11cb53c7d68ff7dab05bd6afd">More...</a><br/></td></tr>
<tr class="separator:ac54e81f11cb53c7d68ff7dab05bd6afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cfb56189c360e005911247ebf5fd42"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af6cfb56189c360e005911247ebf5fd42">copysign</a> (double x, double y)</td></tr>
<tr class="memdesc:af6cfb56189c360e005911247ebf5fd42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes double value with the magnitude of x and the sign of y.  <a href="#af6cfb56189c360e005911247ebf5fd42">More...</a><br/></td></tr>
<tr class="separator:af6cfb56189c360e005911247ebf5fd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb50fcc000a2c2d4b8446fc17a5695e0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#abb50fcc000a2c2d4b8446fc17a5695e0">invsqrtPair</a> (double x0, double x1, double *out0, double *out1)</td></tr>
<tr class="memdesc:abb50fcc000a2c2d4b8446fc17a5695e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for two doubles.  <a href="#abb50fcc000a2c2d4b8446fc17a5695e0">More...</a><br/></td></tr>
<tr class="separator:abb50fcc000a2c2d4b8446fc17a5695e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed9172c60ed326ca31f64a490fabe17"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a8ed9172c60ed326ca31f64a490fabe17">inv</a> (double x)</td></tr>
<tr class="memdesc:a8ed9172c60ed326ca31f64a490fabe17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/x for double.  <a href="#a8ed9172c60ed326ca31f64a490fabe17">More...</a><br/></td></tr>
<tr class="separator:a8ed9172c60ed326ca31f64a490fabe17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b5a9766964a2b854f493fd783bb63d"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa5b5a9766964a2b854f493fd783bb63d">maskzInvsqrt</a> (double x, bool m)</td></tr>
<tr class="memdesc:aa5b5a9766964a2b854f493fd783bb63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for masked entry of double.  <a href="#aa5b5a9766964a2b854f493fd783bb63d">More...</a><br/></td></tr>
<tr class="separator:aa5b5a9766964a2b854f493fd783bb63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5cc89f64ab845f88816a9cbb16d467c"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af5cc89f64ab845f88816a9cbb16d467c">maskzInv</a> (double x, bool m)</td></tr>
<tr class="memdesc:af5cc89f64ab845f88816a9cbb16d467c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/x for masked entry of double.  <a href="#af5cc89f64ab845f88816a9cbb16d467c">More...</a><br/></td></tr>
<tr class="separator:af5cc89f64ab845f88816a9cbb16d467c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398a52e25652367446f9180a50343885"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a398a52e25652367446f9180a50343885">log</a> (double x)</td></tr>
<tr class="memdesc:a398a52e25652367446f9180a50343885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double log(x). This is the natural logarithm.  <a href="#a398a52e25652367446f9180a50343885">More...</a><br/></td></tr>
<tr class="separator:a398a52e25652367446f9180a50343885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8793845dd7a03f8e3d00bde1b04a2785"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a8793845dd7a03f8e3d00bde1b04a2785">exp2</a> (double x)</td></tr>
<tr class="memdesc:a8793845dd7a03f8e3d00bde1b04a2785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double 2^x.  <a href="#a8793845dd7a03f8e3d00bde1b04a2785">More...</a><br/></td></tr>
<tr class="separator:a8793845dd7a03f8e3d00bde1b04a2785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed21bd309bf862089f430402b8fd8b9"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2ed21bd309bf862089f430402b8fd8b9">exp</a> (double x)</td></tr>
<tr class="memdesc:a2ed21bd309bf862089f430402b8fd8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double exp(x).  <a href="#a2ed21bd309bf862089f430402b8fd8b9">More...</a><br/></td></tr>
<tr class="separator:a2ed21bd309bf862089f430402b8fd8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3fe934a0b6419312a82b6bb6b8b6ff"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a6a3fe934a0b6419312a82b6bb6b8b6ff">erf</a> (double x)</td></tr>
<tr class="memdesc:a6a3fe934a0b6419312a82b6bb6b8b6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double erf(x).  <a href="#a6a3fe934a0b6419312a82b6bb6b8b6ff">More...</a><br/></td></tr>
<tr class="separator:a6a3fe934a0b6419312a82b6bb6b8b6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c071a6a14720e2b94e4b034e110614"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a56c071a6a14720e2b94e4b034e110614">erfc</a> (double x)</td></tr>
<tr class="memdesc:a56c071a6a14720e2b94e4b034e110614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double erfc(x).  <a href="#a56c071a6a14720e2b94e4b034e110614">More...</a><br/></td></tr>
<tr class="separator:a56c071a6a14720e2b94e4b034e110614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5923534ff59a386ae0579eb4196b1e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a0a5923534ff59a386ae0579eb4196b1e">sincos</a> (double x, double *sinval, double *cosval)</td></tr>
<tr class="memdesc:a0a5923534ff59a386ae0579eb4196b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double sin &amp; cos.  <a href="#a0a5923534ff59a386ae0579eb4196b1e">More...</a><br/></td></tr>
<tr class="separator:a0a5923534ff59a386ae0579eb4196b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6579216abaac018cb0bc59e9183f99ba"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a6579216abaac018cb0bc59e9183f99ba">sin</a> (double x)</td></tr>
<tr class="memdesc:a6579216abaac018cb0bc59e9183f99ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double sin.  <a href="#a6579216abaac018cb0bc59e9183f99ba">More...</a><br/></td></tr>
<tr class="separator:a6579216abaac018cb0bc59e9183f99ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda573e9aa3efa5d223c9fe39f682cfd"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aeda573e9aa3efa5d223c9fe39f682cfd">cos</a> (double x)</td></tr>
<tr class="memdesc:aeda573e9aa3efa5d223c9fe39f682cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double cos.  <a href="#aeda573e9aa3efa5d223c9fe39f682cfd">More...</a><br/></td></tr>
<tr class="separator:aeda573e9aa3efa5d223c9fe39f682cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e727a4960ac7f8ba5149f9b251c520"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a45e727a4960ac7f8ba5149f9b251c520">tan</a> (double x)</td></tr>
<tr class="memdesc:a45e727a4960ac7f8ba5149f9b251c520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double tan.  <a href="#a45e727a4960ac7f8ba5149f9b251c520">More...</a><br/></td></tr>
<tr class="separator:a45e727a4960ac7f8ba5149f9b251c520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02c7d47595f11074fbfedff40145544"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ab02c7d47595f11074fbfedff40145544">asin</a> (double x)</td></tr>
<tr class="memdesc:ab02c7d47595f11074fbfedff40145544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double asin.  <a href="#ab02c7d47595f11074fbfedff40145544">More...</a><br/></td></tr>
<tr class="separator:ab02c7d47595f11074fbfedff40145544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b534003a0dba716c08d6053e0514311"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a5b534003a0dba716c08d6053e0514311">acos</a> (double x)</td></tr>
<tr class="memdesc:a5b534003a0dba716c08d6053e0514311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double acos.  <a href="#a5b534003a0dba716c08d6053e0514311">More...</a><br/></td></tr>
<tr class="separator:a5b534003a0dba716c08d6053e0514311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15e6f3962e035d69013bd91621fd9f8"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af15e6f3962e035d69013bd91621fd9f8">atan</a> (double x)</td></tr>
<tr class="memdesc:af15e6f3962e035d69013bd91621fd9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double atan.  <a href="#af15e6f3962e035d69013bd91621fd9f8">More...</a><br/></td></tr>
<tr class="separator:af15e6f3962e035d69013bd91621fd9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70a1aa5e9c161a2770d0f9b7eca1805"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa70a1aa5e9c161a2770d0f9b7eca1805">atan2</a> (double y, double x)</td></tr>
<tr class="memdesc:aa70a1aa5e9c161a2770d0f9b7eca1805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double atan2(y,x).  <a href="#aa70a1aa5e9c161a2770d0f9b7eca1805">More...</a><br/></td></tr>
<tr class="separator:aa70a1aa5e9c161a2770d0f9b7eca1805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5275f264f1c6da2502ec03e8fbf855a4"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a5275f264f1c6da2502ec03e8fbf855a4">pmeForceCorrection</a> (double z2)</td></tr>
<tr class="memdesc:a5275f264f1c6da2502ec03e8fbf855a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the force correction due to PME analytically in double.  <a href="#a5275f264f1c6da2502ec03e8fbf855a4">More...</a><br/></td></tr>
<tr class="separator:a5275f264f1c6da2502ec03e8fbf855a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba0166c05fec69dd4a2624ed8dcff95"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#acba0166c05fec69dd4a2624ed8dcff95">pmePotentialCorrection</a> (double z2)</td></tr>
<tr class="memdesc:acba0166c05fec69dd4a2624ed8dcff95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the potential correction due to PME analytically in double.  <a href="#acba0166c05fec69dd4a2624ed8dcff95">More...</a><br/></td></tr>
<tr class="separator:acba0166c05fec69dd4a2624ed8dcff95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44adc739c8fb319abe1b6769f39e9341"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a44adc739c8fb319abe1b6769f39e9341">invsqrtSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a44adc739c8fb319abe1b6769f39e9341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for double, but with single accuracy.  <a href="#a44adc739c8fb319abe1b6769f39e9341">More...</a><br/></td></tr>
<tr class="separator:a44adc739c8fb319abe1b6769f39e9341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f2d71567d1b88689c8498f3592b386"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a18f2d71567d1b88689c8498f3592b386">invsqrtPairSingleAccuracy</a> (double x0, double x1, double *out0, double *out1)</td></tr>
<tr class="memdesc:a18f2d71567d1b88689c8498f3592b386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for two doubles, but with single accuracy.  <a href="#a18f2d71567d1b88689c8498f3592b386">More...</a><br/></td></tr>
<tr class="separator:a18f2d71567d1b88689c8498f3592b386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac51c492a5589e075b7b8ebda5a8cbd"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a8ac51c492a5589e075b7b8ebda5a8cbd">invSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a8ac51c492a5589e075b7b8ebda5a8cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/x for double, but with single accuracy.  <a href="#a8ac51c492a5589e075b7b8ebda5a8cbd">More...</a><br/></td></tr>
<tr class="separator:a8ac51c492a5589e075b7b8ebda5a8cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdaf91102db0bfbc6fd440524b15199"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a1fdaf91102db0bfbc6fd440524b15199">maskzInvsqrtSingleAccuracy</a> (double x, bool m)</td></tr>
<tr class="memdesc:a1fdaf91102db0bfbc6fd440524b15199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for masked entry of double, but with single accuracy.  <a href="#a1fdaf91102db0bfbc6fd440524b15199">More...</a><br/></td></tr>
<tr class="separator:a1fdaf91102db0bfbc6fd440524b15199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2433c82892495a73bf41de15f5e8908f"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2433c82892495a73bf41de15f5e8908f">maskzInvSingleAccuracy</a> (double x, bool m)</td></tr>
<tr class="memdesc:a2433c82892495a73bf41de15f5e8908f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/x for masked entry of double, but with single accuracy.  <a href="#a2433c82892495a73bf41de15f5e8908f">More...</a><br/></td></tr>
<tr class="separator:a2433c82892495a73bf41de15f5e8908f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6d95fd83052d09775c976a961eee29"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2d6d95fd83052d09775c976a961eee29">sqrtSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a2d6d95fd83052d09775c976a961eee29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate sqrt(x) for double, but with single accuracy.  <a href="#a2d6d95fd83052d09775c976a961eee29">More...</a><br/></td></tr>
<tr class="separator:a2d6d95fd83052d09775c976a961eee29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c2c975d7e597b08a67d85920d4f562"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a54c2c975d7e597b08a67d85920d4f562">logSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a54c2c975d7e597b08a67d85920d4f562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double log(x), but with single accuracy. This is the natural logarithm.  <a href="#a54c2c975d7e597b08a67d85920d4f562">More...</a><br/></td></tr>
<tr class="separator:a54c2c975d7e597b08a67d85920d4f562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119f14f4a364f71eb9273b5dd8c927cd"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a119f14f4a364f71eb9273b5dd8c927cd">exp2SingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a119f14f4a364f71eb9273b5dd8c927cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double 2^x, but with single accuracy.  <a href="#a119f14f4a364f71eb9273b5dd8c927cd">More...</a><br/></td></tr>
<tr class="separator:a119f14f4a364f71eb9273b5dd8c927cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6d2866bd8be11dce227ad0e26511a4"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#afa6d2866bd8be11dce227ad0e26511a4">expSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:afa6d2866bd8be11dce227ad0e26511a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double exp(x), but with single accuracy.  <a href="#afa6d2866bd8be11dce227ad0e26511a4">More...</a><br/></td></tr>
<tr class="separator:afa6d2866bd8be11dce227ad0e26511a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2491a7f4b92881d4887491a532e8e5f7"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2491a7f4b92881d4887491a532e8e5f7">erfSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a2491a7f4b92881d4887491a532e8e5f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double erf(x), but with single accuracy.  <a href="#a2491a7f4b92881d4887491a532e8e5f7">More...</a><br/></td></tr>
<tr class="separator:a2491a7f4b92881d4887491a532e8e5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d277c19df61f3b0176da88ba40b53a"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a56d277c19df61f3b0176da88ba40b53a">erfcSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a56d277c19df61f3b0176da88ba40b53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double erfc(x), but with single accuracy.  <a href="#a56d277c19df61f3b0176da88ba40b53a">More...</a><br/></td></tr>
<tr class="separator:a56d277c19df61f3b0176da88ba40b53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200455e2d7401d66cac8e39b4c8142bf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a200455e2d7401d66cac8e39b4c8142bf">sincosSingleAccuracy</a> (double x, double *sinval, double *cosval)</td></tr>
<tr class="memdesc:a200455e2d7401d66cac8e39b4c8142bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double sin &amp; cos, but with single accuracy.  <a href="#a200455e2d7401d66cac8e39b4c8142bf">More...</a><br/></td></tr>
<tr class="separator:a200455e2d7401d66cac8e39b4c8142bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810c7b2f5d8f267f421f2c59a308c11d"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a810c7b2f5d8f267f421f2c59a308c11d">sinSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a810c7b2f5d8f267f421f2c59a308c11d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double sin, but with single accuracy.  <a href="#a810c7b2f5d8f267f421f2c59a308c11d">More...</a><br/></td></tr>
<tr class="separator:a810c7b2f5d8f267f421f2c59a308c11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e717707cf40d6bbacf8752cf28de422"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2e717707cf40d6bbacf8752cf28de422">cosSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a2e717707cf40d6bbacf8752cf28de422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double cos, but with single accuracy.  <a href="#a2e717707cf40d6bbacf8752cf28de422">More...</a><br/></td></tr>
<tr class="separator:a2e717707cf40d6bbacf8752cf28de422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f979f3defa4f725cfce2d7e93fc0d9e"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a0f979f3defa4f725cfce2d7e93fc0d9e">tanSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a0f979f3defa4f725cfce2d7e93fc0d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double tan, but with single accuracy.  <a href="#a0f979f3defa4f725cfce2d7e93fc0d9e">More...</a><br/></td></tr>
<tr class="separator:a0f979f3defa4f725cfce2d7e93fc0d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98465e562d7b1b24755bc693db04c8f5"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a98465e562d7b1b24755bc693db04c8f5">asinSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a98465e562d7b1b24755bc693db04c8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double asin, but with single accuracy.  <a href="#a98465e562d7b1b24755bc693db04c8f5">More...</a><br/></td></tr>
<tr class="separator:a98465e562d7b1b24755bc693db04c8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f487fc13f5bd1b83417f108a74f5a0"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a72f487fc13f5bd1b83417f108a74f5a0">acosSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a72f487fc13f5bd1b83417f108a74f5a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double acos, but with single accuracy.  <a href="#a72f487fc13f5bd1b83417f108a74f5a0">More...</a><br/></td></tr>
<tr class="separator:a72f487fc13f5bd1b83417f108a74f5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ca54cb014d2f33b98f3d523d90a2f5"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a44ca54cb014d2f33b98f3d523d90a2f5">atanSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a44ca54cb014d2f33b98f3d523d90a2f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double atan, but with single accuracy.  <a href="#a44ca54cb014d2f33b98f3d523d90a2f5">More...</a><br/></td></tr>
<tr class="separator:a44ca54cb014d2f33b98f3d523d90a2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2552094c1be29e087e1e85ae02fb0c7a"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2552094c1be29e087e1e85ae02fb0c7a">atan2SingleAccuracy</a> (double y, double x)</td></tr>
<tr class="memdesc:a2552094c1be29e087e1e85ae02fb0c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double atan2(y,x), but with single accuracy.  <a href="#a2552094c1be29e087e1e85ae02fb0c7a">More...</a><br/></td></tr>
<tr class="separator:a2552094c1be29e087e1e85ae02fb0c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd18f07b8fd19f03f12442211982db53"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#abd18f07b8fd19f03f12442211982db53">pmeForceCorrectionSingleAccuracy</a> (double z2)</td></tr>
<tr class="memdesc:abd18f07b8fd19f03f12442211982db53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force correction due to PME in double, but with single accuracy.  <a href="#abd18f07b8fd19f03f12442211982db53">More...</a><br/></td></tr>
<tr class="separator:abd18f07b8fd19f03f12442211982db53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8004b2507f7192ead653fcdcb6735fe"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ab8004b2507f7192ead653fcdcb6735fe">pmePotentialCorrectionSingleAccuracy</a> (double z2)</td></tr>
<tr class="memdesc:ab8004b2507f7192ead653fcdcb6735fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Potential correction due to PME in double, but with single accuracy.  <a href="#ab8004b2507f7192ead653fcdcb6735fe">More...</a><br/></td></tr>
<tr class="separator:ab8004b2507f7192ead653fcdcb6735fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7ff3639534a22d4b9c7a834d7584fd"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:aba7ff3639534a22d4b9c7a834d7584fd"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aba7ff3639534a22d4b9c7a834d7584fd">gatherLoadTranspose</a> (const float *base, const std::int32_t offset[], float *v0, float *v1, float *v2, float *v3)</td></tr>
<tr class="memdesc:aba7ff3639534a22d4b9c7a834d7584fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 4 consecutive floats from base/offset into four variables.  <a href="#aba7ff3639534a22d4b9c7a834d7584fd">More...</a><br/></td></tr>
<tr class="separator:aba7ff3639534a22d4b9c7a834d7584fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0cda66eba19ad12a50e48f848f268f"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a4c0cda66eba19ad12a50e48f848f268f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a4c0cda66eba19ad12a50e48f848f268f">gatherLoadTranspose</a> (const float *base, const std::int32_t offset[], float *v0, float *v1)</td></tr>
<tr class="memdesc:a4c0cda66eba19ad12a50e48f848f268f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 2 consecutive floats from base/offset into four variables.  <a href="#a4c0cda66eba19ad12a50e48f848f268f">More...</a><br/></td></tr>
<tr class="separator:a4c0cda66eba19ad12a50e48f848f268f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfefc291c66a8404f2aad767af91cb21"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:acfefc291c66a8404f2aad767af91cb21"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#acfefc291c66a8404f2aad767af91cb21">gatherLoadUTranspose</a> (const float *base, const std::int32_t offset[], float *v0, float *v1, float *v2)</td></tr>
<tr class="memdesc:acfefc291c66a8404f2aad767af91cb21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 3 consecutive floats from base/offsets, store into three vars.  <a href="#acfefc291c66a8404f2aad767af91cb21">More...</a><br/></td></tr>
<tr class="separator:acfefc291c66a8404f2aad767af91cb21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d8dd5e7a4ade4e3750b48e2a95b308"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a65d8dd5e7a4ade4e3750b48e2a95b308"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a65d8dd5e7a4ade4e3750b48e2a95b308">transposeScatterStoreU</a> (float *base, const std::int32_t offset[], float v0, float v1, float v2)</td></tr>
<tr class="memdesc:a65d8dd5e7a4ade4e3750b48e2a95b308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store 3 floats to 3 to base/offset.  <a href="#a65d8dd5e7a4ade4e3750b48e2a95b308">More...</a><br/></td></tr>
<tr class="separator:a65d8dd5e7a4ade4e3750b48e2a95b308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12069a0402115678c9c39b303585917d"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a12069a0402115678c9c39b303585917d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a12069a0402115678c9c39b303585917d">transposeScatterIncrU</a> (float *base, const std::int32_t offset[], float v0, float v1, float v2)</td></tr>
<tr class="memdesc:a12069a0402115678c9c39b303585917d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add 3 floats to base/offset.  <a href="#a12069a0402115678c9c39b303585917d">More...</a><br/></td></tr>
<tr class="separator:a12069a0402115678c9c39b303585917d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e302c7dcfb8d4937c4388d77057435"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:af7e302c7dcfb8d4937c4388d77057435"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af7e302c7dcfb8d4937c4388d77057435">transposeScatterDecrU</a> (float *base, const std::int32_t offset[], float v0, float v1, float v2)</td></tr>
<tr class="memdesc:af7e302c7dcfb8d4937c4388d77057435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract 3 floats from base/offset.  <a href="#af7e302c7dcfb8d4937c4388d77057435">More...</a><br/></td></tr>
<tr class="separator:af7e302c7dcfb8d4937c4388d77057435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b19d8b9f07e36c8152b30d4b3caaad6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a6b19d8b9f07e36c8152b30d4b3caaad6">expandScalarsToTriplets</a> (float scalar, float *triplets0, float *triplets1, float *triplets2)</td></tr>
<tr class="memdesc:a6b19d8b9f07e36c8152b30d4b3caaad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy single float to three variables.  <a href="#a6b19d8b9f07e36c8152b30d4b3caaad6">More...</a><br/></td></tr>
<tr class="separator:a6b19d8b9f07e36c8152b30d4b3caaad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179f05bc9899fe2b7e71d53a1a95b629"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a179f05bc9899fe2b7e71d53a1a95b629"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a179f05bc9899fe2b7e71d53a1a95b629">gatherLoadBySimdIntTranspose</a> (const float *base, std::int32_t offset, float *v0, float *v1, float *v2, float *v3)</td></tr>
<tr class="memdesc:a179f05bc9899fe2b7e71d53a1a95b629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 4 floats from base/offsets and store into variables.  <a href="#a179f05bc9899fe2b7e71d53a1a95b629">More...</a><br/></td></tr>
<tr class="separator:a179f05bc9899fe2b7e71d53a1a95b629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c67b43b26cfba5ec360bf020df4c8a"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a29c67b43b26cfba5ec360bf020df4c8a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a29c67b43b26cfba5ec360bf020df4c8a">gatherLoadUBySimdIntTranspose</a> (const float *base, std::int32_t offset, float *v0, float *v1)</td></tr>
<tr class="memdesc:a29c67b43b26cfba5ec360bf020df4c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 2 floats from base/offsets and store into variables (unaligned).  <a href="#a29c67b43b26cfba5ec360bf020df4c8a">More...</a><br/></td></tr>
<tr class="separator:a29c67b43b26cfba5ec360bf020df4c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0614e0463cccdf97cec36fffb2b24764"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a0614e0463cccdf97cec36fffb2b24764"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a0614e0463cccdf97cec36fffb2b24764">gatherLoadBySimdIntTranspose</a> (const float *base, std::int32_t offset, float *v0, float *v1)</td></tr>
<tr class="memdesc:a0614e0463cccdf97cec36fffb2b24764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 2 floats from base/offsets and store into variables (aligned).  <a href="#a0614e0463cccdf97cec36fffb2b24764">More...</a><br/></td></tr>
<tr class="separator:a0614e0463cccdf97cec36fffb2b24764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eac2eb3581affdefb5b3e79e000cf84"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a6eac2eb3581affdefb5b3e79e000cf84">reduceIncr4ReturnSum</a> (float *m, float v0, float v1, float v2, float v3)</td></tr>
<tr class="memdesc:a6eac2eb3581affdefb5b3e79e000cf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add each float to four consecutive memory locations, return sum.  <a href="#a6eac2eb3581affdefb5b3e79e000cf84">More...</a><br/></td></tr>
<tr class="separator:a6eac2eb3581affdefb5b3e79e000cf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e990607fd4d48ca160fbc380597f5a"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a94e990607fd4d48ca160fbc380597f5a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a94e990607fd4d48ca160fbc380597f5a">gatherLoadTranspose</a> (const double *base, const std::int32_t offset[], double *v0, double *v1, double *v2, double *v3)</td></tr>
<tr class="memdesc:a94e990607fd4d48ca160fbc380597f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 4 consecutive doubles from base/offset into four variables.  <a href="#a94e990607fd4d48ca160fbc380597f5a">More...</a><br/></td></tr>
<tr class="separator:a94e990607fd4d48ca160fbc380597f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c464ebd492587005bb4baefb4293072"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a0c464ebd492587005bb4baefb4293072"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a0c464ebd492587005bb4baefb4293072">gatherLoadTranspose</a> (const double *base, const std::int32_t offset[], double *v0, double *v1)</td></tr>
<tr class="memdesc:a0c464ebd492587005bb4baefb4293072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 2 consecutive doubles from base/offset into four variables.  <a href="#a0c464ebd492587005bb4baefb4293072">More...</a><br/></td></tr>
<tr class="separator:a0c464ebd492587005bb4baefb4293072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0502844193d9fcf13648a4165a67a1a3"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a0502844193d9fcf13648a4165a67a1a3"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a0502844193d9fcf13648a4165a67a1a3">gatherLoadUTranspose</a> (const double *base, const std::int32_t offset[], double *v0, double *v1, double *v2)</td></tr>
<tr class="memdesc:a0502844193d9fcf13648a4165a67a1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 3 consecutive doubles from base/offsets, store into three vars.  <a href="#a0502844193d9fcf13648a4165a67a1a3">More...</a><br/></td></tr>
<tr class="separator:a0502844193d9fcf13648a4165a67a1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d74c633ff138def6fa648441c5decf"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:ab5d74c633ff138def6fa648441c5decf"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ab5d74c633ff138def6fa648441c5decf">transposeScatterStoreU</a> (double *base, const std::int32_t offset[], double v0, double v1, double v2)</td></tr>
<tr class="memdesc:ab5d74c633ff138def6fa648441c5decf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store 3 doubles to 3 to base/offset.  <a href="#ab5d74c633ff138def6fa648441c5decf">More...</a><br/></td></tr>
<tr class="separator:ab5d74c633ff138def6fa648441c5decf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e3f241eaafa47cfa9258ec9efec8d0"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a83e3f241eaafa47cfa9258ec9efec8d0"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a83e3f241eaafa47cfa9258ec9efec8d0">transposeScatterIncrU</a> (double *base, const std::int32_t offset[], double v0, double v1, double v2)</td></tr>
<tr class="memdesc:a83e3f241eaafa47cfa9258ec9efec8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add 3 doubles to base/offset.  <a href="#a83e3f241eaafa47cfa9258ec9efec8d0">More...</a><br/></td></tr>
<tr class="separator:a83e3f241eaafa47cfa9258ec9efec8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812731a42d1358e6a06f81848a67eeb7"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a812731a42d1358e6a06f81848a67eeb7"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a812731a42d1358e6a06f81848a67eeb7">transposeScatterDecrU</a> (double *base, const std::int32_t offset[], double v0, double v1, double v2)</td></tr>
<tr class="memdesc:a812731a42d1358e6a06f81848a67eeb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract 3 doubles from base/offset.  <a href="#a812731a42d1358e6a06f81848a67eeb7">More...</a><br/></td></tr>
<tr class="separator:a812731a42d1358e6a06f81848a67eeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a2ae7f742d7612f2808bfd39b0f975"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af8a2ae7f742d7612f2808bfd39b0f975">expandScalarsToTriplets</a> (double scalar, double *triplets0, double *triplets1, double *triplets2)</td></tr>
<tr class="memdesc:af8a2ae7f742d7612f2808bfd39b0f975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy single double to three variables.  <a href="#af8a2ae7f742d7612f2808bfd39b0f975">More...</a><br/></td></tr>
<tr class="separator:af8a2ae7f742d7612f2808bfd39b0f975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c67d959864d2549a679f0f2245bacb"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a92c67d959864d2549a679f0f2245bacb"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a92c67d959864d2549a679f0f2245bacb">gatherLoadBySimdIntTranspose</a> (const double *base, std::int32_t offset, double *v0, double *v1, double *v2, double *v3)</td></tr>
<tr class="memdesc:a92c67d959864d2549a679f0f2245bacb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 4 doubles from base/offsets and store into variables.  <a href="#a92c67d959864d2549a679f0f2245bacb">More...</a><br/></td></tr>
<tr class="separator:a92c67d959864d2549a679f0f2245bacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74c58ce1915c6a25061153cd3b4bde8"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:af74c58ce1915c6a25061153cd3b4bde8"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af74c58ce1915c6a25061153cd3b4bde8">gatherLoadUBySimdIntTranspose</a> (const double *base, std::int32_t offset, double *v0, double *v1)</td></tr>
<tr class="memdesc:af74c58ce1915c6a25061153cd3b4bde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 2 doubles from base/offsets and store into variables (unaligned).  <a href="#af74c58ce1915c6a25061153cd3b4bde8">More...</a><br/></td></tr>
<tr class="separator:af74c58ce1915c6a25061153cd3b4bde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb92443ba8da5d878c1dd85b2bcde8d"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a6bb92443ba8da5d878c1dd85b2bcde8d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a6bb92443ba8da5d878c1dd85b2bcde8d">gatherLoadBySimdIntTranspose</a> (const double *base, std::int32_t offset, double *v0, double *v1)</td></tr>
<tr class="memdesc:a6bb92443ba8da5d878c1dd85b2bcde8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 2 doubles from base/offsets and store into variables (aligned).  <a href="#a6bb92443ba8da5d878c1dd85b2bcde8d">More...</a><br/></td></tr>
<tr class="separator:a6bb92443ba8da5d878c1dd85b2bcde8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7989807401d15a5d7b360b91a7dbe04"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ad7989807401d15a5d7b360b91a7dbe04">reduceIncr4ReturnSum</a> (double *m, double v0, double v1, double v2, double v3)</td></tr>
<tr class="memdesc:ad7989807401d15a5d7b360b91a7dbe04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add each double to four consecutive memory locations, return sum.  <a href="#ad7989807401d15a5d7b360b91a7dbe04">More...</a><br/></td></tr>
<tr class="separator:ad7989807401d15a5d7b360b91a7dbe04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f21654b9945d04d277523f6c8ab1d11"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6f21654b9945d04d277523f6c8ab1d11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga6f21654b9945d04d277523f6c8ab1d11">swap</a> (<a class="el" href="classgmx_1_1ArrayRef.xhtml">ArrayRef</a>&lt; T &gt; &amp;a, <a class="el" href="classgmx_1_1ArrayRef.xhtml">ArrayRef</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:ga6f21654b9945d04d277523f6c8ab1d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple swap method for <a class="el" href="classgmx_1_1ArrayRef.xhtml" title="STL-like container for an interface to a C array (or part of a std::vector). ">ArrayRef</a> objects.  <a href="group__module__utility.xhtml#ga6f21654b9945d04d277523f6c8ab1d11">More...</a><br/></td></tr>
<tr class="separator:ga6f21654b9945d04d277523f6c8ab1d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3faec92610cb1ba29dfdf35a05e794cd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3faec92610cb1ba29dfdf35a05e794cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga3faec92610cb1ba29dfdf35a05e794cd">swap</a> (<a class="el" href="classgmx_1_1ConstArrayRef.xhtml">ConstArrayRef</a>&lt; T &gt; &amp;a, <a class="el" href="classgmx_1_1ConstArrayRef.xhtml">ConstArrayRef</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:ga3faec92610cb1ba29dfdf35a05e794cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple swap method for <a class="el" href="classgmx_1_1ConstArrayRef.xhtml" title="STL-like container for non-mutable interface to a C array (or part of a std::vector). ">ConstArrayRef</a> objects.  <a href="group__module__utility.xhtml#ga3faec92610cb1ba29dfdf35a05e794cd">More...</a><br/></td></tr>
<tr class="separator:ga3faec92610cb1ba29dfdf35a05e794cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff67fcd64bdaa64a3823cc1a322a6783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aff67fcd64bdaa64a3823cc1a322a6783">printBinaryInformation</a> (FILE *fp, const <a class="el" href="classgmx_1_1IProgramContext.xhtml">IProgramContext</a> &amp;programContext)</td></tr>
<tr class="memdesc:aff67fcd64bdaa64a3823cc1a322a6783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print basic information about the executable.  <a href="#aff67fcd64bdaa64a3823cc1a322a6783">More...</a><br/></td></tr>
<tr class="separator:aff67fcd64bdaa64a3823cc1a322a6783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c6bc3dc4ee812f31a6076c7d4f42a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ad0c6bc3dc4ee812f31a6076c7d4f42a9">printBinaryInformation</a> (FILE *fp, const <a class="el" href="classgmx_1_1IProgramContext.xhtml">IProgramContext</a> &amp;programContext, const BinaryInformationSettings &amp;settings)</td></tr>
<tr class="memdesc:ad0c6bc3dc4ee812f31a6076c7d4f42a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print basic information about the executable with custom settings.  <a href="#ad0c6bc3dc4ee812f31a6076c7d4f42a9">More...</a><br/></td></tr>
<tr class="separator:ad0c6bc3dc4ee812f31a6076c7d4f42a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0211f291fe376a0bcf8f12e382620495"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0211f291fe376a0bcf8f12e382620495"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a0211f291fe376a0bcf8f12e382620495">bromacs</a> ()</td></tr>
<tr class="memdesc:a0211f291fe376a0bcf8f12e382620495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a cool definition for the acronym GROMACS. <br/></td></tr>
<tr class="separator:a0211f291fe376a0bcf8f12e382620495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a579db3d112ccecde57a054f288216c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a579db3d112ccecde57a054f288216c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a7a579db3d112ccecde57a054f288216c">getCoolQuote</a> ()</td></tr>
<tr class="memdesc:a7a579db3d112ccecde57a054f288216c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string with a cool quote. <br/></td></tr>
<tr class="separator:a7a579db3d112ccecde57a054f288216c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac30db5a87fa0f55776bc8a3dcef0d67"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gaac30db5a87fa0f55776bc8a3dcef0d67">getErrorCodeString</a> (int errorcode)</td></tr>
<tr class="memdesc:gaac30db5a87fa0f55776bc8a3dcef0d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short string description of an error code.  <a href="group__module__utility.xhtml#gaac30db5a87fa0f55776bc8a3dcef0d67">More...</a><br/></td></tr>
<tr class="separator:gaac30db5a87fa0f55776bc8a3dcef0d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6287dc8a550a2d54429e44994e00e58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gac6287dc8a550a2d54429e44994e00e58">printFatalErrorMessage</a> (FILE *fp, const std::exception &amp;ex)</td></tr>
<tr class="memdesc:gac6287dc8a550a2d54429e44994e00e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a standard fatal error message for reporting an exception.  <a href="group__module__utility.xhtml#gac6287dc8a550a2d54429e44994e00e58">More...</a><br/></td></tr>
<tr class="separator:gac6287dc8a550a2d54429e44994e00e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7703ad35b606758d2d12edc0a3d5217"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gac7703ad35b606758d2d12edc0a3d5217">formatExceptionMessageToString</a> (const std::exception &amp;ex)</td></tr>
<tr class="memdesc:gac7703ad35b606758d2d12edc0a3d5217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats an error message for reporting an exception.  <a href="group__module__utility.xhtml#gac7703ad35b606758d2d12edc0a3d5217">More...</a><br/></td></tr>
<tr class="separator:gac7703ad35b606758d2d12edc0a3d5217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5e6f6ec944fb2484d6f273c9a0ff495"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gac5e6f6ec944fb2484d6f273c9a0ff495">formatExceptionMessageToFile</a> (FILE *fp, const std::exception &amp;ex)</td></tr>
<tr class="memdesc:gac5e6f6ec944fb2484d6f273c9a0ff495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats an error message for reporting an exception.  <a href="group__module__utility.xhtml#gac5e6f6ec944fb2484d6f273c9a0ff495">More...</a><br/></td></tr>
<tr class="separator:gac5e6f6ec944fb2484d6f273c9a0ff495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacf6bfb81220e44ed1bf73f0a44d9926"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gaacf6bfb81220e44ed1bf73f0a44d9926">formatExceptionMessageToWriter</a> (TextWriter *writer, const std::exception &amp;ex)</td></tr>
<tr class="memdesc:gaacf6bfb81220e44ed1bf73f0a44d9926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats an error message for reporting an exception.  <a href="group__module__utility.xhtml#gaacf6bfb81220e44ed1bf73f0a44d9926">More...</a><br/></td></tr>
<tr class="separator:gaacf6bfb81220e44ed1bf73f0a44d9926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a45f49e157fa8e1059d24243283e248"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga5a45f49e157fa8e1059d24243283e248">processExceptionAtExit</a> (const std::exception &amp;ex)</td></tr>
<tr class="memdesc:ga5a45f49e157fa8e1059d24243283e248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles an exception that is causing the program to terminate.  <a href="group__module__utility.xhtml#ga5a45f49e157fa8e1059d24243283e248">More...</a><br/></td></tr>
<tr class="separator:ga5a45f49e157fa8e1059d24243283e248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13076c5bb17dd3bf90f683af835b8b62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga13076c5bb17dd3bf90f683af835b8b62">processExceptionAsFatalError</a> (const std::exception &amp;ex)</td></tr>
<tr class="memdesc:ga13076c5bb17dd3bf90f683af835b8b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for terminating the program on an exception.  <a href="group__module__utility.xhtml#ga13076c5bb17dd3bf90f683af835b8b62">More...</a><br/></td></tr>
<tr class="separator:ga13076c5bb17dd3bf90f683af835b8b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b9a1e3988a89d1b90944c6ff6c3e794"><td class="memTemplParams" colspan="2">template&lt;class Exception , class Tag , class T &gt; </td></tr>
<tr class="memitem:ga1b9a1e3988a89d1b90944c6ff6c3e794"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; std::is_base_of<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1GromacsException.xhtml">GromacsException</a>, Exception &gt;<br class="typebreak"/>
::value, const Exception &amp; &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga1b9a1e3988a89d1b90944c6ff6c3e794">operator&lt;&lt;</a> (const Exception &amp;ex, const <a class="el" href="classgmx_1_1ExceptionInfo.xhtml">ExceptionInfo</a>&lt; Tag, T &gt; &amp;item)</td></tr>
<tr class="memdesc:ga1b9a1e3988a89d1b90944c6ff6c3e794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates extra information with an exception.  <a href="group__module__utility.xhtml#ga1b9a1e3988a89d1b90944c6ff6c3e794">More...</a><br/></td></tr>
<tr class="separator:ga1b9a1e3988a89d1b90944c6ff6c3e794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga312499e4abb409ad85844d83e52d795b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classgmx_1_1DataFileFinder.xhtml">DataFileFinder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga312499e4abb409ad85844d83e52d795b">getLibraryFileFinder</a> ()</td></tr>
<tr class="memdesc:ga312499e4abb409ad85844d83e52d795b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a finder for locating data files from share/top/.  <a href="group__module__utility.xhtml#ga312499e4abb409ad85844d83e52d795b">More...</a><br/></td></tr>
<tr class="separator:ga312499e4abb409ad85844d83e52d795b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106cb113fd73e054dbb8dfa2118d7153"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a106cb113fd73e054dbb8dfa2118d7153">setLibraryFileFinder</a> (const <a class="el" href="classgmx_1_1DataFileFinder.xhtml">DataFileFinder</a> *finder)</td></tr>
<tr class="memdesc:a106cb113fd73e054dbb8dfa2118d7153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a finder for location data files from share/top/.  <a href="#a106cb113fd73e054dbb8dfa2118d7153">More...</a><br/></td></tr>
<tr class="separator:a106cb113fd73e054dbb8dfa2118d7153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae00d174a8ddd5325460d74dc663711c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gae00d174a8ddd5325460d74dc663711c0">init</a> (int *argc, char ***argv)</td></tr>
<tr class="memdesc:gae00d174a8ddd5325460d74dc663711c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the GROMACS library.  <a href="group__module__utility.xhtml#gae00d174a8ddd5325460d74dc663711c0">More...</a><br/></td></tr>
<tr class="separator:gae00d174a8ddd5325460d74dc663711c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0a90b2770cb4b69e16229daa271a1af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gaa0a90b2770cb4b69e16229daa271a1af">finalize</a> ()</td></tr>
<tr class="memdesc:gaa0a90b2770cb4b69e16229daa271a1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitializes the GROMACS library.  <a href="group__module__utility.xhtml#gaa0a90b2770cb4b69e16229daa271a1af">More...</a><br/></td></tr>
<tr class="separator:gaa0a90b2770cb4b69e16229daa271a1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ac09bdfd662fa49b0426432744f57be"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classgmx_1_1IProgramContext.xhtml">IProgramContext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga5ac09bdfd662fa49b0426432744f57be">getProgramContext</a> ()</td></tr>
<tr class="memdesc:ga5ac09bdfd662fa49b0426432744f57be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the global <a class="el" href="classgmx_1_1IProgramContext.xhtml" title="Provides context information about the program that is calling the library. ">IProgramContext</a> instance.  <a href="group__module__utility.xhtml#ga5ac09bdfd662fa49b0426432744f57be">More...</a><br/></td></tr>
<tr class="separator:ga5ac09bdfd662fa49b0426432744f57be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cf34635c815cc712b6291c2c8da2555"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga2cf34635c815cc712b6291c2c8da2555">setProgramContext</a> (const <a class="el" href="classgmx_1_1IProgramContext.xhtml">IProgramContext</a> *context)</td></tr>
<tr class="memdesc:ga2cf34635c815cc712b6291c2c8da2555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the global <a class="el" href="classgmx_1_1IProgramContext.xhtml" title="Provides context information about the program that is calling the library. ">IProgramContext</a> instance.  <a href="group__module__utility.xhtml#ga2cf34635c815cc712b6291c2c8da2555">More...</a><br/></td></tr>
<tr class="separator:ga2cf34635c815cc712b6291c2c8da2555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa097a11e79b9b187cadef998470f4e54"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa097a11e79b9b187cadef998470f4e54"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa097a11e79b9b187cadef998470f4e54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa097a11e79b9b187cadef998470f4e54">sfree_wrapper</a> (T *p)</td></tr>
<tr class="memdesc:aa097a11e79b9b187cadef998470f4e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">sfree wrapper to be used as scoped_cptr deleter <br/></td></tr>
<tr class="separator:aa097a11e79b9b187cadef998470f4e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea61e0b5bfc1f24f51a9eb5272b51603"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gaea61e0b5bfc1f24f51a9eb5272b51603">countWords</a> (const char *s)</td></tr>
<tr class="memdesc:gaea61e0b5bfc1f24f51a9eb5272b51603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of space-separated words in zero-terminated char ptr.  <a href="group__module__utility.xhtml#gaea61e0b5bfc1f24f51a9eb5272b51603">More...</a><br/></td></tr>
<tr class="separator:gaea61e0b5bfc1f24f51a9eb5272b51603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae837a92609acdf559a6b8587e9233008"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gae837a92609acdf559a6b8587e9233008">countWords</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gae837a92609acdf559a6b8587e9233008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of space-separated words in a string object.  <a href="group__module__utility.xhtml#gae837a92609acdf559a6b8587e9233008">More...</a><br/></td></tr>
<tr class="separator:gae837a92609acdf559a6b8587e9233008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b22d1fd014cc09c9cf7c4c1615c0a1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga8b22d1fd014cc09c9cf7c4c1615c0a1b">endsWith</a> (const char *str, const char *suffix)</td></tr>
<tr class="memdesc:ga8b22d1fd014cc09c9cf7c4c1615c0a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a string ends with another string.  <a href="group__module__utility.xhtml#ga8b22d1fd014cc09c9cf7c4c1615c0a1b">More...</a><br/></td></tr>
<tr class="separator:ga8b22d1fd014cc09c9cf7c4c1615c0a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea84ff4850c382e09a3e158939b34b3e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gaea84ff4850c382e09a3e158939b34b3e">stripSuffixIfPresent</a> (const std::string &amp;str, const char *suffix)</td></tr>
<tr class="memdesc:gaea84ff4850c382e09a3e158939b34b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a suffix from a string.  <a href="group__module__utility.xhtml#gaea84ff4850c382e09a3e158939b34b3e">More...</a><br/></td></tr>
<tr class="separator:gaea84ff4850c382e09a3e158939b34b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f31464a19604fde038dba36307ac066"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga5f31464a19604fde038dba36307ac066">stripString</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga5f31464a19604fde038dba36307ac066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes leading and trailing whitespace from a string.  <a href="group__module__utility.xhtml#ga5f31464a19604fde038dba36307ac066">More...</a><br/></td></tr>
<tr class="separator:ga5f31464a19604fde038dba36307ac066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed06df18ca6f9fc3f42bad9ea4d7e025"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gaed06df18ca6f9fc3f42bad9ea4d7e025">formatString</a> (const char *fmt,...)</td></tr>
<tr class="memdesc:gaed06df18ca6f9fc3f42bad9ea4d7e025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a string (snprintf() wrapper).  <a href="group__module__utility.xhtml#gaed06df18ca6f9fc3f42bad9ea4d7e025">More...</a><br/></td></tr>
<tr class="separator:gaed06df18ca6f9fc3f42bad9ea4d7e025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga720e46b4a7625c675507adbea1df3f96"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga720e46b4a7625c675507adbea1df3f96">splitString</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga720e46b4a7625c675507adbea1df3f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a string to whitespace separated tokens.  <a href="group__module__utility.xhtml#ga720e46b4a7625c675507adbea1df3f96">More...</a><br/></td></tr>
<tr class="separator:ga720e46b4a7625c675507adbea1df3f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e4d61dba5d6fb924b8888e5597d2d0f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga1e4d61dba5d6fb924b8888e5597d2d0f">replaceAll</a> (const std::string &amp;input, const char *from, const char *to)</td></tr>
<tr class="memdesc:ga1e4d61dba5d6fb924b8888e5597d2d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of a string with another string.  <a href="group__module__utility.xhtml#ga1e4d61dba5d6fb924b8888e5597d2d0f">More...</a><br/></td></tr>
<tr class="separator:ga1e4d61dba5d6fb924b8888e5597d2d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba6fb72c71891e47fc68c36167bee72e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gaba6fb72c71891e47fc68c36167bee72e">replaceAll</a> (const std::string &amp;input, const std::string &amp;from, const std::string &amp;to)</td></tr>
<tr class="memdesc:gaba6fb72c71891e47fc68c36167bee72e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of a string with another string.  <a href="group__module__utility.xhtml#gaba6fb72c71891e47fc68c36167bee72e">More...</a><br/></td></tr>
<tr class="separator:gaba6fb72c71891e47fc68c36167bee72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacdb65ab5673b946ea9764f708a4afcc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gaacdb65ab5673b946ea9764f708a4afcc">replaceAllWords</a> (const std::string &amp;input, const char *from, const char *to)</td></tr>
<tr class="memdesc:gaacdb65ab5673b946ea9764f708a4afcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace whole words with others.  <a href="group__module__utility.xhtml#gaacdb65ab5673b946ea9764f708a4afcc">More...</a><br/></td></tr>
<tr class="separator:gaacdb65ab5673b946ea9764f708a4afcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2df338df2e0b32b8c1fd032452409d57"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga2df338df2e0b32b8c1fd032452409d57">replaceAllWords</a> (const std::string &amp;input, const std::string &amp;from, const std::string &amp;to)</td></tr>
<tr class="memdesc:ga2df338df2e0b32b8c1fd032452409d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace whole words with others.  <a href="group__module__utility.xhtml#ga2df338df2e0b32b8c1fd032452409d57">More...</a><br/></td></tr>
<tr class="separator:ga2df338df2e0b32b8c1fd032452409d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f35bd1d4a654edabc2a3aaf6f6bccea"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga2f35bd1d4a654edabc2a3aaf6f6bccea">isNullOrEmpty</a> (const char *str)</td></tr>
<tr class="memdesc:ga2f35bd1d4a654edabc2a3aaf6f6bccea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a string is null or empty.  <a href="group__module__utility.xhtml#ga2f35bd1d4a654edabc2a3aaf6f6bccea">More...</a><br/></td></tr>
<tr class="separator:ga2f35bd1d4a654edabc2a3aaf6f6bccea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8adb72aeb7775a649d7378c8e51321e6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga8adb72aeb7775a649d7378c8e51321e6">startsWith</a> (const std::string &amp;str, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:ga8adb72aeb7775a649d7378c8e51321e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a string starts with another string.  <a href="group__module__utility.xhtml#ga8adb72aeb7775a649d7378c8e51321e6">More...</a><br/></td></tr>
<tr class="separator:ga8adb72aeb7775a649d7378c8e51321e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87824e9b26adc46671ccffa89f3985d0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga87824e9b26adc46671ccffa89f3985d0">startsWith</a> (const char *str, const char *prefix)</td></tr>
<tr class="memdesc:ga87824e9b26adc46671ccffa89f3985d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a string starts with another string.  <a href="group__module__utility.xhtml#ga87824e9b26adc46671ccffa89f3985d0">More...</a><br/></td></tr>
<tr class="separator:ga87824e9b26adc46671ccffa89f3985d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1e33d963e2538664428c8db95ca564e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gaa1e33d963e2538664428c8db95ca564e">endsWith</a> (const std::string &amp;str, const char *suffix)</td></tr>
<tr class="memdesc:gaa1e33d963e2538664428c8db95ca564e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a string ends with another string.  <a href="group__module__utility.xhtml#gaa1e33d963e2538664428c8db95ca564e">More...</a><br/></td></tr>
<tr class="separator:gaa1e33d963e2538664428c8db95ca564e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d6c1daa93bf46a2c397d179e007e3e8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga5d6c1daa93bf46a2c397d179e007e3e8">contains</a> (const std::string &amp;str, const char *substr)</td></tr>
<tr class="memdesc:ga5d6c1daa93bf46a2c397d179e007e3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a string contains another as a substring.  <a href="group__module__utility.xhtml#ga5d6c1daa93bf46a2c397d179e007e3e8">More...</a><br/></td></tr>
<tr class="separator:ga5d6c1daa93bf46a2c397d179e007e3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0bef974d105fbfcc7e5362111eafed5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gac0bef974d105fbfcc7e5362111eafed5">contains</a> (const std::string &amp;str, const std::string &amp;substr)</td></tr>
<tr class="memdesc:gac0bef974d105fbfcc7e5362111eafed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a string contains another as a substring.  <a href="group__module__utility.xhtml#gac0bef974d105fbfcc7e5362111eafed5">More...</a><br/></td></tr>
<tr class="separator:gac0bef974d105fbfcc7e5362111eafed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga555d78d19565dec63c740318187b4d0d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga555d78d19565dec63c740318187b4d0d">endsWith</a> (const std::string &amp;str, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:ga555d78d19565dec63c740318187b4d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a string ends with another string.  <a href="group__module__utility.xhtml#ga555d78d19565dec63c740318187b4d0d">More...</a><br/></td></tr>
<tr class="separator:ga555d78d19565dec63c740318187b4d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa21c247b747e12412da58cb9f6d500ef"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename FormatterType &gt; </td></tr>
<tr class="memitem:gaa21c247b747e12412da58cb9f6d500ef"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gaa21c247b747e12412da58cb9f6d500ef">formatAndJoin</a> (InputIterator begin, InputIterator end, const char *separator, const FormatterType &amp;formatter)</td></tr>
<tr class="memdesc:gaa21c247b747e12412da58cb9f6d500ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats all the range as strings, and then joins them with a separator in between.  <a href="group__module__utility.xhtml#gaa21c247b747e12412da58cb9f6d500ef">More...</a><br/></td></tr>
<tr class="separator:gaa21c247b747e12412da58cb9f6d500ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e151e320e4072b2cc254b653077bb68"><td class="memTemplParams" colspan="2">template&lt;typename ContainerType , typename FormatterType &gt; </td></tr>
<tr class="memitem:ga8e151e320e4072b2cc254b653077bb68"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga8e151e320e4072b2cc254b653077bb68">formatAndJoin</a> (const ContainerType &amp;container, const char *separator, const FormatterType &amp;formatter)</td></tr>
<tr class="memdesc:ga8e151e320e4072b2cc254b653077bb68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats all elements of the container as strings, and then joins them with a separator in between.  <a href="group__module__utility.xhtml#ga8e151e320e4072b2cc254b653077bb68">More...</a><br/></td></tr>
<tr class="separator:ga8e151e320e4072b2cc254b653077bb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0ae45171d0f46a06095bf86855a8b28"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:gae0ae45171d0f46a06095bf86855a8b28"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gae0ae45171d0f46a06095bf86855a8b28">joinStrings</a> (InputIterator begin, InputIterator end, const char *separator)</td></tr>
<tr class="memdesc:gae0ae45171d0f46a06095bf86855a8b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins strings from a range with a separator in between.  <a href="group__module__utility.xhtml#gae0ae45171d0f46a06095bf86855a8b28">More...</a><br/></td></tr>
<tr class="separator:gae0ae45171d0f46a06095bf86855a8b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dec76a57e8089a89f9298fb2fbaf2ed"><td class="memTemplParams" colspan="2">template&lt;typename ContainerType &gt; </td></tr>
<tr class="memitem:ga7dec76a57e8089a89f9298fb2fbaf2ed"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga7dec76a57e8089a89f9298fb2fbaf2ed">joinStrings</a> (const ContainerType &amp;container, const char *separator)</td></tr>
<tr class="memdesc:ga7dec76a57e8089a89f9298fb2fbaf2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins strings from a container with a separator in between.  <a href="group__module__utility.xhtml#ga7dec76a57e8089a89f9298fb2fbaf2ed">More...</a><br/></td></tr>
<tr class="separator:ga7dec76a57e8089a89f9298fb2fbaf2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31335553bd6174a68ad8d30c48de3df5"><td class="memTemplParams" colspan="2">template&lt;size_t count&gt; </td></tr>
<tr class="memitem:ga31335553bd6174a68ad8d30c48de3df5"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga31335553bd6174a68ad8d30c48de3df5">joinStrings</a> (const char *const (&amp;array)[count], const char *separator)</td></tr>
<tr class="memdesc:ga31335553bd6174a68ad8d30c48de3df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins strings from an array with a separator in between.  <a href="group__module__utility.xhtml#ga31335553bd6174a68ad8d30c48de3df5">More...</a><br/></td></tr>
<tr class="separator:ga31335553bd6174a68ad8d30c48de3df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3862c8128924c3311429a4dadf075ecc"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga3862c8128924c3311429a4dadf075ecc">boolToString</a> (bool value)</td></tr>
<tr class="memdesc:ga3862c8128924c3311429a4dadf075ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a boolean to a "true"/"false" string.  <a href="group__module__utility.xhtml#ga3862c8128924c3311429a4dadf075ecc">More...</a><br/></td></tr>
<tr class="separator:ga3862c8128924c3311429a4dadf075ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ab84fc76c89c13dcc7bd753a720d90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79ab84fc76c89c13dcc7bd753a720d90"></a>
static <a class="el" href="namespacegmx.xhtml#a8593c4aa4e1f10f3571c8b8f2cd933a8">integrator_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a79ab84fc76c89c13dcc7bd753a720d90">my_integrator</a> (unsigned int ei)</td></tr>
<tr class="memdesc:a79ab84fc76c89c13dcc7bd753a720d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correct integrator function. <br/></td></tr>
<tr class="separator:a79ab84fc76c89c13dcc7bd753a720d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112ad714d9aa4e824fdad2c3b4ed75db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a112ad714d9aa4e824fdad2c3b4ed75db">mdrunner</a> (gmx_hw_opt_t *hw_opt, FILE *fplog, struct t_commrec *cr, int nfile, const <a class="el" href="structt__filenm.xhtml">t_filenm</a> fnm[], const gmx_output_env_t *oenv, <a class="el" href="basedefinitions_8h.xhtml#a8fddad319f226e856400d190198d5151">gmx_bool</a> bVerbose, int nstglobalcomm, ivec ddxyz, int dd_rank_order, int npme, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> rdd, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> rconstr, const char *dddlb_opt, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> dlb_scale, const char *ddcsx, const char *ddcsy, const char *ddcsz, const char *nbpu_opt, int nstlist_cmdline, gmx_int64_t nsteps_cmdline, int nstepout, int resetstep, int nmultisim, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> pforce, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> cpt_period, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> max_hours, int imdport, unsigned long Flags)</td></tr>
<tr class="memdesc:a112ad714d9aa4e824fdad2c3b4ed75db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver routine, that calls the different methods.  <a href="#a112ad714d9aa4e824fdad2c3b4ed75db">More...</a><br/></td></tr>
<tr class="separator:a112ad714d9aa4e824fdad2c3b4ed75db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a69d101abde50194b033bd47aca343efb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69d101abde50194b033bd47aca343efb"></a>
<a class="el" href="namespacegmx.xhtml#a8593c4aa4e1f10f3571c8b8f2cd933a8">integrator_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a69d101abde50194b033bd47aca343efb">do_steep</a></td></tr>
<tr class="memdesc:a69d101abde50194b033bd47aca343efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Steepest descents energy minimization. <br/></td></tr>
<tr class="separator:a69d101abde50194b033bd47aca343efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7e06ca1a66d04665db497fe64b8c2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b7e06ca1a66d04665db497fe64b8c2c"></a>
<a class="el" href="namespacegmx.xhtml#a8593c4aa4e1f10f3571c8b8f2cd933a8">integrator_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a6b7e06ca1a66d04665db497fe64b8c2c">do_cg</a></td></tr>
<tr class="memdesc:a6b7e06ca1a66d04665db497fe64b8c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conjugate gradient energy minimization. <br/></td></tr>
<tr class="separator:a6b7e06ca1a66d04665db497fe64b8c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a1b057a39053d0c4a28c49285f900e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6a1b057a39053d0c4a28c49285f900e"></a>
<a class="el" href="namespacegmx.xhtml#a8593c4aa4e1f10f3571c8b8f2cd933a8">integrator_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ac6a1b057a39053d0c4a28c49285f900e">do_lbfgs</a></td></tr>
<tr class="memdesc:ac6a1b057a39053d0c4a28c49285f900e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conjugate gradient energy minimization using the L-BFGS algorithm. <br/></td></tr>
<tr class="separator:ac6a1b057a39053d0c4a28c49285f900e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6872c2f4b813d88a0beccdacfe730c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6872c2f4b813d88a0beccdacfe730c9"></a>
<a class="el" href="namespacegmx.xhtml#a8593c4aa4e1f10f3571c8b8f2cd933a8">integrator_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa6872c2f4b813d88a0beccdacfe730c9">do_nm</a></td></tr>
<tr class="memdesc:aa6872c2f4b813d88a0beccdacfe730c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal mode analysis. <br/></td></tr>
<tr class="separator:aa6872c2f4b813d88a0beccdacfe730c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efd8b13fa02f4aebf73a8d8555e81f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1efd8b13fa02f4aebf73a8d8555e81f9"></a>
<a class="el" href="namespacegmx.xhtml#a8593c4aa4e1f10f3571c8b8f2cd933a8">integrator_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a1efd8b13fa02f4aebf73a8d8555e81f9">do_tpi</a></td></tr>
<tr class="memdesc:a1efd8b13fa02f4aebf73a8d8555e81f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test particle insertion. <br/></td></tr>
<tr class="separator:a1efd8b13fa02f4aebf73a8d8555e81f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f6a93a5bf9ce1e585bebf205d6f6ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19f6a93a5bf9ce1e585bebf205d6f6ea"></a>
<a class="el" href="namespacegmx.xhtml#a8593c4aa4e1f10f3571c8b8f2cd933a8">integrator_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a19f6a93a5bf9ce1e585bebf205d6f6ea">do_md</a></td></tr>
<tr class="memdesc:a19f6a93a5bf9ce1e585bebf205d6f6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">MD simulations. <br/></td></tr>
<tr class="separator:a19f6a93a5bf9ce1e585bebf205d6f6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a7ea21974bdd8acdfa1c344b0945cff1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classgmx_1_1ThreeFry2x64Fast.xhtml">ThreeFry2x64Fast</a> <a class="el" href="namespacegmx.xhtml#a7ea21974bdd8acdfa1c344b0945cff1b">gmx::DefaultRandomEngine</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default fast and accurate random engine in Gromacs. </p>
<p>This engine will return 2*2^64 random results using the default <a class="el" href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0a6311ae17c1ee52b36e68aaf4ad066387" title="Generic - stream uniqueness is not important. ">gmx::RandomDomain::Other</a> stream, and can be initialized with a single seed argument without having to remember empty template angle brackets. </p>

</div>
</div>
<a class="anchor" id="a8593c4aa4e1f10f3571c8b8f2cd933a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double gmx::integrator_t(FILE *fplog, t_commrec *cr, int nfile, const <a class="el" href="structt__filenm.xhtml">t_filenm</a> fnm[], const gmx_output_env_t *oenv, <a class="el" href="basedefinitions_8h.xhtml#a8fddad319f226e856400d190198d5151">gmx_bool</a> bVerbose, int nstglobalcomm, gmx_vsite_t *vsite, gmx_constr_t constr, int stepout, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, t_state *state_global, <a class="el" href="structt__mdatoms.xhtml">t_mdatoms</a> *mdatoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, t_forcerec *fr, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, gmx_membed_t *membed, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> cpt_period, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> max_hours, int imdport, unsigned long Flags, gmx_walltime_accounting_t walltime_accounting)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrator algorithm implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fplog</td><td>Log file for output </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cr</td><td>Communication record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nfile</td><td>Number of files </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fnm</td><td>Filename structure array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oenv</td><td>Output information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bVerbose</td><td>Verbose output or not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nstglobalcomm</td><td>How often global communication is done </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vsite</td><td>Virtual site information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constr</td><td>Constraint information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepout</td><td>How often we writen to the console </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputrec</td><td>Input record with mdp options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top_global</td><td>Molecular topology for the whole system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fcd</td><td>Force and constraint data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state_global</td><td>The state (x, v, f, box etc.) of the whole system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mdatoms</td><td>Structure containing atom information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrnb</td><td>Accounting for floating point operations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wcycle</td><td>Wall cycle timing information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ed</td><td>Essential dynamics sampling information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fr</td><td>Force record with cut-off information and more </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl_ex_nst</td><td>How often we do replica exchange (in steps) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl_ex_nex</td><td>How many replicas we have </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl_ex_seed</td><td>The seed for Monte Carlo swaps </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">membed</td><td>Membrane embedding data structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cpt_period</td><td>How often to checkpoint the simulation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_hours</td><td>Maximume length of the simulation (wall time) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imdport</td><td>Interactive MD port (socket) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Flags</td><td>Flags to control mdrun </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">walltime_accounting</td><td>More timing information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac44e2bbcc40f48812b6b756a503ea51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::random_device <a class="el" href="namespacegmx.xhtml#aac44e2bbcc40f48812b6b756a503ea51">gmx::RandomDevice</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Random device. </p>
<p>For now this is identical to the standard library, but since we use the GROMACS random module for all other random engines and distributions it is convenient to have this too in the same module. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a73202d646d57bcc963d8afd5a16015f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0">gmx::RandomDomain</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerated values for fixed part of random seed (domain) </p>
<p>Random numbers are used in many places in GROMACS, and to avoid identical streams the random seeds should be different. Instead of keeping track of several different user-provided seeds, it is better to use the fact that generators like ThreeFry take two 64-bit keys, and combine a general user-provided 64-bit random seed with a second constant value from this list to make each stream guaranteed unique.</p>
<dl class="section note"><dt>Note</dt><dd>There is no reason to go overboard with adding options; we only need to guarantee different streams for cases that might be present simultaneously in a single simulation. As an example, two different integrators (or thermostats) can reuse the same domain. </dd>
<dd>
When you do add options, leave some space between the values so you can group new options with old ones without changing old values. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a73202d646d57bcc963d8afd5a16015f0a6311ae17c1ee52b36e68aaf4ad066387"></a>Other</em>&nbsp;</td><td class="fielddoc">
<p>Generic - stream uniqueness is not important. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a73202d646d57bcc963d8afd5a16015f0accb9e34a240647891f931e772cad80ef"></a>MaxwellVelocities</em>&nbsp;</td><td class="fielddoc">
<p>Veolcity assignment from Maxwell distribution. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a73202d646d57bcc963d8afd5a16015f0aa42c5450c670a7ecbea5532bde9c0c65"></a>TestParticleInsertion</em>&nbsp;</td><td class="fielddoc">
<p>Test particle insertion. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a73202d646d57bcc963d8afd5a16015f0a23714d9a49cc46ca81ad32670bde8b5e"></a>UpdateCoordinates</em>&nbsp;</td><td class="fielddoc">
<p>Particle integrators. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a73202d646d57bcc963d8afd5a16015f0ab0634f71dbc527342668f2a63f1b3510"></a>UpdateConstraints</em>&nbsp;</td><td class="fielddoc">
<p>Second integrator step for constraints. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a73202d646d57bcc963d8afd5a16015f0a91e0b95db0c752d879aebd0ac65a7fb9"></a>Thermostat</em>&nbsp;</td><td class="fielddoc">
<p>Stochastic temperature coupling. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a73202d646d57bcc963d8afd5a16015f0a79248e4db93ba16182fd3bf1c8e2fda7"></a>Barostat</em>&nbsp;</td><td class="fielddoc">
<p>Stochastic pressure coupling. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a73202d646d57bcc963d8afd5a16015f0ada8008568302912872628be09e68fb84"></a>ReplicaExchange</em>&nbsp;</td><td class="fielddoc">
<p>Replica exchange metropolis moves. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a73202d646d57bcc963d8afd5a16015f0a19bd460326d41817323764fa9e4287ff"></a>ExpandedEnsemble</em>&nbsp;</td><td class="fielddoc">
<p>Expanded ensemble lambda moves. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a5dc46e83d110b8c81339683bf748fc81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::abs </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float Floating-point <a class="el" href="namespacegmx.xhtml#a5dc46e83d110b8c81339683bf748fc81" title="Float Floating-point abs(). ">abs()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>any floating point values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>abs(a) for each element.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ac85ea3af684916aee86e2674a6bd81e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::abs </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>double doubleing-point <a class="el" href="namespacegmx.xhtml#a5dc46e83d110b8c81339683bf748fc81" title="Float Floating-point abs(). ">abs()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>any doubleing point values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>abs(a) for each element.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ab102173c68c06e7a340e4eebbf6c3492"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::acos </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float acos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate acos for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Acos(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b534003a0dba716c08d6053e0514311"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::acos </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double acos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate acos for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Acos(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a72f487fc13f5bd1b83417f108a74f5a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::acosSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double acos, but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate acos for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Acos(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aaec39ef87dbec92292cd5954c922be6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::andNot </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise andnot for two scalar float variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>data1 </td></tr>
    <tr><td class="paramname">b</td><td>data2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(~data1) &amp; data2</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aebb0315d31c3c818a738bdc153397365"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::andNot </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise andnot for two scalar double variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>data1 </td></tr>
    <tr><td class="paramname">b</td><td>data2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(~data1) &amp; data2</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a880a42645963c52980a5790f09e3bd18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::int32_t gmx::andNot </td>
          <td>(</td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise andnot for two scalar integer variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>data1 </td></tr>
    <tr><td class="paramname">b</td><td>data2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(~data1) &amp; data2</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="af90cd5d709899e47809553109383299e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool gmx::anyTrue </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the boolean is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Logical variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a is true, otherwise false.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a3d5120df9c0bf437e64c806a7cfdad02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::asin </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>float asin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate asin for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Asin(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ab02c7d47595f11074fbfedff40145544"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::asin </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double asin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate asin for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Asin(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a98465e562d7b1b24755bc693db04c8f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::asinSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double asin, but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate asin for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Asin(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a1afbc2ada56f899a8d3dc5c61530e28b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::atan </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float atan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate atan for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Atan(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="af15e6f3962e035d69013bd91621fd9f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::atan </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double atan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate atan for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Atan(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aed8336a58abddcdb6afa7835138ecf46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::atan2 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float atan2(y,x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Y component of vector, any quartile </td></tr>
    <tr><td class="paramname">x</td><td>X component of vector, any quartile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Atan(y,x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aa70a1aa5e9c161a2770d0f9b7eca1805"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::atan2 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double atan2(y,x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Y component of vector, any quartile </td></tr>
    <tr><td class="paramname">x</td><td>X component of vector, any quartile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Atan(y,x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a2552094c1be29e087e1e85ae02fb0c7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::atan2SingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double atan2(y,x), but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Y component of vector, any quartile </td></tr>
    <tr><td class="paramname">x</td><td>X component of vector, any quartile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Atan(y,x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a44ca54cb014d2f33b98f3d523d90a2f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::atanSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double atan, but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate atan for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Atan(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a31c5db5940f1fed568d8d6a0dbe7ec1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::blend </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blend float selection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First source </td></tr>
    <tr><td class="paramname">b</td><td>Second source </td></tr>
    <tr><td class="paramname">sel</td><td>Boolean selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Select b if sel is true, a otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a90aa803db2a6a8c9dbb22395dcaf4532"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::blend </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blend double selection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First source </td></tr>
    <tr><td class="paramname">b</td><td>Second source </td></tr>
    <tr><td class="paramname">sel</td><td>Boolean selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Select b if sel is true, a otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="acf33872c1b22ffd9340e77410c693083"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::int32_t gmx::blend </td>
          <td>(</td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blend integer selection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First source </td></tr>
    <tr><td class="paramname">b</td><td>Second source </td></tr>
    <tr><td class="paramname">sel</td><td>Boolean selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Select b if sel is true, a otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ef5f6af06e493a4ae2d47109ee0e723"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::copysign </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes single value with the magnitude of x and the sign of y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Value to set sign for </td></tr>
    <tr><td class="paramname">y</td><td>Value used to set sign </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Magnitude of x, sign of y</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="af6cfb56189c360e005911247ebf5fd42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::copysign </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes double value with the magnitude of x and the sign of y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Value to set sign for </td></tr>
    <tr><td class="paramname">y</td><td>Value used to set sign </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Magnitude of x, sign of y</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a16c6356a58f3d2c2fe6d2f50afc0c686"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::cos </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float cos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate cos for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cos(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aeda573e9aa3efa5d223c9fe39f682cfd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::cos </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double cos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate cos for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cos(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e717707cf40d6bbacf8752cf28de422"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::cosSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double cos, but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate cos for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cos(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="af536d7a23a442f3c0876b05ac20d7d40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gmx::cpuIsX86Nehalem </td>
          <td>(</td>
          <td class="paramtype">const CpuInfo &amp;&#160;</td>
          <td class="paramname"><em>cpuInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the CPU is an Intel x86 Nehalem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpuInfo</td><td>Object with cpu information</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if running on Nehalem CPU </dd></dl>

</div>
</div>
<a class="anchor" id="a27254f29caa9fd12a6e774bf7a13502c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool gmx::cvtB2IB </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just return a boolean (mimicks SIMD real-to-int bool conversions) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>boolean </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>same boolean</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a22401779c65549d3061b4fdd5290ef19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::cvtD2F </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert double to float (mimicks SIMD conversion) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>double </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a, as float</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ac575d3b81809b71e414755dc8acf3317"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::cvtF2D </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert float to double (mimicks SIMD conversion) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>float </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a, as double double</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a69388fb35cb4b891c7517554e4500615"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::int32_t gmx::cvtI2R </td>
          <td>(</td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return integer. </p>
<p>This function mimicks the SIMD integer-to-real conversion routines. By simply returning an integer, we let the compiler sort out whether the conversion should be to float or double rather than using proxy objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>same value (a)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a600fa6a48b5df753c2fcc99c47f3f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool gmx::cvtIB2B </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just return a boolean (mimicks SIMD int-to-real bool conversions) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>boolean </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>same boolean</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a2136f5684897fc7ea139039eba172629"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::int32_t gmx::cvtR2I </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round single precision floating point to integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>float </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer format, a rounded to nearest integer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="acc9f420c1d0c099cc58ac3ae5fcb1ace"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::int32_t gmx::cvtR2I </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round single precision doubleing point to integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>double </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer format, a rounded to nearest integer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c74ba54abe2627167abfc0df7286f5d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::int32_t gmx::cvttR2I </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncate single precision floating point to integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>float </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer format, a truncated to integer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0fb4318cc5c14075330d52382e6bdd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::int32_t gmx::cvttR2I </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncate single precision doubleing point to integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>double </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer format, a truncated to integer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b53df1703a70801419ef4f9004454bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double gmx::do_cg </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fplog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_commrec *&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structt__filenm.xhtml">t_filenm</a>&#160;</td>
          <td class="paramname"><em>fnm</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gmx_output_env_t *&#160;</td>
          <td class="paramname"><em>oenv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="basedefinitions_8h.xhtml#a8fddad319f226e856400d190198d5151">gmx_bool</a>&#160;</td>
          <td class="paramname"><em>bVerbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nstglobalcomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_vsite_t *&#160;</td>
          <td class="paramname"><em>vsite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_constr_t&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stepout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_inputrec *&#160;</td>
          <td class="paramname"><em>inputrec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_mtop_t *&#160;</td>
          <td class="paramname"><em>top_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_fcdata *&#160;</td>
          <td class="paramname"><em>fcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_state *&#160;</td>
          <td class="paramname"><em>state_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__mdatoms.xhtml">t_mdatoms</a> *&#160;</td>
          <td class="paramname"><em>mdatoms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_nrnb *&#160;</td>
          <td class="paramname"><em>nrnb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_wallcycle_t&#160;</td>
          <td class="paramname"><em>wcycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_edsam_t&#160;</td>
          <td class="paramname"><em>ed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_forcerec *&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>repl_ex_nst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>repl_ex_nex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>repl_ex_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_membed_t *&#160;</td>
          <td class="paramname"><em>membed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>&#160;</td>
          <td class="paramname"><em>cpt_period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>&#160;</td>
          <td class="paramname"><em>max_hours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>imdport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_walltime_accounting_t&#160;</td>
          <td class="paramname"><em>walltime_accounting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do conjugate gradients minimization. </p>
<p>Integrator algorithm implementation. (FILE *fplog, t_commrec *cr, </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fplog</td><td>Log file for output </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cr</td><td>Communication record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nfile</td><td>Number of files </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fnm</td><td>Filename structure array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oenv</td><td>Output information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bVerbose</td><td>Verbose output or not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nstglobalcomm</td><td>How often global communication is done </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vsite</td><td>Virtual site information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constr</td><td>Constraint information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepout</td><td>How often we writen to the console </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputrec</td><td>Input record with mdp options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top_global</td><td>Molecular topology for the whole system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fcd</td><td>Force and constraint data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state_global</td><td>The state (x, v, f, box etc.) of the whole system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mdatoms</td><td>Structure containing atom information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrnb</td><td>Accounting for floating point operations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wcycle</td><td>Wall cycle timing information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ed</td><td>Essential dynamics sampling information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fr</td><td>Force record with cut-off information and more </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl_ex_nst</td><td>How often we do replica exchange (in steps) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl_ex_nex</td><td>How many replicas we have </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl_ex_seed</td><td>The seed for Monte Carlo swaps </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">membed</td><td>Membrane embedding data structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cpt_period</td><td>How often to checkpoint the simulation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_hours</td><td>Maximume length of the simulation (wall time) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imdport</td><td>Interactive MD port (socket) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Flags</td><td>Flags to control mdrun </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">walltime_accounting</td><td>More timing information (FILE *fplog, t_commrec *cr, int nfile, const <a class="el" href="structt__filenm.xhtml" title="File name option definition for C code. ">t_filenm</a> fnm[], const gmx_output_env_t *oenv, gmx_bool bVerbose, int nstglobalcomm, gmx_vsite_t *vsite, gmx_constr_t constr, int stepout, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, t_state *state_global, <a class="el" href="structt__mdatoms.xhtml" title="Declares mdatom data structure. ">t_mdatoms</a> *mdatoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, t_forcerec *fr, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, gmx_membed_t gmx_unused *membed, real cpt_period, real max_hours, int imdport, unsigned long Flags, gmx_walltime_accounting_t walltime_accounting) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afaabfc51bc04f2b0de66f075051a610a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double gmx::do_lbfgs </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fplog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_commrec *&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structt__filenm.xhtml">t_filenm</a>&#160;</td>
          <td class="paramname"><em>fnm</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gmx_output_env_t *&#160;</td>
          <td class="paramname"><em>oenv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="basedefinitions_8h.xhtml#a8fddad319f226e856400d190198d5151">gmx_bool</a>&#160;</td>
          <td class="paramname"><em>bVerbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nstglobalcomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_vsite_t *&#160;</td>
          <td class="paramname"><em>vsite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_constr_t&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stepout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_inputrec *&#160;</td>
          <td class="paramname"><em>inputrec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_mtop_t *&#160;</td>
          <td class="paramname"><em>top_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_fcdata *&#160;</td>
          <td class="paramname"><em>fcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_state *&#160;</td>
          <td class="paramname"><em>state_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__mdatoms.xhtml">t_mdatoms</a> *&#160;</td>
          <td class="paramname"><em>mdatoms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_nrnb *&#160;</td>
          <td class="paramname"><em>nrnb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_wallcycle_t&#160;</td>
          <td class="paramname"><em>wcycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_edsam_t&#160;</td>
          <td class="paramname"><em>ed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_forcerec *&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>repl_ex_nst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>repl_ex_nex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>repl_ex_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_membed_t *&#160;</td>
          <td class="paramname"><em>membed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>&#160;</td>
          <td class="paramname"><em>cpt_period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>&#160;</td>
          <td class="paramname"><em>max_hours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>imdport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_walltime_accounting_t&#160;</td>
          <td class="paramname"><em>walltime_accounting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do L-BFGS conjugate gradients minimization. </p>
<p>Integrator algorithm implementation. (FILE *fplog, t_commrec *cr, </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fplog</td><td>Log file for output </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cr</td><td>Communication record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nfile</td><td>Number of files </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fnm</td><td>Filename structure array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oenv</td><td>Output information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bVerbose</td><td>Verbose output or not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nstglobalcomm</td><td>How often global communication is done </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vsite</td><td>Virtual site information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constr</td><td>Constraint information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepout</td><td>How often we writen to the console </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputrec</td><td>Input record with mdp options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top_global</td><td>Molecular topology for the whole system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fcd</td><td>Force and constraint data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state_global</td><td>The state (x, v, f, box etc.) of the whole system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mdatoms</td><td>Structure containing atom information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrnb</td><td>Accounting for floating point operations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wcycle</td><td>Wall cycle timing information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ed</td><td>Essential dynamics sampling information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fr</td><td>Force record with cut-off information and more </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl_ex_nst</td><td>How often we do replica exchange (in steps) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl_ex_nex</td><td>How many replicas we have </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl_ex_seed</td><td>The seed for Monte Carlo swaps </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">membed</td><td>Membrane embedding data structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cpt_period</td><td>How often to checkpoint the simulation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_hours</td><td>Maximume length of the simulation (wall time) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imdport</td><td>Interactive MD port (socket) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Flags</td><td>Flags to control mdrun </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">walltime_accounting</td><td>More timing information (FILE *fplog, t_commrec *cr, int nfile, const <a class="el" href="structt__filenm.xhtml" title="File name option definition for C code. ">t_filenm</a> fnm[], const gmx_output_env_t *oenv, gmx_bool bVerbose, int nstglobalcomm, gmx_vsite_t *vsite, gmx_constr_t constr, int stepout, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, t_state *state_global, <a class="el" href="structt__mdatoms.xhtml" title="Declares mdatom data structure. ">t_mdatoms</a> *mdatoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, t_forcerec *fr, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, real cpt_period, real max_hours, int imdport, unsigned long Flags, gmx_walltime_accounting_t walltime_accounting) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8d0485fabdfa4c15b00267ad27d9a0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double gmx::do_nm </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fplog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_commrec *&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structt__filenm.xhtml">t_filenm</a>&#160;</td>
          <td class="paramname"><em>fnm</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gmx_output_env_t *&#160;</td>
          <td class="paramname"><em>oenv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="basedefinitions_8h.xhtml#a8fddad319f226e856400d190198d5151">gmx_bool</a>&#160;</td>
          <td class="paramname"><em>bVerbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nstglobalcomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_vsite_t *&#160;</td>
          <td class="paramname"><em>vsite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_constr_t&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stepout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_inputrec *&#160;</td>
          <td class="paramname"><em>inputrec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_mtop_t *&#160;</td>
          <td class="paramname"><em>top_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_fcdata *&#160;</td>
          <td class="paramname"><em>fcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_state *&#160;</td>
          <td class="paramname"><em>state_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__mdatoms.xhtml">t_mdatoms</a> *&#160;</td>
          <td class="paramname"><em>mdatoms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_nrnb *&#160;</td>
          <td class="paramname"><em>nrnb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_wallcycle_t&#160;</td>
          <td class="paramname"><em>wcycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_edsam_t&#160;</td>
          <td class="paramname"><em>ed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_forcerec *&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>repl_ex_nst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>repl_ex_nex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>repl_ex_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_membed_t *&#160;</td>
          <td class="paramname"><em>membed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>&#160;</td>
          <td class="paramname"><em>cpt_period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>&#160;</td>
          <td class="paramname"><em>max_hours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>imdport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_walltime_accounting_t&#160;</td>
          <td class="paramname"><em>walltime_accounting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do normal modes analysis. </p>
<p>Integrator algorithm implementation. (FILE *fplog, t_commrec *cr, </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fplog</td><td>Log file for output </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cr</td><td>Communication record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nfile</td><td>Number of files </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fnm</td><td>Filename structure array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oenv</td><td>Output information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bVerbose</td><td>Verbose output or not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nstglobalcomm</td><td>How often global communication is done </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vsite</td><td>Virtual site information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constr</td><td>Constraint information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepout</td><td>How often we writen to the console </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputrec</td><td>Input record with mdp options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top_global</td><td>Molecular topology for the whole system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fcd</td><td>Force and constraint data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state_global</td><td>The state (x, v, f, box etc.) of the whole system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mdatoms</td><td>Structure containing atom information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrnb</td><td>Accounting for floating point operations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wcycle</td><td>Wall cycle timing information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ed</td><td>Essential dynamics sampling information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fr</td><td>Force record with cut-off information and more </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl_ex_nst</td><td>How often we do replica exchange (in steps) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl_ex_nex</td><td>How many replicas we have </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl_ex_seed</td><td>The seed for Monte Carlo swaps </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">membed</td><td>Membrane embedding data structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cpt_period</td><td>How often to checkpoint the simulation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_hours</td><td>Maximume length of the simulation (wall time) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imdport</td><td>Interactive MD port (socket) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Flags</td><td>Flags to control mdrun </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">walltime_accounting</td><td>More timing information (FILE *fplog, t_commrec *cr, int nfile, const <a class="el" href="structt__filenm.xhtml" title="File name option definition for C code. ">t_filenm</a> fnm[], const gmx_output_env_t *oenv, gmx_bool bVerbose, int nstglobalcomm, gmx_vsite_t *vsite, gmx_constr_t constr, int stepout, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, t_state *state_global, <a class="el" href="structt__mdatoms.xhtml" title="Declares mdatom data structure. ">t_mdatoms</a> *mdatoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, t_forcerec *fr, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, real cpt_period, real max_hours, int imdport, unsigned long Flags, gmx_walltime_accounting_t walltime_accounting) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae556e926034aab8ae03d4aa73e2bab4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double gmx::do_steep </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fplog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_commrec *&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structt__filenm.xhtml">t_filenm</a>&#160;</td>
          <td class="paramname"><em>fnm</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gmx_output_env_t *&#160;</td>
          <td class="paramname"><em>oenv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="basedefinitions_8h.xhtml#a8fddad319f226e856400d190198d5151">gmx_bool</a>&#160;</td>
          <td class="paramname"><em>bVerbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nstglobalcomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_vsite_t *&#160;</td>
          <td class="paramname"><em>vsite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_constr_t&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stepout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_inputrec *&#160;</td>
          <td class="paramname"><em>inputrec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_mtop_t *&#160;</td>
          <td class="paramname"><em>top_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_fcdata *&#160;</td>
          <td class="paramname"><em>fcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_state *&#160;</td>
          <td class="paramname"><em>state_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__mdatoms.xhtml">t_mdatoms</a> *&#160;</td>
          <td class="paramname"><em>mdatoms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_nrnb *&#160;</td>
          <td class="paramname"><em>nrnb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_wallcycle_t&#160;</td>
          <td class="paramname"><em>wcycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_edsam_t&#160;</td>
          <td class="paramname"><em>ed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_forcerec *&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>repl_ex_nst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>repl_ex_nex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>repl_ex_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_membed_t *&#160;</td>
          <td class="paramname"><em>membed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>&#160;</td>
          <td class="paramname"><em>cpt_period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>&#160;</td>
          <td class="paramname"><em>max_hours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>imdport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_walltime_accounting_t&#160;</td>
          <td class="paramname"><em>walltime_accounting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do steepest descents minimization. </p>
<p>Integrator algorithm implementation. (FILE *fplog, t_commrec *cr, </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fplog</td><td>Log file for output </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cr</td><td>Communication record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nfile</td><td>Number of files </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fnm</td><td>Filename structure array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oenv</td><td>Output information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bVerbose</td><td>Verbose output or not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nstglobalcomm</td><td>How often global communication is done </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vsite</td><td>Virtual site information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constr</td><td>Constraint information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepout</td><td>How often we writen to the console </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputrec</td><td>Input record with mdp options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top_global</td><td>Molecular topology for the whole system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fcd</td><td>Force and constraint data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state_global</td><td>The state (x, v, f, box etc.) of the whole system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mdatoms</td><td>Structure containing atom information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrnb</td><td>Accounting for floating point operations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wcycle</td><td>Wall cycle timing information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ed</td><td>Essential dynamics sampling information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fr</td><td>Force record with cut-off information and more </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl_ex_nst</td><td>How often we do replica exchange (in steps) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl_ex_nex</td><td>How many replicas we have </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl_ex_seed</td><td>The seed for Monte Carlo swaps </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">membed</td><td>Membrane embedding data structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cpt_period</td><td>How often to checkpoint the simulation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_hours</td><td>Maximume length of the simulation (wall time) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imdport</td><td>Interactive MD port (socket) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Flags</td><td>Flags to control mdrun </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">walltime_accounting</td><td>More timing information (FILE *fplog, t_commrec *cr, int nfile, const <a class="el" href="structt__filenm.xhtml" title="File name option definition for C code. ">t_filenm</a> fnm[], const gmx_output_env_t *oenv, gmx_bool bVerbose, int nstglobalcomm, gmx_vsite_t *vsite, gmx_constr_t constr, int stepout, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, t_state *state_global, <a class="el" href="structt__mdatoms.xhtml" title="Declares mdatom data structure. ">t_mdatoms</a> *mdatoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, t_forcerec *fr, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, real cpt_period, real max_hours, int imdport, unsigned long Flags, gmx_walltime_accounting_t walltime_accounting) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a861907c530b5abf0554f48167ebdd2e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double gmx::do_tpi </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fplog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_commrec *&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structt__filenm.xhtml">t_filenm</a>&#160;</td>
          <td class="paramname"><em>fnm</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gmx_output_env_t *&#160;</td>
          <td class="paramname"><em>oenv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="basedefinitions_8h.xhtml#a8fddad319f226e856400d190198d5151">gmx_bool</a>&#160;</td>
          <td class="paramname"><em>bVerbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nstglobalcomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_vsite_t *&#160;</td>
          <td class="paramname"><em>vsite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_constr_t&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stepout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_inputrec *&#160;</td>
          <td class="paramname"><em>inputrec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_mtop_t *&#160;</td>
          <td class="paramname"><em>top_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_fcdata *&#160;</td>
          <td class="paramname"><em>fcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_state *&#160;</td>
          <td class="paramname"><em>state_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__mdatoms.xhtml">t_mdatoms</a> *&#160;</td>
          <td class="paramname"><em>mdatoms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_nrnb *&#160;</td>
          <td class="paramname"><em>nrnb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_wallcycle_t&#160;</td>
          <td class="paramname"><em>wcycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_edsam_t&#160;</td>
          <td class="paramname"><em>ed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_forcerec *&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>repl_ex_nst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>repl_ex_nex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>repl_ex_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_membed_t *&#160;</td>
          <td class="paramname"><em>membed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>&#160;</td>
          <td class="paramname"><em>cpt_period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>&#160;</td>
          <td class="paramname"><em>max_hours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>imdport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_walltime_accounting_t&#160;</td>
          <td class="paramname"><em>walltime_accounting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do test particle insertion. </p>
<p>Integrator algorithm implementation. (FILE *fplog, t_commrec *cr, </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fplog</td><td>Log file for output </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cr</td><td>Communication record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nfile</td><td>Number of files </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fnm</td><td>Filename structure array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oenv</td><td>Output information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bVerbose</td><td>Verbose output or not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nstglobalcomm</td><td>How often global communication is done </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vsite</td><td>Virtual site information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constr</td><td>Constraint information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepout</td><td>How often we writen to the console </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputrec</td><td>Input record with mdp options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top_global</td><td>Molecular topology for the whole system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fcd</td><td>Force and constraint data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state_global</td><td>The state (x, v, f, box etc.) of the whole system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mdatoms</td><td>Structure containing atom information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrnb</td><td>Accounting for floating point operations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wcycle</td><td>Wall cycle timing information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ed</td><td>Essential dynamics sampling information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fr</td><td>Force record with cut-off information and more </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl_ex_nst</td><td>How often we do replica exchange (in steps) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl_ex_nex</td><td>How many replicas we have </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl_ex_seed</td><td>The seed for Monte Carlo swaps </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">membed</td><td>Membrane embedding data structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cpt_period</td><td>How often to checkpoint the simulation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_hours</td><td>Maximume length of the simulation (wall time) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imdport</td><td>Interactive MD port (socket) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Flags</td><td>Flags to control mdrun </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">walltime_accounting</td><td>More timing information (FILE *fplog, t_commrec *cr, int nfile, const <a class="el" href="structt__filenm.xhtml" title="File name option definition for C code. ">t_filenm</a> fnm[], const gmx_output_env_t *oenv, gmx_bool bVerbose, int nstglobalcomm, gmx_vsite_t *vsite, gmx_constr_t constr, int stepout, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, t_state *state_global, <a class="el" href="structt__mdatoms.xhtml" title="Declares mdatom data structure. ">t_mdatoms</a> *mdatoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, t_forcerec *fr, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, real cpt_period, real max_hours, int imdport, unsigned long Flags, gmx_walltime_accounting_t walltime_accounting) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a81ecdda73e384cd4e6896492144529"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::erf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float erf(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>erf(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a3fe934a0b6419312a82b6bb6b8b6ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::erf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double erf(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>erf(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aad005ed4133f5a01702c63a9440feab7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::erfc </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float erfc(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>erfc(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a56c071a6a14720e2b94e4b034e110614"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::erfc </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double erfc(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>erfc(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a56d277c19df61f3b0176da88ba40b53a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::erfcSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double erfc(x), but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>erfc(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a2dad03094a0ea5970a5f0977ce5fee84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double gmx::erfinv </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverse error function, double precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, should be in the range -1.0 &lt; x &lt; 1.0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse of the error function if the argument is inside the range, +/- infinity if it is exactly 1.0 or -1.0, and NaN otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a85012c7d3609ac21e4052fc3114125a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gmx::erfinv </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverse error function, single precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, should be in the range -1.0 &lt; x &lt; 1.0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse of the error function if the argument is inside the range, +/- infinity if it is exactly 1.0 or -1.0, and NaN otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2491a7f4b92881d4887491a532e8e5f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::erfSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double erf(x), but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>erf(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b3a53c1076c47dbbef4e6ec2d3191ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::exp </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float exp(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>exp(x). Undefined if input argument caused overflow.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ed21bd309bf862089f430402b8fd8b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::exp </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double exp(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>exp(x). Undefined if input argument caused overflow.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aed7303338070cf13c11a8b765017a182"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::exp2 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float 2^x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2^x. Undefined if input argument caused overflow.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a8793845dd7a03f8e3d00bde1b04a2785"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::exp2 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double 2^x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2^x. Undefined if input argument caused overflow.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a119f14f4a364f71eb9273b5dd8c927cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::exp2SingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double 2^x, but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2^x. Undefined if input argument caused overflow.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b19d8b9f07e36c8152b30d4b3caaad6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::expandScalarsToTriplets </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>triplets0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>triplets1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>triplets2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy single float to three variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">scalar</td><td>Floating-point input. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">triplets0</td><td>Copy 1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">triplets1</td><td>Copy 2. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">triplets2</td><td>Copy 3.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="af8a2ae7f742d7612f2808bfd39b0f975"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::expandScalarsToTriplets </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>triplets0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>triplets1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>triplets2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy single double to three variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">scalar</td><td>Floating-point input. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">triplets0</td><td>Copy 1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">triplets1</td><td>Copy 2. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">triplets2</td><td>Copy 3.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="afa6d2866bd8be11dce227ad0e26511a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::expSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double exp(x), but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>exp(x). Undefined if input argument caused overflow.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a183d89182d418bb66a668104978af5bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::fma </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float Fused-multiply-add. Result is a*b + c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a*b + c</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a79e2ba07938cafa28c0988ba52874f46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::fma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>double Fused-multiply-add. Result is a*b + c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a*b + c</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="afad947f51589a3a9eef2f8364ab62c19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::fms </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float Fused-multiply-subtract. Result is a*b - c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a*b - c</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="abcb2c8942d173c6a9964940f90c55b2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::fms </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>double Fused-multiply-subtract. Result is a*b - c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a*b - c</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a55183d689ab9328c18c3b3f819bd7266"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::fnma </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float Fused-negated-multiply-add. Result is -a*b + c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-a*b + c</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="adcf7849c8ce1bbbe3e2fecffedfc05e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::fnma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>double Fused-negated-multiply-add. Result is - a*b + c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-a*b + c</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aa6e6950597f4833fa93b09a94e7b0e16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::fnms </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float Fused-negated-multiply-subtract. Result is -a*b - c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-a*b - c</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9bd8328d5cbdb7f6a054b877183f277"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::fnms </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>double Fused-negated-multiply-subtract. Result is -a*b - c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-a*b - c</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a179f05bc9899fe2b7e71d53a1a95b629"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::gatherLoadBySimdIntTranspose </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 4 floats from base/offsets and store into variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Aligned pointer to the start of the memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Integer type with offset to the start of each triplet. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>First float, base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>Second float, base[align*offset[0] + 1]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v2</td><td>Third float, base[align*offset[0] + 2]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v3</td><td>Fourth float, base[align*offset[0] + 3].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a0614e0463cccdf97cec36fffb2b24764"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::gatherLoadBySimdIntTranspose </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 2 floats from base/offsets and store into variables (aligned). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Aligned pointer to the start of the memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Integer type with offset to the start of each triplet. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>First float, base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>Second float, base[align*offset[0] + 1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a92c67d959864d2549a679f0f2245bacb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::gatherLoadBySimdIntTranspose </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 4 doubles from base/offsets and store into variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Aligned pointer to the start of the memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Integer type with offset to the start of each triplet. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>First double, base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>Second double, base[align*offset[0] + 1]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v2</td><td>Third double, base[align*offset[0] + 2]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v3</td><td>Fourth double, base[align*offset[0] + 3].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a6bb92443ba8da5d878c1dd85b2bcde8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::gatherLoadBySimdIntTranspose </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 2 doubles from base/offsets and store into variables (aligned). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Aligned pointer to the start of the memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Integer type with offset to the start of each triplet. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>First double, base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>Second double, base[align*offset[0] + 1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aba7ff3639534a22d4b9c7a834d7584fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::gatherLoadTranspose </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 4 consecutive floats from base/offset into four variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Index to data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>1st float, base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>2nd float, base[align*offset[0] + 1]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v2</td><td>3rd float, base[align*offset[0] + 2]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v3</td><td>4th float, base[align*offset[0] + 3].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c0cda66eba19ad12a50e48f848f268f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::gatherLoadTranspose </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 2 consecutive floats from base/offset into four variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Index to data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>1st float, base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>2nd float, base[align*offset[0] + 1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a94e990607fd4d48ca160fbc380597f5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::gatherLoadTranspose </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 4 consecutive doubles from base/offset into four variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Index to data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>1st double, base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>2nd double, base[align*offset[0] + 1]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v2</td><td>3rd double, base[align*offset[0] + 2]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v3</td><td>4th double, base[align*offset[0] + 3].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c464ebd492587005bb4baefb4293072"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::gatherLoadTranspose </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 2 consecutive doubles from base/offset into four variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Index to data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>1st double, base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>2nd double, base[align*offset[0] + 1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a29c67b43b26cfba5ec360bf020df4c8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::gatherLoadUBySimdIntTranspose </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 2 floats from base/offsets and store into variables (unaligned). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Aligned pointer to the start of the memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Integer type with offset to the start of each triplet. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>First float, base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>Second float, base[align*offset[0] + 1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="af74c58ce1915c6a25061153cd3b4bde8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::gatherLoadUBySimdIntTranspose </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 2 doubles from base/offsets and store into variables (unaligned). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Aligned pointer to the start of the memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Integer type with offset to the start of each triplet. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>First double, base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>Second double, base[align*offset[0] + 1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="acfefc291c66a8404f2aad767af91cb21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::gatherLoadUTranspose </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 3 consecutive floats from base/offsets, store into three vars. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Offset to the start of data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>1st value, base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>2nd value, base[align*offset[0] + 1]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v2</td><td>3rd value, base[align*offset[0] + 2].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a0502844193d9fcf13648a4165a67a1a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::gatherLoadUTranspose </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 3 consecutive doubles from base/offsets, store into three vars. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Offset to the start of data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>1st double, base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>2nd double, base[align*offset[0] + 1]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v2</td><td>3rd double, base[align*offset[0] + 2].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ba622deb792fdc881824ce7a36d8440"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RealType  = real, unsigned int Bits, class Rng &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RealType gmx::generateCanonical </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a floating-point value with specified number of random bits. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RealType</td><td>Floating-point type to generate </td></tr>
    <tr><td class="paramname">Bits</td><td>Number of random bits to generate </td></tr>
    <tr><td class="paramname">Rng</td><td>Random number generator class</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Random number generator to use</td></tr>
  </table>
  </dd>
</dl>
<p>This implementation avoids the bug in libc++ and stdlibc++ (which is due to the C++ standard being unclear) where 1.0 can be returned occasionally. </p>

</div>
</div>
<a class="anchor" id="a87a820e81baebe1c30a4190eb2aa2a64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t gmx::greatestCommonDivisor </td>
          <td>(</td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find greatest common divisor of two numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>First number, positive </td></tr>
    <tr><td class="paramname">q</td><td>Second number, positive</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Greatest common divisor of p and q </dd></dl>

</div>
</div>
<a class="anchor" id="a6cd74be08263227a2b2f4405dee6a359"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::inv </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/x for float. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be nonzero. This routine does not check arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/x. Result is undefined if your argument was invalid.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ed9172c60ed326ca31f64a490fabe17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::inv </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/x for double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be nonzero. This routine does not check arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/x. Result is undefined if your argument was invalid.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="acabf4874cb58de0554f95f69c1768882"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::invcbrt </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate inverse cube root of x in single precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^(-1/3)</dd></dl>
<p>This routine is typically faster than using std::pow(). </p>

</div>
</div>
<a class="anchor" id="a08d99226376a495b484eccd203d29c8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::invcbrt </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate inverse sixth root of x in double precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^(-1/3)</dd></dl>
<p>This routine is typically faster than using std::pow(). </p>

</div>
</div>
<a class="anchor" id="a1d304cf0e3cac1632695e394077fd2d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::invcbrt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate inverse sixth root of integer x in double precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^(-1/3)</dd></dl>
<p>This routine is typically faster than using std::pow(). </p>

</div>
</div>
<a class="anchor" id="a2c4548b5005dd861681ff13e55e5b6f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::invertBoxMatrix </td>
          <td>(</td>
          <td class="paramtype">const matrix&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert a simulation-box matrix in <code>src</code>, return in <code>dest</code>. </p>
<p>This routine assumes that src is a simulation-box matrix, i.e. has zeroes in the upper-right triangle. A fatal error occurs if the product of the leading diagonal is too small. The inversion can be done "in place", i.e <code>src</code> and <code>dest</code> can be the same matrix. </p>

</div>
</div>
<a class="anchor" id="a2824e7adcb69e96942fefcb67809ec5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::invertMatrix </td>
          <td>(</td>
          <td class="paramtype">const matrix&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert a general 3x3 matrix in <code>src</code>, return in <code>dest</code>. </p>
<p>A fatal error occurs if the determinant is too small. <code>src</code> and <code>dest</code> cannot be the same matrix. </p>

</div>
</div>
<a class="anchor" id="a8ac51c492a5589e075b7b8ebda5a8cbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::invSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/x for double, but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be nonzero. This routine does not check arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/x. Result is undefined if your argument was invalid.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3aeb9a178f07d4bc64b934555d12842"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::invsixthroot </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate inverse sixth root of x in single precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, must be greater than zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^(-1/6)</dd></dl>
<p>This routine is typically faster than using std::pow(). </p>

</div>
</div>
<a class="anchor" id="a2f8b9b01e7c291a443840d4f7af97c5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::invsixthroot </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate inverse sixth root of x in double precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, must be greater than zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^(-1/6)</dd></dl>
<p>This routine is typically faster than using std::pow(). </p>

</div>
</div>
<a class="anchor" id="a1604baa1a44d1de7bafa433c9443c395"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::invsixthroot </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate inverse sixth root of integer x in double precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, must be greater than zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^(-1/6)</dd></dl>
<p>This routine is typically faster than using std::pow(). </p>

</div>
</div>
<a class="anchor" id="a953226d61f6527af6485ea56a8384c85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::invsqrt </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1.0/sqrt(x) in single precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Positive value to calculate inverse square root for</td></tr>
  </table>
  </dd>
</dl>
<p>For now this is implemented with std::sqrt(x) since gcc seems to do a decent job optimizing it. However, we might decide to use instrinsics or compiler-specific functions in the future.</p>
<dl class="section return"><dt>Returns</dt><dd>1.0/sqrt(x) </dd></dl>

</div>
</div>
<a class="anchor" id="ae26d0b65eb141c73979c5d2f1d0e13fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::invsqrt </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1.0/sqrt(x) in double precision, but single range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Positive value to calculate inverse square root for, must be in the input domain valid for single precision.</td></tr>
  </table>
  </dd>
</dl>
<p>For now this is implemented with std::sqrt(x). However, we might decide to use instrinsics or compiler-specific functions in the future, and then we want to have the freedom to do the first step in single precision.</p>
<dl class="section return"><dt>Returns</dt><dd>1.0/sqrt(x) </dd></dl>

</div>
</div>
<a class="anchor" id="aa91cb31b7abc3e020022ac8ce0b1b262"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::invsqrt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1.0/sqrt(x) for integer x in double precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Positive value to calculate inverse square root for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1.0/sqrt(x) </dd></dl>

</div>
</div>
<a class="anchor" id="aba2ac92d9abba8296506e281dc66c47a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::invsqrtPair </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>out1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for two floats. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">x0</td><td>First argument, x0 must be positive - no argument checking. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">x1</td><td>Second argument, x1 must be positive - no argument checking. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out0</td><td>Result 1/sqrt(x0) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out1</td><td>Result 1/sqrt(x1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="abb50fcc000a2c2d4b8446fc17a5695e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::invsqrtPair </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for two doubles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">x0</td><td>First argument, x0 must be positive - no argument checking. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">x1</td><td>Second argument, x1 must be positive - no argument checking. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out0</td><td>Result 1/sqrt(x0) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out1</td><td>Result 1/sqrt(x1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a18f2d71567d1b88689c8498f3592b386"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::invsqrtPairSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for two doubles, but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">x0</td><td>First argument, x0 must be positive - no argument checking. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">x1</td><td>Second argument, x1 must be positive - no argument checking. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out0</td><td>Result 1/sqrt(x0) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out1</td><td>Result 1/sqrt(x1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a44adc739c8fb319abe1b6769f39e9341"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::invsqrtSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for double, but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be &gt;0. This routine does not check arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/sqrt(x). Result is undefined if your argument was invalid.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b0a25f25b649f59d96b67f2d73c8ad8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::log </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float log(x). This is the natural logarithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, should be &gt;0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural logarithm of x. Undefined if argument is invalid.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a398a52e25652367446f9180a50343885"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::log </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double log(x). This is the natural logarithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, should be &gt;0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural logarithm of x. Undefined if argument is invalid.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b47d79ef735987258c2f601cf2822be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int gmx::log2I </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute floor of logarithm to base 2, 32 bit unsigned argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>32-bit unsigned argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log2(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This version of the overloaded function uses unsigned arguments to be able to handle arguments using all 32 bits. </dd></dl>

</div>
</div>
<a class="anchor" id="aa498ec06db6575ec672e5ba847f086ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int gmx::log2I </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute floor of logarithm to base 2, 64 bit unsigned argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>64-bit unsigned argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log2(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This version of the overloaded function uses unsigned arguments to be able to handle arguments using all 64 bits. </dd></dl>

</div>
</div>
<a class="anchor" id="ab1cadcfe34ba004506db6e0e11f36c95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int gmx::log2I </td>
          <td>(</td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute floor of logarithm to base 2, 32 bit signed argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>32-bit signed argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log2(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This version of the overloaded function will assert that x is not negative. </dd></dl>

</div>
</div>
<a class="anchor" id="afbfba3f9dd776dc29c1d0a8311ed793f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int gmx::log2I </td>
          <td>(</td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute floor of logarithm to base 2, 64 bit signed argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>64-bit signed argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log2(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This version of the overloaded function will assert that x is not negative. </dd></dl>

</div>
</div>
<a class="anchor" id="a54c2c975d7e597b08a67d85920d4f562"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::logSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double log(x), but with single accuracy. This is the natural logarithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, should be &gt;0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural logarithm of x. Undefined if argument is invalid.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ddacc94505a46b63d40a995556cef32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gmx_uint64_t gmx::makeRandomSeed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return 64 random bits from the random device, suitable as seed. </p>
<p>If the internal random device output is smaller than 64 bits, this routine will use multiple calls internally until we have 64 bits of random data.</p>
<dl class="section return"><dt>Returns</dt><dd>64-bit unsigned integer with random bits. </dd></dl>

</div>
</div>
<a class="anchor" id="a0178a127dde331652ab015323ae622f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::maskAdd </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add two float variables, masked version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>term1 </td></tr>
    <tr><td class="paramname">b</td><td>term2 </td></tr>
    <tr><td class="paramname">m</td><td>mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a+b where mask is true, a otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a68b090d0e3ab5695c508453406ee43c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::maskAdd </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add two double variables, masked version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>term1 </td></tr>
    <tr><td class="paramname">b</td><td>term2 </td></tr>
    <tr><td class="paramname">m</td><td>mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a+b where mask is true, a otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a8151e61ef06e30e360c03bba6fb5e2ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::maskzFma </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float fused multiply-add, masked version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
    <tr><td class="paramname">m</td><td>mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a*b+c where mask is true, 0.0 otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aa3cf4eaad108887d2462f5beecd4db62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::maskzFma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>double fused multiply-add, masked version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
    <tr><td class="paramname">m</td><td>mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a*b+c where mask is true, 0.0 otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a582d71ff8e7d51cbd2386e29935e89ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::maskzInv </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/x for masked entry of float. </p>
<p>This routine only evaluates 1/x if mask is true. Illegal values for a masked-out float will not lead to floating-point exceptions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be nonzero if masked-in. </td></tr>
    <tr><td class="paramname">m</td><td>Mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/x. Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="af5cc89f64ab845f88816a9cbb16d467c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::maskzInv </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/x for masked entry of double. </p>
<p>This routine only evaluates 1/x if mask is true. Illegal values for a masked-out double will not lead to floating-point exceptions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be nonzero if masked-in. </td></tr>
    <tr><td class="paramname">m</td><td>Mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/x. Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a2433c82892495a73bf41de15f5e8908f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::maskzInvSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/x for masked entry of double, but with single accuracy. </p>
<p>This routine only evaluates 1/x if mask is true. Illegal values for a masked-out double will not lead to floating-point exceptions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be nonzero if masked-in. </td></tr>
    <tr><td class="paramname">m</td><td>Mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/x. Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aa182f9ceead92b3055e6ae5903994651"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::maskzInvsqrt </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for masked entry of float. </p>
<p>This routine only evaluates 1/sqrt(x) if mask is true. Illegal values for a masked-out float will not lead to floating-point exceptions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be &gt;0 if masked-in. </td></tr>
    <tr><td class="paramname">m</td><td>Mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/sqrt(x). Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5b5a9766964a2b854f493fd783bb63d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::maskzInvsqrt </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for masked entry of double. </p>
<p>This routine only evaluates 1/sqrt(x) if mask is true. Illegal values for a masked-out double will not lead to floating-point exceptions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be &gt;0 if masked-in. </td></tr>
    <tr><td class="paramname">m</td><td>Mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/sqrt(x). Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a1fdaf91102db0bfbc6fd440524b15199"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::maskzInvsqrtSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for masked entry of double, but with single accuracy. </p>
<p>This routine only evaluates 1/sqrt(x) if mask is true. Illegal values for a masked-out double will not lead to floating-point exceptions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be &gt;0 if masked-in. </td></tr>
    <tr><td class="paramname">m</td><td>Mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/sqrt(x). Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e3c4084e25d298f95003df8e9aeffa1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::maskzMul </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two float variables, masked version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">m</td><td>mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a*b where mask is true, 0.0 otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e4ab8b1ab046ff242d32ab93366bfde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::maskzMul </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two double variables, masked version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">m</td><td>mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a*b where mask is true, 0.0 otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a35c7b010fbd32f5424afa0de0c70db6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::max </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set each float element to the largest from two variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Any floating-point value </td></tr>
    <tr><td class="paramname">b</td><td>Any floating-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>max(a,b) for each element.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a16f6bf4a20b14262f28168596d5bb8b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::max </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set each double element to the largest from two variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Any doubleing-point value </td></tr>
    <tr><td class="paramname">b</td><td>Any doubleing-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>max(a,b) for each element.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a112ad714d9aa4e824fdad2c3b4ed75db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmx::mdrunner </td>
          <td>(</td>
          <td class="paramtype">gmx_hw_opt_t *&#160;</td>
          <td class="paramname"><em>hw_opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fplog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct t_commrec *&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structt__filenm.xhtml">t_filenm</a>&#160;</td>
          <td class="paramname"><em>fnm</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gmx_output_env_t *&#160;</td>
          <td class="paramname"><em>oenv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="basedefinitions_8h.xhtml#a8fddad319f226e856400d190198d5151">gmx_bool</a>&#160;</td>
          <td class="paramname"><em>bVerbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nstglobalcomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ivec&#160;</td>
          <td class="paramname"><em>ddxyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dd_rank_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>npme</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>&#160;</td>
          <td class="paramname"><em>rdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>&#160;</td>
          <td class="paramname"><em>rconstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dddlb_opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>&#160;</td>
          <td class="paramname"><em>dlb_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ddcsx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ddcsy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ddcsz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nbpu_opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nstlist_cmdline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_int64_t&#160;</td>
          <td class="paramname"><em>nsteps_cmdline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nstepout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>resetstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nmultisim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>repl_ex_nst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>repl_ex_nex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>repl_ex_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>&#160;</td>
          <td class="paramname"><em>pforce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>&#160;</td>
          <td class="paramname"><em>cpt_period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>&#160;</td>
          <td class="paramname"><em>max_hours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>imdport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>Flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver routine, that calls the different methods. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hw_opt</td><td>Hardware detection structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fplog</td><td>File pointer for log file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cr</td><td>Communication data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nfile</td><td>Number of files </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fnm</td><td>Array of filenames and file properties </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oenv</td><td>Output variables for storing xvg files etc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bVerbose</td><td>Verbose output or not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nstglobalcomm</td><td>Number of steps between global communication </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ddxyz</td><td>Division of sub-boxes over processors for use in domain decomposition parallellization </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dd_rank_order</td><td>Ordering of the PP and PME ranks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">npme</td><td>The number of separate PME ranks requested, -1 = auto </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdd</td><td>The maximum distance for bonded interactions with DD (nm) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rconstr</td><td>Maximum distance for P-LINCS (nm) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dddlb_opt</td><td>File name for debugging </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dlb_scale</td><td>File name for debugging </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ddcsx</td><td>File name for debugging </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ddcsy</td><td>File name for debugging </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ddcsz</td><td>File name for debugging </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbpu_opt</td><td>Type of nonbonded processing unit </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nstlist_cmdline</td><td>Override neighbor search frequency </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nsteps_cmdline</td><td>Override number of simulation steps </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nstepout</td><td>How often to write to the console </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resetstep</td><td>Reset the step counter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nmultisim</td><td>Number of parallel simulations to run </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl_ex_nst</td><td>Number steps between replica exchange attempts </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl_ex_nex</td><td>Number of replicas in REMD </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl_ex_seed</td><td>The seed for Monte Carlo swaps </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pforce</td><td>Minimum force for printing (for debugging) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cpt_period</td><td>How often to checkpoint the simulation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_hours</td><td>Maximume length of the simulation (wall time) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imdport</td><td>Interactive MD port (socket) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Flags</td><td>More command line options </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6d21dccd9a94698363bdb1943f139bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::min </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set each float element to the smallest from two variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Any floating-point value </td></tr>
    <tr><td class="paramname">b</td><td>Any floating-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>min(a,b) for each element.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a65fb0c7aa84962905d3d78a913c787c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::min </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set each double element to the smallest from two variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Any doubleing-point value </td></tr>
    <tr><td class="paramname">b</td><td>Any doubleing-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>min(a,b) for each element.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e5b1230d0301fa6760e34d7641ca7e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::pmeForceCorrection </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the force correction due to PME analytically in float. </p>
<p>See the SIMD version of this function for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z2</td><td>input parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Correction to use on force</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a5275f264f1c6da2502ec03e8fbf855a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::pmeForceCorrection </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the force correction due to PME analytically in double. </p>
<p>See the SIMD version of this function for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z2</td><td>input parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Correction to use on force</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="abd18f07b8fd19f03f12442211982db53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::pmeForceCorrectionSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force correction due to PME in double, but with single accuracy. </p>
<p>See the SIMD version of this function for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z2</td><td>input parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Correction to use on force</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ac54e81f11cb53c7d68ff7dab05bd6afd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::pmePotentialCorrection </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the potential correction due to PME analytically in float. </p>
<p>See the SIMD version of this function for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z2</td><td>input parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Correction to use on potential.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="acba0166c05fec69dd4a2624ed8dcff95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::pmePotentialCorrection </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the potential correction due to PME analytically in double. </p>
<p>See the SIMD version of this function for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z2</td><td>input parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Correction to use on potential.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8004b2507f7192ead653fcdcb6735fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::pmePotentialCorrectionSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Potential correction due to PME in double, but with single accuracy. </p>
<p>See the SIMD version of this function for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z2</td><td>input parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Correction to use on potential.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a800ac84e9ee71a2dc0eedda74bea1513"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T gmx::power12 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate x^12 </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of argument and return value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^12 </dd></dl>

</div>
</div>
<a class="anchor" id="abda6daf50f5129fb74816db29e411497"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T gmx::power3 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate x^3 </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of argument and return value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^3 </dd></dl>

</div>
</div>
<a class="anchor" id="a304b15bae3a2a8277f686d4dfc9fa946"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T gmx::power4 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate x^4 </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of argument and return value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^4 </dd></dl>

</div>
</div>
<a class="anchor" id="a4bb914d3b8bf083485bb26c88d2b9dda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T gmx::power5 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate x^5 </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of argument and return value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^5 </dd></dl>

</div>
</div>
<a class="anchor" id="aab162c4ba231de5ffbfc62dc3803e8ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T gmx::power6 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate x^6 </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of argument and return value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^6 </dd></dl>

</div>
</div>
<a class="anchor" id="aff67fcd64bdaa64a3823cc1a322a6783"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::printBinaryInformation </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IProgramContext &amp;&#160;</td>
          <td class="paramname"><em>programContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print basic information about the executable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">fp</td><td>Where to print the information to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">programContext</td><td>Program information object to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0c6bc3dc4ee812f31a6076c7d4f42a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::printBinaryInformation </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IProgramContext &amp;&#160;</td>
          <td class="paramname"><em>programContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BinaryInformationSettings &amp;&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print basic information about the executable with custom settings. </p>
<p>Needed to read the members without otherwise unnecessary accessors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">fp</td><td>Where to print the information to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">programContext</td><td>Program information object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">settings</td><td>Specifies what to print.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>BinaryInformationSettings </dd></dl>

</div>
</div>
<a class="anchor" id="ad8fe34835a6e197f2731e7d604f28992"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmx::processExceptionAtExitForCommandLine </td>
          <td>(</td>
          <td class="paramtype">const std::exception &amp;&#160;</td>
          <td class="paramname"><em>ex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles an exception and deinitializes after initForCommandLine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ex</td><td>Exception that is the cause for terminating the program. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return code to return from <a class="el" href="template_8cpp.xhtml#a0ddf1224851353fc92bfbff6f499fa97" title="The main function for the analysis template. ">main()</a>.</dd></dl>
<p>This method should be called as the last thing before terminating the program because of an exception. See <a class="el" href="group__module__utility.xhtml#ga5a45f49e157fa8e1059d24243283e248" title="Handles an exception that is causing the program to terminate. ">processExceptionAtExit()</a> for details. Additionally this method undoes the work done by initForCommandLine.</p>
<p>Does not throw. </p>

</div>
</div>
<a class="anchor" id="aa4a37558328ab029203170ad4c6c4d01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::reduce </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return sum of all elements in float variable (i.e., the variable itself). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>variable to reduce/sum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The argument variable itself.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a157983d90620412d404e8a77d1ddbd0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::reduce </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return sum of all elements in double variable (i.e., the variable itself). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>variable to reduce/sum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The argument variable itself.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a6eac2eb3581affdefb5b3e79e000cf84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::reduceIncr4ReturnSum </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add each float to four consecutive memory locations, return sum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Pointer to memory where four floats should be incremented </td></tr>
    <tr><td class="paramname">v0</td><td>float to be added to m[0] </td></tr>
    <tr><td class="paramname">v1</td><td>float to be added to m[1] </td></tr>
    <tr><td class="paramname">v2</td><td>float to be added to m[2] </td></tr>
    <tr><td class="paramname">v3</td><td>float to be added to m[3]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>v0+v1+v2+v3.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7989807401d15a5d7b360b91a7dbe04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::reduceIncr4ReturnSum </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add each double to four consecutive memory locations, return sum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Pointer to memory where four floats should be incremented </td></tr>
    <tr><td class="paramname">v0</td><td>double to be added to m[0] </td></tr>
    <tr><td class="paramname">v1</td><td>double to be added to m[1] </td></tr>
    <tr><td class="paramname">v2</td><td>double to be added to m[2] </td></tr>
    <tr><td class="paramname">v3</td><td>double to be added to m[3]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>v0+v1+v2+v3.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a1c0a061335a242530d8d791459a8e2d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::round </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float round to nearest integer value (in floating-point format). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Any floating-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The nearest integer, represented in floating-point format.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a15179b513c1ec4ec0b9090e57b76bac4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::round </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>double round to nearest integer value (in doubleing-point format). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Any doubleing-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The nearest integer, represented in doubleing-point format.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a3bc0e66dda7e48091ad129bede7eff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmx::runCommandLineModule </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICommandLineModule *&#160;</td>
          <td class="paramname"><em>module</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements a <a class="el" href="template_8cpp.xhtml#a0ddf1224851353fc92bfbff6f499fa97" title="The main function for the analysis template. ">main()</a> method that runs a single module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td><code>argc</code> passed to <a class="el" href="template_8cpp.xhtml#a0ddf1224851353fc92bfbff6f499fa97" title="The main function for the analysis template. ">main()</a>. </td></tr>
    <tr><td class="paramname">argv</td><td><code>argv</code> passed to <a class="el" href="template_8cpp.xhtml#a0ddf1224851353fc92bfbff6f499fa97" title="The main function for the analysis template. ">main()</a>. </td></tr>
    <tr><td class="paramname">module</td><td>Module to run.</td></tr>
  </table>
  </dd>
</dl>
<p>This method allows for uniform behavior for binaries that only contain a single module without duplicating any of the implementation from CommandLineModuleManager (startup headers, common options etc.).</p>
<p>The signature assumes that <code>module</code> construction does not throw (because otherwise the caller would need to duplicate all the exception handling code). It is possible to move the construction inside the try/catch in this method using an indirection similar to <a class="el" href="classgmx_1_1TrajectoryAnalysisCommandLineRunner.xhtml#a12cd1b40ed04cda667f315e2adee3337" title="Implements a main() method that runs a given module. ">TrajectoryAnalysisCommandLineRunner::runAsMain()</a>, but until that is necessary, the current approach leads to simpler code.</p>
<p>Usage: </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="template_8cpp.xhtml#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">    CustomCommandLineModule module;</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespacegmx.xhtml#a5a3bc0e66dda7e48091ad129bede7eff">gmx::runCommandLineModule</a>(argc, argv, &amp;module);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Does not throw. All exceptions are caught and handled internally. </p>

</div>
</div>
<a class="anchor" id="a8a7a039b6fae746686d472d1fcae6fee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmx::runCommandLineModule </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; std::unique_ptr&lt; ICommandLineOptionsModule &gt;()&gt;&#160;</td>
          <td class="paramname"><em>factory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements a <a class="el" href="template_8cpp.xhtml#a0ddf1224851353fc92bfbff6f499fa97" title="The main function for the analysis template. ">main()</a> method that runs a single module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">argc</td><td><code>argc</code> passed to <a class="el" href="template_8cpp.xhtml#a0ddf1224851353fc92bfbff6f499fa97" title="The main function for the analysis template. ">main()</a>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">argv</td><td><code>argv</code> passed to <a class="el" href="template_8cpp.xhtml#a0ddf1224851353fc92bfbff6f499fa97" title="The main function for the analysis template. ">main()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name for the module. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">description</td><td>Short description for the module. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">factory</td><td>Factory method that creates the module to run.</td></tr>
  </table>
  </dd>
</dl>
<p>This method allows for uniform behavior for binaries that only contain a single module without duplicating any of the implementation from CommandLineModuleManager (startup headers, common options etc.).</p>
<p>Usage: </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>CustomCommandLineOptionsModule : <span class="keyword">public</span> ICommandLineOptionsModule</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// &lt;...&gt;</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> ICommandLineOptionsModule *create()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> CustomCommandLineOptionsModule();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="template_8cpp.xhtml#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespacegmx.xhtml#a5a3bc0e66dda7e48091ad129bede7eff">gmx::runCommandLineModule</a>(</div>
<div class="line">            argc, argv, <span class="stringliteral">&quot;mymodule&quot;</span>, <span class="stringliteral">&quot;short description&quot;</span>, &amp;create);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Does not throw. All exceptions are caught and handled internally. </p>

</div>
</div>
<a class="anchor" id="af47eb155075f6f9aa99ecca11825b021"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::selectByMask </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select from single precision variable where boolean is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Floating-point variable to select from </td></tr>
    <tr><td class="paramname">mask</td><td>Boolean selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a is selected for true, 0 for false.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1449de9307a87e0c5946fd9cab43b35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::selectByMask </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select from double precision variable where boolean is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>double variable to select from </td></tr>
    <tr><td class="paramname">mask</td><td>Boolean selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a is selected for true, 0 for false.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a543420229312467871aaa26ea79f5a5d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::int32_t gmx::selectByMask </td>
          <td>(</td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select from integer variable where boolean is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Integer variable to select from </td></tr>
    <tr><td class="paramname">mask</td><td>Boolean selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a is selected for true, 0 for false.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a76f8ccf8f582242260b4e785ebf48e3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::selectByNotMask </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select from single precision variable where boolean is false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Floating-point variable to select from </td></tr>
    <tr><td class="paramname">mask</td><td>Boolean selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a is selected for false, 0 for true.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f03ad3380ef6213c5459051c3268ba7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::selectByNotMask </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select from double precision variable where boolean is false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>double variable to select from </td></tr>
    <tr><td class="paramname">mask</td><td>Boolean selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a is selected for false, 0 for true.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1c7d81b9ba8302dadcbdded4fcd4399"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::int32_t gmx::selectByNotMask </td>
          <td>(</td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select from integer variable where boolean is false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Integer variable to select from </td></tr>
    <tr><td class="paramname">mask</td><td>Boolean selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a is selected for false, 0 for true.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a92d3eb4aaecff5c613995ed4bce22a0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> gmx::series_sinhx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maclaurin series for sinh(x)/x. </p>
<p>Used for NH chains and MTTK pressure control. Here, we compute it to 10th order, which might be an overkill. 8th is probably enough, but it's not very much more expensive. </p>

</div>
</div>
<a class="anchor" id="a106cb113fd73e054dbb8dfa2118d7153"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::setLibraryFileFinder </td>
          <td>(</td>
          <td class="paramtype">const DataFileFinder *&#160;</td>
          <td class="paramname"><em>finder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a finder for location data files from share/top/. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">finder</td><td>finder to set (can be NULL to restore the default finder).</td></tr>
  </table>
  </dd>
</dl>
<p>The library does not take ownership of <code>finder</code>. The provided object must remain valid until the global instance is changed by another call to <a class="el" href="namespacegmx.xhtml#a106cb113fd73e054dbb8dfa2118d7153" title="Sets a finder for location data files from share/top/. ">setLibraryFileFinder()</a>.</p>
<p>The global instance is used by <a class="el" href="futil_8h.xhtml#a07349956250b160526d32b00d15a544c" title="Finds full path for a library file. ">gmxlibfn()</a> and <a class="el" href="futil_8h.xhtml#a5be6c498c4e4820ead110d48b4587210" title="Opens a library file for reading. ">libopen()</a>.</p>
<p>This method is not thread-safe. See <a class="el" href="group__module__utility.xhtml#ga2cf34635c815cc712b6291c2c8da2555" title="Sets the global IProgramContext instance. ">setProgramContext()</a>; the same constraints apply here as well.</p>
<p>Does not throw. </p>

</div>
</div>
<a class="anchor" id="a073963d19e7e6337168de8dc0005b7e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::simdPrefetch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prefetch memory at address m. </p>
<p>This typically prefetches one cache line of memory from address m, usually 64bytes or more, but the exact amount will depend on the implementation. On many platforms this is simply a no-op. Technically it might not be part of the SIMD instruction set, but since it is a hardware-specific function that is normally only used in tight loops where we also apply SIMD, it fits well here.</p>
<p>There are no guarantees about the level of cache or temporality, but usually we expect stuff to end up in level 2, and be used in a few hundred clock cycles, after which it stays in cache until evicted (normal caching).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Pointer to location prefetch. There are no alignment requirements, but if the pointer is not aligned the prefetch might start at the lower cache line boundary (meaning fewer bytes are prefetched). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af85c54a566c85f916aaa2561d12fa851"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::sin </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float sin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate sin for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sin(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a6579216abaac018cb0bc59e9183f99ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::sin </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double sin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate sin for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sin(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a3191310c1a122aafe946f0caf2fdf364"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::sincos </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>sinval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>cosval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float sin &amp; cos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">x</td><td>The argument to evaluate sin/cos for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sinval</td><td>Sin(x) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cosval</td><td>Cos(x)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a5923534ff59a386ae0579eb4196b1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::sincos </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>sinval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>cosval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double sin &amp; cos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">x</td><td>The argument to evaluate sin/cos for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sinval</td><td>Sin(x) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cosval</td><td>Cos(x)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a200455e2d7401d66cac8e39b4c8142bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::sincosSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>sinval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>cosval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double sin &amp; cos, but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">x</td><td>The argument to evaluate sin/cos for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sinval</td><td>Sin(x) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cosval</td><td>Cos(x)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a810c7b2f5d8f267f421f2c59a308c11d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::sinSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double sin, but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate sin for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sin(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a12dcc6af3bf2f769ea1e17ed12921e2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::sixthroot </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate sixth root of x in single precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, must be greater than or equal to zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^(1/6)</dd></dl>
<p>This routine is typically faster than using std::pow(). </p>

</div>
</div>
<a class="anchor" id="a4cf2628e4b20455d3396e0c2c234b951"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::sixthroot </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate sixth root of x in double precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, must be greater than or equal to zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^(1/6)</dd></dl>
<p>This routine is typically faster than using std::pow(). </p>

</div>
</div>
<a class="anchor" id="a02308efcb527a69ce399111550575880"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::sixthroot </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate sixth root of integer x, return double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, must be greater than or equal to zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^(1/6)</dd></dl>
<p>This routine is typically faster than using std::pow(). </p>

</div>
</div>
<a class="anchor" id="a2d6d95fd83052d09775c976a961eee29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::sqrtSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate sqrt(x) for double, but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be &gt;=0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sqrt(x).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a06cbcb5324f3eb428189024f020158ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T gmx::square </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate x^2 </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of argument and return value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^2 </dd></dl>

</div>
</div>
<a class="anchor" id="a5ba56cff453ff9a1f21a11d72358592a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::store </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store contents of float variable to aligned memory m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>Pointer to memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>float variable to store</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aea1d0d7a9f81e8e5cac19a3b66f0170e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::store </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store contents of double variable to aligned memory m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>Pointer to memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>double variable to store</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aa169afcbfb3992ab9fde1ed5beee8b06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::store </td>
          <td>(</td>
          <td class="paramtype">std::int32_t *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store contents of integer variable to aligned memory m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>Pointer to memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>integer variable to store</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="af3a3dcd7322b5b2555938fe1c05be15f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::storeU </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store contents of float variable to unaligned memory m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>Pointer to memory, no alignment requirement. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>float variable to store.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aea9644fa777bc5e47ff9d3e2bdde34e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::storeU </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store contents of double variable to unaligned memory m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>Pointer to memory, no alignment requirement. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>double variable to store.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a43354d3d210193bcf5316234dc7d93ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::storeU </td>
          <td>(</td>
          <td class="paramtype">std::int32_t *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store contents of integer variable to unaligned memory m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>Pointer to memory, no alignment requirement. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>integer variable to store.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a7063173231453ec737688c8d91aa0749"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::tan </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float tan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate tan for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tan(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a45e727a4960ac7f8ba5149f9b251c520"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::tan </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double tan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate tan for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tan(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f979f3defa4f725cfce2d7e93fc0d9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::tanSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double tan, but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate tan for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tan(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="af6a3628d9b9ddc7900590f963be7bbf0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool gmx::testBits </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any bits are set in the float variable. </p>
<p>This function is used to handle bitmasks, mainly for exclusions in the inner kernels. Note that it will return true even for -0.0f (sign bit set), so it is not identical to not-equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any bit in a is nonzero.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ae58ba299df96ee6c45043e646a1d01dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool gmx::testBits </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any bits are set in the double variable. </p>
<p>This function is used to handle bitmasks, mainly for exclusions in the inner kernels. Note that it will return true even for -0.0 (sign bit set), so it is not identical to not-equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any bit in a is nonzero.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2a03b61db6a3ed3e8c2d5e1b3acc9a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool gmx::testBits </td>
          <td>(</td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any bits are set in the integer variable. </p>
<p>This function is used to handle bitmasks, mainly for exclusions in the inner kernels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any bit in a is nonzero.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="af7e302c7dcfb8d4937c4388d77057435"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::transposeScatterDecrU </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract 3 floats from base/offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Offset to the start of triplet. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v0</td><td>1st value, subtracted from base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v1</td><td>2nd value, subtracted from base[align*offset[0] + 1]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v2</td><td>3rd value, subtracted from base[align*offset[0] + 2].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a812731a42d1358e6a06f81848a67eeb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::transposeScatterDecrU </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract 3 doubles from base/offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Offset to the start of triplet. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v0</td><td>1st value, subtracted from base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v1</td><td>2nd value, subtracted from base[align*offset[0] + 1]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v2</td><td>3rd value, subtracted from base[align*offset[0] + 2].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a12069a0402115678c9c39b303585917d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::transposeScatterIncrU </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add 3 floats to base/offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Offset to the start of triplet. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v0</td><td>1st value, added to base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v1</td><td>2nd value, added to base[align*offset[0] + 1]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v2</td><td>3rd value, added to base[align*offset[0] + 2].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a83e3f241eaafa47cfa9258ec9efec8d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::transposeScatterIncrU </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add 3 doubles to base/offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Offset to the start of triplet. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v0</td><td>1st value, added to base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v1</td><td>2nd value, added to base[align*offset[0] + 1]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v2</td><td>3rd value, added to base[align*offset[0] + 2].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a65d8dd5e7a4ade4e3750b48e2a95b308"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::transposeScatterStoreU </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store 3 floats to 3 to base/offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Offset to the start of triplet. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v0</td><td>1st value, written to base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v1</td><td>2nd value, written to base[align*offset[0] + 1]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v2</td><td>3rd value, written to base[align*offset[0] + 2].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5d74c633ff138def6fa648441c5decf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::transposeScatterStoreU </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store 3 doubles to 3 to base/offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Offset to the start of triplet. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v0</td><td>1st value, written to base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v1</td><td>2nd value, written to base[align*offset[0] + 1]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v2</td><td>3rd value, written to base[align*offset[0] + 2].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a4323d38c16cd7ce6b1ae9df62e94ef2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::trunc </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncate float, i.e. round towards zero - common hardware instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Any floating-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer rounded towards zero, represented in floating-point format.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a00d84f65dae98aeb02816975f5045eed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::trunc </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncate double, i.e. round towards zero - common hardware instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Any doubleing-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer rounded towards zero, represented in doubleing-point format.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Mar 13 2017 19:18:09 for Gromacs by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
