<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.5">
  <compounddef id="page_simd" kind="page">
    <compoundname>page_simd</compoundname>
    <title>Single-instruction Multiple-data (SIMD) coding</title>
    <detaileddescription>
<para><heading level="1">Coding with SIMD instructions </heading>
</para><para>One important way for GROMACS to achieve high performance is to use modern hardware capabilities where a single assembly instruction operates on multiple data units, essentially short fixed-length vectors (usually 2, 4, 8, or 16 elements). This provides a very efficient way for the CPU to increase floating-point performance, but it is much less versatile than general purpose registers. For this reason it is difficult for the compiler to generate efficient SIMD code, so the user has to organize the data in a way where it is possible to access as vectors, and these vectors often need to be aligned on cache boundaries.</para><para>We have supported a number of different SIMD instruction sets in the group kernels for ages, and it is now also present in the verlet kernels and a few other places. However, with the increased usage and several architectures with different capabilities we now use a vendor-agnostic GROMACS SIMD module, as documented in <ref refid="group__module__simd" kindref="compound">SIMD intrinsics interface (simd)</ref>.</para><para><heading level="1">Design of the GROMACS SIMD module </heading>
</para><para>The functions in <computeroutput>src/gromacs/simd</computeroutput> are intended to be used for writing architecture-independent SIMD intrinsics code. Rather than making assumptions based on architecture, we have introduced a limited number of predefined preprocessor macros that describe the capabilities of the current implementation - these are the ones you need to check when writing SIMD code. As you will see, the functionality exposed by this module as typically a small subset of general SIMD implementations, and in particular we do not even try to expose advanced shuffling or permute operations, simply because we haven&apos;t been able to describe those in a generic way that can be implemented efficiently regardless of the hardware. However, the advantage of this approach is that it is straightforward to extend with support for new simd instruction sets in the future, and that will instantly speed up old code too.</para><para>To support the more complex stuff in the GROMACS nonbonded kernels and to make it possible to use SIMD intrinsics even for some parts of the code where the data is not in SIMD-friendly layout, we have also added about 10 higher-level utility routines. These perform gather/scatter operations on coordinate triplets, they load table data and aligned pairs (Lennard-Jones parameters), and sum up the forces needed in the outer loop of the nonbonded kernels. They are very straightforward to implement, but since they are performance-critical we want to exploit all features of each architecture, and for this reason they are part of the SIMD implementation.</para><para>Finally, for some architectures with large or very large SIMD width (e.g. AVX with 8 elements in single precision, or AVX-512 with 16), the nonbonded kernels can become inefficient. Since all such architectures presently known (AVX, AVX2, MIC, AVX512) also provide extensive support for accessing parts of the register, we optionally define a handful of routines to perform load, store, and reduce operations based on half-SIMD-width data, which can improve performance. It is only useful for wide implementations, and it can safely be ignored first when porting to new platforms - they are only needed for the so-called 2xnn SIMD kernels.</para><para>Unfortunately there is no standard for SIMD architectures. The available features vary a lot, but we still need to use quite a few of them to get the best performance possible. This means some features will only be available on certain platforms, and it is critical that we do NOT make to many assumptions about the storage formats, their size or SIMD width. Just to give a few examples:</para><para><itemizedlist>
<listitem><para>On x86, double precision (64-bit) floating-point values always convert to 32-bit integers, while many other platforms use 64-bit, and some cannot use 32-bit integers at all. This means we cannot use a mask (boolean) derived from integer operations to select double-precision floating-point values, and it could get very complex for higher-level code if all these decisions were exposed. Instead, we want to keep integers 32-bit since all algorithms anyway need to work in single precision (w. 32-bit ints).</para></listitem><listitem><para>IBM QPX uses 4-wide SIMD both for single and double precision. Integer support is highly limited, and the storage format means QPX does not use x86-style all-ones masks (which have different widths in single/double) but it uses the sign bit to denote the <emphasis>false</emphasis> value. In particular, this means we cannot use the bit contents for any fancy mask operations.</para></listitem><listitem><para>AVX1 only supports 4-wide 128-bit integer SIMD arithmetics, but the integer <emphasis>conversions</emphasis> can still be done 8-wide which corresponds to the single precision floating-point width. Similarly, with AVX1 conversions between double-precision and integers use the 32-bit 4-wide 128bit registers where we can also do integer arithmetics. AVX2 adds proper arithmetics for 8-wide integers. We would severely limit performance if we had to say that integer support was not present, so instead we stick to 32-bit ints but limit the operations we expose (and do shuffling internally).</para></listitem><listitem><para>For SSE2 through SSE4.1, double precision is 2-wide, but when we convert to integers they will be put in the first two elements of a 4-wide integer type. This means we cannot assume that floating-point SIMD registers and corresponding integer registers (after conversion) have the same width.</para></listitem><listitem><para>The 2-wide SIMD instructions on BlueGene/L and BlueGene/P cannot do any floating-point logical operations (and/andnot/or/xor) whatsoever, which can be a pain when implementing approximations for math functions.</para></listitem><listitem><para>Since boolean values can have different width for float/double and the integers corresponding to float/double, we need to use separate boolean types for all these values and convert between them if we e.g. want to use result of an integer compare to select floating-point values.</para></listitem></itemizedlist>
</para><para>While this might sound complicated, it is actually far easier than writing separate SIMD code for 10 architectures in both single &amp; double. The point is not that you need to remember the limitations above, but it is critical that you <emphasis>never assume anything about the SIMD implementation</emphasis>. We typically implement SIMD support for a new architecture in days with this new module, and the extensions required for verlet kernels are also very straightforward (group kernels can be more complex, but those are gradually on their way out). For the higher-level code, the only important thing is to never <emphasis>assume</emphasis> anything about the SIMD architecture. Our general strategy in GROMACS is to split the SIMD coding in three levels:</para><para><variablelist>
<varlistentry><term>Base level generic SIMD </term></varlistentry>
<listitem><para>The base level SIMD module (which we get by including <computeroutput><ref refid="simd_8h" kindref="compound">gromacs/simd/simd.h</ref></computeroutput> provides the API to define and manipulate SIMD datatypes. This will be enough for lots of cases, and it is a huge advantage that there is roughly parity between different architectures.  </para></listitem>
<varlistentry><term>Higher-level architecture-specific SIMD utility functions </term></varlistentry>
<listitem><para>For some parts of the code this is not enough. In particular, both the group and Verlet kernels do insane amounts of floating-point operations, and since we spend 85-90% of the time in these kernels it is critical that we can optimize them as much as possible. Here, our strategy is first to define larger high-level functions that e.g. take a number of distances and loads the table interactions for this interaction. This way we can move this architecture-specific implementation to the SIMD module, and both achieve a reasonably clean kernel but still optimize a lot. This is what we have done for the approximately 10 functions for the nonbonded kernels, to load tables and Lennard-Jones parameters, and to sum up the forces in the outer loop. These functions have intentionally been given names that describe what they do with the data, rather than what their function is in GROMACS. By looking at the documentation for these routines, and the reference implementation, it should be quite straightforward to implement them for a new architecture too.  </para></listitem>
<varlistentry><term>Half-SIMD-width architecture-specific utility functions </term></varlistentry>
<listitem><para>As described earlier, as the SIMD width increases to 8 or more elements, the nonbonded kernels can become inefficient due to the large j-particle cluster size. Things will still work, but if an architecture supports efficient access to partial SIMD registers (e.g. loading half the width), we can use this to alter the balance between memory load/store operations and floating-point arithmetic operations by processing either e.g. 4-by-4 or 2-by-8 interactions in one iteration. When <ref refid="group__module__simd_1ga0d9f8d6284ecbbd135b89f2ad8999839" kindref="member">GMX_SIMD_HAVE_HSIMD_UTIL_REAL</ref> is set, a handful of routines to use this in the nonbonded kernels is present. Avoid using these routines outside the nonbonded kernels since they are slightly more complex, and is is not straightforward to determine which alternative provides the best performance.  </para></listitem>
<varlistentry><term>Architecture-specific kernels (directories/files) </term></varlistentry>
<listitem><para>No code outside the SIMD module implementation directories should try to execute anything hardware specific. Note that this includes even checking for what architecture the current SIMD implementation is - you should check for features instead, so it will work with future ports too.  </para></listitem>
</variablelist>
</para><para><heading level="1">File organization </heading>
</para><para>The SIMD module uses a couple of different files:</para><para><variablelist>
<varlistentry><term><computeroutput><ref refid="simd_8h" kindref="compound">gromacs/simd/simd.h</ref></computeroutput> </term></varlistentry>
<listitem><para>This is the top-level wrapper that you should always include first. It will check the settings made at configuration time and include a suitable low-level implementation (that can be either single, double, or both). It also contains the routines for memory alignment, and based on the current GROMACS precision it will set aliases to &apos;real&apos; SIMD datatypes (see further down) so the implementations do not have to care about GROMACS-specific details. However, note that you might not get all SIMD support you hoped for: If you compiled GROMACS in double precision but the hardware only supports single-precision SIMD there will not be any SIMD routines for default GROMACS &apos;real&apos; precision. There are #defines you can use to check this, as described further down.  </para></listitem>
<varlistentry><term><computeroutput><ref refid="impl__reference_8h" kindref="compound">gromacs/simd/impl_reference/impl_reference.h</ref></computeroutput> </term></varlistentry>
<listitem><para>This is an example of a low-level implementation. You should never, ever, work directly with these in higher-level code. The reference implementation contains the documentation for all SIMD wrappers, though. This file will in turn include other separate implementation files for single, double, simd4, etc. Since we want to be able to run the low-level SIMD implementation in simulators for new platforms, these files are intentionally not using the rest of the GROMACS infrastructure, e.g. for asserts().  </para></listitem>
<varlistentry><term><computeroutput><ref refid="simd__math_8h" kindref="compound">gromacs/simd/simd_math.h</ref></computeroutput> </term></varlistentry>
<listitem><para>SIMD math functions. All functions in this file have to be designed so they work no matter whether the hardware supports integer SIMD, logical operations on integer or floating-point SIMD, or arithmetic operations on integers. However, a few routines check for defines and use faster algorithms if these features are present.  </para></listitem>
<varlistentry><term><computeroutput><ref refid="vector__operations_8h" kindref="compound">gromacs/simd/vector_operations.h</ref></computeroutput> </term></varlistentry>
<listitem><para>This file contains a few rvec-related SIMD functions, e.g. to calculate scalar products, norms, or cross products. They obviously cannot operate on scalar GROMACS rvec types, but use separate SIMD variables for X,Y, and Z vector components.  </para></listitem>
</variablelist>
</para><para><heading level="1">SIMD datatypes </heading>
</para><para>The SIMD module handles the challenges mentioned in the introduction by introducing a number of datatypes; many of these might map to the same underlying SIMD types, but we need separate types because some architectures use different registers e.g. for boolean types.</para><para><heading level="2">Floating-point data </heading>
</para><para><variablelist>
<varlistentry><term><computeroutput><ref refid="namespacegmx_1a8591d5e5ac6d1bec936a013fdc41b904" kindref="member">gmx::SimdReal</ref></computeroutput> </term></varlistentry>
<listitem><para>This is the SIMD-version of GROMACS&apos; real type, which is set based on the CMake configuration and internally aliased to one of the next two types.  </para></listitem>
<varlistentry><term><computeroutput><ref refid="classgmx_1_1SimdFloat" kindref="compound">gmx::SimdFloat</ref></computeroutput> </term></varlistentry>
<listitem><para>This is always single-precision data, but it might not be supported on all architectures.  </para></listitem>
<varlistentry><term><computeroutput><ref refid="classgmx_1_1SimdDouble" kindref="compound">gmx::SimdDouble</ref></computeroutput> </term></varlistentry>
<listitem><para>This is always double precision when available, and in rare cases you might want to use a specific precision.  </para></listitem>
</variablelist>
</para><para><heading level="2">Integers corresponding to floating-point values </heading>
</para><para>For these types, &apos;correspond&apos; means that it is the integer type we get when we convert data e.g. from single (or double) precision floating-point SIMD variables. Those need to be different, since many common implementations only use half as many elements for double as for single SIMD variables, and then we only get half the number of integers too.</para><para><variablelist>
<varlistentry><term><computeroutput><ref refid="namespacegmx_1a6598cea23dd103ce19bff4743279e3bc" kindref="member">gmx::SimdInt32</ref></computeroutput> </term></varlistentry>
<listitem><para>This is used for integers when converting to/from GROMACS default &quot;real&quot; type.  </para></listitem>
<varlistentry><term><computeroutput><ref refid="classgmx_1_1SimdFInt32" kindref="compound">gmx::SimdFInt32</ref></computeroutput> </term></varlistentry>
<listitem><para>Integers obtained when converting from single precision, or intended to be converted to single precision floating-point. These are normal integers (not a special conversion type), but since some SIMD architectures such as SSE or AVX use different registers for integer SIMD variables having the same width as float and double, respectively, we need to separate these two types of integers. The actual operations you perform on the are normal ones such as addition or multiplication. This will also be the widest integer data type if you want to do pure integer SIMD operations, but that will not be supported on all platforms. If the architecture does not support any SIMD integer type at all, this will likely be defined from the floating-point SIMD type, without support for any integer operations apart from load/store/convert.  </para></listitem>
<varlistentry><term><computeroutput><ref refid="classgmx_1_1SimdDInt32" kindref="compound">gmx::SimdDInt32</ref></computeroutput> </term></varlistentry>
<listitem><para>Integers used when converting to/from double. See the preceding item for a detailed explanation. On many architectures, including all x86 ones, this will be a narrower type than <computeroutput><ref refid="classgmx_1_1SimdFInt32" kindref="compound">gmx::SimdFInt32</ref></computeroutput>.  </para></listitem>
</variablelist>
</para><para>Note that all integer load/stores operations defined here load/store 32-bit integers, even when the internal register storage might be 64-bit, and we set the &quot;width&quot; of the SIMD implementation based on how many float/double/ integers we load/store - even if the internal width could be larger.</para><para><heading level="2">Boolean values </heading>
</para><para>We need a separate boolean datatype for masks and comparison results, since we cannot assume they are identical either to integers, floats or double - some implementations use specific predicate registers for booleans.</para><para><variablelist>
<varlistentry><term><computeroutput><ref refid="namespacegmx_1a307172d59a1a7c9ed87bc2cb4df83efa" kindref="member">gmx::SimdBool</ref></computeroutput> </term></varlistentry>
<listitem><para>Results from boolean operations involving reals, and the booleans we use to select between real values. The corresponding routines have suffix <computeroutput>B</computeroutput>, like <computeroutput>gmx::simdOrB()</computeroutput>.  </para></listitem>
<varlistentry><term><computeroutput><ref refid="classgmx_1_1SimdFBool" kindref="compound">gmx::SimdFBool</ref></computeroutput> </term></varlistentry>
<listitem><para>Booleans specifically for single precision.  </para></listitem>
<varlistentry><term><computeroutput><ref refid="classgmx_1_1SimdDBool" kindref="compound">gmx::SimdDBool</ref></computeroutput> </term></varlistentry>
<listitem><para>Operations specifically on double.  </para></listitem>
<varlistentry><term><computeroutput><ref refid="namespacegmx_1a5e12584989a27abf28198dc8a709d604" kindref="member">gmx::SimdIBool</ref></computeroutput> </term></varlistentry>
<listitem><para>Boolean operations on integers corresponding to real (see floating-point descriptions above).  </para></listitem>
<varlistentry><term><computeroutput><ref refid="classgmx_1_1SimdFIBool" kindref="compound">gmx::SimdFIBool</ref></computeroutput> </term></varlistentry>
<listitem><para>Booleans for integers corresponding to float.  </para></listitem>
<varlistentry><term><computeroutput><ref refid="classgmx_1_1SimdDIBool" kindref="compound">gmx::SimdDIBool</ref></computeroutput> </term></varlistentry>
<listitem><para>Booleans for integers corresponding to double.  </para></listitem>
</variablelist>
</para><para>Note: You should NOT try to store and load boolean SIMD types to memory - that is the whole reason why there are no store or load operations provided for them. While it will be technically possible to achieve by defining objects inside a structure and then doing a placement new with aligned memory, this can be a very expensive operation on platforms where special single-bit predicate registers are used to represent booleans. You will need to find a more portable algorithm for your code instead.</para><para><heading level="2">The subset you should use in practice </heading>
</para><para>If this seems daunting, in practice you should only need to use these types when you start coding:</para><para><variablelist>
<varlistentry><term><computeroutput><ref refid="namespacegmx_1a8591d5e5ac6d1bec936a013fdc41b904" kindref="member">gmx::SimdReal</ref></computeroutput> </term></varlistentry>
<listitem><para>Floating-point data.  </para></listitem>
<varlistentry><term><computeroutput><ref refid="namespacegmx_1a307172d59a1a7c9ed87bc2cb4df83efa" kindref="member">gmx::SimdBool</ref></computeroutput> </term></varlistentry>
<listitem><para>Booleans.  </para></listitem>
<varlistentry><term><computeroutput><ref refid="namespacegmx_1a6598cea23dd103ce19bff4743279e3bc" kindref="member">gmx::SimdInt32</ref></computeroutput> </term></varlistentry>
<listitem><para>Integer data. Might not be supported, so you must check the preprocessor macros described below.  </para></listitem>
</variablelist>
</para><para>Operations on these types will be defined to either float/double (or corresponding integers) based on the current GROMACS precision, so the documentation is occasionally more detailed for the lower-level actual implementation functions.</para><para>Note that it is critical for these types to be aligned in memory. This should always be the case when you declare variables on the stack, but unfortunately some compilers (at least clang-3.7 on OS X) appear to be buggy when our SIMD datatypes are placed inside a structure. Somewhere in the processes where this structure includes our class, which in turn includes the actual SIMD datatype, the alignment appears to be lost. Thus, even though the compiler will not warn you, until further notice we need to avoid putting the SIMD datatypes into other structures. This is particular severe when allocating memory on the heap, but it occurs for stack structures/classes too.</para><para><heading level="2">SIMD4 implementation </heading>
</para><para>The above should be sufficient for code that works with the full SIMD width. Unfortunately reality is not that simple. Some algorithms like lattice summation need quartets of elements, so even when the SIMD width is &gt;4 we need width-4 SIMD if it is supported. The availability of SIMD4 is indicated by <ref refid="group__module__simd_1ga86b316f5c5de088d4cb073300198f4d3" kindref="member">GMX_SIMD4_HAVE_FLOAT</ref> and <ref refid="group__module__simd_1ga5a245d615fbc175986d8bd51d816e46d" kindref="member">GMX_SIMD4_HAVE_DOUBLE</ref>. For now we only support a small subset of SIMD operations for SIMD4.</para><para><heading level="1">Predefined SIMD preprocessor macros </heading>
</para><para>Functionality-wise, we have a small set of core set of features that we require to be present on all platforms, while more avanced features can be used in the code when defines like e.g. <ref refid="group__module__simd_1gacf774b2a886d1ed4149f825c50c8fec2" kindref="member">GMX_SIMD_HAVE_LOADU</ref> have the value 1.</para><para>This is a summary of the currently available preprocessor defines that you should use to check for support when using the corresponding features. We first list the float/double/int defines set by the <emphasis>implementation</emphasis>; in most cases you do not want to check directly for float/double defines, but you should instead use the derived &quot;real&quot; defines set in this file - we list those at the end below.</para><para>Preprocessor predefined macro defines set by the low-level implementation. These only have the value 1 if they work for all datatypes; <ref refid="group__module__simd_1gacf774b2a886d1ed4149f825c50c8fec2" kindref="member">GMX_SIMD_HAVE_LOADU</ref> thus means we can load both float, double, and integers from unaligned memory, and that the unaligned loads are available for SIMD4 too.</para><para><variablelist>
<varlistentry><term><ref refid="group__module__simd_1ga94ddf013ff498c818811cc6cf2c3c71d" kindref="member">GMX_SIMD</ref> </term></varlistentry>
<listitem><para>Some sort of SIMD architecture is enabled.  </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1ga8d093280bad2b3ebecbcd426bdddb73b" kindref="member">GMX_SIMD_HAVE_FLOAT</ref> </term></varlistentry>
<listitem><para>Single-precision instructions available.  </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1gaf5545c033bb4a28657239e4c9739cefe" kindref="member">GMX_SIMD_HAVE_DOUBLE</ref> </term></varlistentry>
<listitem><para>Double-precision instructions available.  </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1gacf774b2a886d1ed4149f825c50c8fec2" kindref="member">GMX_SIMD_HAVE_LOADU</ref> </term></varlistentry>
<listitem><para>Load from unaligned memory available.  </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1ga38ee3ad2fadedbafff3129df1e7c15b4" kindref="member">GMX_SIMD_HAVE_STOREU</ref> </term></varlistentry>
<listitem><para>Store to unaligned memory available.  </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1gaf002483e94d5f42de1d5105cf924f8b8" kindref="member">GMX_SIMD_HAVE_LOGICAL</ref> </term></varlistentry>
<listitem><para>Support for and/andnot/or/xor on floating-point variables.  </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1ga28b81d356fae5d8b1b3b76273c360360" kindref="member">GMX_SIMD_HAVE_FMA</ref> </term></varlistentry>
<listitem><para>Floating-point fused multiply-add. Note: We provide emulated FMA instructions if you do not have FMA support, but in that case you might be able to code it more efficient w/o FMA.  </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1ga23ac53a0050467ac215f146f6afc6380" kindref="member">GMX_SIMD_HAVE_FINT32_EXTRACT</ref> </term></varlistentry>
<listitem><para>Support for extracting integer SIMD elements from <computeroutput><ref refid="classgmx_1_1SimdFInt32" kindref="compound">gmx::SimdFInt32</ref></computeroutput>.  </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1ga354867d2570fecb6b341047947bee0d1" kindref="member">GMX_SIMD_HAVE_FINT32_LOGICAL</ref> </term></varlistentry>
<listitem><para>Bitwise shifts on <computeroutput><ref refid="classgmx_1_1SimdFInt32" kindref="compound">gmx::SimdFInt32</ref></computeroutput>.  </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1ga9febc62e1abd58eb8a035b8b81f93292" kindref="member">GMX_SIMD_HAVE_FINT32_ARITHMETICS</ref> </term></varlistentry>
<listitem><para>Arithmetic ops for <computeroutput><ref refid="classgmx_1_1SimdFInt32" kindref="compound">gmx::SimdFInt32</ref></computeroutput>.  </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1gabae2f56a4d87b8e52b5df066888a4c07" kindref="member">GMX_SIMD_HAVE_DINT32_EXTRACT</ref> </term></varlistentry>
<listitem><para>Support for extracting integer SIMD elements from <computeroutput><ref refid="classgmx_1_1SimdDInt32" kindref="compound">gmx::SimdDInt32</ref></computeroutput>.  </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1ga0ccbae145ecb27cee3c98ec7bded1d45" kindref="member">GMX_SIMD_HAVE_DINT32_LOGICAL</ref> </term></varlistentry>
<listitem><para>Bitwise shifts on <computeroutput><ref refid="classgmx_1_1SimdDInt32" kindref="compound">gmx::SimdDInt32</ref></computeroutput>.  </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1gab8469202af6999f95405779355d89c30" kindref="member">GMX_SIMD_HAVE_DINT32_ARITHMETICS</ref> </term></varlistentry>
<listitem><para>Arithmetic ops for <computeroutput><ref refid="classgmx_1_1SimdDInt32" kindref="compound">gmx::SimdDInt32</ref></computeroutput>.  </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1gac40bf3261e36fb7ff022e8ab37b04fcf" kindref="member">GMX_SIMD_HAVE_HSIMD_UTIL_FLOAT</ref> </term></varlistentry>
<listitem><para>Half-SIMD-width nonbonded kernel utilities available for float SIMD.  </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1gadef533340f8e648dfb550cbd8cfd9fc7" kindref="member">GMX_SIMD_HAVE_HSIMD_UTIL_DOUBLE</ref> </term></varlistentry>
<listitem><para>Half-SIMD-width nonbonded kernel utilities available for double SIMD.  </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1ga5ba6c684641af238fb2a5a7d4c6e0237" kindref="member">GMX_SIMD_HAVE_GATHER_LOADU_BYSIMDINT_TRANSPOSE_FLOAT</ref> </term></varlistentry>
<listitem><para>Can load pairs of unaligned floats from simd offsets (meant for linear tables).  </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1ga5f609eec37d8c92163def72ec28bb435" kindref="member">GMX_SIMD_HAVE_GATHER_LOADU_BYSIMDINT_TRANSPOSE_DOUBLE</ref> </term></varlistentry>
<listitem><para>Can load pairs of unaligned doubles from simd offsets (meant for linear tables).  </para></listitem>
</variablelist>
</para><para>There are also two macros specific to SIMD4: <ref refid="group__module__simd_1ga86b316f5c5de088d4cb073300198f4d3" kindref="member">GMX_SIMD4_HAVE_FLOAT</ref> is set if we can use SIMD4 in single precision, and <ref refid="group__module__simd_1ga5a245d615fbc175986d8bd51d816e46d" kindref="member">GMX_SIMD4_HAVE_DOUBLE</ref> similarly denotes support for a double-precision SIMD4 implementation. For generic properties (e.g. whether SIMD4 FMA is supported), you should check the normal SIMD macros above.</para><para><heading level="2">Implementation properties </heading>
</para><para>Higher-level code can use these macros to find information about the implementation, for instance what the SIMD width is:</para><para><variablelist>
<varlistentry><term><ref refid="group__module__simd_1gafdbf804a40bfa3dcb15bc50055e58e74" kindref="member">GMX_SIMD_FLOAT_WIDTH</ref> </term></varlistentry>
<listitem><para>Number of elements in <computeroutput><ref refid="classgmx_1_1SimdFloat" kindref="compound">gmx::SimdFloat</ref></computeroutput>, and practical width of <computeroutput><ref refid="classgmx_1_1SimdFInt32" kindref="compound">gmx::SimdFInt32</ref></computeroutput>.  </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1ga417e9d28b6310876bb2c69eb528c0a86" kindref="member">GMX_SIMD_DOUBLE_WIDTH</ref> </term></varlistentry>
<listitem><para>Number of elements in <computeroutput><ref refid="classgmx_1_1SimdDouble" kindref="compound">gmx::SimdDouble</ref></computeroutput>, and practical width of <computeroutput><ref refid="classgmx_1_1SimdDInt32" kindref="compound">gmx::SimdDInt32</ref></computeroutput> </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1ga7e207d56564fc020b246563d09214aac" kindref="member">GMX_SIMD_RSQRT_BITS</ref> </term></varlistentry>
<listitem><para>Accuracy (bits) of 1/sqrt(x) lookup step.  </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1ga8b7a7c4421c0ce401b74c469a109e82c" kindref="member">GMX_SIMD_RCP_BITS</ref> </term></varlistentry>
<listitem><para>Accuracy (bits) of 1/x lookup step.  </para></listitem>
</variablelist>
</para><para>After including the low-level architecture-specific implementation, this header sets the following derived defines based on the current precision; these are the ones you should check for unless you absolutely want to dig deep into the explicit single/double precision implementations:</para><para><variablelist>
<varlistentry><term><ref refid="group__module__simd_1ga1578fccdb327f36a2bea338457cbf883" kindref="member">GMX_SIMD_HAVE_REAL</ref> </term></varlistentry>
<listitem><para>Set to either <ref refid="group__module__simd_1ga8d093280bad2b3ebecbcd426bdddb73b" kindref="member">GMX_SIMD_HAVE_FLOAT</ref> or <ref refid="group__module__simd_1gaf5545c033bb4a28657239e4c9739cefe" kindref="member">GMX_SIMD_HAVE_DOUBLE</ref>  </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1ga6c015b9c619e63324df85f91e25191c5" kindref="member">GMX_SIMD4_HAVE_REAL</ref> </term></varlistentry>
<listitem><para>Set to either <ref refid="group__module__simd_1ga86b316f5c5de088d4cb073300198f4d3" kindref="member">GMX_SIMD4_HAVE_FLOAT</ref> or <ref refid="group__module__simd_1ga5a245d615fbc175986d8bd51d816e46d" kindref="member">GMX_SIMD4_HAVE_DOUBLE</ref>  </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1ga586ccc19c21a1d5e9c97e15b70822fba" kindref="member">GMX_SIMD_REAL_WIDTH</ref> </term></varlistentry>
<listitem><para>Set to either <ref refid="group__module__simd_1gafdbf804a40bfa3dcb15bc50055e58e74" kindref="member">GMX_SIMD_FLOAT_WIDTH</ref> or <ref refid="group__module__simd_1ga417e9d28b6310876bb2c69eb528c0a86" kindref="member">GMX_SIMD_DOUBLE_WIDTH</ref>  </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1ga036e9a3893a355aa51267fef7b5d4cae" kindref="member">GMX_SIMD_HAVE_INT32_EXTRACT</ref> </term></varlistentry>
<listitem><para>Set to either <ref refid="group__module__simd_1ga23ac53a0050467ac215f146f6afc6380" kindref="member">GMX_SIMD_HAVE_FINT32_EXTRACT</ref> or <ref refid="group__module__simd_1gabae2f56a4d87b8e52b5df066888a4c07" kindref="member">GMX_SIMD_HAVE_DINT32_EXTRACT</ref>  </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1ga69de9b6e1473a9dc3ab6a5588d00192a" kindref="member">GMX_SIMD_HAVE_INT32_LOGICAL</ref> </term></varlistentry>
<listitem><para>Set to either <ref refid="group__module__simd_1ga354867d2570fecb6b341047947bee0d1" kindref="member">GMX_SIMD_HAVE_FINT32_LOGICAL</ref> or <ref refid="group__module__simd_1ga0ccbae145ecb27cee3c98ec7bded1d45" kindref="member">GMX_SIMD_HAVE_DINT32_LOGICAL</ref>  </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1ga8a9534860edf5a3f2b9cd1bc60529b39" kindref="member">GMX_SIMD_HAVE_INT32_ARITHMETICS</ref> </term></varlistentry>
<listitem><para>Set to either <ref refid="group__module__simd_1ga9febc62e1abd58eb8a035b8b81f93292" kindref="member">GMX_SIMD_HAVE_FINT32_ARITHMETICS</ref> or <ref refid="group__module__simd_1gab8469202af6999f95405779355d89c30" kindref="member">GMX_SIMD_HAVE_DINT32_ARITHMETICS</ref>  </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1ga0d9f8d6284ecbbd135b89f2ad8999839" kindref="member">GMX_SIMD_HAVE_HSIMD_UTIL_REAL</ref> </term></varlistentry>
<listitem><para>Set to either <ref refid="group__module__simd_1gac40bf3261e36fb7ff022e8ab37b04fcf" kindref="member">GMX_SIMD_HAVE_HSIMD_UTIL_FLOAT</ref> or <ref refid="group__module__simd_1gadef533340f8e648dfb550cbd8cfd9fc7" kindref="member">GMX_SIMD_HAVE_HSIMD_UTIL_DOUBLE</ref>  </para></listitem>
<varlistentry><term><ref refid="group__module__simd_1gad1350cf295aeed5d4fce461ca2048c56" kindref="member">GMX_SIMD_HAVE_GATHER_LOADU_BYSIMDINT_TRANSPOSE_REAL</ref> </term></varlistentry>
<listitem><para>Set to either <ref refid="group__module__simd_1ga5ba6c684641af238fb2a5a7d4c6e0237" kindref="member">GMX_SIMD_HAVE_GATHER_LOADU_BYSIMDINT_TRANSPOSE_FLOAT</ref> or <ref refid="group__module__simd_1ga5f609eec37d8c92163def72ec28bb435" kindref="member">GMX_SIMD_HAVE_GATHER_LOADU_BYSIMDINT_TRANSPOSE_DOUBLE</ref>  </para></listitem>
</variablelist>
</para><para>For convenience we also define <ref refid="group__module__simd_1ga103880e9c6120155f60f16f440aa5b37" kindref="member">GMX_SIMD4_WIDTH</ref> to 4. This will never vary, but using it helps you make it clear that a loop or array refers to the SIMD4 width rather than some other &apos;4&apos;.</para><para>While all these defines are available to specify the features of the hardware, we would strongly recommend that you do NOT sprinkle your code with defines - if nothing else it will be a debug nightmare. Instead you can write a slower generic SIMD function that works everywhere, and then override this with faster architecture-specific versions for some implementations. The recommended way to do that is to add a define around the generic function that skips it if the name is already defined. The actual implementations in the lowest-level files are typically defined to an architecture-specific name (such as <computeroutput>simdSinCosD_Sse2</computeroutput>) so we can override it (e.g. in SSE4) by simply undefining and setting a new definition. Still, this is an implementation detail you won&apos;t have to worry about until you start writing support for a new SIMD architecture.</para><para><heading level="2">Function naming </heading>
</para><para>We rely on C++ overloading, so the name of a function is usually identical regardless of what datatype it operates on. There are a few exceptions to this for functions that do not take arguments but only return a value, e.g. <ref refid="namespacegmx_1a1b9689c4629a14843a0464a0053c8e9e" kindref="member">setZero()</ref>, since overloading only works if the formal parameters are different. To solve this, we use different low-level function names in these cases, but then create proxy objects in the high-level <computeroutput><ref refid="simd_8h" kindref="compound">gromacs/simd/simd.h</ref></computeroutput> so that you can still get the functionality by simply writing <ref refid="namespacegmx_1a1b9689c4629a14843a0464a0053c8e9e" kindref="member">setZero()</ref> in the code.</para><para><heading level="2">Automated checking </heading>
</para><para>Having fallback implementations when SIMD is not supported can be a performance problem if the code does not correctly include <computeroutput><ref refid="simd_8h" kindref="compound">gromacs/simd/simd.h</ref></computeroutput>, particularly after refactoring. <computeroutput>make check-source</computeroutput> checks the whole code for the use of symbols defined in <computeroutput><ref refid="simd_8h" kindref="compound">gromacs/simd/simd.h</ref></computeroutput> and requires that files using those symbols do the correct include. Similar checking is done for higher-level SIMD-management headers, e.g. <computeroutput>gromacs/ewald/pme-simd.h</computeroutput>. </para>    </detaileddescription>
  </compounddef>
</doxygen>
