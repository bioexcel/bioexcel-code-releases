<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.5">
  <compounddef id="namespacegmx" kind="namespace">
    <compoundname>gmx</compoundname>
    <innerclass refid="classgmx_1_1AbstractAnalysisData" prot="public">gmx::AbstractAnalysisData</innerclass>
    <innerclass refid="classgmx_1_1AnalysisData" prot="public">gmx::AnalysisData</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataHandle" prot="public">gmx::AnalysisDataHandle</innerclass>
    <innerclass refid="classgmx_1_1AbstractAnalysisArrayData" prot="public">gmx::AbstractAnalysisArrayData</innerclass>
    <innerclass refid="classgmx_1_1AnalysisArrayData" prot="public">gmx::AnalysisArrayData</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataValue" prot="public">gmx::AnalysisDataValue</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataFrameHeader" prot="public">gmx::AnalysisDataFrameHeader</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataPointSetRef" prot="public">gmx::AnalysisDataPointSetRef</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataFrameRef" prot="public">gmx::AnalysisDataFrameRef</innerclass>
    <innerclass refid="classgmx_1_1IAnalysisDataModule" prot="public">gmx::IAnalysisDataModule</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataModuleSerial" prot="public">gmx::AnalysisDataModuleSerial</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataModuleParallel" prot="public">gmx::AnalysisDataModuleParallel</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataModuleManager" prot="public">gmx::AnalysisDataModuleManager</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataProxy" prot="public">gmx::AnalysisDataProxy</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataStorageFrame" prot="public">gmx::AnalysisDataStorageFrame</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataStorage" prot="public">gmx::AnalysisDataStorage</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataFrameLocalDataSetHandle" prot="public">gmx::AnalysisDataFrameLocalDataSetHandle</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataFrameLocalDataHandle" prot="public">gmx::AnalysisDataFrameLocalDataHandle</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataFrameLocalData" prot="public">gmx::AnalysisDataFrameLocalData</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataAverageModule" prot="public">gmx::AnalysisDataAverageModule</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataFrameAverageModule" prot="public">gmx::AnalysisDataFrameAverageModule</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataDisplacementModule" prot="public">gmx::AnalysisDataDisplacementModule</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataFrameAverager" prot="public">gmx::AnalysisDataFrameAverager</innerclass>
    <innerclass refid="classgmx_1_1AnalysisHistogramSettingsInitializer" prot="public">gmx::AnalysisHistogramSettingsInitializer</innerclass>
    <innerclass refid="classgmx_1_1AnalysisHistogramSettings" prot="public">gmx::AnalysisHistogramSettings</innerclass>
    <innerclass refid="classgmx_1_1AbstractAverageHistogram" prot="public">gmx::AbstractAverageHistogram</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataSimpleHistogramModule" prot="public">gmx::AnalysisDataSimpleHistogramModule</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataWeightedHistogramModule" prot="public">gmx::AnalysisDataWeightedHistogramModule</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataBinAverageModule" prot="public">gmx::AnalysisDataBinAverageModule</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataLifetimeModule" prot="public">gmx::AnalysisDataLifetimeModule</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataPlotSettings" prot="public">gmx::AnalysisDataPlotSettings</innerclass>
    <innerclass refid="classgmx_1_1AbstractPlotModule" prot="public">gmx::AbstractPlotModule</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataPlotModule" prot="public">gmx::AnalysisDataPlotModule</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataVectorPlotModule" prot="public">gmx::AnalysisDataVectorPlotModule</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataParallelOptions" prot="public">gmx::AnalysisDataParallelOptions</innerclass>
    <innerclass refid="classgmx_1_1CommandLineHelpContext" prot="public">gmx::CommandLineHelpContext</innerclass>
    <innerclass refid="classgmx_1_1GlobalCommandLineHelpContext" prot="public">gmx::GlobalCommandLineHelpContext</innerclass>
    <innerclass refid="classgmx_1_1CommandLineHelpModuleImpl" prot="public">gmx::CommandLineHelpModuleImpl</innerclass>
    <innerclass refid="classgmx_1_1CommandLineHelpModule" prot="public">gmx::CommandLineHelpModule</innerclass>
    <innerclass refid="classgmx_1_1ConstArrayRef" prot="public">gmx::ConstArrayRef</innerclass>
    <innerclass refid="classgmx_1_1CommandLineHelpWriter" prot="public">gmx::CommandLineHelpWriter</innerclass>
    <innerclass refid="classgmx_1_1CommandLineModuleSettings" prot="public">gmx::CommandLineModuleSettings</innerclass>
    <innerclass refid="classgmx_1_1ICommandLineModule" prot="public">gmx::ICommandLineModule</innerclass>
    <innerclass refid="classgmx_1_1CommandLineModuleGroupData" prot="public">gmx::CommandLineModuleGroupData</innerclass>
    <innerclass refid="classgmx_1_1CommandLineCommonOptionsHolder" prot="public">gmx::CommandLineCommonOptionsHolder</innerclass>
    <innerclass refid="classgmx_1_1CommandLineModuleManager" prot="public">gmx::CommandLineModuleManager</innerclass>
    <innerclass refid="classgmx_1_1CommandLineModuleGroup" prot="public">gmx::CommandLineModuleGroup</innerclass>
    <innerclass refid="classgmx_1_1ICommandLineOptionsModuleSettings" prot="public">gmx::ICommandLineOptionsModuleSettings</innerclass>
    <innerclass refid="classgmx_1_1ICommandLineOptionsModule" prot="public">gmx::ICommandLineOptionsModule</innerclass>
    <innerclass refid="classgmx_1_1CommandLineParser" prot="public">gmx::CommandLineParser</innerclass>
    <innerclass refid="classgmx_1_1IExecutableEnvironment" prot="public">gmx::IExecutableEnvironment</innerclass>
    <innerclass refid="classgmx_1_1CommandLineProgramContext" prot="public">gmx::CommandLineProgramContext</innerclass>
    <innerclass refid="classgmx_1_1ShellCompletionWriter" prot="public">gmx::ShellCompletionWriter</innerclass>
    <innerclass refid="classgmx_1_1InsertMoleculesInfo" prot="public">gmx::InsertMoleculesInfo</innerclass>
    <innerclass refid="classgmx_1_1CpuInfo" prot="public">gmx::CpuInfo</innerclass>
    <innerclass refid="classgmx_1_1HardwareTopology" prot="public">gmx::HardwareTopology</innerclass>
    <innerclass refid="structgmx_1_1StaticLog2" prot="public">gmx::StaticLog2</innerclass>
    <innerclass refid="structgmx_1_1StaticLog2_3_011_01_4" prot="public">gmx::StaticLog2&lt; 1 &gt;</innerclass>
    <innerclass refid="structgmx_1_1StaticLog2_3_010_01_4" prot="public">gmx::StaticLog2&lt; 0 &gt;</innerclass>
    <innerclass refid="classgmx_1_1BasicVector" prot="public">gmx::BasicVector</innerclass>
    <innerclass refid="classgmx_1_1ArrayRef" prot="public">gmx::ArrayRef</innerclass>
    <innerclass refid="classgmx_1_1SimulationSignal" prot="public">gmx::SimulationSignal</innerclass>
    <innerclass refid="classgmx_1_1SimulationSignaller" prot="public">gmx::SimulationSignaller</innerclass>
    <innerclass refid="classgmx_1_1TextTableFormatter" prot="public">gmx::TextTableFormatter</innerclass>
    <innerclass refid="classgmx_1_1HelpManager" prot="public">gmx::HelpManager</innerclass>
    <innerclass refid="classgmx_1_1AbstractSimpleHelpTopic" prot="public">gmx::AbstractSimpleHelpTopic</innerclass>
    <innerclass refid="classgmx_1_1AbstractCompositeHelpTopic" prot="public">gmx::AbstractCompositeHelpTopic</innerclass>
    <innerclass refid="classgmx_1_1SimpleHelpTopic" prot="public">gmx::SimpleHelpTopic</innerclass>
    <innerclass refid="classgmx_1_1CompositeHelpTopic" prot="public">gmx::CompositeHelpTopic</innerclass>
    <innerclass refid="classgmx_1_1HelpLinks" prot="public">gmx::HelpLinks</innerclass>
    <innerclass refid="classgmx_1_1HelpWriterContext" prot="public">gmx::HelpWriterContext</innerclass>
    <innerclass refid="classgmx_1_1IHelpTopic" prot="public">gmx::IHelpTopic</innerclass>
    <innerclass refid="classgmx_1_1RstParagraphIterator" prot="public">gmx::RstParagraphIterator</innerclass>
    <innerclass refid="classgmx_1_1OptionStorageTemplate" prot="public">gmx::OptionStorageTemplate</innerclass>
    <innerclass refid="classgmx_1_1AbstractOption" prot="public">gmx::AbstractOption</innerclass>
    <innerclass refid="classgmx_1_1OptionTemplate" prot="public">gmx::OptionTemplate</innerclass>
    <innerclass refid="classgmx_1_1OptionInfo" prot="public">gmx::OptionInfo</innerclass>
    <innerclass refid="classgmx_1_1AbstractOptionStorage" prot="public">gmx::AbstractOptionStorage</innerclass>
    <innerclass refid="classgmx_1_1BooleanOption" prot="public">gmx::BooleanOption</innerclass>
    <innerclass refid="classgmx_1_1IntegerOption" prot="public">gmx::IntegerOption</innerclass>
    <innerclass refid="classgmx_1_1Int64Option" prot="public">gmx::Int64Option</innerclass>
    <innerclass refid="classgmx_1_1DoubleOption" prot="public">gmx::DoubleOption</innerclass>
    <innerclass refid="classgmx_1_1FloatOption" prot="public">gmx::FloatOption</innerclass>
    <innerclass refid="classgmx_1_1StringOption" prot="public">gmx::StringOption</innerclass>
    <innerclass refid="classgmx_1_1EnumOption" prot="public">gmx::EnumOption</innerclass>
    <innerclass refid="classgmx_1_1BooleanOptionInfo" prot="public">gmx::BooleanOptionInfo</innerclass>
    <innerclass refid="classgmx_1_1IntegerOptionInfo" prot="public">gmx::IntegerOptionInfo</innerclass>
    <innerclass refid="classgmx_1_1Int64OptionInfo" prot="public">gmx::Int64OptionInfo</innerclass>
    <innerclass refid="classgmx_1_1DoubleOptionInfo" prot="public">gmx::DoubleOptionInfo</innerclass>
    <innerclass refid="classgmx_1_1FloatOptionInfo" prot="public">gmx::FloatOptionInfo</innerclass>
    <innerclass refid="classgmx_1_1StringOptionInfo" prot="public">gmx::StringOptionInfo</innerclass>
    <innerclass refid="classgmx_1_1EnumOptionInfo" prot="public">gmx::EnumOptionInfo</innerclass>
    <innerclass refid="classgmx_1_1BooleanOptionStorage" prot="public">gmx::BooleanOptionStorage</innerclass>
    <innerclass refid="classgmx_1_1IntegerOptionStorage" prot="public">gmx::IntegerOptionStorage</innerclass>
    <innerclass refid="classgmx_1_1Int64OptionStorage" prot="public">gmx::Int64OptionStorage</innerclass>
    <innerclass refid="classgmx_1_1DoubleOptionStorage" prot="public">gmx::DoubleOptionStorage</innerclass>
    <innerclass refid="classgmx_1_1FloatOptionStorage" prot="public">gmx::FloatOptionStorage</innerclass>
    <innerclass refid="classgmx_1_1StringOptionStorage" prot="public">gmx::StringOptionStorage</innerclass>
    <innerclass refid="classgmx_1_1EnumOptionStorage" prot="public">gmx::EnumOptionStorage</innerclass>
    <innerclass refid="classgmx_1_1OptionsBehaviorCollection" prot="public">gmx::OptionsBehaviorCollection</innerclass>
    <innerclass refid="classgmx_1_1FileNameOption" prot="public">gmx::FileNameOption</innerclass>
    <innerclass refid="classgmx_1_1FileNameOptionInfo" prot="public">gmx::FileNameOptionInfo</innerclass>
    <innerclass refid="classgmx_1_1FileNameOptionManager" prot="public">gmx::FileNameOptionManager</innerclass>
    <innerclass refid="classgmx_1_1FileNameOptionStorage" prot="public">gmx::FileNameOptionStorage</innerclass>
    <innerclass refid="classgmx_1_1IOptionsBehavior" prot="public">gmx::IOptionsBehavior</innerclass>
    <innerclass refid="classgmx_1_1IOptionsContainer" prot="public">gmx::IOptionsContainer</innerclass>
    <innerclass refid="classgmx_1_1OptionManagerContainer" prot="public">gmx::OptionManagerContainer</innerclass>
    <innerclass refid="classgmx_1_1IOptionManager" prot="public">gmx::IOptionManager</innerclass>
    <innerclass refid="classgmx_1_1Options" prot="public">gmx::Options</innerclass>
    <innerclass refid="classgmx_1_1OptionsAssigner" prot="public">gmx::OptionsAssigner</innerclass>
    <innerclass refid="classgmx_1_1OptionsVisitor" prot="public">gmx::OptionsVisitor</innerclass>
    <innerclass refid="classgmx_1_1OptionsTypeVisitor" prot="public">gmx::OptionsTypeVisitor</innerclass>
    <innerclass refid="classgmx_1_1OptionsIterator" prot="public">gmx::OptionsIterator</innerclass>
    <innerclass refid="classgmx_1_1OptionsModifyingVisitor" prot="public">gmx::OptionsModifyingVisitor</innerclass>
    <innerclass refid="classgmx_1_1OptionsModifyingTypeVisitor" prot="public">gmx::OptionsModifyingTypeVisitor</innerclass>
    <innerclass refid="classgmx_1_1OptionsModifyingIterator" prot="public">gmx::OptionsModifyingIterator</innerclass>
    <innerclass refid="classgmx_1_1TimeUnitManager" prot="public">gmx::TimeUnitManager</innerclass>
    <innerclass refid="classgmx_1_1TimeUnitBehavior" prot="public">gmx::TimeUnitBehavior</innerclass>
    <innerclass refid="classgmx_1_1ExponentialDistribution" prot="public">gmx::ExponentialDistribution</innerclass>
    <innerclass refid="classgmx_1_1GammaDistribution" prot="public">gmx::GammaDistribution</innerclass>
    <innerclass refid="classgmx_1_1NormalDistribution" prot="public">gmx::NormalDistribution</innerclass>
    <innerclass refid="classgmx_1_1TabulatedNormalDistribution" prot="public">gmx::TabulatedNormalDistribution</innerclass>
    <innerclass refid="classgmx_1_1ThreeFry2x64General" prot="public">gmx::ThreeFry2x64General</innerclass>
    <innerclass refid="classgmx_1_1ThreeFry2x64" prot="public">gmx::ThreeFry2x64</innerclass>
    <innerclass refid="classgmx_1_1ThreeFry2x64Fast" prot="public">gmx::ThreeFry2x64Fast</innerclass>
    <innerclass refid="classgmx_1_1UniformIntDistribution" prot="public">gmx::UniformIntDistribution</innerclass>
    <innerclass refid="classgmx_1_1UniformRealDistribution" prot="public">gmx::UniformRealDistribution</innerclass>
    <innerclass refid="classgmx_1_1SelectionCompiler" prot="public">gmx::SelectionCompiler</innerclass>
    <innerclass refid="classgmx_1_1AnalysisNeighborhoodPositions" prot="public">gmx::AnalysisNeighborhoodPositions</innerclass>
    <innerclass refid="classgmx_1_1AnalysisNeighborhood" prot="public">gmx::AnalysisNeighborhood</innerclass>
    <innerclass refid="classgmx_1_1AnalysisNeighborhoodPair" prot="public">gmx::AnalysisNeighborhoodPair</innerclass>
    <innerclass refid="classgmx_1_1AnalysisNeighborhoodSearch" prot="public">gmx::AnalysisNeighborhoodSearch</innerclass>
    <innerclass refid="classgmx_1_1AnalysisNeighborhoodPairSearch" prot="public">gmx::AnalysisNeighborhoodPairSearch</innerclass>
    <innerclass refid="classgmx_1_1SelectionParserValue" prot="public">gmx::SelectionParserValue</innerclass>
    <innerclass refid="classgmx_1_1SelectionParserParameter" prot="public">gmx::SelectionParserParameter</innerclass>
    <innerclass refid="classgmx_1_1PositionCalculationCollection" prot="public">gmx::PositionCalculationCollection</innerclass>
    <innerclass refid="classgmx_1_1Selection" prot="public">gmx::Selection</innerclass>
    <innerclass refid="classgmx_1_1SelectionPosition" prot="public">gmx::SelectionPosition</innerclass>
    <innerclass refid="classgmx_1_1SelectionEvaluator" prot="public">gmx::SelectionEvaluator</innerclass>
    <innerclass refid="classgmx_1_1SelectionCollection" prot="public">gmx::SelectionCollection</innerclass>
    <innerclass refid="classgmx_1_1SelectionFileOption" prot="public">gmx::SelectionFileOption</innerclass>
    <innerclass refid="classgmx_1_1SelectionFileOptionInfo" prot="public">gmx::SelectionFileOptionInfo</innerclass>
    <innerclass refid="classgmx_1_1SelectionFileOptionStorage" prot="public">gmx::SelectionFileOptionStorage</innerclass>
    <innerclass refid="classgmx_1_1SelectionOption" prot="public">gmx::SelectionOption</innerclass>
    <innerclass refid="classgmx_1_1SelectionOptionInfo" prot="public">gmx::SelectionOptionInfo</innerclass>
    <innerclass refid="classgmx_1_1ITopologyProvider" prot="public">gmx::ITopologyProvider</innerclass>
    <innerclass refid="classgmx_1_1SelectionOptionBehavior" prot="public">gmx::SelectionOptionBehavior</innerclass>
    <innerclass refid="classgmx_1_1SelectionOptionManager" prot="public">gmx::SelectionOptionManager</innerclass>
    <innerclass refid="classgmx_1_1SelectionOptionStorage" prot="public">gmx::SelectionOptionStorage</innerclass>
    <innerclass refid="structgmx_1_1SelectionLocation" prot="public">gmx::SelectionLocation</innerclass>
    <innerclass refid="classgmx_1_1SelectionTreeElement" prot="public">gmx::SelectionTreeElement</innerclass>
    <innerclass refid="classgmx_1_1SelectionParserSymbol" prot="public">gmx::SelectionParserSymbol</innerclass>
    <innerclass refid="classgmx_1_1SelectionParserSymbolIterator" prot="public">gmx::SelectionParserSymbolIterator</innerclass>
    <innerclass refid="classgmx_1_1SelectionParserSymbolTable" prot="public">gmx::SelectionParserSymbolTable</innerclass>
    <innerclass refid="classgmx_1_1Simd4Double" prot="public">gmx::Simd4Double</innerclass>
    <innerclass refid="classgmx_1_1Simd4DBool" prot="public">gmx::Simd4DBool</innerclass>
    <innerclass refid="classgmx_1_1Simd4Float" prot="public">gmx::Simd4Float</innerclass>
    <innerclass refid="classgmx_1_1Simd4FBool" prot="public">gmx::Simd4FBool</innerclass>
    <innerclass refid="classgmx_1_1SimdDouble" prot="public">gmx::SimdDouble</innerclass>
    <innerclass refid="classgmx_1_1SimdDInt32" prot="public">gmx::SimdDInt32</innerclass>
    <innerclass refid="classgmx_1_1SimdDBool" prot="public">gmx::SimdDBool</innerclass>
    <innerclass refid="classgmx_1_1SimdDIBool" prot="public">gmx::SimdDIBool</innerclass>
    <innerclass refid="classgmx_1_1SimdFloat" prot="public">gmx::SimdFloat</innerclass>
    <innerclass refid="classgmx_1_1SimdFInt32" prot="public">gmx::SimdFInt32</innerclass>
    <innerclass refid="classgmx_1_1SimdFBool" prot="public">gmx::SimdFBool</innerclass>
    <innerclass refid="classgmx_1_1SimdFIBool" prot="public">gmx::SimdFIBool</innerclass>
    <innerclass refid="classgmx_1_1SimdLoadFProxyInternal" prot="public">gmx::SimdLoadFProxyInternal</innerclass>
    <innerclass refid="classgmx_1_1SimdLoadUFProxyInternal" prot="public">gmx::SimdLoadUFProxyInternal</innerclass>
    <innerclass refid="classgmx_1_1SimdLoadDProxyInternal" prot="public">gmx::SimdLoadDProxyInternal</innerclass>
    <innerclass refid="classgmx_1_1SimdLoadUDProxyInternal" prot="public">gmx::SimdLoadUDProxyInternal</innerclass>
    <innerclass refid="classgmx_1_1SimdLoadIProxyInternal" prot="public">gmx::SimdLoadIProxyInternal</innerclass>
    <innerclass refid="classgmx_1_1SimdLoadUIProxyInternal" prot="public">gmx::SimdLoadUIProxyInternal</innerclass>
    <innerclass refid="classgmx_1_1SimdSetZeroProxyInternal" prot="public">gmx::SimdSetZeroProxyInternal</innerclass>
    <innerclass refid="classgmx_1_1AtomsBuilder" prot="public">gmx::AtomsBuilder</innerclass>
    <innerclass refid="classgmx_1_1AtomsRemover" prot="public">gmx::AtomsRemover</innerclass>
    <innerclass refid="classgmx_1_1TrajectoryAnalysisModuleData" prot="public">gmx::TrajectoryAnalysisModuleData</innerclass>
    <innerclass refid="classgmx_1_1TrajectoryAnalysisModule" prot="public">gmx::TrajectoryAnalysisModule</innerclass>
    <innerclass refid="classgmx_1_1TrajectoryAnalysisSettings" prot="public">gmx::TrajectoryAnalysisSettings</innerclass>
    <innerclass refid="classgmx_1_1TopologyInformation" prot="public">gmx::TopologyInformation</innerclass>
    <innerclass refid="classgmx_1_1TrajectoryAnalysisCommandLineRunner" prot="public">gmx::TrajectoryAnalysisCommandLineRunner</innerclass>
    <innerclass refid="classgmx_1_1SurfaceAreaCalculator" prot="public">gmx::SurfaceAreaCalculator</innerclass>
    <innerclass refid="classgmx_1_1TrajectoryAnalysisRunnerCommon" prot="public">gmx::TrajectoryAnalysisRunnerCommon</innerclass>
    <innerclass refid="classgmx_1_1SelectionTester" prot="public">gmx::SelectionTester</innerclass>
    <innerclass refid="classgmx_1_1AlignedAllocator" prot="public">gmx::AlignedAllocator</innerclass>
    <innerclass refid="structgmx_1_1EmptyArrayRef" prot="public">gmx::EmptyArrayRef</innerclass>
    <innerclass refid="classgmx_1_1BinaryInformationSettings" prot="public">gmx::BinaryInformationSettings</innerclass>
    <innerclass refid="classgmx_1_1PrivateImplPointer" prot="public">gmx::PrivateImplPointer</innerclass>
    <innerclass refid="classgmx_1_1DataFileOptions" prot="public">gmx::DataFileOptions</innerclass>
    <innerclass refid="structgmx_1_1DataFileInfo" prot="public">gmx::DataFileInfo</innerclass>
    <innerclass refid="classgmx_1_1DataFileFinder" prot="public">gmx::DataFileFinder</innerclass>
    <innerclass refid="classgmx_1_1DirectoryEnumerator" prot="public">gmx::DirectoryEnumerator</innerclass>
    <innerclass refid="classgmx_1_1ExceptionInfo" prot="public">gmx::ExceptionInfo</innerclass>
    <innerclass refid="structgmx_1_1ThrowLocation" prot="public">gmx::ThrowLocation</innerclass>
    <innerclass refid="classgmx_1_1ExceptionInitializer" prot="public">gmx::ExceptionInitializer</innerclass>
    <innerclass refid="classgmx_1_1GromacsException" prot="public">gmx::GromacsException</innerclass>
    <innerclass refid="classgmx_1_1FileIOError" prot="public">gmx::FileIOError</innerclass>
    <innerclass refid="classgmx_1_1UserInputError" prot="public">gmx::UserInputError</innerclass>
    <innerclass refid="classgmx_1_1InvalidInputError" prot="public">gmx::InvalidInputError</innerclass>
    <innerclass refid="classgmx_1_1InconsistentInputError" prot="public">gmx::InconsistentInputError</innerclass>
    <innerclass refid="classgmx_1_1SimulationInstabilityError" prot="public">gmx::SimulationInstabilityError</innerclass>
    <innerclass refid="classgmx_1_1InternalError" prot="public">gmx::InternalError</innerclass>
    <innerclass refid="classgmx_1_1APIError" prot="public">gmx::APIError</innerclass>
    <innerclass refid="classgmx_1_1NotImplementedError" prot="public">gmx::NotImplementedError</innerclass>
    <innerclass refid="classgmx_1_1IFileInputRedirector" prot="public">gmx::IFileInputRedirector</innerclass>
    <innerclass refid="classgmx_1_1IFileOutputRedirector" prot="public">gmx::IFileOutputRedirector</innerclass>
    <innerclass refid="classgmx_1_1StandardInputStream" prot="public">gmx::StandardInputStream</innerclass>
    <innerclass refid="classgmx_1_1TextInputFile" prot="public">gmx::TextInputFile</innerclass>
    <innerclass refid="classgmx_1_1TextOutputFile" prot="public">gmx::TextOutputFile</innerclass>
    <innerclass refid="classgmx_1_1FlagsTemplate" prot="public">gmx::FlagsTemplate</innerclass>
    <innerclass refid="classgmx_1_1Regex" prot="public">gmx::Regex</innerclass>
    <innerclass refid="classgmx_1_1MessageStringCollector" prot="public">gmx::MessageStringCollector</innerclass>
    <innerclass refid="classgmx_1_1MessageStringContext" prot="public">gmx::MessageStringContext</innerclass>
    <innerclass refid="structgmx_1_1no__delete" prot="public">gmx::no_delete</innerclass>
    <innerclass refid="classgmx_1_1Path" prot="public">gmx::Path</innerclass>
    <innerclass refid="classgmx_1_1File" prot="public">gmx::File</innerclass>
    <innerclass refid="classgmx_1_1Directory" prot="public">gmx::Directory</innerclass>
    <innerclass refid="structgmx_1_1InstallationPrefixInfo" prot="public">gmx::InstallationPrefixInfo</innerclass>
    <innerclass refid="classgmx_1_1IProgramContext" prot="public">gmx::IProgramContext</innerclass>
    <innerclass refid="classgmx_1_1scoped__cptr" prot="public">gmx::scoped_cptr</innerclass>
    <innerclass refid="classgmx_1_1StringOutputStream" prot="public">gmx::StringOutputStream</innerclass>
    <innerclass refid="classgmx_1_1StringInputStream" prot="public">gmx::StringInputStream</innerclass>
    <innerclass refid="classgmx_1_1StringFormatter" prot="public">gmx::StringFormatter</innerclass>
    <innerclass refid="classgmx_1_1IdentityFormatter" prot="public">gmx::IdentityFormatter</innerclass>
    <innerclass refid="classgmx_1_1TextLineWrapperSettings" prot="public">gmx::TextLineWrapperSettings</innerclass>
    <innerclass refid="classgmx_1_1TextLineWrapper" prot="public">gmx::TextLineWrapper</innerclass>
    <innerclass refid="classgmx_1_1TextReader" prot="public">gmx::TextReader</innerclass>
    <innerclass refid="classgmx_1_1TextInputStream" prot="public">gmx::TextInputStream</innerclass>
    <innerclass refid="classgmx_1_1TextOutputStream" prot="public">gmx::TextOutputStream</innerclass>
    <innerclass refid="classgmx_1_1TextWriter" prot="public">gmx::TextWriter</innerclass>
    <innernamespace refid="namespacegmx_1_1analysismodules">gmx::analysismodules</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02analysismodule_8cpp_03">gmx::anonymous_namespace{analysismodule.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02arrayref_8cpp_03">gmx::anonymous_namespace{arrayref.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02autocorr_8cpp_03">gmx::anonymous_namespace{autocorr.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02cmdlinehelpcontext_8cpp_03">gmx::anonymous_namespace{cmdlinehelpcontext.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02cmdlinehelpmodule_8cpp_03">gmx::anonymous_namespace{cmdlinehelpmodule.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02cmdlinehelpwriter_8cpp_03">gmx::anonymous_namespace{cmdlinehelpwriter.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02cmdlineinit_8cpp_03">gmx::anonymous_namespace{cmdlineinit.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02cmdlinemodulemanager_8cpp_03">gmx::anonymous_namespace{cmdlinemodulemanager.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02cmdlineoptionsmodule_8cpp_03">gmx::anonymous_namespace{cmdlineoptionsmodule.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02cmdlineprogramcontext_8cpp_03">gmx::anonymous_namespace{cmdlineprogramcontext.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02cmdlinerunner_8cpp_03">gmx::anonymous_namespace{cmdlinerunner.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02coolstuff_8cpp_03">gmx::anonymous_namespace{coolstuff.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02cpuinfo_8cpp_03">gmx::anonymous_namespace{cpuinfo.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02errorcodes_8cpp_03">gmx::anonymous_namespace{errorcodes.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02exceptions_8cpp_03">gmx::anonymous_namespace{exceptions.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02expfit_8cpp_03">gmx::anonymous_namespace{expfit.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02exponentialdistribution_8cpp_03">gmx::anonymous_namespace{exponentialdistribution.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02filenameoption_8cpp_03">gmx::anonymous_namespace{filenameoption.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02filenameoptionmanager_8cpp_03">gmx::anonymous_namespace{filenameoptionmanager.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02fileredirector_8cpp_03">gmx::anonymous_namespace{fileredirector.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02filestream_8cpp_03">gmx::anonymous_namespace{filestream.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02futil_8cpp_03">gmx::anonymous_namespace{futil.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02gammadistribution_8cpp_03">gmx::anonymous_namespace{gammadistribution.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02hardwaretopology_8cpp_03">gmx::anonymous_namespace{hardwaretopology.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02helpwritercontext_8cpp_03">gmx::anonymous_namespace{helpwritercontext.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02histogram_8cpp_03">gmx::anonymous_namespace{histogram.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02init_8cpp_03">gmx::anonymous_namespace{init.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02insert-molecules_8cpp_03">gmx::anonymous_namespace{insert-molecules.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02modules_8cpp_03">gmx::anonymous_namespace{modules.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02nbsearch_8cpp_03">gmx::anonymous_namespace{nbsearch.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02normaldistribution_8cpp_03">gmx::anonymous_namespace{normaldistribution.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02optionsvisitor_8cpp_03">gmx::anonymous_namespace{optionsvisitor.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02pargs_8cpp_03">gmx::anonymous_namespace{pargs.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02programcontext_8cpp_03">gmx::anonymous_namespace{programcontext.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02pull_8cpp_03">gmx::anonymous_namespace{pull.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02rstparser_8cpp_03">gmx::anonymous_namespace{rstparser.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02seed_8cpp_03">gmx::anonymous_namespace{seed.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02selectioncollection_8cpp_03">gmx::anonymous_namespace{selectioncollection.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02selhelp_8cpp_03">gmx::anonymous_namespace{selhelp.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02shellcompletions_8cpp_03">gmx::anonymous_namespace{shellcompletions.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02stringutil_8cpp_03">gmx::anonymous_namespace{stringutil.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02tabulatednormaldistribution_8cpp_03">gmx::anonymous_namespace{tabulatednormaldistribution.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02tabulatednormaldistribution_8h_03">gmx::anonymous_namespace{tabulatednormaldistribution.h}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02threefry_8cpp_03">gmx::anonymous_namespace{threefry.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02timeunitmanager_8cpp_03">gmx::anonymous_namespace{timeunitmanager.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02uniformintdistribution_8cpp_03">gmx::anonymous_namespace{uniformintdistribution.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1anonymous__namespace_02uniformrealdistribution_8cpp_03">gmx::anonymous_namespace{uniformrealdistribution.cpp}</innernamespace>
    <innernamespace refid="namespacegmx_1_1internal">gmx::internal</innernamespace>
    <innernamespace refid="namespacegmx_1_1ocl">gmx::ocl</innernamespace>
    <innernamespace refid="namespacegmx_1_1test">gmx::test</innernamespace>
    <innernamespace refid="namespacegmx_1_1testing">gmx::testing</innernamespace>
      <sectiondef kind="user-defined">
      <header>Constant width-4 double precision SIMD types and instructions</header>
      <memberdef kind="function" id="group__module__simd_1ga66ff320228b17e4c9fbbb61c7acde2eb" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::load4</definition>
        <argsstring>(const double *m)</argsstring>
        <name>load4</name>
        <param>
          <type>const double *</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Load 4 double values from aligned memory into SIMD4 variable. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory aligned to 4 elements. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD4 variable with data loaded. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="131" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="131" bodyend="139"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gaf6c0b04d40ff74a4ad39c24f9fd3da20" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::store4</definition>
        <argsstring>(double *m, Simd4Double a)</argsstring>
        <name>store4</name>
        <param>
          <type>double *</type>
          <declname>m</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Store the contents of SIMD4 double to aligned memory m. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory, aligned to 4 elements. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD4 variable to store </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="147" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="147" bodyend="152"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga8e92b72e3e3a4f159180cf15da1889c8" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::load4U</definition>
        <argsstring>(const double *m)</argsstring>
        <name>load4U</name>
        <param>
          <type>const double *</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Load SIMD4 double from unaligned memory. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gacf774b2a886d1ed4149f825c50c8fec2" kindref="member">GMX_SIMD_HAVE_LOADU</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory, no alignment requirement. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD4 variable with data loaded. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="162" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="162" bodyend="167"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga61ae7be76c3865fcfe038dd2457a09cd" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::store4U</definition>
        <argsstring>(double *m, Simd4Double a)</argsstring>
        <name>store4U</name>
        <param>
          <type>double *</type>
          <declname>m</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Store SIMD4 double to unaligned memory. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga38ee3ad2fadedbafff3129df1e7c15b4" kindref="member">GMX_SIMD_HAVE_STOREU</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory, no alignment requirement. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD4 variable to store. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="177" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="177" bodyend="180"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gac88aa19e4c856c2333bf814c3521c488" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::simd4SetZeroD</definition>
        <argsstring>()</argsstring>
        <name>simd4SetZeroD</name>
        <briefdescription>
<para>Set all SIMD4 double elements to 0. </para>        </briefdescription>
        <detaileddescription>
<para>You should typically just call <ref refid="namespacegmx_1a1b9689c4629a14843a0464a0053c8e9e" kindref="member">gmx::setZero()</ref>, which uses proxy objects internally to handle all types rather than adding the suffix used here.</para><para><simplesect kind="return"><para>SIMD4 0.0 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="190" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="190" bodyend="193"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga0d555bbdc50b7b523ef3f0e6383808ef" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::operator&amp;</definition>
        <argsstring>(Simd4Double a, Simd4Double b)</argsstring>
        <name>operator&amp;</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Bitwise and for two SIMD4 double variables. </para>        </briefdescription>
        <detaileddescription>
<para>Supported if <ref refid="group__module__simd_1gaf002483e94d5f42de1d5105cf924f8b8" kindref="member">GMX_SIMD_HAVE_LOGICAL</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>data1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>data2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>data1 &amp; data2 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="205" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="205" bodyend="224"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga847080625fcb1aff7a1db138afd57222" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::andNot</definition>
        <argsstring>(Simd4Double a, Simd4Double b)</argsstring>
        <name>andNot</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Bitwise andnot for two SIMD4 double variables. c=(~a) &amp; b. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gaf002483e94d5f42de1d5105cf924f8b8" kindref="member">GMX_SIMD_HAVE_LOGICAL</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>data1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>data2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(~data1) &amp; data2 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="236" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="236" bodyend="255"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gabcaa9a287c021ad7e3507311ffe23497" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::operator|</definition>
        <argsstring>(Simd4Double a, Simd4Double b)</argsstring>
        <name>operator|</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Bitwise or for two SIMD4 doubles. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gaf002483e94d5f42de1d5105cf924f8b8" kindref="member">GMX_SIMD_HAVE_LOGICAL</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>data1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>data2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>data1 | data2 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="267" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="267" bodyend="286"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gaad7bb7baf5edd91a8707584c9cdc086e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::operator^</definition>
        <argsstring>(Simd4Double a, Simd4Double b)</argsstring>
        <name>operator^</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Bitwise xor for two SIMD4 double variables. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gaf002483e94d5f42de1d5105cf924f8b8" kindref="member">GMX_SIMD_HAVE_LOGICAL</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>data1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>data2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>data1 ^ data2 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="297" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="297" bodyend="316"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga07f6ab30b594fa03c4975bed7bffab81" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::operator+</definition>
        <argsstring>(Simd4Double a, Simd4Double b)</argsstring>
        <name>operator+</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Add two double SIMD4 variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>term1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>term2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a+b </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="325" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="325" bodyend="334"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gab08e1e219e78b06a60cc995ae663dbab" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::operator-</definition>
        <argsstring>(Simd4Double a, Simd4Double b)</argsstring>
        <name>operator-</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Subtract two SIMD4 variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>term1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>term2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a-b </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="343" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="343" bodyend="352"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga4b75b800db84a744c11534a41f3c08c6" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::operator-</definition>
        <argsstring>(Simd4Double a)</argsstring>
        <name>operator-</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>SIMD4 floating-point negate. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD4 floating-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>-a </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="360" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="360" bodyend="369"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga59d8295d88c9f60db412cb53eb47b768" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::operator*</definition>
        <argsstring>(Simd4Double a, Simd4Double b)</argsstring>
        <name>operator*</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Multiply two SIMD4 variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="378" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="378" bodyend="387"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga68d608d0650ac219cb4c0d3034ee855f" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::fma</definition>
        <argsstring>(Simd4Double a, Simd4Double b, Simd4Double c)</argsstring>
        <name>fma</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>SIMD4 Fused-multiply-add. Result is a*b+c. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b+c </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="397" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="397" bodyend="400"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga78a3204bd78e9122ba1998e985d1a5bd" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::fms</definition>
        <argsstring>(Simd4Double a, Simd4Double b, Simd4Double c)</argsstring>
        <name>fms</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>SIMD4 Fused-multiply-subtract. Result is a*b-c. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b-c </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="410" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="410" bodyend="413"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gae9ec59669729860c9efd1b9c70f3911b" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::fnma</definition>
        <argsstring>(Simd4Double a, Simd4Double b, Simd4Double c)</argsstring>
        <name>fnma</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>SIMD4 Fused-negated-multiply-add. Result is -a*b+c. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>-a*b+c </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="423" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="423" bodyend="426"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gac7afe2f2f840c1de18cb7c61917ba11c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::fnms</definition>
        <argsstring>(Simd4Double a, Simd4Double b, Simd4Double c)</argsstring>
        <name>fnms</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>SIMD4 Fused-negated-multiply-subtract. Result is -a*b-c. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>-a*b-c </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="436" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="436" bodyend="439"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga535ead71c3aeb4caaae55d6aefc78799" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::rsqrt</definition>
        <argsstring>(Simd4Double x)</argsstring>
        <name>rsqrt</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD4 1.0/sqrt(x) lookup. </para>        </briefdescription>
        <detaileddescription>
<para>This is a low-level instruction that should only be called from routines implementing the inverse square root in <ref refid="simd__math_8h" kindref="compound">simd_math.h</ref>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument, x&gt;0 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Approximation of 1/sqrt(x), accuracy is <ref refid="group__module__simd_1ga7e207d56564fc020b246563d09214aac" kindref="member">GMX_SIMD_RSQRT_BITS</ref>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="450" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="450" bodyend="460"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga9339c53d13a59e946834c14d565f1e18" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::abs</definition>
        <argsstring>(Simd4Double a)</argsstring>
        <name>abs</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>SIMD4 Floating-point <ref refid="group__module__simd_1ga9339c53d13a59e946834c14d565f1e18" kindref="member">abs()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>any floating point values </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>fabs(a) for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="469" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="469" bodyend="478"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga68bbfb58d0ab7d2362d0efde15c14ca3" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::max</definition>
        <argsstring>(Simd4Double a, Simd4Double b)</argsstring>
        <name>max</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Set each SIMD4 element to the largest from two variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>max(a,b) for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="487" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="487" bodyend="496"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gacf515651ecc6efcf3ec65a8ff488ea02" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::min</definition>
        <argsstring>(Simd4Double a, Simd4Double b)</argsstring>
        <name>min</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Set each SIMD4 element to the largest from two variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>max(a,b) for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="506" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="506" bodyend="515"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga3b425556720d8ff72c1998c86c777e75" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::round</definition>
        <argsstring>(Simd4Double a)</argsstring>
        <name>round</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>SIMD4 Round to nearest integer value (in floating-point format). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The nearest integer, represented in floating-point format. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="524" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="524" bodyend="533"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga4383bb9ab1055fc9888e65655db350ba" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::trunc</definition>
        <argsstring>(Simd4Double a)</argsstring>
        <name>trunc</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Truncate SIMD4, i.e. round towards zero - common hardware instruction. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Integer rounded towards zero, represented in floating-point format.</para></simplesect>
<simplesect kind="note"><para>This is truncation towards zero, not floor(). The reason for this is that truncation is virtually always present as a dedicated hardware instruction, but floor() frequently isn&apos;t. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="546" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="546" bodyend="555"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga48eb5014bfc9c6c43e9e21bf8c87ecc4" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double gmx_simdcall</type>
        <definition>static double gmx_simdcall gmx::dotProduct</definition>
        <argsstring>(Simd4Double a, Simd4Double b)</argsstring>
        <name>dotProduct</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Return dot product of two double precision SIMD4 variables. </para>        </briefdescription>
        <detaileddescription>
<para>The dot product is calculated between the first three elements in the two vectors, while the fourth is ignored. The result is returned as a scalar.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>vector1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>vector2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a[0]*b[0]+a[1]*b[1]+a[2]*b[2], returned as scalar. Last element is ignored. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="567" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="567" bodyend="573"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gaf7a690a2d884f1210349194e3c07a5a3" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::transpose</definition>
        <argsstring>(Simd4Double *v0, Simd4Double *v1, Simd4Double *v2, Simd4Double *v3)</argsstring>
        <name>transpose</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> *</type>
          <declname>v1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> *</type>
          <declname>v2</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> *</type>
          <declname>v3</declname>
        </param>
        <briefdescription>
<para>SIMD4 double transpose. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>Row 0 on input, column 0 on output </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>Row 1 on input, column 1 on output </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">v2</parametername>
</parameternamelist>
<parameterdescription>
<para>Row 2 on input, column 2 on output </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">v3</parametername>
</parameternamelist>
<parameterdescription>
<para>Row 3 on input, column 3 on output </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="583" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="583" bodyend="606"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga905fa4e11c1b9d4628ea5bdeeed3ca77" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4DBool" kindref="compound">Simd4DBool</ref> gmx_simdcall</type>
        <definition>static Simd4DBool gmx_simdcall gmx::operator==</definition>
        <argsstring>(Simd4Double a, Simd4Double b)</argsstring>
        <name>operator==</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>a==b for SIMD4 double </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>value1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>value2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Each element of the boolean will be set to true if a==b. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="615" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="615" bodyend="624"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga55e1d875f190a65651a57df761799027" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4DBool" kindref="compound">Simd4DBool</ref> gmx_simdcall</type>
        <definition>static Simd4DBool gmx_simdcall gmx::operator!=</definition>
        <argsstring>(Simd4Double a, Simd4Double b)</argsstring>
        <name>operator!=</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>a!=b for SIMD4 double </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>value1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>value2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Each element of the boolean will be set to true if a!=b. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="633" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="633" bodyend="642"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga161caa368bcf9f1d566b6bbb81b23a5f" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4DBool" kindref="compound">Simd4DBool</ref> gmx_simdcall</type>
        <definition>static Simd4DBool gmx_simdcall gmx::operator&lt;</definition>
        <argsstring>(Simd4Double a, Simd4Double b)</argsstring>
        <name>operator&lt;</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>a&lt;b for SIMD4 double </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>value1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>value2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Each element of the boolean will be set to true if a&lt;b. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="650" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="651" bodyend="660"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga65c76bc6290f217b5fce5d5538c5f342" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4DBool" kindref="compound">Simd4DBool</ref> gmx_simdcall</type>
        <definition>static Simd4DBool gmx_simdcall gmx::operator&lt;=</definition>
        <argsstring>(Simd4Double a, Simd4Double b)</argsstring>
        <name>operator&lt;=</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>a&lt;=b for SIMD4 double. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>value1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>value2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Each element of the boolean will be set to true if a&lt;=b. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="669" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="670" bodyend="679"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gaacd2b1a31c667bffa467f02e57b191e5" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4DBool" kindref="compound">Simd4DBool</ref> gmx_simdcall</type>
        <definition>static Simd4DBool gmx_simdcall gmx::operator&amp;&amp;</definition>
        <argsstring>(Simd4DBool a, Simd4DBool b)</argsstring>
        <name>operator&amp;&amp;</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4DBool" kindref="compound">Simd4DBool</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4DBool" kindref="compound">Simd4DBool</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Logical <emphasis>and</emphasis> on single precision SIMD4 booleans. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>logical vars 1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>logical vars 2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>For each element, the result boolean is true if a &amp; b are true.</para></simplesect>
<simplesect kind="note"><para>This is not necessarily a bitwise operation - the storage format of booleans is implementation-dependent. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="691" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="691" bodyend="700"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga5d5483d15fe15e3c3eaf1e4e90e53f90" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4DBool" kindref="compound">Simd4DBool</ref> gmx_simdcall</type>
        <definition>static Simd4DBool gmx_simdcall gmx::operator||</definition>
        <argsstring>(Simd4DBool a, Simd4DBool b)</argsstring>
        <name>operator||</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4DBool" kindref="compound">Simd4DBool</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4DBool" kindref="compound">Simd4DBool</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Logical <emphasis>or</emphasis> on single precision SIMD4 booleans. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>logical vars 1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>logical vars 2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>For each element, the result boolean is true if a or b is true.</para></simplesect>
Note that this is not necessarily a bitwise operation - the storage format of booleans is implementation-dependent. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="712" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="712" bodyend="721"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga314f00cbdc12d0615a873dff3bdd38db" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool gmx_simdcall</type>
        <definition>static bool gmx_simdcall gmx::anyTrue</definition>
        <argsstring>(Simd4DBool a)</argsstring>
        <name>anyTrue</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4DBool" kindref="compound">Simd4DBool</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns non-zero if any of the boolean in SIMD4 a is True, otherwise 0. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Logical variable. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if any element in a is true, otherwise false.</para></simplesect>
The actual return value for truth will depend on the architecture, so any non-zero value is considered truth. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="732" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="732" bodyend="741"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga223de776671702527c62b4da8f6e570a" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::selectByMask</definition>
        <argsstring>(Simd4Double a, Simd4DBool mask)</argsstring>
        <name>selectByMask</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4DBool" kindref="compound">Simd4DBool</ref></type>
          <declname>mask</declname>
        </param>
        <briefdescription>
<para>Select from single precision SIMD4 variable where boolean is true. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Floating-point variable to select from </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>For each element, a is selected for true, 0 for false. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="750" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="750" bodyend="759"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga388cbdee2056718a2d23b3080d4c9b84" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::selectByNotMask</definition>
        <argsstring>(Simd4Double a, Simd4DBool mask)</argsstring>
        <name>selectByNotMask</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4DBool" kindref="compound">Simd4DBool</ref></type>
          <declname>mask</declname>
        </param>
        <briefdescription>
<para>Select from single precision SIMD4 variable where boolean is false. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Floating-point variable to select from </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>For each element, a is selected for false, 0 for true (sic). </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="768" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="768" bodyend="777"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gafa1d01238ab3305ab17f301f73eaeaa1" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::blend</definition>
        <argsstring>(Simd4Double a, Simd4Double b, Simd4DBool sel)</argsstring>
        <name>blend</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4DBool" kindref="compound">Simd4DBool</ref></type>
          <declname>sel</declname>
        </param>
        <briefdescription>
<para>Vector-blend SIMD4 selection. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>First source </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Second source </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sel</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>For each element, select b if sel is true, a otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="788" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="788" bodyend="797"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga5ee526de5755cc7bb8d7c46c532483e4" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double gmx_simdcall</type>
        <definition>static double gmx_simdcall gmx::reduce</definition>
        <argsstring>(Simd4Double a)</argsstring>
        <name>reduce</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Return sum of all elements in SIMD4 double variable. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD4 variable to reduce/sum. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The sum of all elements in the argument variable. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" line="807" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_double.h" bodystart="807" bodyend="816"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Constant width-4 single precision SIMD types and instructions</header>
      <memberdef kind="function" id="group__module__simd_1ga0c25c98d5fca0e4c2294d775f75949f4" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::load4</definition>
        <argsstring>(const float *m)</argsstring>
        <name>load4</name>
        <param>
          <type>const float *</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Load 4 float values from aligned memory into SIMD4 variable. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory aligned to 4 elements. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD4 variable with data loaded. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="131" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="131" bodyend="139"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gafc95fcf592b08dfca9aabc44cf994ece" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::store4</definition>
        <argsstring>(float *m, Simd4Float a)</argsstring>
        <name>store4</name>
        <param>
          <type>float *</type>
          <declname>m</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Store the contents of SIMD4 float to aligned memory m. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory, aligned to 4 elements. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD4 variable to store </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="147" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="147" bodyend="152"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga30c2c73886641040a0f0d5c1f16da97d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::load4U</definition>
        <argsstring>(const float *m)</argsstring>
        <name>load4U</name>
        <param>
          <type>const float *</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Load SIMD4 float from unaligned memory. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gacf774b2a886d1ed4149f825c50c8fec2" kindref="member">GMX_SIMD_HAVE_LOADU</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory, no alignment requirement. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD4 variable with data loaded. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="162" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="162" bodyend="167"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga8a91843f00041c799a995535a7cdc12f" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::store4U</definition>
        <argsstring>(float *m, Simd4Float a)</argsstring>
        <name>store4U</name>
        <param>
          <type>float *</type>
          <declname>m</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Store SIMD4 float to unaligned memory. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga38ee3ad2fadedbafff3129df1e7c15b4" kindref="member">GMX_SIMD_HAVE_STOREU</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory, no alignment requirement. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD4 variable to store. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="177" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="177" bodyend="180"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gafa583e5ea332a308e773ad9422e0d080" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::simd4SetZeroF</definition>
        <argsstring>()</argsstring>
        <name>simd4SetZeroF</name>
        <briefdescription>
<para>Set all SIMD4 float elements to 0. </para>        </briefdescription>
        <detaileddescription>
<para>You should typically just call <ref refid="namespacegmx_1a1b9689c4629a14843a0464a0053c8e9e" kindref="member">gmx::setZero()</ref>, which uses proxy objects internally to handle all types rather than adding the suffix used here.</para><para><simplesect kind="return"><para>SIMD4 0.0 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="190" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="190" bodyend="193"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gab1b1d6f3300a808b8b3a3b516dd39b15" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::operator&amp;</definition>
        <argsstring>(Simd4Float a, Simd4Float b)</argsstring>
        <name>operator&amp;</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Bitwise and for two SIMD4 float variables. </para>        </briefdescription>
        <detaileddescription>
<para>Supported if <ref refid="group__module__simd_1gaf002483e94d5f42de1d5105cf924f8b8" kindref="member">GMX_SIMD_HAVE_LOGICAL</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>data1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>data2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>data1 &amp; data2 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="205" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="205" bodyend="224"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga4dfe3fded0fc0c151f918e6892603121" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::andNot</definition>
        <argsstring>(Simd4Float a, Simd4Float b)</argsstring>
        <name>andNot</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Bitwise andnot for two SIMD4 float variables. c=(~a) &amp; b. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gaf002483e94d5f42de1d5105cf924f8b8" kindref="member">GMX_SIMD_HAVE_LOGICAL</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>data1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>data2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(~data1) &amp; data2 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="236" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="236" bodyend="255"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gad759e852213903c61d6d4b9053e794fc" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::operator|</definition>
        <argsstring>(Simd4Float a, Simd4Float b)</argsstring>
        <name>operator|</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Bitwise or for two SIMD4 floats. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gaf002483e94d5f42de1d5105cf924f8b8" kindref="member">GMX_SIMD_HAVE_LOGICAL</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>data1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>data2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>data1 | data2 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="267" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="267" bodyend="286"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga8385ef4b8312eff3f715d2f817604e51" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::operator^</definition>
        <argsstring>(Simd4Float a, Simd4Float b)</argsstring>
        <name>operator^</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Bitwise xor for two SIMD4 float variables. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gaf002483e94d5f42de1d5105cf924f8b8" kindref="member">GMX_SIMD_HAVE_LOGICAL</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>data1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>data2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>data1 ^ data2 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="297" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="297" bodyend="316"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gafd943dd0c83fa26c6eb5805ad5025e17" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::operator+</definition>
        <argsstring>(Simd4Float a, Simd4Float b)</argsstring>
        <name>operator+</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Add two float SIMD4 variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>term1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>term2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a+b </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="325" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="325" bodyend="334"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gadb00887996b2ed9e672c7b556c53cb98" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::operator-</definition>
        <argsstring>(Simd4Float a, Simd4Float b)</argsstring>
        <name>operator-</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Subtract two SIMD4 variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>term1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>term2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a-b </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="343" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="343" bodyend="352"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gaad9353fb4bd3db4bb232f65d47a6abcf" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::operator-</definition>
        <argsstring>(Simd4Float a)</argsstring>
        <name>operator-</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>SIMD4 floating-point negate. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD4 floating-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>-a </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="360" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="360" bodyend="369"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga42f5e1c65d65ad34afa31b6d0e5f7c7b" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::operator*</definition>
        <argsstring>(Simd4Float a, Simd4Float b)</argsstring>
        <name>operator*</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Multiply two SIMD4 variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="378" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="378" bodyend="387"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gaa2db026253ce788e7f136326089e8a77" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::fma</definition>
        <argsstring>(Simd4Float a, Simd4Float b, Simd4Float c)</argsstring>
        <name>fma</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>SIMD4 Fused-multiply-add. Result is a*b+c. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b+c </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="397" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="397" bodyend="400"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gafb3861a4cc7cae530fcf5bf83955da1b" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::fms</definition>
        <argsstring>(Simd4Float a, Simd4Float b, Simd4Float c)</argsstring>
        <name>fms</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>SIMD4 Fused-multiply-subtract. Result is a*b-c. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b-c </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="410" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="410" bodyend="413"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gaaf4df87eca51bb2f57ffe0bcb1c9de02" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::fnma</definition>
        <argsstring>(Simd4Float a, Simd4Float b, Simd4Float c)</argsstring>
        <name>fnma</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>SIMD4 Fused-negated-multiply-add. Result is -a*b+c. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>-a*b+c </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="423" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="423" bodyend="426"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gace0a9be42a2c83de88e9de207cd82e80" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::fnms</definition>
        <argsstring>(Simd4Float a, Simd4Float b, Simd4Float c)</argsstring>
        <name>fnms</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>SIMD4 Fused-negated-multiply-subtract. Result is -a*b-c. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>-a*b-c </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="436" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="436" bodyend="439"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gaae4a6def215dcf244fcba8ba06eb1f26" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::rsqrt</definition>
        <argsstring>(Simd4Float x)</argsstring>
        <name>rsqrt</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD4 1.0/sqrt(x) lookup. </para>        </briefdescription>
        <detaileddescription>
<para>This is a low-level instruction that should only be called from routines implementing the inverse square root in <ref refid="simd__math_8h" kindref="compound">simd_math.h</ref>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument, x&gt;0 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Approximation of 1/sqrt(x), accuracy is <ref refid="group__module__simd_1ga7e207d56564fc020b246563d09214aac" kindref="member">GMX_SIMD_RSQRT_BITS</ref>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="450" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="450" bodyend="459"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga4555c730e6119f070664703072a7235c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::abs</definition>
        <argsstring>(Simd4Float a)</argsstring>
        <name>abs</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>SIMD4 Floating-point fabs(). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>any floating point values </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>fabs(a) for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="468" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="468" bodyend="477"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga3c66081dde9666200461f364725a4085" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::max</definition>
        <argsstring>(Simd4Float a, Simd4Float b)</argsstring>
        <name>max</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Set each SIMD4 element to the largest from two variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>max(a,b) for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="486" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="486" bodyend="495"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga2da2e85aea6a6eef4add06627566b8ab" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::min</definition>
        <argsstring>(Simd4Float a, Simd4Float b)</argsstring>
        <name>min</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Set each SIMD4 element to the largest from two variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>max(a,b) for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="505" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="505" bodyend="514"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gacf1bf91a0d1377886282a96f558798c8" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::round</definition>
        <argsstring>(Simd4Float a)</argsstring>
        <name>round</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>SIMD4 Round to nearest integer value (in floating-point format). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The nearest integer, represented in floating-point format. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="523" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="523" bodyend="532"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga97c12b8d0415b8633da6b48f437d6078" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::trunc</definition>
        <argsstring>(Simd4Float a)</argsstring>
        <name>trunc</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Truncate SIMD4, i.e. round towards zero - common hardware instruction. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Integer rounded towards zero, represented in floating-point format.</para></simplesect>
<simplesect kind="note"><para>This is truncation towards zero, not floor(). The reason for this is that truncation is virtually always present as a dedicated hardware instruction, but floor() frequently isn&apos;t. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="545" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="545" bodyend="554"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gac0420b0ba8ce5c0bbdf94d69c67ab563" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float gmx_simdcall</type>
        <definition>static float gmx_simdcall gmx::dotProduct</definition>
        <argsstring>(Simd4Float a, Simd4Float b)</argsstring>
        <name>dotProduct</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Return dot product of two single precision SIMD4 variables. </para>        </briefdescription>
        <detaileddescription>
<para>The dot product is calculated between the first three elements in the two vectors, while the fourth is ignored. The result is returned as a scalar.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>vector1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>vector2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a[0]*b[0]+a[1]*b[1]+a[2]*b[2], returned as scalar. Last element is ignored. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="566" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="566" bodyend="572"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga059f7a354565ad8c1494853ec9a00d3f" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::transpose</definition>
        <argsstring>(Simd4Float *v0, Simd4Float *v1, Simd4Float *v2, Simd4Float *v3)</argsstring>
        <name>transpose</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> *</type>
          <declname>v1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> *</type>
          <declname>v2</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> *</type>
          <declname>v3</declname>
        </param>
        <briefdescription>
<para>SIMD4 float transpose. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>Row 0 on input, column 0 on output </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>Row 1 on input, column 1 on output </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">v2</parametername>
</parameternamelist>
<parameterdescription>
<para>Row 2 on input, column 2 on output </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">v3</parametername>
</parameternamelist>
<parameterdescription>
<para>Row 3 on input, column 3 on output </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="582" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="582" bodyend="605"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gae817b7cf5e876f1c6357e14a4666a3c6" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4FBool" kindref="compound">Simd4FBool</ref> gmx_simdcall</type>
        <definition>static Simd4FBool gmx_simdcall gmx::operator==</definition>
        <argsstring>(Simd4Float a, Simd4Float b)</argsstring>
        <name>operator==</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>a==b for SIMD4 float </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>value1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>value2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Each element of the boolean will be set to true if a==b. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="614" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="614" bodyend="623"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gaabe89c1073d64ee649e9cd7b37c85e2e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4FBool" kindref="compound">Simd4FBool</ref> gmx_simdcall</type>
        <definition>static Simd4FBool gmx_simdcall gmx::operator!=</definition>
        <argsstring>(Simd4Float a, Simd4Float b)</argsstring>
        <name>operator!=</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>a!=b for SIMD4 float </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>value1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>value2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Each element of the boolean will be set to true if a!=b. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="632" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="632" bodyend="641"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gaf02163d0cb41985160b79503ef1d53d0" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4FBool" kindref="compound">Simd4FBool</ref> gmx_simdcall</type>
        <definition>static Simd4FBool gmx_simdcall gmx::operator&lt;</definition>
        <argsstring>(Simd4Float a, Simd4Float b)</argsstring>
        <name>operator&lt;</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>a&lt;b for SIMD4 float </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>value1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>value2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Each element of the boolean will be set to true if a&lt;b. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="649" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="650" bodyend="659"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga46491dc3239fcdcd48c55e00184c81ec" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4FBool" kindref="compound">Simd4FBool</ref> gmx_simdcall</type>
        <definition>static Simd4FBool gmx_simdcall gmx::operator&lt;=</definition>
        <argsstring>(Simd4Float a, Simd4Float b)</argsstring>
        <name>operator&lt;=</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>a&lt;=b for SIMD4 float. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>value1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>value2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Each element of the boolean will be set to true if a&lt;=b. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="668" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="669" bodyend="678"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gab72a2c3a96ed9681d4df89e38ec1583e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4FBool" kindref="compound">Simd4FBool</ref> gmx_simdcall</type>
        <definition>static Simd4FBool gmx_simdcall gmx::operator&amp;&amp;</definition>
        <argsstring>(Simd4FBool a, Simd4FBool b)</argsstring>
        <name>operator&amp;&amp;</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4FBool" kindref="compound">Simd4FBool</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4FBool" kindref="compound">Simd4FBool</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Logical <emphasis>and</emphasis> on single precision SIMD4 booleans. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>logical vars 1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>logical vars 2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>For each element, the result boolean is true if a &amp; b are true.</para></simplesect>
<simplesect kind="note"><para>This is not necessarily a bitwise operation - the storage format of booleans is implementation-dependent. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="690" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="690" bodyend="699"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gaf2ab4b4f3d3e7f6e9a012df64c1d9f3c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4FBool" kindref="compound">Simd4FBool</ref> gmx_simdcall</type>
        <definition>static Simd4FBool gmx_simdcall gmx::operator||</definition>
        <argsstring>(Simd4FBool a, Simd4FBool b)</argsstring>
        <name>operator||</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4FBool" kindref="compound">Simd4FBool</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4FBool" kindref="compound">Simd4FBool</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Logical <emphasis>or</emphasis> on single precision SIMD4 booleans. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>logical vars 1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>logical vars 2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>For each element, the result boolean is true if a or b is true.</para></simplesect>
Note that this is not necessarily a bitwise operation - the storage format of booleans is implementation-dependent. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="711" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="711" bodyend="720"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga5b8118b5d14f17aa83d64531e7793e4e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool gmx_simdcall</type>
        <definition>static bool gmx_simdcall gmx::anyTrue</definition>
        <argsstring>(Simd4FBool a)</argsstring>
        <name>anyTrue</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4FBool" kindref="compound">Simd4FBool</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns non-zero if any of the boolean in SIMD4 a is True, otherwise 0. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Logical variable. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if any element in a is true, otherwise false.</para></simplesect>
The actual return value for truth will depend on the architecture, so any non-zero value is considered truth. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="731" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="731" bodyend="740"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga76ed0866ac21967e0a9641acca32ab50" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::selectByMask</definition>
        <argsstring>(Simd4Float a, Simd4FBool mask)</argsstring>
        <name>selectByMask</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4FBool" kindref="compound">Simd4FBool</ref></type>
          <declname>mask</declname>
        </param>
        <briefdescription>
<para>Select from single precision SIMD4 variable where boolean is true. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Floating-point variable to select from </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>For each element, a is selected for true, 0 for false. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="749" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="749" bodyend="758"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gaaff9aa6673f42b4d0d4f3b154deac384" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::selectByNotMask</definition>
        <argsstring>(Simd4Float a, Simd4FBool mask)</argsstring>
        <name>selectByNotMask</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4FBool" kindref="compound">Simd4FBool</ref></type>
          <declname>mask</declname>
        </param>
        <briefdescription>
<para>Select from single precision SIMD4 variable where boolean is false. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Floating-point variable to select from </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>For each element, a is selected for false, 0 for true (sic). </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="767" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="767" bodyend="776"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga9a3c7493047defc21bf934ca9fc39476" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::blend</definition>
        <argsstring>(Simd4Float a, Simd4Float b, Simd4FBool sel)</argsstring>
        <name>blend</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4FBool" kindref="compound">Simd4FBool</ref></type>
          <declname>sel</declname>
        </param>
        <briefdescription>
<para>Vector-blend SIMD4 selection. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>First source </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Second source </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sel</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>For each element, select b if sel is true, a otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="787" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="787" bodyend="796"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga072c4a40acda5dbbd28687df84331335" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float gmx_simdcall</type>
        <definition>static float gmx_simdcall gmx::reduce</definition>
        <argsstring>(Simd4Float a)</argsstring>
        <name>reduce</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Return sum of all elements in SIMD4 float variable. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD4 variable to reduce/sum. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The sum of all elements in the argument variable. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" line="806" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd4_float.h" bodystart="806" bodyend="815"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>SIMD implementation load/store operations for double precision floating point</header>
      <memberdef kind="function" id="namespacegmx_1aca6f2a60f2104d5a19d51bf16fe4ecd2" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::simdLoad</definition>
        <argsstring>(const double *m)</argsstring>
        <name>simdLoad</name>
        <param>
          <type>const double *</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Load <ref refid="group__module__simd_1ga417e9d28b6310876bb2c69eb528c0a86" kindref="member">GMX_SIMD_DOUBLE_WIDTH</ref> numbers from aligned memory. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory aligned to the SIMD width. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD variable with data loaded. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="198" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="198" bodyend="206"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a9c1227e97a6084a280a611c2934c8ee1" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::store</definition>
        <argsstring>(double *m, SimdDouble a)</argsstring>
        <name>store</name>
        <param>
          <type>double *</type>
          <declname>m</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Store the contents of SIMD double variable to aligned memory m. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory, aligned to SIMD width. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD variable to store </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="214" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="214" bodyend="219"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ae4f7f04699111821557406cf7bfe75b9" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::simdLoadU</definition>
        <argsstring>(const double *m)</argsstring>
        <name>simdLoadU</name>
        <param>
          <type>const double *</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Load SIMD double from unaligned memory. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gacf774b2a886d1ed4149f825c50c8fec2" kindref="member">GMX_SIMD_HAVE_LOADU</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory, no alignment requirement. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD variable with data loaded. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="229" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="229" bodyend="234"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a9a8c867df8fe75511871290626c367ed" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::storeU</definition>
        <argsstring>(double *m, SimdDouble a)</argsstring>
        <name>storeU</name>
        <param>
          <type>double *</type>
          <declname>m</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Store SIMD double to unaligned memory. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga38ee3ad2fadedbafff3129df1e7c15b4" kindref="member">GMX_SIMD_HAVE_STOREU</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory, no alignment requirement. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD variable to store. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="244" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="244" bodyend="247"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a09dfcfeaf5bcd29a456e658026d65c01" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::setZeroD</definition>
        <argsstring>()</argsstring>
        <name>setZeroD</name>
        <briefdescription>
<para>Set all SIMD double variable elements to 0.0. </para>        </briefdescription>
        <detaileddescription>
<para>You should typically just call <ref refid="namespacegmx_1a1b9689c4629a14843a0464a0053c8e9e" kindref="member">gmx::setZero()</ref>, which uses proxy objects internally to handle all types rather than adding the suffix used here.</para><para><simplesect kind="return"><para>SIMD 0.0 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="257" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="257" bodyend="260"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>SIMD implementation load/store operations for integers (corresponding to double)</header>
      <memberdef kind="function" id="namespacegmx_1a0943da18bf332314bf2d524586c728e5" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref> gmx_simdcall</type>
        <definition>static SimdDInt32 gmx_simdcall gmx::simdLoadDI</definition>
        <argsstring>(const std::int32_t *m)</argsstring>
        <name>simdLoadDI</name>
        <param>
          <type>const std::int32_t *</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Load aligned SIMD integer data, width corresponds to <ref refid="classgmx_1_1SimdDouble" kindref="compound">gmx::SimdDouble</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>You should typically just call <ref refid="namespacegmx_1af6ad160249e7bc4726d93e89407c987e" kindref="member">gmx::load()</ref>, which uses proxy objects internally to handle all types rather than adding the suffix used here.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory, aligned to (double) integer SIMD width. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD integer variable. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="277" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="277" bodyend="285"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a4aef7840d04d5d9e2fabbc44445babad" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::store</definition>
        <argsstring>(std::int32_t *m, SimdDInt32 a)</argsstring>
        <name>store</name>
        <param>
          <type>std::int32_t *</type>
          <declname>m</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Store aligned SIMD integer data, width corresponds to <ref refid="classgmx_1_1SimdDouble" kindref="compound">gmx::SimdDouble</ref>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Memory aligned to (double) integer SIMD width. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD (double) integer variable to store. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="293" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="293" bodyend="298"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a236d2b76779fdbdf5e6e9e9c5dd00a6d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref> gmx_simdcall</type>
        <definition>static SimdDInt32 gmx_simdcall gmx::simdLoadUDI</definition>
        <argsstring>(const std::int32_t *m)</argsstring>
        <name>simdLoadUDI</name>
        <param>
          <type>const std::int32_t *</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Load unaligned integer SIMD data, width corresponds to <ref refid="classgmx_1_1SimdDouble" kindref="compound">gmx::SimdDouble</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>You should typically just call <ref refid="namespacegmx_1aac60a1e9bf9b5e7ae62895fb23311d99" kindref="member">gmx::loadU()</ref>, which uses proxy objects internally to handle all types rather than adding the suffix used here.</para><para>Available if <ref refid="group__module__simd_1gacf774b2a886d1ed4149f825c50c8fec2" kindref="member">GMX_SIMD_HAVE_LOADU</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory, no alignment requirements. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD integer variable. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="311" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="311" bodyend="316"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1abe60b257e28900c4cf3cc8c45a0d1d64" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::storeU</definition>
        <argsstring>(std::int32_t *m, SimdDInt32 a)</argsstring>
        <name>storeU</name>
        <param>
          <type>std::int32_t *</type>
          <declname>m</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Store unaligned SIMD integer data, width corresponds to <ref refid="classgmx_1_1SimdDouble" kindref="compound">gmx::SimdDouble</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga38ee3ad2fadedbafff3129df1e7c15b4" kindref="member">GMX_SIMD_HAVE_STOREU</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Memory pointer, no alignment requirements. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD (double) integer variable to store. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="326" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="326" bodyend="329"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a9b6fe2f4cd666b23f1c0e7aa8b0a31d0" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref> gmx_simdcall</type>
        <definition>static SimdDInt32 gmx_simdcall gmx::setZeroDI</definition>
        <argsstring>()</argsstring>
        <name>setZeroDI</name>
        <briefdescription>
<para>Set all SIMD (double) integer variable elements to 0. </para>        </briefdescription>
        <detaileddescription>
<para>You should typically just call <ref refid="namespacegmx_1a1b9689c4629a14843a0464a0053c8e9e" kindref="member">gmx::setZero()</ref>, which uses proxy objects internally to handle all types rather than adding the suffix used here.</para><para><simplesect kind="return"><para>SIMD 0 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="339" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="339" bodyend="342"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a3db712af1745296d49be276840062dee" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>index</declname>
            <defname>index</defname>
          </param>
        </templateparamlist>
        <type>std::int32_t gmx_simdcall</type>
        <definition>static std::int32_t gmx_simdcall gmx::extract</definition>
        <argsstring>(SimdDInt32 a)</argsstring>
        <name>extract</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Extract element with index i from <ref refid="classgmx_1_1SimdDInt32" kindref="compound">gmx::SimdDInt32</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gabae2f56a4d87b8e52b5df066888a4c07" kindref="member">GMX_SIMD_HAVE_DINT32_EXTRACT</ref> is 1.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>Compile-time constant, position to extract (first position is 0) </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD variable from which to extract value. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Single integer from position index in SIMD variable. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="354" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="354" bodyend="357"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>SIMD implementation double precision floating-point bitwise logical operations</header>
      <memberdef kind="function" id="namespacegmx_1a1f1cadff23a6ebe7ef211147359a3841" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::operator&amp;</definition>
        <argsstring>(SimdDouble a, SimdDouble b)</argsstring>
        <name>operator&amp;</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Bitwise and for two SIMD double variables. </para>        </briefdescription>
        <detaileddescription>
<para>Supported if <ref refid="group__module__simd_1gaf002483e94d5f42de1d5105cf924f8b8" kindref="member">GMX_SIMD_HAVE_LOGICAL</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>data1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>data2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>data1 &amp; data2 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="374" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="374" bodyend="393"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a374d7e1788f0ec4f2c5952d8d9ebdada" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::andNot</definition>
        <argsstring>(SimdDouble a, SimdDouble b)</argsstring>
        <name>andNot</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Bitwise andnot for SIMD double. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gaf002483e94d5f42de1d5105cf924f8b8" kindref="member">GMX_SIMD_HAVE_LOGICAL</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>data1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>data2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(~data1) &amp; data2 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="404" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="404" bodyend="423"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a72cbfbcd5395b355e242f2ef4284f5c5" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::operator|</definition>
        <argsstring>(SimdDouble a, SimdDouble b)</argsstring>
        <name>operator|</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Bitwise or for SIMD double. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gaf002483e94d5f42de1d5105cf924f8b8" kindref="member">GMX_SIMD_HAVE_LOGICAL</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>data1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>data2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>data1 | data2 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="434" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="434" bodyend="453"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ad65f7d7aa6d2a6c4b697ac0be0f3a616" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::operator^</definition>
        <argsstring>(SimdDouble a, SimdDouble b)</argsstring>
        <name>operator^</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Bitwise xor for SIMD double. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gaf002483e94d5f42de1d5105cf924f8b8" kindref="member">GMX_SIMD_HAVE_LOGICAL</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>data1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>data2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>data1 ^ data2 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="464" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="464" bodyend="483"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>SIMD implementation double precision floating-point arithmetics</header>
      <memberdef kind="function" id="namespacegmx_1a436c58e62a6941821532df1b75b4c99f" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::operator+</definition>
        <argsstring>(SimdDouble a, SimdDouble b)</argsstring>
        <name>operator+</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Add two double SIMD variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>term1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>term2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a+b </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="498" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="498" bodyend="507"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a97d6e522f43e9b9501d4c0c6b94ca6b9" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::operator-</definition>
        <argsstring>(SimdDouble a, SimdDouble b)</argsstring>
        <name>operator-</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Subtract two double SIMD variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>term1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>term2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a-b </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="516" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="516" bodyend="525"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aa0b76cf454d06f1d328d25b58135b570" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::operator-</definition>
        <argsstring>(SimdDouble a)</argsstring>
        <name>operator-</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>SIMD double precision negate. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD double precision value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>-a </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="533" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="533" bodyend="542"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a3a520d9799e6ece1f2446a51eee48ea4" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::operator*</definition>
        <argsstring>(SimdDouble a, SimdDouble b)</argsstring>
        <name>operator*</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Multiply two double SIMD variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="551" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="551" bodyend="560"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a3b86949473ebaef8ccbd4d2852947839" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::fma</definition>
        <argsstring>(SimdDouble a, SimdDouble b, SimdDouble c)</argsstring>
        <name>fma</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>SIMD double Fused-multiply-add. Result is a*b+c. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b+c </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="570" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="570" bodyend="573"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a86c14cb73d3484b0a5e01e74640a4ee3" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::fms</definition>
        <argsstring>(SimdDouble a, SimdDouble b, SimdDouble c)</argsstring>
        <name>fms</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>SIMD double Fused-multiply-subtract. Result is a*b-c. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b-c </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="583" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="583" bodyend="586"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aaeca5c242a059145a90dc091db78ad57" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::fnma</definition>
        <argsstring>(SimdDouble a, SimdDouble b, SimdDouble c)</argsstring>
        <name>fnma</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>SIMD double Fused-negated-multiply-add. Result is -a*b+c. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>-a*b+c </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="596" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="596" bodyend="599"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a44d26f7a7b8d6088d41be0b646f71543" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::fnms</definition>
        <argsstring>(SimdDouble a, SimdDouble b, SimdDouble c)</argsstring>
        <name>fnms</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>SIMD double Fused-negated-multiply-subtract. Result is -a*b-c. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>-a*b-c </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="609" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="609" bodyend="612"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1add1d990b3c0c841a88ea4e4d4df90425" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::rsqrt</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>rsqrt</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>double SIMD 1.0/sqrt(x) lookup. </para>        </briefdescription>
        <detaileddescription>
<para>This is a low-level instruction that should only be called from routines implementing the inverse square root in <ref refid="simd__math_8h" kindref="compound">simd_math.h</ref>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument, x&gt;0 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Approximation of 1/sqrt(x), accuracy is <ref refid="group__module__simd_1ga7e207d56564fc020b246563d09214aac" kindref="member">GMX_SIMD_RSQRT_BITS</ref>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="623" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="623" bodyend="633"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a4c2c3eae5c42d898373ec6e90dd99064" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::rcp</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>rcp</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD double 1.0/x lookup. </para>        </briefdescription>
        <detaileddescription>
<para>This is a low-level instruction that should only be called from routines implementing the reciprocal in <ref refid="simd__math_8h" kindref="compound">simd_math.h</ref>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument, x!=0 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Approximation of 1/x, accuracy is <ref refid="group__module__simd_1ga8b7a7c4421c0ce401b74c469a109e82c" kindref="member">GMX_SIMD_RCP_BITS</ref>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="644" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="644" bodyend="654"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1adab86e04bd62248ab68039d8983a9206" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::maskAdd</definition>
        <argsstring>(SimdDouble a, SimdDouble b, SimdDBool m)</argsstring>
        <name>maskAdd</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref></type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Add two double SIMD variables, masked version. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>term1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>term2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a+b where mask is true, 0.0 otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="664" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="664" bodyend="673"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1afb416d879be4463f38af9b670583fd65" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::maskzMul</definition>
        <argsstring>(SimdDouble a, SimdDouble b, SimdDBool m)</argsstring>
        <name>maskzMul</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref></type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Multiply two double SIMD variables, masked version. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b where mask is true, 0.0 otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="683" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="683" bodyend="692"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aaa689a6c17b1d60d62b6fcd51daa7639" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::maskzFma</definition>
        <argsstring>(SimdDouble a, SimdDouble b, SimdDouble c, SimdDBool m)</argsstring>
        <name>maskzFma</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>c</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref></type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>SIMD double fused multiply-add, masked version. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b+c where mask is true, 0.0 otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="703" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="703" bodyend="712"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a3bbc24d75706e7515afc2f2071f1a469" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::maskzRsqrt</definition>
        <argsstring>(SimdDouble x, SimdDBool m)</argsstring>
        <name>maskzRsqrt</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref></type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>SIMD double 1.0/sqrt(x) lookup, masked version. </para>        </briefdescription>
        <detaileddescription>
<para>This is a low-level instruction that should only be called from routines implementing the inverse square root in <ref refid="simd__math_8h" kindref="compound">simd_math.h</ref>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument, x&gt;0 for entries where mask is true. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Approximation of 1/sqrt(x), accuracy is <ref refid="group__module__simd_1ga7e207d56564fc020b246563d09214aac" kindref="member">GMX_SIMD_RSQRT_BITS</ref>. The result for masked-out entries will be 0.0. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="725" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="725" bodyend="735"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a0f425368efd0895189b0e11d4b5d4ccc" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::maskzRcp</definition>
        <argsstring>(SimdDouble x, SimdDBool m)</argsstring>
        <name>maskzRcp</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref></type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>SIMD double 1.0/x lookup, masked version. </para>        </briefdescription>
        <detaileddescription>
<para>This is a low-level instruction that should only be called from routines implementing the reciprocal in <ref refid="simd__math_8h" kindref="compound">simd_math.h</ref>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument, x&gt;0 for entries where mask is true. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Approximation of 1/x, accuracy is <ref refid="group__module__simd_1ga8b7a7c4421c0ce401b74c469a109e82c" kindref="member">GMX_SIMD_RCP_BITS</ref>. The result for masked-out entries will be 0.0. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="748" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="748" bodyend="757"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a7ccaa7e4df0a45208a4c316d8b71d01c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::abs</definition>
        <argsstring>(SimdDouble a)</argsstring>
        <name>abs</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>SIMD double floating-point fabs(). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>any floating point values </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>fabs(a) for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="765" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="765" bodyend="774"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aceb279f0a831efc0d8e6be7d96c9e6d2" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::max</definition>
        <argsstring>(SimdDouble a, SimdDouble b)</argsstring>
        <name>max</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Set each SIMD double element to the largest from two variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>max(a,b) for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="783" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="783" bodyend="792"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a48c0e6ede1542c0a5eee7094c56d51b2" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::min</definition>
        <argsstring>(SimdDouble a, SimdDouble b)</argsstring>
        <name>min</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Set each SIMD double element to the smallest from two variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>min(a,b) for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="801" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="801" bodyend="810"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ae99869398e453b11f1305a657ce8d886" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::round</definition>
        <argsstring>(SimdDouble a)</argsstring>
        <name>round</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>SIMD double round to nearest integer value (in floating-point format). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The nearest integer, represented in floating-point format. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="818" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="818" bodyend="827"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1acc9e911dbe1d9be0b86d8870a91b399c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::trunc</definition>
        <argsstring>(SimdDouble a)</argsstring>
        <name>trunc</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Truncate SIMD double, i.e. round towards zero - common hardware instruction. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Integer rounded towards zero, represented in floating-point format.</para></simplesect>
<simplesect kind="note"><para>This is truncation towards zero, not floor(). The reason for this is that truncation is virtually always present as a dedicated hardware instruction, but floor() frequently isn&apos;t. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="839" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="839" bodyend="848"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a93cd53cbf5857c1350814602d5e6418d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::frexp</definition>
        <argsstring>(SimdDouble value, SimdDInt32 *exponent)</argsstring>
        <name>frexp</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>value</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref> *</type>
          <declname>exponent</declname>
        </param>
        <briefdescription>
<para>Extract (integer) exponent and fraction from double precision SIMD. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>Floating-point value to extract from </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">exponent</parametername>
</parameternamelist>
<parameterdescription>
<para>Returned exponent of value, integer SIMD format. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Fraction of value, floating-point SIMD format. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="857" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="857" bodyend="866"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a86c665079d6936b82f5b7bc065dd13aa" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::ldexp</definition>
        <argsstring>(SimdDouble value, SimdDInt32 exponent)</argsstring>
        <name>ldexp</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>value</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>exponent</declname>
        </param>
        <briefdescription>
<para>Multiply a SIMD double value by the number 2 raised to an exp power. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>Floating-point number to multiply with new exponent </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>exponent</parametername>
</parameternamelist>
<parameterdescription>
<para>Integer that will not overflow as 2^exponent. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>value*2^exponent </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="875" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="875" bodyend="884"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a62d67c8b5c817dab3ee4acdd5779c14b" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double gmx_simdcall</type>
        <definition>static double gmx_simdcall gmx::reduce</definition>
        <argsstring>(SimdDouble a)</argsstring>
        <name>reduce</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Return sum of all elements in SIMD double variable. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD variable to reduce/sum. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The sum of all elements in the argument variable. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="893" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="893" bodyend="902"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>SIMD implementation double precision floating-point comparison, boolean, selection.</header>
      <memberdef kind="function" id="namespacegmx_1ad31f9caa693d0383acaf2b1b174ab0da" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref> gmx_simdcall</type>
        <definition>static SimdDBool gmx_simdcall gmx::operator==</definition>
        <argsstring>(SimdDouble a, SimdDouble b)</argsstring>
        <name>operator==</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SIMD a==b for double SIMD. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>value1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>value2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Each element of the boolean will be set to true if a==b.</para></simplesect>
Beware that exact floating-point comparisons are difficult. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="919" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="919" bodyend="928"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a9711191866c2d823326c3bab599914b9" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref> gmx_simdcall</type>
        <definition>static SimdDBool gmx_simdcall gmx::operator!=</definition>
        <argsstring>(SimdDouble a, SimdDouble b)</argsstring>
        <name>operator!=</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SIMD a!=b for double SIMD. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>value1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>value2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Each element of the boolean will be set to true if a!=b.</para></simplesect>
Beware that exact floating-point comparisons are difficult. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="939" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="939" bodyend="948"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ad8d93f6a684ac7c60b588ed9f7241b97" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref> gmx_simdcall</type>
        <definition>static SimdDBool gmx_simdcall gmx::operator&lt;</definition>
        <argsstring>(SimdDouble a, SimdDouble b)</argsstring>
        <name>operator&lt;</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SIMD a&lt;b for double SIMD. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>value1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>value2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Each element of the boolean will be set to true if a&lt;b. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="956" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="957" bodyend="966"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a2c82364af392a21816e7eedf1a086812" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref> gmx_simdcall</type>
        <definition>static SimdDBool gmx_simdcall gmx::operator&lt;=</definition>
        <argsstring>(SimdDouble a, SimdDouble b)</argsstring>
        <name>operator&lt;=</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SIMD a&lt;=b for double SIMD. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>value1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>value2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Each element of the boolean will be set to true if a&lt;=b. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="974" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="975" bodyend="984"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a5c87788b1cb09e4e6bfdf94f83f1ec76" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref> gmx_simdcall</type>
        <definition>static SimdDBool gmx_simdcall gmx::testBits</definition>
        <argsstring>(SimdDouble a)</argsstring>
        <name>testBits</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Return true if any bits are set in the single precision SIMD. </para>        </briefdescription>
        <detaileddescription>
<para>This function is used to handle bitmasks, mainly for exclusions in the inner kernels. Note that it will return true even for -0.0 (sign bit set), so it is not identical to not-equal.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Each element of the boolean will be true if any bit in a is nonzero. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="996" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="996" bodyend="1012"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1afccdf85d0ee6c0e8a8ca8070010cc268" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref> gmx_simdcall</type>
        <definition>static SimdDBool gmx_simdcall gmx::operator&amp;&amp;</definition>
        <argsstring>(SimdDBool a, SimdDBool b)</argsstring>
        <name>operator&amp;&amp;</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Logical <emphasis>and</emphasis> on double precision SIMD booleans. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>logical vars 1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>logical vars 2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>For each element, the result boolean is true if a &amp; b are true.</para></simplesect>
<simplesect kind="note"><para>This is not necessarily a bitwise operation - the storage format of booleans is implementation-dependent. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1024" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1024" bodyend="1033"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ad1da27c5bc4fd40afe78810c7b6e0730" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref> gmx_simdcall</type>
        <definition>static SimdDBool gmx_simdcall gmx::operator||</definition>
        <argsstring>(SimdDBool a, SimdDBool b)</argsstring>
        <name>operator||</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Logical <emphasis>or</emphasis> on double precision SIMD booleans. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>logical vars 1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>logical vars 2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>For each element, the result boolean is true if a or b is true.</para></simplesect>
Note that this is not necessarily a bitwise operation - the storage format of booleans is implementation-dependent.</para><para>\ </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1046" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1046" bodyend="1055"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aa6391860ba12e41a4a827077b6037f98" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool gmx_simdcall</type>
        <definition>static bool gmx_simdcall gmx::anyTrue</definition>
        <argsstring>(SimdDBool a)</argsstring>
        <name>anyTrue</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns non-zero if any of the boolean in SIMD a is True, otherwise 0. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Logical variable. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if any element in a is true, otherwise false.</para></simplesect>
The actual return value for truth will depend on the architecture, so any non-zero value is considered truth. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1066" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1066" bodyend="1075"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1adb2e8393818311d9b97ab723b8150e77" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::selectByMask</definition>
        <argsstring>(SimdDouble a, SimdDBool mask)</argsstring>
        <name>selectByMask</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref></type>
          <declname>mask</declname>
        </param>
        <briefdescription>
<para>Select from double precision SIMD variable where boolean is true. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Floating-point variable to select from </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>For each element, a is selected for true, 0 for false. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1084" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1084" bodyend="1093"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a2ad9dbb3900122823a8c86435335d3e6" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::selectByNotMask</definition>
        <argsstring>(SimdDouble a, SimdDBool mask)</argsstring>
        <name>selectByNotMask</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref></type>
          <declname>mask</declname>
        </param>
        <briefdescription>
<para>Select from double precision SIMD variable where boolean is false. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Floating-point variable to select from </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>For each element, a is selected for false, 0 for true (sic). </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1102" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1102" bodyend="1111"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aa089539a35e39d68f6c8b40421e0a68e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::blend</definition>
        <argsstring>(SimdDouble a, SimdDouble b, SimdDBool sel)</argsstring>
        <name>blend</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref></type>
          <declname>sel</declname>
        </param>
        <briefdescription>
<para>Vector-blend SIMD double selection. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>First source </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Second source </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sel</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>For each element, select b if sel is true, a otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1121" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1121" bodyend="1130"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>SIMD implementation integer (corresponding to double) bitwise logical operations</header>
      <memberdef kind="function" id="namespacegmx_1a34f3bd81d4cc0d29e1811642fcb320d6" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref> gmx_simdcall</type>
        <definition>static SimdDInt32 gmx_simdcall gmx::operator&lt;&lt;</definition>
        <argsstring>(SimdDInt32 a, int n)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>SIMD integer shift left logical, based on immediate value. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga0ccbae145ecb27cee3c98ec7bded1d45" kindref="member">GMX_SIMD_HAVE_DINT32_LOGICAL</ref> is 1.</para><para>Logical shift. Each element is shifted (independently) up to 32 positions left, while zeros are shifted in from the right.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>integer data to shift </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of positions to shift left. n&lt;=32. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>shifted values </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1149" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1150" bodyend="1159"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a574a9e9fc8c684d24234850bee75ce8e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref> gmx_simdcall</type>
        <definition>static SimdDInt32 gmx_simdcall gmx::operator&gt;&gt;</definition>
        <argsstring>(SimdDInt32 a, int n)</argsstring>
        <name>operator&gt;&gt;</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>SIMD integer shift right logical, based on immediate value. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga0ccbae145ecb27cee3c98ec7bded1d45" kindref="member">GMX_SIMD_HAVE_DINT32_LOGICAL</ref> is 1.</para><para>Logical shift. Each element is shifted (independently) up to 32 positions right, while zeros are shifted in from the left.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>integer data to shift </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of positions to shift right. n&lt;=32. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>shifted values </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1173" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1173" bodyend="1182"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a8db7e6183dba97097e0f1379c6368dad" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref> gmx_simdcall</type>
        <definition>static SimdDInt32 gmx_simdcall gmx::operator&amp;</definition>
        <argsstring>(SimdDInt32 a, SimdDInt32 b)</argsstring>
        <name>operator&amp;</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Integer SIMD bitwise and. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga0ccbae145ecb27cee3c98ec7bded1d45" kindref="member">GMX_SIMD_HAVE_DINT32_LOGICAL</ref> is 1.</para><para><simplesect kind="note"><para>You can <emphasis>not</emphasis> use this operation directly to select based on a boolean SIMD variable, since booleans are separate from integer SIMD. If that is what you need, have a look at <ref refid="group__module__simd_1ga223de776671702527c62b4da8f6e570a" kindref="member">gmx::selectByMask</ref> instead.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>first integer SIMD </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>second integer SIMD </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a &amp; b (bitwise and) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1197" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1197" bodyend="1206"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ae3ee5a899ca3b9e9aafd6fd6323537e0" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref> gmx_simdcall</type>
        <definition>static SimdDInt32 gmx_simdcall gmx::andNot</definition>
        <argsstring>(SimdDInt32 a, SimdDInt32 b)</argsstring>
        <name>andNot</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Integer SIMD bitwise not/complement. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga0ccbae145ecb27cee3c98ec7bded1d45" kindref="member">GMX_SIMD_HAVE_DINT32_LOGICAL</ref> is 1.</para><para><simplesect kind="note"><para>You can <emphasis>not</emphasis> use this operation directly to select based on a boolean SIMD variable, since booleans are separate from integer SIMD. If that is what you need, have a look at <ref refid="group__module__simd_1ga223de776671702527c62b4da8f6e570a" kindref="member">gmx::selectByMask</ref> instead.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>integer SIMD </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>integer SIMD </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(~a) &amp; b </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1221" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1221" bodyend="1230"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a65d3eb9cd43b33b4665dfe676c0e79d2" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref> gmx_simdcall</type>
        <definition>static SimdDInt32 gmx_simdcall gmx::operator|</definition>
        <argsstring>(SimdDInt32 a, SimdDInt32 b)</argsstring>
        <name>operator|</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Integer SIMD bitwise or. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga0ccbae145ecb27cee3c98ec7bded1d45" kindref="member">GMX_SIMD_HAVE_DINT32_LOGICAL</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>first integer SIMD </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>second integer SIMD </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a | b (bitwise or) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1241" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1241" bodyend="1250"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aba7ccd2477ecf6b07f5b7696d9490038" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref> gmx_simdcall</type>
        <definition>static SimdDInt32 gmx_simdcall gmx::operator^</definition>
        <argsstring>(SimdDInt32 a, SimdDInt32 b)</argsstring>
        <name>operator^</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Integer SIMD bitwise xor. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga0ccbae145ecb27cee3c98ec7bded1d45" kindref="member">GMX_SIMD_HAVE_DINT32_LOGICAL</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>first integer SIMD </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>second integer SIMD </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a ^ b (bitwise xor) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1261" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1261" bodyend="1270"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>SIMD implementation integer (corresponding to double) arithmetics</header>
      <memberdef kind="function" id="namespacegmx_1ae94ff177ebee1634f158cb0d7ff8b1a1" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref> gmx_simdcall</type>
        <definition>static SimdDInt32 gmx_simdcall gmx::operator+</definition>
        <argsstring>(SimdDInt32 a, SimdDInt32 b)</argsstring>
        <name>operator+</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Add SIMD integers. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gab8469202af6999f95405779355d89c30" kindref="member">GMX_SIMD_HAVE_DINT32_ARITHMETICS</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>term1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>term2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a+b </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1287" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1287" bodyend="1296"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a669d0b90b5b52a929462ae00735125c0" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref> gmx_simdcall</type>
        <definition>static SimdDInt32 gmx_simdcall gmx::operator-</definition>
        <argsstring>(SimdDInt32 a, SimdDInt32 b)</argsstring>
        <name>operator-</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Subtract SIMD integers. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gab8469202af6999f95405779355d89c30" kindref="member">GMX_SIMD_HAVE_DINT32_ARITHMETICS</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>term1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>term2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a-b </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1307" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1307" bodyend="1316"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1acc27ad2d3586f1a673bd0c9c1f344f4f" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref> gmx_simdcall</type>
        <definition>static SimdDInt32 gmx_simdcall gmx::operator*</definition>
        <argsstring>(SimdDInt32 a, SimdDInt32 b)</argsstring>
        <name>operator*</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Multiply SIMD integers. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gab8469202af6999f95405779355d89c30" kindref="member">GMX_SIMD_HAVE_DINT32_ARITHMETICS</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b.</para></simplesect>
<simplesect kind="note"><para>Only the low 32 bits are retained, so this can overflow. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1329" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1329" bodyend="1338"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>SIMD implementation integer (corresponding to double) comparisons, boolean selection</header>
      <memberdef kind="function" id="namespacegmx_1a2f054cf4aa61343e3a940b6d64939c5c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDIBool" kindref="compound">SimdDIBool</ref> gmx_simdcall</type>
        <definition>static SimdDIBool gmx_simdcall gmx::operator==</definition>
        <argsstring>(SimdDInt32 a, SimdDInt32 b)</argsstring>
        <name>operator==</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Equality comparison of two integers corresponding to double values. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gab8469202af6999f95405779355d89c30" kindref="member">GMX_SIMD_HAVE_DINT32_ARITHMETICS</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD integer1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD integer2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD integer boolean with true for elements where a==b </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1355" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1355" bodyend="1364"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a464359cf52613efaacad1cb0f39832bc" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDIBool" kindref="compound">SimdDIBool</ref> gmx_simdcall</type>
        <definition>static SimdDIBool gmx_simdcall gmx::operator&lt;</definition>
        <argsstring>(SimdDInt32 a, SimdDInt32 b)</argsstring>
        <name>operator&lt;</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Less-than comparison of two SIMD integers corresponding to double values. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gab8469202af6999f95405779355d89c30" kindref="member">GMX_SIMD_HAVE_DINT32_ARITHMETICS</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD integer1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD integer2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD integer boolean with true for elements where a&lt;b </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1374" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1375" bodyend="1384"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1af2ea05053a363baccc4a01d7d0bc137d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDIBool" kindref="compound">SimdDIBool</ref> gmx_simdcall</type>
        <definition>static SimdDIBool gmx_simdcall gmx::testBits</definition>
        <argsstring>(SimdDInt32 a)</argsstring>
        <name>testBits</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Check if any bit is set in each element. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gab8469202af6999f95405779355d89c30" kindref="member">GMX_SIMD_HAVE_DINT32_ARITHMETICS</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD integer </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD integer boolean with true for elements where any bit is set </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1394" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1394" bodyend="1403"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aae41bec54342cb6c56e395fab2ac3dc2" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDIBool" kindref="compound">SimdDIBool</ref> gmx_simdcall</type>
        <definition>static SimdDIBool gmx_simdcall gmx::operator&amp;&amp;</definition>
        <argsstring>(SimdDIBool a, SimdDIBool b)</argsstring>
        <name>operator&amp;&amp;</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDIBool" kindref="compound">SimdDIBool</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDIBool" kindref="compound">SimdDIBool</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Logical AND on <ref refid="classgmx_1_1SimdDIBool" kindref="compound">SimdDIBool</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gab8469202af6999f95405779355d89c30" kindref="member">GMX_SIMD_HAVE_DINT32_ARITHMETICS</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD boolean 1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD boolean 2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True for elements where both a and b are true. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1414" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1414" bodyend="1423"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a2382ca9a262a0503bb5dcfcec09df671" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDIBool" kindref="compound">SimdDIBool</ref> gmx_simdcall</type>
        <definition>static SimdDIBool gmx_simdcall gmx::operator||</definition>
        <argsstring>(SimdDIBool a, SimdDIBool b)</argsstring>
        <name>operator||</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDIBool" kindref="compound">SimdDIBool</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDIBool" kindref="compound">SimdDIBool</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Logical OR on <ref refid="classgmx_1_1SimdDIBool" kindref="compound">SimdDIBool</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gab8469202af6999f95405779355d89c30" kindref="member">GMX_SIMD_HAVE_DINT32_ARITHMETICS</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD boolean 1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD boolean 2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True for elements where both a and b are true. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1434" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1434" bodyend="1443"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a01b540961fe7e3f5aede8df5bba89237" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool gmx_simdcall</type>
        <definition>static bool gmx_simdcall gmx::anyTrue</definition>
        <argsstring>(SimdDIBool a)</argsstring>
        <name>anyTrue</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDIBool" kindref="compound">SimdDIBool</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns true if any of the boolean in x is True, otherwise 0. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gab8469202af6999f95405779355d89c30" kindref="member">GMX_SIMD_HAVE_DINT32_ARITHMETICS</ref> is 1.</para><para>The actual return value for &quot;any true&quot; will depend on the architecture. Any non-zero value should be considered truth.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD boolean </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if any of the elements in a is true, otherwise 0. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1456" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1456" bodyend="1465"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a41408567ca23cb56ace128e8fe0be4f4" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref> gmx_simdcall</type>
        <definition>static SimdDInt32 gmx_simdcall gmx::selectByMask</definition>
        <argsstring>(SimdDInt32 a, SimdDIBool mask)</argsstring>
        <name>selectByMask</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDIBool" kindref="compound">SimdDIBool</ref></type>
          <declname>mask</declname>
        </param>
        <briefdescription>
<para>Select from <ref refid="classgmx_1_1SimdDInt32" kindref="compound">gmx::SimdDInt32</ref> variable where boolean is true. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gab8469202af6999f95405779355d89c30" kindref="member">GMX_SIMD_HAVE_DINT32_ARITHMETICS</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD integer to select from </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Elements from a where sel is true, 0 otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1476" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1476" bodyend="1485"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a5465630a9899275f6ab90f2e0af66554" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref> gmx_simdcall</type>
        <definition>static SimdDInt32 gmx_simdcall gmx::selectByNotMask</definition>
        <argsstring>(SimdDInt32 a, SimdDIBool mask)</argsstring>
        <name>selectByNotMask</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDIBool" kindref="compound">SimdDIBool</ref></type>
          <declname>mask</declname>
        </param>
        <briefdescription>
<para>Select from <ref refid="classgmx_1_1SimdDInt32" kindref="compound">gmx::SimdDInt32</ref> variable where boolean is false. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gab8469202af6999f95405779355d89c30" kindref="member">GMX_SIMD_HAVE_DINT32_ARITHMETICS</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD integer to select from </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Elements from a where sel is false, 0 otherwise (sic). </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1496" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1496" bodyend="1505"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a897cd563974628f57a983656bc4f0be5" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref> gmx_simdcall</type>
        <definition>static SimdDInt32 gmx_simdcall gmx::blend</definition>
        <argsstring>(SimdDInt32 a, SimdDInt32 b, SimdDIBool sel)</argsstring>
        <name>blend</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDIBool" kindref="compound">SimdDIBool</ref></type>
          <declname>sel</declname>
        </param>
        <briefdescription>
<para>Vector-blend SIMD integer selection. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gab8469202af6999f95405779355d89c30" kindref="member">GMX_SIMD_HAVE_DINT32_ARITHMETICS</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>First source </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Second source </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sel</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>For each element, select b if sel is true, a otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1517" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1517" bodyend="1526"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>SIMD implementation conversion operations</header>
      <memberdef kind="function" id="namespacegmx_1ab44adfad19a5d4f810428dea125c2618" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref> gmx_simdcall</type>
        <definition>static SimdDInt32 gmx_simdcall gmx::cvtR2I</definition>
        <argsstring>(SimdDouble a)</argsstring>
        <name>cvtR2I</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Round double precision floating point to integer. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD floating-point </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD integer, rounded to nearest integer. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1540" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1540" bodyend="1549"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ac4adbb04ea5039d62805c3082368dd76" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref> gmx_simdcall</type>
        <definition>static SimdDInt32 gmx_simdcall gmx::cvttR2I</definition>
        <argsstring>(SimdDouble a)</argsstring>
        <name>cvttR2I</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Truncate double precision floating point to integer. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD floating-point </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD integer, truncated to nearest integer. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1557" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1557" bodyend="1566"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a97d21ad971c1efb6685f073f344590cc" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::cvtI2R</definition>
        <argsstring>(SimdDInt32 a)</argsstring>
        <name>cvtI2R</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Convert integer to double precision floating point. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD integer </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD floating-point </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1574" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1574" bodyend="1583"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a15023cda21995e0a86c76416fff7575e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDIBool" kindref="compound">SimdDIBool</ref> gmx_simdcall</type>
        <definition>static SimdDIBool gmx_simdcall gmx::cvtB2IB</definition>
        <argsstring>(SimdDBool a)</argsstring>
        <name>cvtB2IB</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Convert from double precision boolean to corresponding integer boolean. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD floating-point boolean </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD integer boolean </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1591" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1591" bodyend="1600"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1abb2ccc1aebc69073299a26c404fcf5ba" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref> gmx_simdcall</type>
        <definition>static SimdDBool gmx_simdcall gmx::cvtIB2B</definition>
        <argsstring>(SimdDIBool a)</argsstring>
        <name>cvtIB2B</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDIBool" kindref="compound">SimdDIBool</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Convert from integer boolean to corresponding double precision boolean. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD integer boolean </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD floating-point boolean </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1608" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1608" bodyend="1617"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a67d3b8f955282068904125585dfe4791" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::cvtF2D</definition>
        <argsstring>(SimdFloat f)</argsstring>
        <name>cvtF2D</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Convert SIMD float to double. </para>        </briefdescription>
        <detaileddescription>
<para>This version is available if <ref refid="group__module__simd_1gafdbf804a40bfa3dcb15bc50055e58e74" kindref="member">GMX_SIMD_FLOAT_WIDTH</ref> is identical to <ref refid="group__module__simd_1ga417e9d28b6310876bb2c69eb528c0a86" kindref="member">GMX_SIMD_DOUBLE_WIDTH</ref>.</para><para>Float/double conversions are complex since the SIMD width could either be different (e.g. on x86) or identical (e.g. IBM QPX). This means you will need to check for the width in the code, and have different code paths.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Single-precision SIMD variable </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Double-precision SIMD variable of the same width </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1632" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1632" bodyend="1644"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a8fb883892d82707c8c58f3ecb3d0f7a3" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::cvtD2F</definition>
        <argsstring>(SimdDouble d)</argsstring>
        <name>cvtD2F</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>Convert SIMD double to float. </para>        </briefdescription>
        <detaileddescription>
<para>This version is available if <ref refid="group__module__simd_1gafdbf804a40bfa3dcb15bc50055e58e74" kindref="member">GMX_SIMD_FLOAT_WIDTH</ref> is identical to <ref refid="group__module__simd_1ga417e9d28b6310876bb2c69eb528c0a86" kindref="member">GMX_SIMD_DOUBLE_WIDTH</ref>.</para><para>Float/double conversions are complex since the SIMD width could either be different (e.g. on x86) or identical (e.g. IBM QPX). This means you will need to check for the width in the code, and have different code paths.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>d</parametername>
</parameternamelist>
<parameterdescription>
<para>Double-precision SIMD variable </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Single-precision SIMD variable of the same width </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1659" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1659" bodyend="1671"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a1567e05e71a05d804c30ef65e66e9e96" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::cvtF2DD</definition>
        <argsstring>(SimdFloat f, SimdDouble *d0, SimdDouble *d1)</argsstring>
        <name>cvtF2DD</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>f</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>d0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>d1</declname>
        </param>
        <briefdescription>
<para>Convert SIMD float to double. </para>        </briefdescription>
        <detaileddescription>
<para>This version is available if <ref refid="group__module__simd_1gafdbf804a40bfa3dcb15bc50055e58e74" kindref="member">GMX_SIMD_FLOAT_WIDTH</ref> is twice as large as <ref refid="group__module__simd_1ga417e9d28b6310876bb2c69eb528c0a86" kindref="member">GMX_SIMD_DOUBLE_WIDTH</ref>.</para><para>Float/double conversions are complex since the SIMD width could either be different (e.g. on x86) or identical (e.g. IBM QPX). This means you will need to check for the width in the code, and have different code paths.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Single-precision SIMD variable </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">d0</parametername>
</parameternamelist>
<parameterdescription>
<para>Double-precision SIMD variable, first half of values from f. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">d1</parametername>
</parameternamelist>
<parameterdescription>
<para>Double-precision SIMD variable, second half of values from f. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1687" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1687" bodyend="1698"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a9cc129ae379b11a89f6f100b82dcecfa" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::cvtDD2F</definition>
        <argsstring>(SimdDouble d0, SimdDouble d1)</argsstring>
        <name>cvtDD2F</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>d0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>d1</declname>
        </param>
        <briefdescription>
<para>Convert SIMD double to float. </para>        </briefdescription>
        <detaileddescription>
<para>This version is available if <ref refid="group__module__simd_1gafdbf804a40bfa3dcb15bc50055e58e74" kindref="member">GMX_SIMD_FLOAT_WIDTH</ref> is twice as large as <ref refid="group__module__simd_1ga417e9d28b6310876bb2c69eb528c0a86" kindref="member">GMX_SIMD_DOUBLE_WIDTH</ref>.</para><para>Float/double conversions are complex since the SIMD width could either be different (e.g. on x86) or identical (e.g. IBM QPX). This means you will need to check for the width in the code, and have different code paths.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>d0</parametername>
</parameternamelist>
<parameterdescription>
<para>Double-precision SIMD variable, first half of values to put in f. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>d1</parametername>
</parameternamelist>
<parameterdescription>
<para>Double-precision SIMD variable, second half of values to put in f. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Single-precision SIMD variable with all values. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" line="1714" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_double.h" bodystart="1714" bodyend="1727"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ac552eafd6724baac337732185e7aab5b" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref> gmx_simdcall</type>
        <definition>static SimdFInt32 gmx_simdcall gmx::cvtR2I</definition>
        <argsstring>(SimdFloat a)</argsstring>
        <name>cvtR2I</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Round single precision floating point to integer. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD floating-point </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD integer, rounded to nearest integer. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1538" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1538" bodyend="1547"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a9ea0550c9f9a416bc631e091c2fcbb4e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref> gmx_simdcall</type>
        <definition>static SimdFInt32 gmx_simdcall gmx::cvttR2I</definition>
        <argsstring>(SimdFloat a)</argsstring>
        <name>cvttR2I</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Truncate single precision floating point to integer. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD floating-point </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD integer, truncated to nearest integer. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1555" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1555" bodyend="1564"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a4dcd41f15fc944cfda5f034cd3c4ecfb" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::cvtI2R</definition>
        <argsstring>(SimdFInt32 a)</argsstring>
        <name>cvtI2R</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Convert integer to single precision floating point. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD integer </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD floating-point </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1572" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1572" bodyend="1581"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ae297fc04e625ca46ca931b39c0c01603" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFIBool" kindref="compound">SimdFIBool</ref> gmx_simdcall</type>
        <definition>static SimdFIBool gmx_simdcall gmx::cvtB2IB</definition>
        <argsstring>(SimdFBool a)</argsstring>
        <name>cvtB2IB</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Convert from single precision boolean to corresponding integer boolean. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD floating-point boolean </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD integer boolean </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1589" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1589" bodyend="1598"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a05ffa14c31a2ddbc8edc180e65e3b25d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref> gmx_simdcall</type>
        <definition>static SimdFBool gmx_simdcall gmx::cvtIB2B</definition>
        <argsstring>(SimdFIBool a)</argsstring>
        <name>cvtIB2B</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFIBool" kindref="compound">SimdFIBool</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Convert from integer boolean to corresponding single precision boolean. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD integer boolean </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD floating-point boolean </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1606" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1606" bodyend="1615"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>SIMD implementation load/store operations for single precision floating point</header>
      <memberdef kind="function" id="namespacegmx_1af4e458ade067ee9a54638f2cfda3a156" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::simdLoad</definition>
        <argsstring>(const float *m)</argsstring>
        <name>simdLoad</name>
        <param>
          <type>const float *</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Load <ref refid="group__module__simd_1gafdbf804a40bfa3dcb15bc50055e58e74" kindref="member">GMX_SIMD_FLOAT_WIDTH</ref> float numbers from aligned memory. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory aligned to the SIMD width. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD variable with data loaded. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="194" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="194" bodyend="202"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a52f7df2355065163447397f980294447" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::store</definition>
        <argsstring>(float *m, SimdFloat a)</argsstring>
        <name>store</name>
        <param>
          <type>float *</type>
          <declname>m</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Store the contents of SIMD float variable to aligned memory m. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory, aligned to SIMD width. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD variable to store </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="210" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="210" bodyend="215"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a3f6db4291f0fb805ed63c168b34b12e7" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::simdLoadU</definition>
        <argsstring>(const float *m)</argsstring>
        <name>simdLoadU</name>
        <param>
          <type>const float *</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Load SIMD float from unaligned memory. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gacf774b2a886d1ed4149f825c50c8fec2" kindref="member">GMX_SIMD_HAVE_LOADU</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory, no alignment requirement. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD variable with data loaded. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="225" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="225" bodyend="230"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a78a753ce93218a4e83f9733c66a48020" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::storeU</definition>
        <argsstring>(float *m, SimdFloat a)</argsstring>
        <name>storeU</name>
        <param>
          <type>float *</type>
          <declname>m</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Store SIMD float to unaligned memory. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga38ee3ad2fadedbafff3129df1e7c15b4" kindref="member">GMX_SIMD_HAVE_STOREU</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory, no alignment requirement. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD variable to store. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="240" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="240" bodyend="243"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aaeabcbecb3158411b57502164c854a31" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::setZeroF</definition>
        <argsstring>()</argsstring>
        <name>setZeroF</name>
        <briefdescription>
<para>Set all SIMD float variable elements to 0.0. </para>        </briefdescription>
        <detaileddescription>
<para>You should typically just call <ref refid="namespacegmx_1a1b9689c4629a14843a0464a0053c8e9e" kindref="member">gmx::setZero()</ref>, which uses proxy objects internally to handle all types rather than adding the suffix used here.</para><para><simplesect kind="return"><para>SIMD 0.0f </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="253" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="253" bodyend="256"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>SIMD implementation load/store operations for integers (corresponding to float)</header>
      <memberdef kind="function" id="namespacegmx_1a8b416215a20a73aff5fa5808c448811e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref> gmx_simdcall</type>
        <definition>static SimdFInt32 gmx_simdcall gmx::simdLoadFI</definition>
        <argsstring>(const std::int32_t *m)</argsstring>
        <name>simdLoadFI</name>
        <param>
          <type>const std::int32_t *</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Load aligned SIMD integer data, width corresponds to <ref refid="classgmx_1_1SimdFloat" kindref="compound">gmx::SimdFloat</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>You should typically just call <ref refid="namespacegmx_1af6ad160249e7bc4726d93e89407c987e" kindref="member">gmx::load()</ref>, which uses proxy objects internally to handle all types rather than adding the suffix used here.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory, aligned to (float) integer SIMD width. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD integer variable. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="275" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="275" bodyend="283"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a05b56e14f8499393813cb23869a97a98" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::store</definition>
        <argsstring>(std::int32_t *m, SimdFInt32 a)</argsstring>
        <name>store</name>
        <param>
          <type>std::int32_t *</type>
          <declname>m</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Store aligned SIMD integer data, width corresponds to <ref refid="classgmx_1_1SimdFloat" kindref="compound">gmx::SimdFloat</ref>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Memory aligned to (float) integer SIMD width. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD variable to store. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="291" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="291" bodyend="296"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a37e5f3b6be0b2d544f0239939a775f91" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref> gmx_simdcall</type>
        <definition>static SimdFInt32 gmx_simdcall gmx::simdLoadUFI</definition>
        <argsstring>(const std::int32_t *m)</argsstring>
        <name>simdLoadUFI</name>
        <param>
          <type>const std::int32_t *</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Load unaligned integer SIMD data, width corresponds to <ref refid="classgmx_1_1SimdFloat" kindref="compound">gmx::SimdFloat</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>You should typically just call <ref refid="namespacegmx_1aac60a1e9bf9b5e7ae62895fb23311d99" kindref="member">gmx::loadU()</ref>, which uses proxy objects internally to handle all types rather than adding the suffix used here.</para><para>Available if <ref refid="group__module__simd_1gacf774b2a886d1ed4149f825c50c8fec2" kindref="member">GMX_SIMD_HAVE_LOADU</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory, no alignment requirements. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD integer variable. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="309" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="309" bodyend="314"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a849eec56bc26a1d99f3f198fc9a9cba5" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::storeU</definition>
        <argsstring>(std::int32_t *m, SimdFInt32 a)</argsstring>
        <name>storeU</name>
        <param>
          <type>std::int32_t *</type>
          <declname>m</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Store unaligned SIMD integer data, width corresponds to <ref refid="classgmx_1_1SimdFloat" kindref="compound">gmx::SimdFloat</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga38ee3ad2fadedbafff3129df1e7c15b4" kindref="member">GMX_SIMD_HAVE_STOREU</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Memory pointer, no alignment requirements. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD variable to store. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="324" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="324" bodyend="327"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a52eac01d95edbe3b448fc447832a5d3c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref> gmx_simdcall</type>
        <definition>static SimdFInt32 gmx_simdcall gmx::setZeroFI</definition>
        <argsstring>()</argsstring>
        <name>setZeroFI</name>
        <briefdescription>
<para>Set all SIMD (float) integer variable elements to 0. </para>        </briefdescription>
        <detaileddescription>
<para>You should typically just call <ref refid="namespacegmx_1a1b9689c4629a14843a0464a0053c8e9e" kindref="member">gmx::setZero()</ref>, which uses proxy objects internally to handle all types rather than adding the suffix used here.</para><para><simplesect kind="return"><para>SIMD 0 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="337" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="337" bodyend="340"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a48a0504dfe392db42fd419cd80ea7d9a" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>index</declname>
            <defname>index</defname>
          </param>
        </templateparamlist>
        <type>std::int32_t gmx_simdcall</type>
        <definition>static std::int32_t gmx_simdcall gmx::extract</definition>
        <argsstring>(SimdFInt32 a)</argsstring>
        <name>extract</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Extract element with index i from <ref refid="classgmx_1_1SimdFInt32" kindref="compound">gmx::SimdFInt32</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga23ac53a0050467ac215f146f6afc6380" kindref="member">GMX_SIMD_HAVE_FINT32_EXTRACT</ref> is 1.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>Compile-time constant, position to extract (first position is 0) </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD variable from which to extract value. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Single integer from position index in SIMD variable. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="352" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="352" bodyend="355"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>SIMD implementation single precision floating-point bitwise logical operations</header>
      <memberdef kind="function" id="namespacegmx_1a4093d368f060b40d9a9dee083b33411c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::operator&amp;</definition>
        <argsstring>(SimdFloat a, SimdFloat b)</argsstring>
        <name>operator&amp;</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Bitwise and for two SIMD float variables. </para>        </briefdescription>
        <detaileddescription>
<para>Supported if <ref refid="group__module__simd_1gaf002483e94d5f42de1d5105cf924f8b8" kindref="member">GMX_SIMD_HAVE_LOGICAL</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>data1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>data2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>data1 &amp; data2 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="372" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="372" bodyend="391"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a621b6d4eb9d2d992b07f7bc515dad46d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::andNot</definition>
        <argsstring>(SimdFloat a, SimdFloat b)</argsstring>
        <name>andNot</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Bitwise andnot for SIMD float. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gaf002483e94d5f42de1d5105cf924f8b8" kindref="member">GMX_SIMD_HAVE_LOGICAL</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>data1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>data2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(~data1) &amp; data2 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="402" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="402" bodyend="421"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a69973d1808eb0e8e60715d3abf01cd22" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::operator|</definition>
        <argsstring>(SimdFloat a, SimdFloat b)</argsstring>
        <name>operator|</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Bitwise or for SIMD float. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gaf002483e94d5f42de1d5105cf924f8b8" kindref="member">GMX_SIMD_HAVE_LOGICAL</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>data1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>data2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>data1 | data2 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="432" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="432" bodyend="451"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a37544015fbce9d2b11dce07e159e878b" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::operator^</definition>
        <argsstring>(SimdFloat a, SimdFloat b)</argsstring>
        <name>operator^</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Bitwise xor for SIMD float. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1gaf002483e94d5f42de1d5105cf924f8b8" kindref="member">GMX_SIMD_HAVE_LOGICAL</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>data1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>data2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>data1 ^ data2 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="462" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="462" bodyend="481"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>SIMD implementation single precision floating-point arithmetics</header>
      <memberdef kind="function" id="namespacegmx_1aebe772c4714b2ce0f9a70c7fbbc01f98" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::operator+</definition>
        <argsstring>(SimdFloat a, SimdFloat b)</argsstring>
        <name>operator+</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Add two float SIMD variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>term1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>term2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a+b </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="496" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="496" bodyend="505"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ae00e0dcf36832ed7c591e1204dd9dcc8" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::operator-</definition>
        <argsstring>(SimdFloat a, SimdFloat b)</argsstring>
        <name>operator-</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Subtract two float SIMD variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>term1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>term2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a-b </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="514" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="514" bodyend="523"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ae409460fda30359c437522eca447e24e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::operator-</definition>
        <argsstring>(SimdFloat a)</argsstring>
        <name>operator-</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>SIMD single precision negate. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD double precision value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>-a </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="531" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="531" bodyend="540"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a51972cf72cc64e7d4ec87e53d4b25376" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::operator*</definition>
        <argsstring>(SimdFloat a, SimdFloat b)</argsstring>
        <name>operator*</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Multiply two float SIMD variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="549" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="549" bodyend="558"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a6969c0baf1592d7a5fec29636a85628f" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::fma</definition>
        <argsstring>(SimdFloat a, SimdFloat b, SimdFloat c)</argsstring>
        <name>fma</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>SIMD float Fused-multiply-add. Result is a*b+c. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b+c </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="568" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="568" bodyend="571"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a075eeabb5171e4f74cdd74e2f97bab5c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::fms</definition>
        <argsstring>(SimdFloat a, SimdFloat b, SimdFloat c)</argsstring>
        <name>fms</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>SIMD float Fused-multiply-subtract. Result is a*b-c. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b-c </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="581" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="581" bodyend="584"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a6be2e3e5adbdf49e6468c8a2d638658d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::fnma</definition>
        <argsstring>(SimdFloat a, SimdFloat b, SimdFloat c)</argsstring>
        <name>fnma</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>SIMD float Fused-negated-multiply-add. Result is -a*b+c. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>-a*b+c </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="594" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="594" bodyend="597"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1af8fe2e25414c377f8ed03d5c23f84963" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::fnms</definition>
        <argsstring>(SimdFloat a, SimdFloat b, SimdFloat c)</argsstring>
        <name>fnms</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>SIMD float Fused-negated-multiply-subtract. Result is -a*b-c. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>-a*b-c </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="607" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="607" bodyend="610"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a611e17e307050f3a78e3390a5e63c460" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::rsqrt</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>rsqrt</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float 1.0/sqrt(x) lookup. </para>        </briefdescription>
        <detaileddescription>
<para>This is a low-level instruction that should only be called from routines implementing the inverse square root in <ref refid="simd__math_8h" kindref="compound">simd_math.h</ref>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument, x&gt;0 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Approximation of 1/sqrt(x), accuracy is <ref refid="group__module__simd_1ga7e207d56564fc020b246563d09214aac" kindref="member">GMX_SIMD_RSQRT_BITS</ref>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="621" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="621" bodyend="630"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a48cb29271cf7ac44a06cfe20e5c29dc2" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::rcp</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>rcp</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float 1.0/x lookup. </para>        </briefdescription>
        <detaileddescription>
<para>This is a low-level instruction that should only be called from routines implementing the reciprocal in <ref refid="simd__math_8h" kindref="compound">simd_math.h</ref>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument, x!=0 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Approximation of 1/x, accuracy is <ref refid="group__module__simd_1ga8b7a7c4421c0ce401b74c469a109e82c" kindref="member">GMX_SIMD_RCP_BITS</ref>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="641" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="641" bodyend="650"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a766a313a4a158cfcb0eed0373dd82dfc" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::maskAdd</definition>
        <argsstring>(SimdFloat a, SimdFloat b, SimdFBool m)</argsstring>
        <name>maskAdd</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref></type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Add two float SIMD variables, masked version. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>term1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>term2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a+b where mask is true, a otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="660" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="660" bodyend="669"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aa732ce9ab59cca63f834923a8cb4c775" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::maskzMul</definition>
        <argsstring>(SimdFloat a, SimdFloat b, SimdFBool m)</argsstring>
        <name>maskzMul</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref></type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Multiply two float SIMD variables, masked version. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b where mask is true, 0.0 otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="679" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="679" bodyend="688"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ac21c886b9883657fd67d8b48e784af2d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::maskzFma</definition>
        <argsstring>(SimdFloat a, SimdFloat b, SimdFloat c, SimdFBool m)</argsstring>
        <name>maskzFma</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>c</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref></type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>SIMD float fused multiply-add, masked version. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b+c where mask is true, 0.0 otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="699" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="699" bodyend="708"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a6eb1ba8851b08ceea1c160b6b255ee9b" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::maskzRsqrt</definition>
        <argsstring>(SimdFloat x, SimdFBool m)</argsstring>
        <name>maskzRsqrt</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref></type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>SIMD float 1.0/sqrt(x) lookup, masked version. </para>        </briefdescription>
        <detaileddescription>
<para>This is a low-level instruction that should only be called from routines implementing the inverse square root in <ref refid="simd__math_8h" kindref="compound">simd_math.h</ref>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument, x&gt;0 for entries where mask is true. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Approximation of 1/sqrt(x), accuracy is <ref refid="group__module__simd_1ga7e207d56564fc020b246563d09214aac" kindref="member">GMX_SIMD_RSQRT_BITS</ref>. The result for masked-out entries will be 0.0. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="721" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="721" bodyend="730"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1abda785f716b1445f709fc7aa028c0589" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::maskzRcp</definition>
        <argsstring>(SimdFloat x, SimdFBool m)</argsstring>
        <name>maskzRcp</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref></type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>SIMD float 1.0/x lookup, masked version. </para>        </briefdescription>
        <detaileddescription>
<para>This is a low-level instruction that should only be called from routines implementing the reciprocal in <ref refid="simd__math_8h" kindref="compound">simd_math.h</ref>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument, x&gt;0 for entries where mask is true. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Approximation of 1/x, accuracy is <ref refid="group__module__simd_1ga8b7a7c4421c0ce401b74c469a109e82c" kindref="member">GMX_SIMD_RCP_BITS</ref>. The result for masked-out entries will be 0.0. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="743" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="743" bodyend="752"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ad59e3c65fd7e52438579b9ea98edefba" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::abs</definition>
        <argsstring>(SimdFloat a)</argsstring>
        <name>abs</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>SIMD float Floating-point <ref refid="group__module__simd_1ga9339c53d13a59e946834c14d565f1e18" kindref="member">abs()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>any floating point values </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>abs(a) for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="760" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="760" bodyend="769"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a4edeef3c458f5c77cf3ceb80532a57ff" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::max</definition>
        <argsstring>(SimdFloat a, SimdFloat b)</argsstring>
        <name>max</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Set each SIMD float element to the largest from two variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>max(a,b) for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="778" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="778" bodyend="787"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a66c497c1f66c2aaccafefdfdeaf6ce2f" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::min</definition>
        <argsstring>(SimdFloat a, SimdFloat b)</argsstring>
        <name>min</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Set each SIMD float element to the smallest from two variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>min(a,b) for each element. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="796" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="796" bodyend="805"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a3ef18bc7373b1450c963374f72d472e4" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::round</definition>
        <argsstring>(SimdFloat a)</argsstring>
        <name>round</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>SIMD float round to nearest integer value (in floating-point format). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The nearest integer, represented in floating-point format. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="813" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="813" bodyend="822"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a03c0d9c75faf734c06f162e92e56f5f7" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::trunc</definition>
        <argsstring>(SimdFloat a)</argsstring>
        <name>trunc</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Truncate SIMD float, i.e. round towards zero - common hardware instruction. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Integer rounded towards zero, represented in floating-point format.</para></simplesect>
<simplesect kind="note"><para>This is truncation towards zero, not floor(). The reason for this is that truncation is virtually always present as a dedicated hardware instruction, but floor() frequently isn&apos;t. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="834" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="834" bodyend="843"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a25fcdea880b577ac51ac92b915fd89e7" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::frexp</definition>
        <argsstring>(SimdFloat value, SimdFInt32 *exponent)</argsstring>
        <name>frexp</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>value</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref> *</type>
          <declname>exponent</declname>
        </param>
        <briefdescription>
<para>Extract (integer) exponent and fraction from single precision SIMD. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>Floating-point value to extract from </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">exponent</parametername>
</parameternamelist>
<parameterdescription>
<para>Returned exponent of value, integer SIMD format. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Fraction of value, floating-point SIMD format. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="852" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="852" bodyend="861"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a7d8d4c79d514bc6dc56832b2a44fc312" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::ldexp</definition>
        <argsstring>(SimdFloat value, SimdFInt32 exponent)</argsstring>
        <name>ldexp</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>value</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>exponent</declname>
        </param>
        <briefdescription>
<para>Multiply a SIMD float value by the number 2 raised to an exp power. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>Floating-point number to multiply with new exponent </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>exponent</parametername>
</parameternamelist>
<parameterdescription>
<para>Integer that will not overflow as 2^exponent. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>value*2^exponent </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="870" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="870" bodyend="879"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a55d2bf9090a7a9aed6e4b1f6391ef844" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float gmx_simdcall</type>
        <definition>static float gmx_simdcall gmx::reduce</definition>
        <argsstring>(SimdFloat a)</argsstring>
        <name>reduce</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Return sum of all elements in SIMD float variable. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD variable to reduce/sum. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The sum of all elements in the argument variable. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="888" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="888" bodyend="897"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>SIMD implementation single precision floating-point comparisons, boolean, selection.</header>
      <memberdef kind="function" id="namespacegmx_1afc42a1e43f4158ce45339e3a8ea225b7" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref> gmx_simdcall</type>
        <definition>static SimdFBool gmx_simdcall gmx::operator==</definition>
        <argsstring>(SimdFloat a, SimdFloat b)</argsstring>
        <name>operator==</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SIMD a==b for single SIMD. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>value1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>value2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Each element of the boolean will be set to true if a==b.</para></simplesect>
Beware that exact floating-point comparisons are difficult. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="914" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="914" bodyend="923"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a254a7b42f107dbc05f506a139ff24cb6" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref> gmx_simdcall</type>
        <definition>static SimdFBool gmx_simdcall gmx::operator!=</definition>
        <argsstring>(SimdFloat a, SimdFloat b)</argsstring>
        <name>operator!=</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SIMD a!=b for single SIMD. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>value1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>value2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Each element of the boolean will be set to true if a!=b.</para></simplesect>
Beware that exact floating-point comparisons are difficult. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="934" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="934" bodyend="943"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1acd963f002451c284f4dc52167c6c1dc1" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref> gmx_simdcall</type>
        <definition>static SimdFBool gmx_simdcall gmx::operator&lt;</definition>
        <argsstring>(SimdFloat a, SimdFloat b)</argsstring>
        <name>operator&lt;</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SIMD a&lt;b for single SIMD. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>value1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>value2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Each element of the boolean will be set to true if a&lt;b. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="951" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="952" bodyend="961"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ad0e463866d58d57bbc388c17299c4829" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref> gmx_simdcall</type>
        <definition>static SimdFBool gmx_simdcall gmx::operator&lt;=</definition>
        <argsstring>(SimdFloat a, SimdFloat b)</argsstring>
        <name>operator&lt;=</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SIMD a&lt;=b for single SIMD. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>value1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>value2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Each element of the boolean will be set to true if a&lt;=b. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="969" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="970" bodyend="979"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a10dfe150e697592814f1d3edd5c3c87e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref> gmx_simdcall</type>
        <definition>static SimdFBool gmx_simdcall gmx::testBits</definition>
        <argsstring>(SimdFloat a)</argsstring>
        <name>testBits</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Return true if any bits are set in the single precision SIMD. </para>        </briefdescription>
        <detaileddescription>
<para>This function is used to handle bitmasks, mainly for exclusions in the inner kernels. Note that it will return true even for -0.0f (sign bit set), so it is not identical to not-equal.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Each element of the boolean will be true if any bit in a is nonzero. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="991" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="991" bodyend="1007"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ae161ba7a8d47adeac2e26eca03095d13" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref> gmx_simdcall</type>
        <definition>static SimdFBool gmx_simdcall gmx::operator&amp;&amp;</definition>
        <argsstring>(SimdFBool a, SimdFBool b)</argsstring>
        <name>operator&amp;&amp;</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Logical <emphasis>and</emphasis> on single precision SIMD booleans. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>logical vars 1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>logical vars 2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>For each element, the result boolean is true if a &amp; b are true.</para></simplesect>
<simplesect kind="note"><para>This is not necessarily a bitwise operation - the storage format of booleans is implementation-dependent. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1019" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1019" bodyend="1028"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a5595db8a2c813f0ae078285a1b6b8bd3" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref> gmx_simdcall</type>
        <definition>static SimdFBool gmx_simdcall gmx::operator||</definition>
        <argsstring>(SimdFBool a, SimdFBool b)</argsstring>
        <name>operator||</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Logical <emphasis>or</emphasis> on single precision SIMD booleans. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>logical vars 1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>logical vars 2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>For each element, the result boolean is true if a or b is true.</para></simplesect>
Note that this is not necessarily a bitwise operation - the storage format of booleans is implementation-dependent.</para><para>\ </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1041" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1041" bodyend="1050"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ad3771cceb27c74f62fe77ae2b3375f19" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool gmx_simdcall</type>
        <definition>static bool gmx_simdcall gmx::anyTrue</definition>
        <argsstring>(SimdFBool a)</argsstring>
        <name>anyTrue</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns non-zero if any of the boolean in SIMD a is True, otherwise 0. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Logical variable. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if any element in a is true, otherwise false.</para></simplesect>
The actual return value for truth will depend on the architecture, so any non-zero value is considered truth. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1061" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1061" bodyend="1070"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ad8662b109c880042900ece585e9b4c68" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::selectByMask</definition>
        <argsstring>(SimdFloat a, SimdFBool mask)</argsstring>
        <name>selectByMask</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref></type>
          <declname>mask</declname>
        </param>
        <briefdescription>
<para>Select from single precision SIMD variable where boolean is true. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Floating-point variable to select from </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>For each element, a is selected for true, 0 for false. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1079" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1079" bodyend="1088"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a3b181964f04f57a08d6241f639696d31" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::selectByNotMask</definition>
        <argsstring>(SimdFloat a, SimdFBool mask)</argsstring>
        <name>selectByNotMask</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref></type>
          <declname>mask</declname>
        </param>
        <briefdescription>
<para>Select from single precision SIMD variable where boolean is false. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Floating-point variable to select from </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>For each element, a is selected for false, 0 for true (sic). </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1097" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1097" bodyend="1106"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a443be80edc7822ae0582bc5a4d4da34c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::blend</definition>
        <argsstring>(SimdFloat a, SimdFloat b, SimdFBool sel)</argsstring>
        <name>blend</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref></type>
          <declname>sel</declname>
        </param>
        <briefdescription>
<para>Vector-blend SIMD float selection. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>First source </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Second source </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sel</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>For each element, select b if sel is true, a otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1116" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1116" bodyend="1125"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>SIMD implementation integer (corresponding to float) bitwise logical operations</header>
      <memberdef kind="function" id="namespacegmx_1a944742d0897cd5cd137f635350038916" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref> gmx_simdcall</type>
        <definition>static SimdFInt32 gmx_simdcall gmx::operator&lt;&lt;</definition>
        <argsstring>(SimdFInt32 a, int n)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>SIMD integer shift left logical, based on immediate value. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga354867d2570fecb6b341047947bee0d1" kindref="member">GMX_SIMD_HAVE_FINT32_LOGICAL</ref> is 1.</para><para>Logical shift. Each element is shifted (independently) up to 32 positions left, while zeros are shifted in from the right.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>integer data to shift </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of positions to shift left. n&lt;=32. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>shifted values </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1144" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1145" bodyend="1154"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1af05b883b2ca284120a3f7458354ed27a" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref> gmx_simdcall</type>
        <definition>static SimdFInt32 gmx_simdcall gmx::operator&gt;&gt;</definition>
        <argsstring>(SimdFInt32 a, int n)</argsstring>
        <name>operator&gt;&gt;</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>SIMD integer shift right logical, based on immediate value. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga354867d2570fecb6b341047947bee0d1" kindref="member">GMX_SIMD_HAVE_FINT32_LOGICAL</ref> is 1.</para><para>Logical shift. Each element is shifted (independently) up to 32 positions right, while zeros are shifted in from the left.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>integer data to shift </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of positions to shift right. n&lt;=32. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>shifted values </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1168" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1168" bodyend="1177"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aaa2f30ddbbff1d91de4d1ef1f516fe9f" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref> gmx_simdcall</type>
        <definition>static SimdFInt32 gmx_simdcall gmx::operator&amp;</definition>
        <argsstring>(SimdFInt32 a, SimdFInt32 b)</argsstring>
        <name>operator&amp;</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Integer SIMD bitwise and. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga354867d2570fecb6b341047947bee0d1" kindref="member">GMX_SIMD_HAVE_FINT32_LOGICAL</ref> is 1.</para><para><simplesect kind="note"><para>You can <emphasis>not</emphasis> use this operation directly to select based on a boolean SIMD variable, since booleans are separate from integer SIMD. If that is what you need, have a look at <ref refid="group__module__simd_1ga223de776671702527c62b4da8f6e570a" kindref="member">gmx::selectByMask</ref> instead.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>first integer SIMD </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>second integer SIMD </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a &amp; b (bitwise and) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1192" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1192" bodyend="1201"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a03632f7c71496ded26a0c3eda8ed33b7" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref> gmx_simdcall</type>
        <definition>static SimdFInt32 gmx_simdcall gmx::andNot</definition>
        <argsstring>(SimdFInt32 a, SimdFInt32 b)</argsstring>
        <name>andNot</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Integer SIMD bitwise not/complement. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga354867d2570fecb6b341047947bee0d1" kindref="member">GMX_SIMD_HAVE_FINT32_LOGICAL</ref> is 1.</para><para><simplesect kind="note"><para>You can <emphasis>not</emphasis> use this operation directly to select based on a boolean SIMD variable, since booleans are separate from integer SIMD. If that is what you need, have a look at <ref refid="group__module__simd_1ga223de776671702527c62b4da8f6e570a" kindref="member">gmx::selectByMask</ref> instead.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>integer SIMD </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>integer SIMD </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(~a) &amp; b </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1216" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1216" bodyend="1225"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1af6f2042babc63e1b20b08ed61d859f74" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref> gmx_simdcall</type>
        <definition>static SimdFInt32 gmx_simdcall gmx::operator|</definition>
        <argsstring>(SimdFInt32 a, SimdFInt32 b)</argsstring>
        <name>operator|</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Integer SIMD bitwise or. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga354867d2570fecb6b341047947bee0d1" kindref="member">GMX_SIMD_HAVE_FINT32_LOGICAL</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>first integer SIMD </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>second integer SIMD </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a | b (bitwise or) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1236" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1236" bodyend="1245"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1abb7e81f2ef83cfb9aaae088c8762c2b0" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref> gmx_simdcall</type>
        <definition>static SimdFInt32 gmx_simdcall gmx::operator^</definition>
        <argsstring>(SimdFInt32 a, SimdFInt32 b)</argsstring>
        <name>operator^</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Integer SIMD bitwise xor. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga354867d2570fecb6b341047947bee0d1" kindref="member">GMX_SIMD_HAVE_FINT32_LOGICAL</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>first integer SIMD </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>second integer SIMD </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a ^ b (bitwise xor) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1256" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1256" bodyend="1265"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>SIMD implementation integer (corresponding to float) arithmetics</header>
      <memberdef kind="function" id="namespacegmx_1af3c5a94b0e74b2e5b7fbb4c9c0bd1938" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref> gmx_simdcall</type>
        <definition>static SimdFInt32 gmx_simdcall gmx::operator+</definition>
        <argsstring>(SimdFInt32 a, SimdFInt32 b)</argsstring>
        <name>operator+</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Add SIMD integers. </para>        </briefdescription>
        <detaileddescription>
<para>This routine is only available if <ref refid="group__module__simd_1ga9febc62e1abd58eb8a035b8b81f93292" kindref="member">GMX_SIMD_HAVE_FINT32_ARITHMETICS</ref> (single) or <ref refid="group__module__simd_1gab8469202af6999f95405779355d89c30" kindref="member">GMX_SIMD_HAVE_DINT32_ARITHMETICS</ref> (double) is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>term1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>term2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a+b </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1283" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1283" bodyend="1292"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1accbca9c905a278763e5ff7c584f75f21" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref> gmx_simdcall</type>
        <definition>static SimdFInt32 gmx_simdcall gmx::operator-</definition>
        <argsstring>(SimdFInt32 a, SimdFInt32 b)</argsstring>
        <name>operator-</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Subtract SIMD integers. </para>        </briefdescription>
        <detaileddescription>
<para>This routine is only available if <ref refid="group__module__simd_1ga9febc62e1abd58eb8a035b8b81f93292" kindref="member">GMX_SIMD_HAVE_FINT32_ARITHMETICS</ref> (single) or <ref refid="group__module__simd_1gab8469202af6999f95405779355d89c30" kindref="member">GMX_SIMD_HAVE_DINT32_ARITHMETICS</ref> (double) is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>term1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>term2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a-b </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1304" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1304" bodyend="1313"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a9acf86fe51d043353aa609f65263386e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref> gmx_simdcall</type>
        <definition>static SimdFInt32 gmx_simdcall gmx::operator*</definition>
        <argsstring>(SimdFInt32 a, SimdFInt32 b)</argsstring>
        <name>operator*</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Multiply SIMD integers. </para>        </briefdescription>
        <detaileddescription>
<para>This routine is only available if <ref refid="group__module__simd_1ga9febc62e1abd58eb8a035b8b81f93292" kindref="member">GMX_SIMD_HAVE_FINT32_ARITHMETICS</ref> (single) or <ref refid="group__module__simd_1gab8469202af6999f95405779355d89c30" kindref="member">GMX_SIMD_HAVE_DINT32_ARITHMETICS</ref> (double) is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b.</para></simplesect>
<simplesect kind="note"><para>Only the low 32 bits are retained, so this can overflow. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1327" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1327" bodyend="1336"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>SIMD implementation integer (corresponding to float) comparisons, boolean, selection</header>
      <memberdef kind="function" id="namespacegmx_1aec52e80a85ca0737723f5d9b358b1660" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFIBool" kindref="compound">SimdFIBool</ref> gmx_simdcall</type>
        <definition>static SimdFIBool gmx_simdcall gmx::operator==</definition>
        <argsstring>(SimdFInt32 a, SimdFInt32 b)</argsstring>
        <name>operator==</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Equality comparison of two integers corresponding to float values. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga9febc62e1abd58eb8a035b8b81f93292" kindref="member">GMX_SIMD_HAVE_FINT32_ARITHMETICS</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD integer1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD integer2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD integer boolean with true for elements where a==b </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1353" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1353" bodyend="1362"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1afb9d95ea1f60f4422ff48866615741d3" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFIBool" kindref="compound">SimdFIBool</ref> gmx_simdcall</type>
        <definition>static SimdFIBool gmx_simdcall gmx::operator&lt;</definition>
        <argsstring>(SimdFInt32 a, SimdFInt32 b)</argsstring>
        <name>operator&lt;</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Less-than comparison of two SIMD integers corresponding to float values. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga9febc62e1abd58eb8a035b8b81f93292" kindref="member">GMX_SIMD_HAVE_FINT32_ARITHMETICS</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD integer1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD integer2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD integer boolean with true for elements where a&lt;b </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1372" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1373" bodyend="1382"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a47337ed69b038e337974eb220e9455bd" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFIBool" kindref="compound">SimdFIBool</ref> gmx_simdcall</type>
        <definition>static SimdFIBool gmx_simdcall gmx::testBits</definition>
        <argsstring>(SimdFInt32 a)</argsstring>
        <name>testBits</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Check if any bit is set in each element. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga9febc62e1abd58eb8a035b8b81f93292" kindref="member">GMX_SIMD_HAVE_FINT32_ARITHMETICS</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD integer </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD integer boolean with true for elements where any bit is set </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1392" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1392" bodyend="1401"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a0187183d12327ef78c5c5307dd6e1fbf" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFIBool" kindref="compound">SimdFIBool</ref> gmx_simdcall</type>
        <definition>static SimdFIBool gmx_simdcall gmx::operator&amp;&amp;</definition>
        <argsstring>(SimdFIBool a, SimdFIBool b)</argsstring>
        <name>operator&amp;&amp;</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFIBool" kindref="compound">SimdFIBool</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFIBool" kindref="compound">SimdFIBool</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Logical AND on <ref refid="classgmx_1_1SimdFIBool" kindref="compound">SimdFIBool</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga9febc62e1abd58eb8a035b8b81f93292" kindref="member">GMX_SIMD_HAVE_FINT32_ARITHMETICS</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD boolean 1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD boolean 2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True for elements where both a and b are true. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1412" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1412" bodyend="1421"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ab7b197309edc60323a129fa9620a7400" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFIBool" kindref="compound">SimdFIBool</ref> gmx_simdcall</type>
        <definition>static SimdFIBool gmx_simdcall gmx::operator||</definition>
        <argsstring>(SimdFIBool a, SimdFIBool b)</argsstring>
        <name>operator||</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFIBool" kindref="compound">SimdFIBool</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFIBool" kindref="compound">SimdFIBool</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Logical OR on <ref refid="classgmx_1_1SimdFIBool" kindref="compound">SimdFIBool</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga9febc62e1abd58eb8a035b8b81f93292" kindref="member">GMX_SIMD_HAVE_FINT32_ARITHMETICS</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD boolean 1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD boolean 2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True for elements where both a and b are true. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1432" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1432" bodyend="1441"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ac07fb03248b03957ceee7a258cb01ec9" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool gmx_simdcall</type>
        <definition>static bool gmx_simdcall gmx::anyTrue</definition>
        <argsstring>(SimdFIBool a)</argsstring>
        <name>anyTrue</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFIBool" kindref="compound">SimdFIBool</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns true if any of the boolean in x is True, otherwise 0. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga9febc62e1abd58eb8a035b8b81f93292" kindref="member">GMX_SIMD_HAVE_FINT32_ARITHMETICS</ref> is 1.</para><para>The actual return value for &quot;any true&quot; will depend on the architecture. Any non-zero value should be considered truth.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD boolean </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if any of the elements in a is true, otherwise 0. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1454" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1454" bodyend="1463"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a514569727a2e78d7308e19718aa52073" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref> gmx_simdcall</type>
        <definition>static SimdFInt32 gmx_simdcall gmx::selectByMask</definition>
        <argsstring>(SimdFInt32 a, SimdFIBool mask)</argsstring>
        <name>selectByMask</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFIBool" kindref="compound">SimdFIBool</ref></type>
          <declname>mask</declname>
        </param>
        <briefdescription>
<para>Select from <ref refid="classgmx_1_1SimdFInt32" kindref="compound">gmx::SimdFInt32</ref> variable where boolean is true. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga9febc62e1abd58eb8a035b8b81f93292" kindref="member">GMX_SIMD_HAVE_FINT32_ARITHMETICS</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD integer to select from </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Elements from a where sel is true, 0 otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1474" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1474" bodyend="1483"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ab614faa655138f6dd9647301290d993d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref> gmx_simdcall</type>
        <definition>static SimdFInt32 gmx_simdcall gmx::selectByNotMask</definition>
        <argsstring>(SimdFInt32 a, SimdFIBool mask)</argsstring>
        <name>selectByNotMask</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFIBool" kindref="compound">SimdFIBool</ref></type>
          <declname>mask</declname>
        </param>
        <briefdescription>
<para>Select from <ref refid="classgmx_1_1SimdFInt32" kindref="compound">gmx::SimdFInt32</ref> variable where boolean is false. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga9febc62e1abd58eb8a035b8b81f93292" kindref="member">GMX_SIMD_HAVE_FINT32_ARITHMETICS</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD integer to select from </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Elements from a where sel is false, 0 otherwise (sic). </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1494" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1494" bodyend="1503"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a3f3f322cbf3a7d646003849046028f65" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref> gmx_simdcall</type>
        <definition>static SimdFInt32 gmx_simdcall gmx::blend</definition>
        <argsstring>(SimdFInt32 a, SimdFInt32 b, SimdFIBool sel)</argsstring>
        <name>blend</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFIBool" kindref="compound">SimdFIBool</ref></type>
          <declname>sel</declname>
        </param>
        <briefdescription>
<para>Vector-blend SIMD integer selection. </para>        </briefdescription>
        <detaileddescription>
<para>Available if <ref refid="group__module__simd_1ga9febc62e1abd58eb8a035b8b81f93292" kindref="member">GMX_SIMD_HAVE_FINT32_ARITHMETICS</ref> is 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>First source </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Second source </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sel</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>For each element, select b if sel is true, a otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" line="1515" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_simd_float.h" bodystart="1515" bodyend="1524"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Higher-level SIMD utilities accessing partial (half-width) SIMD doubles.</header>
      <description><para>See the single-precision versions for documentation. Since double precision is typically half the width of single, this double version is likely only useful with 512-bit and larger implementations. </para></description>
      <memberdef kind="function" id="namespacegmx_1a5ddc2fd6582a66337e35df94128c183c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::loadDualHsimd</definition>
        <argsstring>(const double *m0, const double *m1)</argsstring>
        <name>loadDualHsimd</name>
        <param>
          <type>const double *</type>
          <declname>m0</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>m1</declname>
        </param>
        <briefdescription>
<para>Load low &amp; high parts of SIMD double from different locations. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m0</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory aligned to half SIMD width. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m1</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory aligned to half SIMD width.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD variable with low part loaded from m0, high from m1.</para></simplesect>
Available if <ref refid="group__module__simd_1gadef533340f8e648dfb550cbd8cfd9fc7" kindref="member">GMX_SIMD_HAVE_HSIMD_UTIL_DOUBLE</ref> is 1. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" line="651" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" bodystart="651" bodyend="666"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a0fc17c3e9b2d0f83db3b7f1274f945b5" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::loadDuplicateHsimd</definition>
        <argsstring>(const double *m)</argsstring>
        <name>loadDuplicateHsimd</name>
        <param>
          <type>const double *</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Load half-SIMD-width double data, spread to both halves. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory aligned to half SIMD width.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD variable with both halves loaded from m..</para></simplesect>
Available if <ref refid="group__module__simd_1gadef533340f8e648dfb550cbd8cfd9fc7" kindref="member">GMX_SIMD_HAVE_HSIMD_UTIL_DOUBLE</ref> is 1. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" line="677" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" bodystart="677" bodyend="690"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a110e4ed8c03c3842609f70bcf1d86dab" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::load1DualHsimd</definition>
        <argsstring>(const double *m)</argsstring>
        <name>load1DualHsimd</name>
        <param>
          <type>const double *</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Load two doubles, spread 1st in low half, 2nd in high half. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to two adjacent double values.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD variable where all elements in the low half have been set to m[0], and all elements in high half to m[1].</para></simplesect>
<simplesect kind="note"><para>This routine always loads two values and sets the halves separately. If you want to set all elements to the same value, simply use the standard (non-half-SIMD) operations.</para></simplesect>
Available if <ref refid="group__module__simd_1gadef533340f8e648dfb550cbd8cfd9fc7" kindref="member">GMX_SIMD_HAVE_HSIMD_UTIL_DOUBLE</ref> is 1. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" line="706" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" bodystart="706" bodyend="716"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a875057cc36d19c7e9be3f840612428d4" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::storeDualHsimd</definition>
        <argsstring>(double *m0, double *m1, SimdDouble a)</argsstring>
        <name>storeDualHsimd</name>
        <param>
          <type>double *</type>
          <declname>m0</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>m1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Store low &amp; high parts of SIMD double to different locations. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m0</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory aligned to half SIMD width. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m1</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory aligned to half SIMD width. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD variable. Low half should be stored to m0, high to m1.</para></parameterdescription>
</parameteritem>
</parameterlist>
Available if <ref refid="group__module__simd_1gadef533340f8e648dfb550cbd8cfd9fc7" kindref="member">GMX_SIMD_HAVE_HSIMD_UTIL_DOUBLE</ref> is 1. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" line="728" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" bodystart="728" bodyend="741"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a2e7f54c2fe31c60ecc1dd2b4c95667d8" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::incrDualHsimd</definition>
        <argsstring>(double *m0, double *m1, SimdDouble a)</argsstring>
        <name>incrDualHsimd</name>
        <param>
          <type>double *</type>
          <declname>m0</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>m1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Add each half of SIMD variable to separate memory adresses. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m0</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory aligned to half SIMD width. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m1</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory aligned to half SIMD width. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD variable. Lower half will be added to m0, upper half to m1.</para></parameterdescription>
</parameteritem>
</parameterlist>
The memory must be aligned to half SIMD width.</para><para><simplesect kind="note"><para>The updated m0 value is written before m1 is read from memory, so the result will be correct even if the memory regions overlap.</para></simplesect>
Available if <ref refid="group__module__simd_1gadef533340f8e648dfb550cbd8cfd9fc7" kindref="member">GMX_SIMD_HAVE_HSIMD_UTIL_DOUBLE</ref> is 1. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" line="757" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" bodystart="757" bodyend="773"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a0233e7b9cab30a7cd2ad5e59d8910a35" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::decrHsimd</definition>
        <argsstring>(double *m, SimdDouble a)</argsstring>
        <name>decrHsimd</name>
        <param>
          <type>double *</type>
          <declname>m</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Add the two halves of a SIMD double, subtract the sum from half-SIMD-width consecutive doubles in memory. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>half-width aligned memory, from which sum of the halves will be subtracted. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD variable. Upper &amp; lower halves will first be added.</para></parameterdescription>
</parameteritem>
</parameterlist>
If the SIMD width is 8 and contains [a b c d e f g h], the memory will be modified to [m[0]-(a+e) m[1]-(b+f) m[2]-(c+g) m[3]-(d+h)].</para><para>The memory must be aligned to half SIMD width.</para><para>Available if <ref refid="group__module__simd_1gadef533340f8e648dfb550cbd8cfd9fc7" kindref="member">GMX_SIMD_HAVE_HSIMD_UTIL_DOUBLE</ref> is 1. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" line="789" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" bodystart="789" bodyend="799"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a66c1f8fc580e64de5835134f18f75f61" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::gatherLoadTransposeHsimd</definition>
        <argsstring>(const double *base0, const double *base1, std::int32_t offset[], SimdDouble *v0, SimdDouble *v1)</argsstring>
        <name>gatherLoadTransposeHsimd</name>
        <param>
          <type>const double *</type>
          <declname>base0</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>base1</declname>
        </param>
        <param>
          <type>std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Load 2 consecutive doubles from each of GMX_SIMD_DOUBLE_WIDTH/2 offsets, transpose into SIMD double (low half from base0, high from base1). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the storage, i.e. the distance (measured in elements, not bytes) between index points. When this is identical to the number of output components the data is packed without padding. This must be a multiple of the alignment to keep all data aligned. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base0</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to base of first aligned memory </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>base1</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to base of second aligned memory </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Offset to the start of each pair </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st element in each pair, base0 in low and base1 in high half. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd element in each pair, base0 in low and base1 in high half.</para></parameterdescription>
</parameteritem>
</parameterlist>
The offset array should be of half the SIMD width length, so it corresponds to the half-SIMD-register operations. This also means it must be aligned to half the integer SIMD width (i.e., GMX_SIMD_DINT32_WIDTH/2).</para><para>The floating-point memory locations must be aligned, but only to the smaller of two elements and the floating-point SIMD width.</para><para>This routine is primarily designed to load nonbonded parameters in the kernels. It is the equivalent of the full-width routine <ref refid="group__module__simd_1ga725596b415f4bca94e71321b6845bed4" kindref="member">gatherLoadTranspose()</ref>, but just as the other hsimd routines it will pick half-SIMD-width data from base0 and put in the lower half, while the upper half comes from base1.</para><para>For an example, assume the SIMD width is 8, align is 2, that base0 is [A0 A1 B0 B1 C0 C1 D0 D1 ...], and base1 [E0 E1 F0 F1 G0 G1 H0 H1...].</para><para>Then we will get v0 as [A0 B0 C0 D0 E0 F0 G0 H0] and v1 as [A1 B1 C1 D1 E1 F1 G1 H1].</para><para>Available if <ref refid="group__module__simd_1gadef533340f8e648dfb550cbd8cfd9fc7" kindref="member">GMX_SIMD_HAVE_HSIMD_UTIL_DOUBLE</ref> is 1. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" line="838" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" bodystart="838" bodyend="859"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a774b79fe30e71192635a3081e369023e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double gmx_simdcall</type>
        <definition>static double gmx_simdcall gmx::reduceIncr4ReturnSumHsimd</definition>
        <argsstring>(double *m, SimdDouble v0, SimdDouble v1)</argsstring>
        <name>reduceIncr4ReturnSumHsimd</name>
        <param>
          <type>double *</type>
          <declname>m</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Reduce the 4 half-SIMD-with doubles in 2 SIMD variables (sum halves), increment four consecutive doubles in memory, return sum. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory where the four values should be incremented </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v0</parametername>
</parameternamelist>
<parameterdescription>
<para>Variable whose half-SIMD sums should be added to m[0]/m[1], respectively. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>Variable whose half-SIMD sums should be added to m[2]/m[3], respectively.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Sum of all elements in the four SIMD variables.</para></simplesect>
The pointer m must be aligned, but only to the smaller of four elements and the floating-point SIMD width.</para><para><simplesect kind="note"><para>This is the half-SIMD-width version of <ref refid="group__module__simd_1gace1c53e05ba045977e06eb98778c0123" kindref="member">reduceIncr4ReturnSum()</ref>. The only difference is that the four half-SIMD inputs needed are present in the low/high halves of the two SIMD arguments.</para></simplesect>
Available if <ref refid="group__module__simd_1gadef533340f8e648dfb550cbd8cfd9fc7" kindref="member">GMX_SIMD_HAVE_HSIMD_UTIL_DOUBLE</ref> is 1. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" line="882" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" bodystart="882" bodyend="906"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Higher-level SIMD utilities accessing partial (half-width) SIMD floats.</header>
      <description><para>These functions are optional. The are only useful for SIMD implementation where the width is 8 or larger, and where it would be inefficient to process 4*8, 8*8, or more, interactions in parallel.</para><para>Currently, only Intel provides very wide SIMD implementations, but these also come with excellent support for loading, storing, accessing and shuffling parts of the register in so-called &apos;lanes&apos; of 4 bytes each. We can use this to load separate parts into the low/high halves of the register in the inner loop of the nonbonded kernel, which e.g. makes it possible to process 4*4 nonbonded interactions as a pattern of 2*8. We can also use implementations with width 16 or greater.</para><para>To make this more generic, when <ref refid="group__module__simd_1ga0d9f8d6284ecbbd135b89f2ad8999839" kindref="member">GMX_SIMD_HAVE_HSIMD_UTIL_REAL</ref> is 1, the SIMD implementation provides seven special routines that:</para><para><itemizedlist>
<listitem><para>Load the low/high parts of a SIMD variable from different pointers</para></listitem><listitem><para>Load half the SIMD width from one pointer, and duplicate in low/high parts</para></listitem><listitem><para>Load two reals, put 1st one in all low elements, and 2nd in all high ones.</para></listitem><listitem><para>Store the low/high parts of a SIMD variable to different pointers</para></listitem><listitem><para>Subtract both SIMD halves from a single half-SIMD-width memory location.</para></listitem><listitem><para>Load aligned pairs (LJ parameters) from two base pointers, with a common offset list, and put these in the low/high SIMD halves.</para></listitem><listitem><para>Reduce each half of two SIMD registers (i.e., 4 parts in total), increment four adjacent memory positions, and return the total sum.</para></listitem></itemizedlist>
</para><para>Remember: this is ONLY used when the native SIMD width is large. You will just waste time if you implement it for normal 16-byte SIMD architectures.</para><para>This is part of the new C++ SIMD interface, so these functions are only available when using C++. Since some Gromacs code reliying on the SIMD module is still C (not C++), we have kept the C-style naming for now - this will change once we are entirely C++. </para></description>
      <memberdef kind="function" id="namespacegmx_1a22b5bada57cd592ed73c5af81953f4b1" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::loadDualHsimd</definition>
        <argsstring>(const float *m0, const float *m1)</argsstring>
        <name>loadDualHsimd</name>
        <param>
          <type>const float *</type>
          <declname>m0</declname>
        </param>
        <param>
          <type>const float *</type>
          <declname>m1</declname>
        </param>
        <briefdescription>
<para>Load low &amp; high parts of SIMD float from different locations. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m0</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory aligned to half SIMD width. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m1</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory aligned to half SIMD width.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD variable with low part loaded from m0, high from m1.</para></simplesect>
Available if <ref refid="group__module__simd_1gac40bf3261e36fb7ff022e8ab37b04fcf" kindref="member">GMX_SIMD_HAVE_HSIMD_UTIL_FLOAT</ref> is 1. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" line="700" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" bodystart="700" bodyend="715"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a62c7b5f1de8725256644546b05e3e63b" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::loadDuplicateHsimd</definition>
        <argsstring>(const float *m)</argsstring>
        <name>loadDuplicateHsimd</name>
        <param>
          <type>const float *</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Load half-SIMD-width float data, spread to both halves. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory aligned to half SIMD width.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD variable with both halves loaded from m..</para></simplesect>
Available if <ref refid="group__module__simd_1gac40bf3261e36fb7ff022e8ab37b04fcf" kindref="member">GMX_SIMD_HAVE_HSIMD_UTIL_FLOAT</ref> is 1. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" line="726" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" bodystart="726" bodyend="739"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aa822fac47b4eafdd526a831d32438840" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::load1DualHsimd</definition>
        <argsstring>(const float *m)</argsstring>
        <name>load1DualHsimd</name>
        <param>
          <type>const float *</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Load two floats, spread 1st in low half, 2nd in high half. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to two adjacent float values.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>SIMD variable where all elements in the low half have been set to m[0], and all elements in high half to m[1].</para></simplesect>
<simplesect kind="note"><para>This routine always loads two values and sets the halves separately. If you want to set all elements to the same value, simply use the standard (non-half-SIMD) operations.</para></simplesect>
Available if <ref refid="group__module__simd_1gac40bf3261e36fb7ff022e8ab37b04fcf" kindref="member">GMX_SIMD_HAVE_HSIMD_UTIL_FLOAT</ref> is 1. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" line="755" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" bodystart="755" bodyend="765"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a5e9a1e1e45a47398ab3d7eb1732d9abc" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::storeDualHsimd</definition>
        <argsstring>(float *m0, float *m1, SimdFloat a)</argsstring>
        <name>storeDualHsimd</name>
        <param>
          <type>float *</type>
          <declname>m0</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>m1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Store low &amp; high parts of SIMD float to different locations. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m0</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory aligned to half SIMD width. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m1</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory aligned to half SIMD width. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD variable. Low half should be stored to m0, high to m1.</para></parameterdescription>
</parameteritem>
</parameterlist>
Available if <ref refid="group__module__simd_1gac40bf3261e36fb7ff022e8ab37b04fcf" kindref="member">GMX_SIMD_HAVE_HSIMD_UTIL_FLOAT</ref> is 1. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" line="777" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" bodystart="777" bodyend="790"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a02c414f8f25b517e035764998720dd1c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::incrDualHsimd</definition>
        <argsstring>(float *m0, float *m1, SimdFloat a)</argsstring>
        <name>incrDualHsimd</name>
        <param>
          <type>float *</type>
          <declname>m0</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>m1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Add each half of SIMD variable to separate memory adresses. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m0</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory aligned to half SIMD width. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m1</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory aligned to half SIMD width. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD variable. Lower half will be added to m0, upper half to m1.</para></parameterdescription>
</parameteritem>
</parameterlist>
The memory must be aligned to half SIMD width.</para><para><simplesect kind="note"><para>The updated m0 value is written before m1 is read from memory, so the result will be correct even if the memory regions overlap.</para></simplesect>
Available if <ref refid="group__module__simd_1gac40bf3261e36fb7ff022e8ab37b04fcf" kindref="member">GMX_SIMD_HAVE_HSIMD_UTIL_FLOAT</ref> is 1. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" line="806" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" bodystart="806" bodyend="822"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ab498b7b673584374b736bb2299575f3b" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::decrHsimd</definition>
        <argsstring>(float *m, SimdFloat a)</argsstring>
        <name>decrHsimd</name>
        <param>
          <type>float *</type>
          <declname>m</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Add the two halves of a SIMD float, subtract the sum from half-SIMD-width consecutive floats in memory. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>half-width aligned memory, from which sum of the halves will be subtracted. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD variable. Upper &amp; lower halves will first be added.</para></parameterdescription>
</parameteritem>
</parameterlist>
If the SIMD width is 8 and contains [a b c d e f g h], the memory will be modified to [m[0]-(a+e) m[1]-(b+f) m[2]-(c+g) m[3]-(d+h)].</para><para>The memory must be aligned to half SIMD width.</para><para>Available if <ref refid="group__module__simd_1gac40bf3261e36fb7ff022e8ab37b04fcf" kindref="member">GMX_SIMD_HAVE_HSIMD_UTIL_FLOAT</ref> is 1. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" line="838" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" bodystart="838" bodyend="848"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a11666cd65bdfee331799b2c1dc732c60" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::gatherLoadTransposeHsimd</definition>
        <argsstring>(const float *base0, const float *base1, const std::int32_t offset[], SimdFloat *v0, SimdFloat *v1)</argsstring>
        <name>gatherLoadTransposeHsimd</name>
        <param>
          <type>const float *</type>
          <declname>base0</declname>
        </param>
        <param>
          <type>const float *</type>
          <declname>base1</declname>
        </param>
        <param>
          <type>const std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Load 2 consecutive floats from each of GMX_SIMD_FLOAT_WIDTH/2 offsets, transpose into SIMD float (low half from base0, high from base1). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the storage, i.e. the distance (measured in elements, not bytes) between index points. When this is identical to the number of output components the data is packed without padding. This must be a multiple of the alignment to keep all data aligned. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base0</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to base of first aligned memory </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>base1</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to base of second aligned memory </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Offset to the start of each pair </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st element in each pair, base0 in low and base1 in high half. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd element in each pair, base0 in low and base1 in high half.</para></parameterdescription>
</parameteritem>
</parameterlist>
The offset array should be of half the SIMD width length, so it corresponds to the half-SIMD-register operations. This also means it must be aligned to half the integer SIMD width (i.e., GMX_SIMD_FINT32_WIDTH/2).</para><para>The floating-point memory locations must be aligned, but only to the smaller of two elements and the floating-point SIMD width.</para><para>This routine is primarily designed to load nonbonded parameters in the kernels. It is the equivalent of the full-width routine <ref refid="group__module__simd_1ga725596b415f4bca94e71321b6845bed4" kindref="member">gatherLoadTranspose()</ref>, but just as the other hsimd routines it will pick half-SIMD-width data from base0 and put in the lower half, while the upper half comes from base1.</para><para>For an example, assume the SIMD width is 8, align is 2, that base0 is [A0 A1 B0 B1 C0 C1 D0 D1 ...], and base1 [E0 E1 F0 F1 G0 G1 H0 H1...].</para><para>Then we will get v0 as [A0 B0 C0 D0 E0 F0 G0 H0] and v1 as [A1 B1 C1 D1 E1 F1 G1 H1].</para><para>Available if <ref refid="group__module__simd_1gac40bf3261e36fb7ff022e8ab37b04fcf" kindref="member">GMX_SIMD_HAVE_HSIMD_UTIL_FLOAT</ref> is 1. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" line="886" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" bodystart="886" bodyend="907"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ab658dd5cd12d3a06f13bc4b36de8ef97" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float gmx_simdcall</type>
        <definition>static float gmx_simdcall gmx::reduceIncr4ReturnSumHsimd</definition>
        <argsstring>(float *m, SimdFloat v0, SimdFloat v1)</argsstring>
        <name>reduceIncr4ReturnSumHsimd</name>
        <param>
          <type>float *</type>
          <declname>m</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Reduce the 4 half-SIMD-with floats in 2 SIMD variables (sum halves), increment four consecutive floats in memory, return sum. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory where the four values should be incremented </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v0</parametername>
</parameternamelist>
<parameterdescription>
<para>Variable whose half-SIMD sums should be added to m[0]/m[1], respectively. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>Variable whose half-SIMD sums should be added to m[2]/m[3], respectively.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Sum of all elements in the four SIMD variables.</para></simplesect>
The pointer m must be aligned, but only to the smaller of four elements and the floating-point SIMD width.</para><para><simplesect kind="note"><para>This is the half-SIMD-width version of <ref refid="group__module__simd_1gace1c53e05ba045977e06eb98778c0123" kindref="member">reduceIncr4ReturnSum()</ref>. The only difference is that the four half-SIMD inputs needed are present in the low/high halves of the two SIMD arguments.</para></simplesect>
Available if <ref refid="group__module__simd_1gac40bf3261e36fb7ff022e8ab37b04fcf" kindref="member">GMX_SIMD_HAVE_HSIMD_UTIL_FLOAT</ref> is 1. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" line="929" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" bodystart="929" bodyend="953"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>SIMD data types</header>
      <description><para>The actual storage of these types is implementation dependent. The documentation is generated from the reference implementation, but for normal usage this will likely not be what you are using. </para></description>
      <memberdef kind="typedef" id="namespacegmx_1a8591d5e5ac6d1bec936a013fdc41b904" prot="public" static="no">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
        <definition>typedef SimdFloat gmx::SimdReal</definition>
        <argsstring></argsstring>
        <name>SimdReal</name>
        <briefdescription>
<para>Real precision floating-point SIMD datatype. </para>        </briefdescription>
        <detaileddescription>
<para>This type is only available if <ref refid="group__module__simd_1ga1578fccdb327f36a2bea338457cbf883" kindref="member">GMX_SIMD_HAVE_REAL</ref> is 1.</para><para><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> if GMX_DOUBLE is 1, otherwise <ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref>.</para><para><simplesect kind="note"><para>This variable cannot be placed inside other structures or classes, since some compilers (including at least clang-3.7) appear to lose the alignment. This is likely particularly severe when allocating such memory on the heap, but it occurs for stack structures too. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" line="232" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" bodystart="232" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a307172d59a1a7c9ed87bc2cb4df83efa" prot="public" static="no">
        <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref></type>
        <definition>typedef SimdFBool gmx::SimdBool</definition>
        <argsstring></argsstring>
        <name>SimdBool</name>
        <briefdescription>
<para>Boolean SIMD type for usage with <ref refid="namespacegmx_1a8591d5e5ac6d1bec936a013fdc41b904" kindref="member">SimdReal</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>This type is only available if <ref refid="group__module__simd_1ga1578fccdb327f36a2bea338457cbf883" kindref="member">GMX_SIMD_HAVE_REAL</ref> is 1.</para><para>If GMX_DOUBLE is 1, this will be set to <ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref> internally, otherwise <ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref>. This is necessary since some SIMD implementations use bitpatterns for marking truth, so single- vs. double precision booleans are not necessarily exchangable. As long as you just use this type you will not have to worry about precision.</para><para>See <ref refid="namespacegmx_1a5e12584989a27abf28198dc8a709d604" kindref="member">SimdIBool</ref> for an explanation of real vs. integer booleans.</para><para><simplesect kind="note"><para>This variable cannot be placed inside other structures or classes, since some compilers (including at least clang-3.7) appear to lose the alignment. This is likely particularly severe when allocating such memory on the heap, but it occurs for stack structures too. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" line="256" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" bodystart="256" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a6598cea23dd103ce19bff4743279e3bc" prot="public" static="no">
        <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
        <definition>typedef SimdFInt32 gmx::SimdInt32</definition>
        <argsstring></argsstring>
        <name>SimdInt32</name>
        <briefdescription>
<para>32-bit integer SIMD type. </para>        </briefdescription>
        <detaileddescription>
<para>If GMX_DOUBLE is 1, this will be set to <ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref> internally, otherwise <ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref>. This might seem a strange implementation detail, but it is because some SIMD implementations use different types/widths of integers registers when converting from double vs. single precision floating point. As long as you just use this type you will not have to worry about precision.</para><para><simplesect kind="note"><para>This variable cannot be placed inside other structures or classes, since some compilers (including at least clang-3.7) appear to lose the alignment. This is likely particularly severe when allocating such memory on the heap, but it occurs for stack structures too. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" line="277" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" bodystart="277" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a5e12584989a27abf28198dc8a709d604" prot="public" static="no">
        <type><ref refid="classgmx_1_1SimdFIBool" kindref="compound">SimdFIBool</ref></type>
        <definition>typedef SimdFIBool gmx::SimdIBool</definition>
        <argsstring></argsstring>
        <name>SimdIBool</name>
        <briefdescription>
<para>Boolean SIMD type for usage with <ref refid="namespacegmx_1a6598cea23dd103ce19bff4743279e3bc" kindref="member">SimdInt32</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>This type is only available if <ref refid="group__module__simd_1ga8a9534860edf5a3f2b9cd1bc60529b39" kindref="member">GMX_SIMD_HAVE_INT32_ARITHMETICS</ref> is 1.</para><para>If GMX_DOUBLE is 1, this will be set to <ref refid="classgmx_1_1SimdDIBool" kindref="compound">SimdDIBool</ref> internally, otherwise <ref refid="classgmx_1_1SimdFIBool" kindref="compound">SimdFIBool</ref>. This is necessary since some SIMD implementations use bitpatterns for marking truth, so single- vs. double precision booleans are not necessarily exchangable, and while a double-precision boolean might be represented with a 64-bit mask, the corresponding integer might only use a 32-bit mask.</para><para>We provide conversion routines for these cases, so the only thing you need to keep in mind is to use <ref refid="namespacegmx_1a307172d59a1a7c9ed87bc2cb4df83efa" kindref="member">SimdBool</ref> when working with <ref refid="namespacegmx_1a8591d5e5ac6d1bec936a013fdc41b904" kindref="member">SimdReal</ref> while you pick <ref refid="namespacegmx_1a5e12584989a27abf28198dc8a709d604" kindref="member">SimdIBool</ref> when working with <ref refid="namespacegmx_1a6598cea23dd103ce19bff4743279e3bc" kindref="member">SimdInt32</ref> .</para><para>To convert between them, use <ref refid="namespacegmx_1a15023cda21995e0a86c76416fff7575e" kindref="member">cvtB2IB</ref> and <ref refid="namespacegmx_1abb2ccc1aebc69073299a26c404fcf5ba" kindref="member">cvtIB2B</ref>.</para><para><simplesect kind="note"><para>This variable cannot be placed inside other structures or classes, since some compilers (including at least clang-3.7) appear to lose the alignment. This is likely particularly severe when allocating such memory on the heap, but it occurs for stack structures too. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" line="307" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" bodystart="307" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a37686b0c2ec48a361d6c4473c1fdb70c" prot="public" static="no">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
        <definition>typedef Simd4Float gmx::Simd4Real</definition>
        <argsstring></argsstring>
        <name>Simd4Real</name>
        <briefdescription>
<para>Real precision floating-point SIMD4 datatype. </para>        </briefdescription>
        <detaileddescription>
<para>This type is only available if <ref refid="group__module__simd_1ga6c015b9c619e63324df85f91e25191c5" kindref="member">GMX_SIMD4_HAVE_REAL</ref> is 1.</para><para><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> if GMX_DOUBLE is 1, otherwise <ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref>.</para><para><simplesect kind="note"><para>This variable cannot be placed inside other structures or classes, since some compilers (including at least clang-3.7) appear to lose the alignment. This is likely particularly severe when allocating such memory on the heap, but it occurs for stack structures too. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" line="335" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" bodystart="335" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1acb6a84be080be397c2c09cda9f315037" prot="public" static="no">
        <type><ref refid="classgmx_1_1Simd4FBool" kindref="compound">Simd4FBool</ref></type>
        <definition>typedef Simd4FBool gmx::Simd4Bool</definition>
        <argsstring></argsstring>
        <name>Simd4Bool</name>
        <briefdescription>
<para>Boolean SIMD4 type for usage with <ref refid="namespacegmx_1a8591d5e5ac6d1bec936a013fdc41b904" kindref="member">SimdReal</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>This type is only available if <ref refid="group__module__simd_1ga6c015b9c619e63324df85f91e25191c5" kindref="member">GMX_SIMD4_HAVE_REAL</ref> is 1.</para><para>If GMX_DOUBLE is 1, this will be set to <ref refid="classgmx_1_1Simd4DBool" kindref="compound">Simd4DBool</ref> internally, otherwise <ref refid="classgmx_1_1Simd4FBool" kindref="compound">Simd4FBool</ref>. This is necessary since some SIMD implementations use bitpatterns for marking truth, so single- vs. double precision booleans are not necessarily exchangable. As long as you just use this type you will not have to worry about precision.</para><para><simplesect kind="note"><para>This variable cannot be placed inside other structures or classes, since some compilers (including at least clang-3.7) appear to lose the alignment. This is likely particularly severe when allocating such memory on the heap, but it occurs for stack structures too. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" line="357" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" bodystart="357" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacegmx_1a8eebcb368cafe13131f39ffd69130e0b" prot="public" static="no" mutable="no">
        <type>const int</type>
        <definition>const int gmx::c_simdBestPairAlignment</definition>
        <argsstring></argsstring>
        <name>c_simdBestPairAlignment</name>
        <initializer>= <ref refid="group__module__simd_1gacc4ad17022538e3d670e55694e55ccc2" kindref="member">c_simdBestPairAlignmentFloat</ref></initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" line="315" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" bodystart="315" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>High-level SIMD proxy objects to disambiguate load/set operations</header>
      <memberdef kind="function" id="namespacegmx_1af6ad160249e7bc4726d93e89407c987e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="classgmx_1_1SimdLoadFProxyInternal" kindref="compound">SimdLoadFProxyInternal</ref> gmx_simdcall</type>
        <definition>static const SimdLoadFProxyInternal gmx_simdcall gmx::load</definition>
        <argsstring>(const float *m)</argsstring>
        <name>load</name>
        <param>
          <type>const float *</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Load function that returns proxy object for <ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> and float. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to load memory </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Proxy object that will call the actual load for either <ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> or float when you assign it and the conversion method is called. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" line="370" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" bodystart="413" bodyend="418"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aac60a1e9bf9b5e7ae62895fb23311d99" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="classgmx_1_1SimdLoadUFProxyInternal" kindref="compound">SimdLoadUFProxyInternal</ref> gmx_simdcall</type>
        <definition>static const SimdLoadUFProxyInternal gmx_simdcall gmx::loadU</definition>
        <argsstring>(const float *m)</argsstring>
        <name>loadU</name>
        <param>
          <type>const float *</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>LoadU function that returns proxy object for <ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> and float. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to loadU memory </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Proxy object that will call the actual loadU for either <ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> or float when you assign it and the conversion method is called. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" line="424" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" bodystart="468" bodyend="473"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a9445e827c666024d7b59d6c40052f1ea" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="classgmx_1_1SimdLoadDProxyInternal" kindref="compound">SimdLoadDProxyInternal</ref> gmx_simdcall</type>
        <definition>static const SimdLoadDProxyInternal gmx_simdcall gmx::load</definition>
        <argsstring>(const double *m)</argsstring>
        <name>load</name>
        <param>
          <type>const double *</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Load function that returns proxy object for <ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> and double. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to load memory </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Proxy object that will call the actual load for either <ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> or double when you assign it and the conversion method is called. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" line="478" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" bodystart="521" bodyend="526"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1adb032148e6416b68e560f6683c889519" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="classgmx_1_1SimdLoadUDProxyInternal" kindref="compound">SimdLoadUDProxyInternal</ref> gmx_simdcall</type>
        <definition>static const SimdLoadUDProxyInternal gmx_simdcall gmx::loadU</definition>
        <argsstring>(const double *m)</argsstring>
        <name>loadU</name>
        <param>
          <type>const double *</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Load function that returns proxy object for <ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> and double. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to load memory </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Proxy object that will call the actual load for either <ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> or double when you assign it and the conversion method is called. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" line="531" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" bodystart="574" bodyend="579"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ad94d8159b73ca606c72cb0210cd69ad7" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="classgmx_1_1SimdLoadIProxyInternal" kindref="compound">SimdLoadIProxyInternal</ref> gmx_simdcall</type>
        <definition>static const SimdLoadIProxyInternal gmx_simdcall gmx::load</definition>
        <argsstring>(const std::int32_t *m)</argsstring>
        <name>load</name>
        <param>
          <type>const std::int32_t *</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Integer load function (proxy object) for <ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref>, SImdDInt32, and int32. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to load memory </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Proxy object that will call the actual load for either <ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref> or <ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref> when you assign it and the conversion method is called. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" line="585" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" bodystart="631" bodyend="636"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a121aa049cf305d012ca3c4462eb5e5f7" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="classgmx_1_1SimdLoadUIProxyInternal" kindref="compound">SimdLoadUIProxyInternal</ref> gmx_simdcall</type>
        <definition>static const SimdLoadUIProxyInternal gmx_simdcall gmx::loadU</definition>
        <argsstring>(const std::int32_t *m)</argsstring>
        <name>loadU</name>
        <param>
          <type>const std::int32_t *</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Integer loadU function (proxy object) for <ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref>, SImdDInt32, and int32. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to load memory </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Proxy object that will call the actual load for either <ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref> or <ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref> when you assign it and the conversion method is called. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" line="642" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" bodystart="680" bodyend="685"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a1b9689c4629a14843a0464a0053c8e9e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="classgmx_1_1SimdSetZeroProxyInternal" kindref="compound">SimdSetZeroProxyInternal</ref> gmx_simdcall</type>
        <definition>static const SimdSetZeroProxyInternal gmx_simdcall gmx::setZero</definition>
        <argsstring>()</argsstring>
        <name>setZero</name>
        <briefdescription>
<para>Proxy object to set any SIMD or scalar variable to zero. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>Proxy object that will call the actual function to set a SIMD/scalar variable to zero based on the conversion function called when you assign the result. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" line="691" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd.h" bodystart="745" bodyend="748"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Single precision SIMD math functions</header>
      <description><para><simplesect kind="note"><para>In most cases you should use the real-precision functions instead. </para></simplesect>
</para></description>
      <memberdef kind="function" id="group__module__simd_1gacb8a1939549a71a3c2861de9ce865301" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::copysign</definition>
        <argsstring>(SimdFloat x, SimdFloat y)</argsstring>
        <name>copysign</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>y</declname>
        </param>
        <briefdescription>
<para>Composes floating point value with the magnitude of x and the sign of y. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Values to set sign for </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>Values used to set sign </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Magnitude of x, sign of y </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="102" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="102" bodyend="109"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gade7401625051e95c057a8f5fe6dc5fbc" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::rsqrtIter</definition>
        <argsstring>(SimdFloat lu, SimdFloat x)</argsstring>
        <name>rsqrtIter</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>lu</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Perform one Newton-Raphson iteration to improve 1/sqrt(x) for SIMD float. </para>        </briefdescription>
        <detaileddescription>
<para>This is a low-level routine that should only be used by SIMD math routine that evaluates the inverse square root.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>lu</parametername>
</parameternamelist>
<parameterdescription>
<para>Approximation of 1/sqrt(x), typically obtained from lookup. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The reference (starting) value x for which we want 1/sqrt(x). </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An improved approximation with roughly twice as many bits of accuracy. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="123" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="123" bodyend="129"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga1bf9fd932f39d4ad83b360395f1c3986" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::invsqrt</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>invsqrt</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate 1/sqrt(x) for SIMD float. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be &gt;0. This routine does not check arguments. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/sqrt(x). Result is undefined if your argument was invalid. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="138" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="138" bodyend="151"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga2a4b0a1815e2a09330e4e61444b3f630" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::invsqrtPair</definition>
        <argsstring>(SimdFloat x0, SimdFloat x1, SimdFloat *out0, SimdFloat *out1)</argsstring>
        <name>invsqrtPair</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>out0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>out1</declname>
        </param>
        <briefdescription>
<para>Calculate 1/sqrt(x) for two SIMD floats. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x0</parametername>
</parameternamelist>
<parameterdescription>
<para>First set of arguments, x0 must be positive - no argument checking. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x1</parametername>
</parameternamelist>
<parameterdescription>
<para>Second set of arguments, x1 must be positive - no argument checking. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out0</parametername>
</parameternamelist>
<parameterdescription>
<para>Result 1/sqrt(x0) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out1</parametername>
</parameternamelist>
<parameterdescription>
<para>Result 1/sqrt(x1)</para></parameterdescription>
</parameteritem>
</parameterlist>
In particular for double precision we can sometimes calculate square root pairs slightly faster by using single precision until the very last step. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="164" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="164" bodyend="169"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga85e439a79e5b92d8544451b8c1ba41f5" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::rcpIter</definition>
        <argsstring>(SimdFloat lu, SimdFloat x)</argsstring>
        <name>rcpIter</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>lu</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Perform one Newton-Raphson iteration to improve 1/x for SIMD float. </para>        </briefdescription>
        <detaileddescription>
<para>This is a low-level routine that should only be used by SIMD math routine that evaluates the reciprocal.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>lu</parametername>
</parameternamelist>
<parameterdescription>
<para>Approximation of 1/x, typically obtained from lookup. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The reference (starting) value x for which we want 1/x. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An improved approximation with roughly twice as many bits of accuracy. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="182" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="182" bodyend="185"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga6a3c6ca88a6073aba3eb600da20cc92b" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::inv</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>inv</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate 1/x for SIMD float. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be nonzero. This routine does not check arguments. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/x. Result is undefined if your argument was invalid. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="194" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="194" bodyend="207"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga0f60c988e122306d212679a83bd12910" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::operator/</definition>
        <argsstring>(SimdFloat nom, SimdFloat denom)</argsstring>
        <name>operator/</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>nom</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>denom</declname>
        </param>
        <briefdescription>
<para>Division for SIMD floats. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>nom</parametername>
</parameternamelist>
<parameterdescription>
<para>Nominator </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>denom</parametername>
</parameternamelist>
<parameterdescription>
<para>Denominator</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>nom/denom</para></simplesect>
<simplesect kind="note"><para>This function does not use any masking to avoid problems with zero values in the denominator. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="220" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="220" bodyend="223"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gab41aa57f986f3983040e5f589e3eb07c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
        <definition>static SimdFloat gmx::maskzInvsqrt</definition>
        <argsstring>(SimdFloat x, SimdFBool m)</argsstring>
        <name>maskzInvsqrt</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref></type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Calculate 1/sqrt(x) for masked entries of SIMD float. </para>        </briefdescription>
        <detaileddescription>
<para>This routine only evaluates 1/sqrt(x) for elements for which mask is true. Illegal values in the masked-out elements will not lead to floating-point exceptions.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be &gt;0 for masked-in entries </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/sqrt(x). Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="237" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="237" bodyend="250"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gae1968e5334b953108c682435b6e59694" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::maskzInv</definition>
        <argsstring>(SimdFloat x, SimdFBool m)</argsstring>
        <name>maskzInv</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref></type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Calculate 1/x for SIMD float, masked version. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be nonzero for non-masked entries. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/x for elements where m is true, or 0.0 for masked-out entries. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="259" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="259" bodyend="272"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga1d2c28e41df6d892f3d043868337d1f7" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::sqrt</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>sqrt</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate sqrt(x) correctly for SIMD floats, including argument 0.0. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be &gt;=0. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>sqrt(x). If x=0, the result will correctly be set to 0. The result is undefined if the input value is negative. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="281" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="281" bodyend="285"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga332f838e799c55c26e23126ea2aeace5" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::log</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>log</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float log(x). This is the natural logarithm. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument, should be &gt;0. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The natural logarithm of x. Undefined if argument is invalid. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="294" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="294" bodyend="327"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga1b3445fee9da86cf6b12f6b378f402ce" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::exp2</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>exp2</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float 2^x. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>2^x. Undefined if input argument caused overflow. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="337" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="337" bodyend="368"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gaf3ae8db3847b4c3ba765f6b9b51e6c80" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::exp</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>exp</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float exp(x). </para>        </briefdescription>
        <detaileddescription>
<para>In addition to scaling the argument for 2^x this routine correctly does extended precision arithmetics to improve accuracy.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>exp(x). Undefined if input argument caused overflow, which can happen if abs(x) &gt; 7e13. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="382" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="382" bodyend="417"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga60e354f86286dc5b7620f6bc663bb089" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::erf</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>erf</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float erf(x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to calculate erf(x) for. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>erf(x)</para></simplesect>
This routine achieves very close to full precision, but we do not care about the last bit or the subnormal result range. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="429" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="429" bodyend="535"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga1e169e3f45d0532ab2350daad387ca57" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::erfc</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>erfc</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float erfc(x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to calculate erfc(x) for. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>erfc(x)</para></simplesect>
This routine achieves full precision (bar the last bit) over most of the input range, but for large arguments where the result is getting close to the minimum representable numbers we accept slightly larger errors (think results that are in the ballpark of 10^-30 for single precision) since that is not relevant for MD. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="549" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="549" bodyend="712"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga2640bfdb9db1762df1b5da82d80e73b8" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::sincos</definition>
        <argsstring>(SimdFloat x, SimdFloat *sinval, SimdFloat *cosval)</argsstring>
        <name>sincos</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>sinval</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>cosval</declname>
        </param>
        <briefdescription>
<para>SIMD float sin &amp; cos. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate sin/cos for </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">sinval</parametername>
</parameternamelist>
<parameterdescription>
<para>Sin(x) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">cosval</parametername>
</parameternamelist>
<parameterdescription>
<para>Cos(x)</para></parameterdescription>
</parameteritem>
</parameterlist>
This version achieves close to machine precision, but for very large magnitudes of the argument we inherently begin to lose accuracy due to the argument reduction, despite using extended precision arithmetics internally. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="725" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="725" bodyend="834"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga9ef875418e7985b298af5f6d58f32e23" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::sin</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>sin</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float sin(x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate sin for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Sin(x)</para></simplesect>
<simplesect kind="attention"><para>Do NOT call both sin &amp; cos if you need both results, since each of them will then call <ref refid="namespacegmx_1a3191310c1a122aafe946f0caf2fdf364" kindref="member">sincos</ref> and waste a factor 2 in performance. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="845" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="845" bodyend="850"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga9c58146cc6b29eaa9756faea26eba851" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::cos</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>cos</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float cos(x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate cos for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Cos(x)</para></simplesect>
<simplesect kind="attention"><para>Do NOT call both sin &amp; cos if you need both results, since each of them will then call <ref refid="namespacegmx_1a3191310c1a122aafe946f0caf2fdf364" kindref="member">sincos</ref> and waste a factor 2 in performance. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="861" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="861" bodyend="866"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gaa9b029f69c4afa8bbe7941990507d0f5" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::tan</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>tan</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float tan(x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate tan for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Tan(x) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="874" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="874" bodyend="939"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gabad1890270f5f95bf48d2decd31c7a1a" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::asin</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>asin</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float asin(x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate asin for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Asin(x) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="947" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="947" bodyend="989"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga95f617b5ff9a30dde812f59c8c50bab4" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::acos</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>acos</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float acos(x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate acos for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Acos(x) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="997" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="997" bodyend="1024"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gac4afec2509b0edcdae7fe2ddfc2f3ecc" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::atan</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>atan</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float asin(x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate atan for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Atan(x), same argument/value range as standard math library. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="1032" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="1032" bodyend="1068"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga7f1a591557aea01675643b86653ca136" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::atan2</definition>
        <argsstring>(SimdFloat y, SimdFloat x)</argsstring>
        <name>atan2</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>y</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float atan2(y,x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>Y component of vector, any quartile </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>X component of vector, any quartile </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Atan(y,x), same argument/value range as standard math library.</para></simplesect>
<simplesect kind="note"><para>This routine should provide correct results for all finite non-zero or positive-zero arguments. However, negative zero arguments will be treated as positive zero, which means the return value will deviate from the standard math library atan2(y,x) for those cases. That should not be of any concern in Gromacs, and in particular it will not affect calculations of angles from vectors. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="1084" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="1084" bodyend="1108"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gae7ea15fc154a3be2831f786b660b8a6c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::pmeForceCorrection</definition>
        <argsstring>(SimdFloat z2)</argsstring>
        <name>pmeForceCorrection</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>z2</declname>
        </param>
        <briefdescription>
<para>Calculate the force correction due to PME analytically in SIMD float. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>z2</parametername>
</parameternamelist>
<parameterdescription>
<para><formula id="19">$(r \beta)^2$</formula> - see below for details. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Correction factor to coulomb force - see below for details.</para></simplesect>
This routine is meant to enable analytical evaluation of the direct-space PME electrostatic force to avoid tables.</para><para>The direct-space potential should be <formula id="20">$ \mbox{erfc}(\beta r)/r$</formula>, but there are some problems evaluating that:</para><para>First, the error function is difficult (read: expensive) to approxmiate accurately for intermediate to large arguments, and this happens already in ranges of <formula id="21">$(\beta r)$</formula> that occur in simulations. Second, we now try to avoid calculating potentials in Gromacs but use forces directly.</para><para>We can simply things slight by noting that the PME part is really a correction to the normal Coulomb force since <formula id="22">$\mbox{erfc}(z)=1-\mbox{erf}(z)$</formula>, i.e. <formula id="23">\[ V = \frac{1}{r} - \frac{\mbox{erf}(\beta r)}{r} \]</formula> The first term we already have from the inverse square root, so that we can leave out of this routine.</para><para>For pme tolerances of 1e-3 to 1e-8 and cutoffs of 0.5nm to 1.8nm, the argument <formula id="24">$beta r$</formula> will be in the range 0.15 to ~4, which is the range used for the minimax fit. Use your favorite plotting program to realize how well-behaved <formula id="25">$\frac{\mbox{erf}(z)}{z}$</formula> is in this range!</para><para>We approximate <formula id="26">$f(z)=\mbox{erf}(z)/z$</formula> with a rational minimax polynomial. However, it turns out it is more efficient to approximate <formula id="27">$f(z)/z$</formula> and then only use even powers. This is another minor optimization, since we actually <emphasis>want</emphasis> <formula id="27">$f(z)/z$</formula>, because it is going to be multiplied by the vector between the two atoms to get the vectorial force. The fastest flops are the ones we can avoid calculating!</para><para>So, here&apos;s how it should be used:</para><para><orderedlist>
<listitem><para>Calculate <formula id="28">$r^2$</formula>.</para></listitem><listitem><para>Multiply by <formula id="29">$\beta^2$</formula>, so you get <formula id="30">$z^2=(\beta r)^2$</formula>.</para></listitem><listitem><para>Evaluate this routine with <formula id="31">$z^2$</formula> as the argument.</para></listitem><listitem><para>The return value is the expression:</para><para><formula id="32">\[ \frac{2 \exp{-z^2}}{\sqrt{\pi} z^2}-\frac{\mbox{erf}(z)}{z^3} \]</formula></para></listitem><listitem><para>Multiply the entire expression by <formula id="33">$\beta^3$</formula>. This will get you</para><para><formula id="34">\[ \frac{2 \beta^3 \exp(-z^2)}{\sqrt{\pi} z^2} - \frac{\beta^3 \mbox{erf}(z)}{z^3} \]</formula></para><para>or, switching back to <formula id="35">$r$</formula> (since <formula id="36">$z=r \beta$</formula>):</para><para><formula id="37">\[ \frac{2 \beta \exp(-r^2 \beta^2)}{\sqrt{\pi} r^2} - \frac{\mbox{erf}(r \beta)}{r^3} \]</formula></para><para>With a bit of math exercise you should be able to confirm that this is exactly</para><para><formula id="38">\[ \frac{\frac{d}{dr}\left( \frac{\mbox{erf}(\beta r)}{r} \right)}{r} \]</formula></para></listitem><listitem><para>Add the result to <formula id="39">$r^{-3}$</formula>, multiply by the product of the charges, and you have your force (divided by <formula id="35">$r$</formula>). A final multiplication with the vector connecting the two particles and you have your vectorial force to add to the particles.</para></listitem></orderedlist>
</para><para>This approximation achieves an error slightly lower than 1e-6 in single precision and 1e-11 in double precision for arguments smaller than 16 ( <formula id="40">$\beta r \leq 4 $</formula>); when added to <formula id="41">$1/r$</formula> the error will be insignificant. For <formula id="42">$\beta r \geq 7206$</formula> the return value can be inf or NaN. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="1190" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="1190" bodyend="1226"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga5324a396c60387bdb3cf42e734f6b465" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::pmePotentialCorrection</definition>
        <argsstring>(SimdFloat z2)</argsstring>
        <name>pmePotentialCorrection</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>z2</declname>
        </param>
        <briefdescription>
<para>Calculate the potential correction due to PME analytically in SIMD float. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>z2</parametername>
</parameternamelist>
<parameterdescription>
<para><formula id="19">$(r \beta)^2$</formula> - see below for details. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Correction factor to coulomb potential - see below for details.</para></simplesect>
See <ref refid="namespacegmx_1a1e5b1230d0301fa6760e34d7641ca7e4" kindref="member">pmeForceCorrection</ref> for details about the approximation.</para><para>This routine calculates <formula id="43">$\mbox{erf}(z)/z$</formula>, although you should provide <formula id="31">$z^2$</formula> as the input argument.</para><para>Here&apos;s how it should be used:</para><para><orderedlist>
<listitem><para>Calculate <formula id="28">$r^2$</formula>.</para></listitem><listitem><para>Multiply by <formula id="29">$\beta^2$</formula>, so you get <formula id="44">$z^2=\beta^2*r^2$</formula>.</para></listitem><listitem><para>Evaluate this routine with z^2 as the argument.</para></listitem><listitem><para>The return value is the expression:</para><para><formula id="45">\[ \frac{\mbox{erf}(z)}{z} \]</formula></para></listitem><listitem><para>Multiply the entire expression by beta and switching back to <formula id="35">$r$</formula> (since <formula id="36">$z=r \beta$</formula>):</para><para><formula id="46">\[ \frac{\mbox{erf}(r \beta)}{r} \]</formula></para></listitem><listitem><para>Subtract the result from <formula id="41">$1/r$</formula>, multiply by the product of the charges, and you have your potential.</para></listitem></orderedlist>
</para><para>This approximation achieves an error slightly lower than 1e-6 in single precision and 4e-11 in double precision for arguments smaller than 16 ( <formula id="47">$ 0.15 \leq \beta r \leq 4 $</formula>); for <formula id="48">$ \beta r \leq 0.15$</formula> the error can be twice as high; when added to <formula id="41">$1/r$</formula> the error will be insignificant. For <formula id="49">$\beta r \geq 7142$</formula> the return value can be inf or NaN. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="1268" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="1268" bodyend="1302"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Double precision SIMD math functions</header>
      <description><para><simplesect kind="note"><para>In most cases you should use the real-precision functions instead. </para></simplesect>
</para></description>
      <memberdef kind="function" id="group__module__simd_1ga3013bbebe9a43572658b37ad9b6b13be" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::copysign</definition>
        <argsstring>(SimdDouble x, SimdDouble y)</argsstring>
        <name>copysign</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>y</declname>
        </param>
        <briefdescription>
<para>Composes floating point value with the magnitude of x and the sign of y. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Values to set sign for </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>Values used to set sign </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Magnitude of x, sign of y </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="1328" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="1328" bodyend="1335"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga9dfcf89d49e6e2f75f1249972f2e270f" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::rsqrtIter</definition>
        <argsstring>(SimdDouble lu, SimdDouble x)</argsstring>
        <name>rsqrtIter</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>lu</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Perform one Newton-Raphson iteration to improve 1/sqrt(x) for SIMD double. </para>        </briefdescription>
        <detaileddescription>
<para>This is a low-level routine that should only be used by SIMD math routine that evaluates the inverse square root.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>lu</parametername>
</parameternamelist>
<parameterdescription>
<para>Approximation of 1/sqrt(x), typically obtained from lookup. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The reference (starting) value x for which we want 1/sqrt(x). </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An improved approximation with roughly twice as many bits of accuracy. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="1349" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="1349" bodyend="1355"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gae7e05436d95febdcc32866b5e8eca46a" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::invsqrt</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>invsqrt</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate 1/sqrt(x) for SIMD double. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be &gt;0. This routine does not check arguments. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/sqrt(x). Result is undefined if your argument was invalid. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="1364" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="1364" bodyend="1380"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga4a20afb3111cd1748f262a693338362b" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::invsqrtPair</definition>
        <argsstring>(SimdDouble x0, SimdDouble x1, SimdDouble *out0, SimdDouble *out1)</argsstring>
        <name>invsqrtPair</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>out0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>out1</declname>
        </param>
        <briefdescription>
<para>Calculate 1/sqrt(x) for two SIMD doubles. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x0</parametername>
</parameternamelist>
<parameterdescription>
<para>First set of arguments, x0 must be positive - no argument checking. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x1</parametername>
</parameternamelist>
<parameterdescription>
<para>Second set of arguments, x1 must be positive - no argument checking. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out0</parametername>
</parameternamelist>
<parameterdescription>
<para>Result 1/sqrt(x0) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out1</parametername>
</parameternamelist>
<parameterdescription>
<para>Result 1/sqrt(x1)</para></parameterdescription>
</parameteritem>
</parameterlist>
In particular for double precision we can sometimes calculate square root pairs slightly faster by using single precision until the very last step. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="1393" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="1393" bodyend="1426"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gaa0f0ffc8730b377743e0b5433d4e2f1a" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::rcpIter</definition>
        <argsstring>(SimdDouble lu, SimdDouble x)</argsstring>
        <name>rcpIter</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>lu</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Perform one Newton-Raphson iteration to improve 1/x for SIMD double. </para>        </briefdescription>
        <detaileddescription>
<para>This is a low-level routine that should only be used by SIMD math routine that evaluates the reciprocal.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>lu</parametername>
</parameternamelist>
<parameterdescription>
<para>Approximation of 1/x, typically obtained from lookup. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The reference (starting) value x for which we want 1/x. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An improved approximation with roughly twice as many bits of accuracy. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="1439" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="1439" bodyend="1442"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga698c7785928f003a6f8f0218550ef3af" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::inv</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>inv</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate 1/x for SIMD double. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be nonzero. This routine does not check arguments. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/x. Result is undefined if your argument was invalid. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="1451" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="1451" bodyend="1467"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga0d5275903c74226798172bd46bac3e87" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::operator/</definition>
        <argsstring>(SimdDouble nom, SimdDouble denom)</argsstring>
        <name>operator/</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>nom</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>denom</declname>
        </param>
        <briefdescription>
<para>Division for SIMD doubles. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>nom</parametername>
</parameternamelist>
<parameterdescription>
<para>Nominator </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>denom</parametername>
</parameternamelist>
<parameterdescription>
<para>Denominator</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>nom/denom</para></simplesect>
<simplesect kind="note"><para>This function does not use any masking to avoid problems with zero values in the denominator. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="1480" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="1480" bodyend="1483"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga3342ee008526f40deb602eb1024ba895" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
        <definition>static SimdDouble gmx::maskzInvsqrt</definition>
        <argsstring>(SimdDouble x, SimdDBool m)</argsstring>
        <name>maskzInvsqrt</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref></type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Calculate 1/sqrt(x) for masked entries of SIMD double. </para>        </briefdescription>
        <detaileddescription>
<para>This routine only evaluates 1/sqrt(x) for elements for which mask is true. Illegal values in the masked-out elements will not lead to floating-point exceptions.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be &gt;0 for masked-in entries </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/sqrt(x). Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="1498" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="1498" bodyend="1514"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga91e427c6575308730c135fb8de51a7c9" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::maskzInv</definition>
        <argsstring>(SimdDouble x, SimdDBool m)</argsstring>
        <name>maskzInv</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref></type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Calculate 1/x for SIMD double, masked version. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be nonzero for non-masked entries. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/x for elements where m is true, or 0.0 for masked-out entries. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="1523" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="1523" bodyend="1539"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga79fb2a08a687e05eb88794a3fe2bd4f0" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::sqrt</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>sqrt</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate sqrt(x) correctly for SIMD doubles, including argument 0.0. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be &gt;=0. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>sqrt(x). If x=0, the result will correctly be set to 0. The result is undefined if the input value is negative. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="1549" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="1549" bodyend="1552"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga2b6148113de97d3d9e2c9340c72debae" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::log</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>log</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD double log(x). This is the natural logarithm. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument, should be &gt;0. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The natural logarithm of x. Undefined if argument is invalid. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="1561" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="1561" bodyend="1600"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga47973fa75d633ed078827a63b037ec5e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::exp2</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>exp2</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD double 2^x. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>2^x. Undefined if input argument caused overflow. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="1610" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="1610" bodyend="1650"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga025472567a0e3e8aea57fed6bc01398c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::exp</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>exp</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD double exp(x). </para>        </briefdescription>
        <detaileddescription>
<para>In addition to scaling the argument for 2^x this routine correctly does extended precision arithmetics to improve accuracy.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>exp(x). Undefined if input argument caused overflow, which can happen if abs(x) &gt; 7e13. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="1664" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="1664" bodyend="1711"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga900477ac8042bfd9d6c85a06e3f003c8" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::erf</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>erf</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD double erf(x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to calculate erf(x) for. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>erf(x)</para></simplesect>
This routine achieves very close to full precision, but we do not care about the last bit or the subnormal result range. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="1723" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="1723" bodyend="1870"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gabd11e43f0479bca8e5b9d58b73307ae6" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::erfc</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>erfc</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD double erfc(x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to calculate erfc(x) for. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>erfc(x)</para></simplesect>
This routine achieves full precision (bar the last bit) over most of the input range, but for large arguments where the result is getting close to the minimum representable numbers we accept slightly larger errors (think results that are in the ballpark of 10^-200 for double) since that is not relevant for MD. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="1884" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="1884" bodyend="2030"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga532aa17b3c80780baf5c123eb64cf645" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::sincos</definition>
        <argsstring>(SimdDouble x, SimdDouble *sinval, SimdDouble *cosval)</argsstring>
        <name>sincos</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>sinval</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>cosval</declname>
        </param>
        <briefdescription>
<para>SIMD double sin &amp; cos. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate sin/cos for </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">sinval</parametername>
</parameternamelist>
<parameterdescription>
<para>Sin(x) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">cosval</parametername>
</parameternamelist>
<parameterdescription>
<para>Cos(x)</para></parameterdescription>
</parameteritem>
</parameterlist>
This version achieves close to machine precision, but for very large magnitudes of the argument we inherently begin to lose accuracy due to the argument reduction, despite using extended precision arithmetics internally. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="2043" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="2043" bodyend="2165"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gab860ef109b42bb7e0ce25bdc304e8492" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::sin</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>sin</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD double sin(x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate sin for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Sin(x)</para></simplesect>
<simplesect kind="attention"><para>Do NOT call both sin &amp; cos if you need both results, since each of them will then call <ref refid="namespacegmx_1a3191310c1a122aafe946f0caf2fdf364" kindref="member">sincos</ref> and waste a factor 2 in performance. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="2176" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="2176" bodyend="2181"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga4fb04efe2288b65a54c4e8fd5585f125" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::cos</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>cos</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD double cos(x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate cos for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Cos(x)</para></simplesect>
<simplesect kind="attention"><para>Do NOT call both sin &amp; cos if you need both results, since each of them will then call <ref refid="namespacegmx_1a3191310c1a122aafe946f0caf2fdf364" kindref="member">sincos</ref> and waste a factor 2 in performance. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="2192" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="2192" bodyend="2197"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga9f1b0a83035fb507f2827fb510fcf084" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::tan</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>tan</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD double tan(x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate tan for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Tan(x) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="2205" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="2205" bodyend="2289"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gafc20a60ae6b0e838d65d127e944effbb" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::asin</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>asin</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD double asin(x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate asin for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Asin(x) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="2297" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="2297" bodyend="2400"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga5459281155e8be7fd6356c5e366acb0e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::acos</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>acos</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD double acos(x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate acos for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Acos(x) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="2408" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="2408" bodyend="2434"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga0e327fdca86999b2716b5109621b1936" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::atan</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>atan</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD double asin(x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate atan for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Atan(x), same argument/value range as standard math library. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="2442" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="2442" bodyend="2511"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gae3d1e53759871924024fc4bfa8cd7e41" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::atan2</definition>
        <argsstring>(SimdDouble y, SimdDouble x)</argsstring>
        <name>atan2</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>y</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD double atan2(y,x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>Y component of vector, any quartile </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>X component of vector, any quartile </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Atan(y,x), same argument/value range as standard math library.</para></simplesect>
<simplesect kind="note"><para>This routine should provide correct results for all finite non-zero or positive-zero arguments. However, negative zero arguments will be treated as positive zero, which means the return value will deviate from the standard math library atan2(y,x) for those cases. That should not be of any concern in Gromacs, and in particular it will not affect calculations of angles from vectors. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="2527" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="2527" bodyend="2551"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gad35bd0d2751d6097b63b26b7077ad53c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::pmeForceCorrection</definition>
        <argsstring>(SimdDouble z2)</argsstring>
        <name>pmeForceCorrection</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>z2</declname>
        </param>
        <briefdescription>
<para>Calculate the force correction due to PME analytically in SIMD double. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>z2</parametername>
</parameternamelist>
<parameterdescription>
<para>This should be the value <formula id="19">$(r \beta)^2$</formula>, where r is your interaction distance and beta the ewald splitting parameters. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Correction factor to coulomb force.</para></simplesect>
This routine is meant to enable analytical evaluation of the direct-space PME electrostatic force to avoid tables. For details, see the single precision function. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="2565" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="2565" bodyend="2613"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga6e52f9306e036285c0a9ac5f55565cc0" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::pmePotentialCorrection</definition>
        <argsstring>(SimdDouble z2)</argsstring>
        <name>pmePotentialCorrection</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>z2</declname>
        </param>
        <briefdescription>
<para>Calculate the potential correction due to PME analytically in SIMD double. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>z2</parametername>
</parameternamelist>
<parameterdescription>
<para>This should be the value <formula id="19">$(r \beta)^2$</formula>, where r is your interaction distance and beta the ewald splitting parameters. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Correction factor to coulomb force.</para></simplesect>
This routine is meant to enable analytical evaluation of the direct-space PME electrostatic potential to avoid tables. For details, see the single precision function. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="2628" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="2628" bodyend="2672"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>SIMD math functions for double prec. data, single prec. accuracy</header>
      <description><para><simplesect kind="note"><para>In some cases we do not need full double accuracy of individual SIMD math functions, although the data is stored in double precision SIMD registers. This might be the case for special algorithms, or if the architecture does not support single precision. Since the full double precision evaluation of math functions typically require much more expensive polynomial approximations these functions implement the algorithms used in the single precision SIMD math functions, but they operate on double precision SIMD variables. </para></simplesect>
</para></description>
      <memberdef kind="function" id="group__module__simd_1ga539e3c6e2f58dbd5e59d444707237691" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::invsqrtSingleAccuracy</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>invsqrtSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate 1/sqrt(x) for SIMD double, but in single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be &gt;0. This routine does not check arguments. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/sqrt(x). Result is undefined if your argument was invalid. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="2702" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="2702" bodyend="2715"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga19373a6a16b4e74441b86bdcabe1bbcb" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
        <definition>static SimdDouble gmx::maskzInvsqrtSingleAccuracy</definition>
        <argsstring>(SimdDouble x, SimdDBool m)</argsstring>
        <name>maskzInvsqrtSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref></type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>1/sqrt(x) for masked-in entries of SIMD double, but in single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para>This routine only evaluates 1/sqrt(x) for elements for which mask is true. Illegal values in the masked-out elements will not lead to floating-point exceptions.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be &gt;0 for masked-in entries </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/sqrt(x). Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="2729" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="2729" bodyend="2742"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga0cde0a4bdb349db5235f05fc93c0441d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::invsqrtPairSingleAccuracy</definition>
        <argsstring>(SimdDouble x0, SimdDouble x1, SimdDouble *out0, SimdDouble *out1)</argsstring>
        <name>invsqrtPairSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>out0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>out1</declname>
        </param>
        <briefdescription>
<para>Calculate 1/sqrt(x) for two SIMD doubles, but single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x0</parametername>
</parameternamelist>
<parameterdescription>
<para>First set of arguments, x0 must be positive - no argument checking. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x1</parametername>
</parameternamelist>
<parameterdescription>
<para>Second set of arguments, x1 must be positive - no argument checking. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out0</parametername>
</parameternamelist>
<parameterdescription>
<para>Result 1/sqrt(x0) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out1</parametername>
</parameternamelist>
<parameterdescription>
<para>Result 1/sqrt(x1)</para></parameterdescription>
</parameteritem>
</parameterlist>
In particular for double precision we can sometimes calculate square root pairs slightly faster by using single precision until the very last step. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="2755" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="2755" bodyend="2780"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gad500e0cd00f7c9a8b65448d3a428c57d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::invSingleAccuracy</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>invSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate 1/x for SIMD double, but in single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be nonzero. This routine does not check arguments. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/x. Result is undefined if your argument was invalid. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="2788" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="2788" bodyend="2801"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gaed815c342f2554cecb7045da5ba52e57" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::maskzInvSingleAccuracy</definition>
        <argsstring>(SimdDouble x, SimdDBool m)</argsstring>
        <name>maskzInvSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDBool" kindref="compound">SimdDBool</ref></type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>1/x for masked entries of SIMD double, single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be nonzero for non-masked entries. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/x for elements where m is true, or 0.0 for masked-out entries. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="2810" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="2810" bodyend="2823"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gaf0240b2f28c94cad4a6ece5706eada40" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::sqrtSingleAccuracy</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>sqrtSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate sqrt(x) (correct for 0.0) for SIMD double, single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be &gt;=0. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>sqrt(x). If x=0, the result will correctly be set to 0. The result is undefined if the input value is negative. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="2833" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="2833" bodyend="2836"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga29dcfc4f360ed173f66b26ad9ac3b28b" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::logSingleAccuracy</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>logSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD log(x). Double precision SIMD data, single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument, should be &gt;0. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The natural logarithm of x. Undefined if argument is invalid. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="2844" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="2844" bodyend="2877"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gac779f45cfb482be57cfc674d1828971f" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::exp2SingleAccuracy</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>exp2SingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD 2^x. Double precision SIMD data, single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>2^x. Undefined if input argument caused overflow. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="2885" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="2885" bodyend="2917"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gaba7463d0b0ed07d1eb1e3e08d4558e83" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::expSingleAccuracy</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>expSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD exp(x). Double precision SIMD data, single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>exp(x). Undefined if input argument caused overflow. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="2925" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="2925" bodyend="2960"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gac6ce232cb0593b32dc9789e04679bc6c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::erfSingleAccuracy</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>erfSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD erf(x). Double precision SIMD data, single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to calculate erf(x) for. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>erf(x)</para></simplesect>
This routine achieves very close to single precision, but we do not care about the last bit or the subnormal result range. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="2971" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="2971" bodyend="3076"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gae8d996acb25e6bdb2d08ca2b26bb19c3" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::erfcSingleAccuracy</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>erfcSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD erfc(x). Double precision SIMD data, single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to calculate erfc(x) for. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>erfc(x)</para></simplesect>
This routine achieves singleprecision (bar the last bit) over most of the input range, but for large arguments where the result is getting close to the minimum representable numbers we accept slightly larger errors (think results that are in the ballpark of 10^-30) since that is not relevant for MD. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="3090" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="3090" bodyend="3195"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga80d8d17a5843dfa4126ce3d6672d2c5d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::sinCosSingleAccuracy</definition>
        <argsstring>(SimdDouble x, SimdDouble *sinval, SimdDouble *cosval)</argsstring>
        <name>sinCosSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>sinval</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>cosval</declname>
        </param>
        <briefdescription>
<para>SIMD sin &amp; cos. Double precision SIMD data, single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate sin/cos for </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">sinval</parametername>
</parameternamelist>
<parameterdescription>
<para>Sin(x) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">cosval</parametername>
</parameternamelist>
<parameterdescription>
<para>Cos(x) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="3204" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="3204" bodyend="3312"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga322afd1e05781ae2cd10ec6fdb1fb2be" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::sinSingleAccuracy</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>sinSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD sin(x). Double precision SIMD data, single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate sin for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Sin(x)</para></simplesect>
<simplesect kind="attention"><para>Do NOT call both sin &amp; cos if you need both results, since each of them will then call <ref refid="namespacegmx_1a3191310c1a122aafe946f0caf2fdf364" kindref="member">sincos</ref> and waste a factor 2 in performance. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="3323" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="3323" bodyend="3328"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga1b867b3b628740d6f710a480626cffa8" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::cosSingleAccuracy</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>cosSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD cos(x). Double precision SIMD data, single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate cos for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Cos(x)</para></simplesect>
<simplesect kind="attention"><para>Do NOT call both sin &amp; cos if you need both results, since each of them will then call <ref refid="namespacegmx_1a3191310c1a122aafe946f0caf2fdf364" kindref="member">sincos</ref> and waste a factor 2 in performance. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="3339" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="3339" bodyend="3344"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga97094c3429db78b1a101aa994a69f162" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::tanSingleAccuracy</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>tanSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD tan(x). Double precision SIMD data, single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate tan for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Tan(x) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="3352" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="3352" bodyend="3415"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga7e098546fed7424b9c449588ebb84252" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::asinSingleAccuracy</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>asinSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD asin(x). Double precision SIMD data, single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate asin for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Asin(x) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="3423" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="3423" bodyend="3465"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga73027d18d5366998dbf0af8c52f68b60" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::acosSingleAccuracy</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>acosSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD acos(x). Double precision SIMD data, single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate acos for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Acos(x) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="3473" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="3473" bodyend="3500"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga39be2b2651b8a68340c2132becf1c372" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::atanSingleAccuracy</definition>
        <argsstring>(SimdDouble x)</argsstring>
        <name>atanSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD asin(x). Double precision SIMD data, single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate atan for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Atan(x), same argument/value range as standard math library. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="3508" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="3508" bodyend="3543"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga193d8e790944928be53940809d6f2385" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::atan2SingleAccuracy</definition>
        <argsstring>(SimdDouble y, SimdDouble x)</argsstring>
        <name>atan2SingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>y</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD atan2(y,x). Double precision SIMD data, single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>Y component of vector, any quartile </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>X component of vector, any quartile </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Atan(y,x), same argument/value range as standard math library.</para></simplesect>
<simplesect kind="note"><para>This routine should provide correct results for all finite non-zero or positive-zero arguments. However, negative zero arguments will be treated as positive zero, which means the return value will deviate from the standard math library atan2(y,x) for those cases. That should not be of any concern in Gromacs, and in particular it will not affect calculations of angles from vectors. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="3559" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="3559" bodyend="3583"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga7c64f03842963e248fba796bead3c5ce" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::pmeForceCorrectionSingleAccuracy</definition>
        <argsstring>(SimdDouble z2)</argsstring>
        <name>pmeForceCorrectionSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>z2</declname>
        </param>
        <briefdescription>
<para>Analytical PME force correction, double SIMD data, single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>z2</parametername>
</parameternamelist>
<parameterdescription>
<para><formula id="19">$(r \beta)^2$</formula> - see below for details. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Correction factor to coulomb force - see below for details.</para></simplesect>
This routine is meant to enable analytical evaluation of the direct-space PME electrostatic force to avoid tables.</para><para>The direct-space potential should be <formula id="20">$ \mbox{erfc}(\beta r)/r$</formula>, but there are some problems evaluating that:</para><para>First, the error function is difficult (read: expensive) to approxmiate accurately for intermediate to large arguments, and this happens already in ranges of <formula id="21">$(\beta r)$</formula> that occur in simulations. Second, we now try to avoid calculating potentials in Gromacs but use forces directly.</para><para>We can simply things slight by noting that the PME part is really a correction to the normal Coulomb force since <formula id="22">$\mbox{erfc}(z)=1-\mbox{erf}(z)$</formula>, i.e. <formula id="23">\[ V = \frac{1}{r} - \frac{\mbox{erf}(\beta r)}{r} \]</formula> The first term we already have from the inverse square root, so that we can leave out of this routine.</para><para>For pme tolerances of 1e-3 to 1e-8 and cutoffs of 0.5nm to 1.8nm, the argument <formula id="24">$beta r$</formula> will be in the range 0.15 to ~4. Use your favorite plotting program to realize how well-behaved <formula id="25">$\frac{\mbox{erf}(z)}{z}$</formula> is in this range!</para><para>We approximate <formula id="26">$f(z)=\mbox{erf}(z)/z$</formula> with a rational minimax polynomial. However, it turns out it is more efficient to approximate <formula id="27">$f(z)/z$</formula> and then only use even powers. This is another minor optimization, since we actually <emphasis>want</emphasis> <formula id="27">$f(z)/z$</formula>, because it is going to be multiplied by the vector between the two atoms to get the vectorial force. The fastest flops are the ones we can avoid calculating!</para><para>So, here&apos;s how it should be used:</para><para><orderedlist>
<listitem><para>Calculate <formula id="28">$r^2$</formula>.</para></listitem><listitem><para>Multiply by <formula id="29">$\beta^2$</formula>, so you get <formula id="30">$z^2=(\beta r)^2$</formula>.</para></listitem><listitem><para>Evaluate this routine with <formula id="31">$z^2$</formula> as the argument.</para></listitem><listitem><para>The return value is the expression:</para><para><formula id="32">\[ \frac{2 \exp{-z^2}}{\sqrt{\pi} z^2}-\frac{\mbox{erf}(z)}{z^3} \]</formula></para></listitem><listitem><para>Multiply the entire expression by <formula id="33">$\beta^3$</formula>. This will get you</para><para><formula id="34">\[ \frac{2 \beta^3 \exp(-z^2)}{\sqrt{\pi} z^2} - \frac{\beta^3 \mbox{erf}(z)}{z^3} \]</formula></para><para>or, switching back to <formula id="35">$r$</formula> (since <formula id="36">$z=r \beta$</formula>):</para><para><formula id="37">\[ \frac{2 \beta \exp(-r^2 \beta^2)}{\sqrt{\pi} r^2} - \frac{\mbox{erf}(r \beta)}{r^3} \]</formula></para><para>With a bit of math exercise you should be able to confirm that this is exactly</para><para><formula id="38">\[ \frac{\frac{d}{dr}\left( \frac{\mbox{erf}(\beta r)}{r} \right)}{r} \]</formula></para></listitem><listitem><para>Add the result to <formula id="39">$r^{-3}$</formula>, multiply by the product of the charges, and you have your force (divided by <formula id="35">$r$</formula>). A final multiplication with the vector connecting the two particles and you have your vectorial force to add to the particles.</para></listitem></orderedlist>
</para><para>This approximation achieves an accuracy slightly lower than 1e-6; when added to <formula id="41">$1/r$</formula> the error will be insignificant. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="3662" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="3662" bodyend="3698"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gad079618800dfdfb943ca73f89f63d45e" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::pmePotentialCorrectionSingleAccuracy</definition>
        <argsstring>(SimdDouble z2)</argsstring>
        <name>pmePotentialCorrectionSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>z2</declname>
        </param>
        <briefdescription>
<para>Analytical PME potential correction, double SIMD data, single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>z2</parametername>
</parameternamelist>
<parameterdescription>
<para><formula id="19">$(r \beta)^2$</formula> - see below for details. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Correction factor to coulomb potential - see below for details.</para></simplesect>
This routine calculates <formula id="43">$\mbox{erf}(z)/z$</formula>, although you should provide <formula id="31">$z^2$</formula> as the input argument.</para><para>Here&apos;s how it should be used:</para><para><orderedlist>
<listitem><para>Calculate <formula id="28">$r^2$</formula>.</para></listitem><listitem><para>Multiply by <formula id="29">$\beta^2$</formula>, so you get <formula id="44">$z^2=\beta^2*r^2$</formula>.</para></listitem><listitem><para>Evaluate this routine with z^2 as the argument.</para></listitem><listitem><para>The return value is the expression:</para><para><formula id="45">\[ \frac{\mbox{erf}(z)}{z} \]</formula></para></listitem><listitem><para>Multiply the entire expression by beta and switching back to <formula id="35">$r$</formula> (since <formula id="36">$z=r \beta$</formula>):</para><para><formula id="46">\[ \frac{\mbox{erf}(r \beta)}{r} \]</formula></para></listitem><listitem><para>Subtract the result from <formula id="41">$1/r$</formula>, multiply by the product of the charges, and you have your potential.</para></listitem></orderedlist>
</para><para>This approximation achieves an accuracy slightly lower than 1e-6; when added to <formula id="41">$1/r$</formula> the error will be insignificant. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="3734" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="3734" bodyend="3768"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>SIMD4 math functions</header>
      <description><para><simplesect kind="note"><para>Only a subset of the math functions are implemented for SIMD4. </para></simplesect>
</para></description>
      <memberdef kind="function" id="group__module__simd_1ga4be9c1041c5ce806e1262c9469a4a625" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::rsqrtIter</definition>
        <argsstring>(Simd4Float lu, Simd4Float x)</argsstring>
        <name>rsqrtIter</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>lu</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Perform one Newton-Raphson iteration to improve 1/sqrt(x) for SIMD4 float. </para>        </briefdescription>
        <detaileddescription>
<para>This is a low-level routine that should only be used by SIMD math routine that evaluates the inverse square root.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>lu</parametername>
</parameternamelist>
<parameterdescription>
<para>Approximation of 1/sqrt(x), typically obtained from lookup. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The reference (starting) value x for which we want 1/sqrt(x). </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An improved approximation with roughly twice as many bits of accuracy. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="3796" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="3796" bodyend="3802"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gab8ed1f98091a17221318dfd97e52c916" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::invsqrt</definition>
        <argsstring>(Simd4Float x)</argsstring>
        <name>invsqrt</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate 1/sqrt(x) for SIMD4 float. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be &gt;0. This routine does not check arguments. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/sqrt(x). Result is undefined if your argument was invalid. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="3810" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="3810" bodyend="3823"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga4b6db4a7ce63f7c3c6e7a0d3008dea6b" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::rsqrtIter</definition>
        <argsstring>(Simd4Double lu, Simd4Double x)</argsstring>
        <name>rsqrtIter</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>lu</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Perform one Newton-Raphson iteration to improve 1/sqrt(x) for SIMD4 double. </para>        </briefdescription>
        <detaileddescription>
<para>This is a low-level routine that should only be used by SIMD math routine that evaluates the inverse square root.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>lu</parametername>
</parameternamelist>
<parameterdescription>
<para>Approximation of 1/sqrt(x), typically obtained from lookup. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The reference (starting) value x for which we want 1/sqrt(x). </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An improved approximation with roughly twice as many bits of accuracy. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="3845" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="3845" bodyend="3851"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga9d84208bf91d57b70761d4c161f2f9de" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::invsqrt</definition>
        <argsstring>(Simd4Double x)</argsstring>
        <name>invsqrt</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate 1/sqrt(x) for SIMD4 double. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be &gt;0. This routine does not check arguments. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/sqrt(x). Result is undefined if your argument was invalid. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="3859" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="3859" bodyend="3875"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga0b4da22bcb5cebd8721f180626d11fbf" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::invsqrtSingleAccuracy</definition>
        <argsstring>(Simd4Double x)</argsstring>
        <name>invsqrtSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate 1/sqrt(x) for SIMD4 double, but in single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be &gt;0. This routine does not check arguments. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/sqrt(x). Result is undefined if your argument was invalid. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="3888" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="3888" bodyend="3901"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Error codes for buggy code</header>
      <description><para>Error codes below are for internal error checking; if triggered, they should indicate a bug in the code. </para></description>
      </sectiondef>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="group__module__commandline_1ga996baa646a1074569194ee226c23efae" prot="public" static="no">
        <name>ShellCompletionFormat</name>
        <enumvalue id="group__module__commandline_1gga996baa646a1074569194ee226c23efaead37d9ad080b97ba93b14096c95d722be" prot="public">
          <name>eShellCompletionFormat_Bash</name>
          <briefdescription>
<para>Shell completions for bash. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Output format for <ref refid="classgmx_1_1ShellCompletionWriter" kindref="compound">ShellCompletionWriter</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/shellcompletions.h" line="65" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/shellcompletions.h" bodystart="64" bodyend="67"/>
      </memberdef>
      <memberdef kind="enum" id="namespacegmx_1adc6936f6090da8e4cf7801c8e71ee37f" prot="public" static="no">
        <name>HelpOutputFormat</name>
        <enumvalue id="namespacegmx_1adc6936f6090da8e4cf7801c8e71ee37fa665b8486de1b34898ad6caeb20d3d179" prot="public">
          <name>eHelpOutputFormat_Console</name>
          <briefdescription>
<para>Plain text directly on the console. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1adc6936f6090da8e4cf7801c8e71ee37fa10bf3dadfe0fe221eb490caf89b4d791" prot="public">
          <name>eHelpOutputFormat_Rst</name>
          <briefdescription>
<para>reStructuredText for online manual and man pages. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1adc6936f6090da8e4cf7801c8e71ee37fa40e0858263ee116ab541df1e9fe8be81" prot="public">
          <name>eHelpOutputFormat_Other</name>
          <briefdescription>
<para>Used for extensions in other modules. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1adc6936f6090da8e4cf7801c8e71ee37fac94bcc656a16820a6b88de28eef7be68" prot="public">
          <name>eHelpOutputFormat_NR</name>
          <briefdescription>
<para>Used for the number of output formats. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para> <libinternal />  Output format for help writing. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/onlinehelp/helpwritercontext.h" line="60" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/onlinehelp/helpwritercontext.h" bodystart="59" bodyend="65"/>
      </memberdef>
      <memberdef kind="enum" id="group__module__options_1ga89f55fd684646bb146f99a8c6c18569b" prot="public" static="no">
        <name>OptionFileType</name>
        <enumvalue id="group__module__options_1gga89f55fd684646bb146f99a8c6c18569ba15e867ef140542d62b5546da5b3a6472" prot="public">
          <name>eftUnknown</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__module__options_1gga89f55fd684646bb146f99a8c6c18569bafbfe4703cea922fb349c900c6bd24014" prot="public">
          <name>eftTopology</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__module__options_1gga89f55fd684646bb146f99a8c6c18569ba8878708e3a85d820dfa321d21c1d9d2b" prot="public">
          <name>eftTrajectory</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__module__options_1gga89f55fd684646bb146f99a8c6c18569babf09eb93e898fcb08601efe82915306c" prot="public">
          <name>eftEnergy</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__module__options_1gga89f55fd684646bb146f99a8c6c18569ba9615873144b06172d135a80767b34641" prot="public">
          <name>eftPDB</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__module__options_1gga89f55fd684646bb146f99a8c6c18569bab0bb0b931760bc89531f3739665ed652" prot="public">
          <name>eftIndex</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__module__options_1gga89f55fd684646bb146f99a8c6c18569ba7ea980c4762cb4eb1ea2a2b64f5ed599" prot="public">
          <name>eftPlot</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__module__options_1gga89f55fd684646bb146f99a8c6c18569bab62caee79b490e195fad94f00029e74e" prot="public">
          <name>eftGenericData</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__module__options_1gga89f55fd684646bb146f99a8c6c18569badbac16019eee0ae7cfccbec2395e53ac" prot="public">
          <name>eftOptionFileType_NR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Purpose of file(s) provided through an option. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/options/optionfiletype.h" line="54" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/options/optionfiletype.h" bodystart="54" bodyend="64"/>
      </memberdef>
      <memberdef kind="enum" id="namespacegmx_1a3f775199bddf83f286ee8172f7dda987" prot="public" static="no">
        <name>OptionFlag</name>
        <enumvalue id="namespacegmx_1a3f775199bddf83f286ee8172f7dda987a4f1877245e691baa84f1a210c81f8f4e" prot="public">
          <name>efOption_Set</name>
          <initializer>= 1&lt;&lt;0</initializer>
          <briefdescription>
<para>Option has been set. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1a3f775199bddf83f286ee8172f7dda987a4da48601127e56bf49a2167792d693ce" prot="public">
          <name>efOption_HasDefaultValue</name>
          <initializer>= 1&lt;&lt;1</initializer>
          <briefdescription>
<para>The current value of the option is a programmatic default value. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1a3f775199bddf83f286ee8172f7dda987ac61016418af8d8a2426f494de8c9278d" prot="public">
          <name>efOption_ExplicitDefaultValue</name>
          <initializer>= 1&lt;&lt;2</initializer>
          <briefdescription>
<para>An explicit default value has been provided for the option. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1a3f775199bddf83f286ee8172f7dda987a32e377a026ebd483633dd6a4fa442c3d" prot="public">
          <name>efOption_ClearOnNextSet</name>
          <initializer>= 1&lt;&lt;3</initializer>
          <briefdescription>
<para>Next assignment to the option clears old values. </para>          </briefdescription>
          <detaileddescription>
<para>This flag is set when a new option source starts, such that values from the new source will overwrite old ones. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1a3f775199bddf83f286ee8172f7dda987afeeedad770c218f98d60c36cdc9f0bc3" prot="public">
          <name>efOption_Required</name>
          <initializer>= 1&lt;&lt;4</initializer>
          <briefdescription>
<para>Option is required to be set. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1a3f775199bddf83f286ee8172f7dda987a31719daac8b8d93c1db41332e5fa9d1f" prot="public">
          <name>efOption_MultipleTimes</name>
          <initializer>= 1&lt;&lt;5</initializer>
          <briefdescription>
<para>Option can be specified multiple times. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1a3f775199bddf83f286ee8172f7dda987ae52a5b8ffe8cd8a948fb65c787e25182" prot="public">
          <name>efOption_Hidden</name>
          <initializer>= 1&lt;&lt;6</initializer>
          <briefdescription>
<para>Option is hidden from standard help. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1a3f775199bddf83f286ee8172f7dda987a021311861537a7daa949a7733cbaec87" prot="public">
          <name>efOption_Vector</name>
          <initializer>= 1&lt;&lt;8</initializer>
          <briefdescription>
<para>Option value is a vector, but a single value is also accepted. </para>          </briefdescription>
          <detaileddescription>
<para><simplesect kind="see"><para><ref refid="classgmx_1_1AbstractOption_1ab7833e4048807e6a41ef144bdd2ec6b1" kindref="member">AbstractOption::setVector()</ref> </para></simplesect>
</para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1a3f775199bddf83f286ee8172f7dda987a6e4c2d93bdc5aca1c9d836745d0ca39f" prot="public">
          <name>efOption_DefaultValueIfSetExists</name>
          <initializer>= 1&lt;&lt;11</initializer>
          <briefdescription>
<para>Option has a defaultValueIfSet() specified. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1a3f775199bddf83f286ee8172f7dda987ad167facccde7228b8f6fe16ea97cbc4d" prot="public">
          <name>efOption_NoDefaultValue</name>
          <initializer>= 1&lt;&lt;9</initializer>
          <briefdescription>
<para>Option does not support default values. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1a3f775199bddf83f286ee8172f7dda987a975016de72bfedd5e03e0ae7a8a67d9e" prot="public">
          <name>efOption_DontCheckMinimumCount</name>
          <initializer>= 1&lt;&lt;10</initializer>
          <briefdescription>
<para>Storage object does its custom checking for minimum value count. </para>          </briefdescription>
          <detaileddescription>
<para>If this flag is set, the class derived from <ref refid="classgmx_1_1OptionStorageTemplate" kindref="compound">OptionStorageTemplate</ref> should implement processSetValues(), processAll(), and possible other functions it provides such that it always fails if not enough values are provided. This is useful to override the default check, which is done in <ref refid="classgmx_1_1OptionStorageTemplate_1a72cf6c7884e6e23e6f71b8dc2dbede40" kindref="member">OptionStorageTemplate::processSet()</ref>. </para>          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Flags for options. </para>        </briefdescription>
        <detaileddescription>
<para> <libinternal /> These flags are not part of the public interface, even though they are in an installed header. They are needed in a few template class implementations.</para><para><xrefsect id="todo_1_todo000040"><xreftitle>Todo</xreftitle><xrefdescription><para>The flags related to default values are confusing, consider reorganizing them. </para></xrefdescription></xrefsect></para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/options/optionflags.h" line="66" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/options/optionflags.h" bodystart="65" bodyend="106"/>
      </memberdef>
      <memberdef kind="enum" id="group__group__publicapi_1ga1c22d32956f25d2432d5a6870983d5cb" prot="public" static="no">
        <name>TimeUnit</name>
        <enumvalue id="group__group__publicapi_1gga1c22d32956f25d2432d5a6870983d5cbaf62491a2d381280231fdb1d87c3788be" prot="public">
          <name>TimeUnit_fs</name>
          <briefdescription>
<para>Femtoseconds. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__publicapi_1gga1c22d32956f25d2432d5a6870983d5cbaa937a11ed8176ada593733a46cd985dd" prot="public">
          <name>TimeUnit_ps</name>
          <briefdescription>
<para>Picoseconds. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__publicapi_1gga1c22d32956f25d2432d5a6870983d5cbaee83c8ee85640f404d1da7f659c74e0b" prot="public">
          <name>TimeUnit_ns</name>
          <briefdescription>
<para>Nanoseconds. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__publicapi_1gga1c22d32956f25d2432d5a6870983d5cba788b558db3581dbb3c4929e73be61226" prot="public">
          <name>TimeUnit_us</name>
          <briefdescription>
<para>Microseconds. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__publicapi_1gga1c22d32956f25d2432d5a6870983d5cbac129739439b285acd9608020af58baaf" prot="public">
          <name>TimeUnit_ms</name>
          <briefdescription>
<para>Milliseconds. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__publicapi_1gga1c22d32956f25d2432d5a6870983d5cbae96310bb9de653e86c390aa0f081b0ce" prot="public">
          <name>TimeUnit_s</name>
          <briefdescription>
<para>Seconds. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__publicapi_1gga1c22d32956f25d2432d5a6870983d5cba7c00d373b2fbd17b4236fc8636ed52ce" prot="public">
          <name>TimeUnit_Default</name>
          <initializer>= TimeUnit_ps</initializer>
          <briefdescription>
<para>Default time unit. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Time values for <ref refid="classgmx_1_1TimeUnitManager" kindref="compound">TimeUnitManager</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>Currently, this should match with the time_unit_t enum defined in oenv.h except that there is no NULL first item in this enum. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/options/timeunitmanager.h" line="67" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/options/timeunitmanager.h" bodystart="66" bodyend="75"/>
      </memberdef>
      <memberdef kind="enum" id="namespacegmx_1a73202d646d57bcc963d8afd5a16015f0" prot="public" static="no">
        <name>RandomDomain</name>
        <enumvalue id="namespacegmx_1a73202d646d57bcc963d8afd5a16015f0a6311ae17c1ee52b36e68aaf4ad066387" prot="public">
          <name>Other</name>
          <initializer>= 0x00000000</initializer>
          <briefdescription>
<para>Generic - stream uniqueness is not important. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1a73202d646d57bcc963d8afd5a16015f0accb9e34a240647891f931e772cad80ef" prot="public">
          <name>MaxwellVelocities</name>
          <initializer>= 0x00001000</initializer>
          <briefdescription>
<para>Veolcity assignment from Maxwell distribution. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1a73202d646d57bcc963d8afd5a16015f0aa42c5450c670a7ecbea5532bde9c0c65" prot="public">
          <name>TestParticleInsertion</name>
          <initializer>= 0x00002000</initializer>
          <briefdescription>
<para>Test particle insertion. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1a73202d646d57bcc963d8afd5a16015f0a23714d9a49cc46ca81ad32670bde8b5e" prot="public">
          <name>UpdateCoordinates</name>
          <initializer>= 0x00003000</initializer>
          <briefdescription>
<para>Particle integrators. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1a73202d646d57bcc963d8afd5a16015f0ab0634f71dbc527342668f2a63f1b3510" prot="public">
          <name>UpdateConstraints</name>
          <initializer>= 0x00004000</initializer>
          <briefdescription>
<para>Second integrator step for constraints. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1a73202d646d57bcc963d8afd5a16015f0a91e0b95db0c752d879aebd0ac65a7fb9" prot="public">
          <name>Thermostat</name>
          <initializer>= 0x00005000</initializer>
          <briefdescription>
<para>Stochastic temperature coupling. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1a73202d646d57bcc963d8afd5a16015f0a79248e4db93ba16182fd3bf1c8e2fda7" prot="public">
          <name>Barostat</name>
          <initializer>= 0x00006000</initializer>
          <briefdescription>
<para>Stochastic pressure coupling. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1a73202d646d57bcc963d8afd5a16015f0ada8008568302912872628be09e68fb84" prot="public">
          <name>ReplicaExchange</name>
          <initializer>= 0x00007000</initializer>
          <briefdescription>
<para>Replica exchange metropolis moves. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1a73202d646d57bcc963d8afd5a16015f0a19bd460326d41817323764fa9e4287ff" prot="public">
          <name>ExpandedEnsemble</name>
          <initializer>= 0x00008000</initializer>
          <briefdescription>
<para>Expanded ensemble lambda moves. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enumerated values for fixed part of random seed (domain) </para>        </briefdescription>
        <detaileddescription>
<para>Random numbers are used in many places in GROMACS, and to avoid identical streams the random seeds should be different. Instead of keeping track of several different user-provided seeds, it is better to use the fact that generators like ThreeFry take two 64-bit keys, and combine a general user-provided 64-bit random seed with a second constant value from this list to make each stream guaranteed unique.</para><para><simplesect kind="note"><para>There is no reason to go overboard with adding options; we only need to guarantee different streams for cases that might be present simultaneously in a single simulation. As an example, two different integrators (or thermostats) can reuse the same domain. </para><simplesectsep/><para>When you do add options, leave some space between the values so you can group new options with old ones without changing old values. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/random/seed.h" line="93" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/random/seed.h" bodystart="92" bodyend="103"/>
      </memberdef>
      <memberdef kind="enum" id="group__module__selection_1ga2ab58eea84794341a35ac67e9b2dd229" prot="public" static="no">
        <name>SelectionStringMatchType</name>
        <enumvalue id="group__module__selection_1gga2ab58eea84794341a35ac67e9b2dd229a76e91d87b1fc9e35af5a744934e0be5d" prot="public">
          <name>eStringMatchType_Auto</name>
          <briefdescription>
<para>Deduce from the string. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__module__selection_1gga2ab58eea84794341a35ac67e9b2dd229ae3793d484d4d5b121f9beff792e7a542" prot="public">
          <name>eStringMatchType_Exact</name>
          <briefdescription>
<para>Match as a literal string. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__module__selection_1gga2ab58eea84794341a35ac67e9b2dd229a9c54f931f9075ae0a0bd35e55e07312b" prot="public">
          <name>eStringMatchType_Wildcard</name>
          <briefdescription>
<para>Match using ? and * as wildcards. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__module__selection_1gga2ab58eea84794341a35ac67e9b2dd229ad061c2f42b00f07d32e9d3a18222e84c" prot="public">
          <name>eStringMatchType_RegularExpression</name>
          <briefdescription>
<para>Match using regular expressions. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>String matching mode for string keyword expressions. </para>        </briefdescription>
        <detaileddescription>
<internal></internal>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/parsetree.h" line="81" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/parsetree.h" bodystart="80" bodyend="86"/>
      </memberdef>
      <memberdef kind="enum" id="namespacegmx_1af16ecfd69d5704fc5de46b97ceff3b65" prot="public" static="no">
        <name>SelectionFlag</name>
        <enumvalue id="namespacegmx_1af16ecfd69d5704fc5de46b97ceff3b65a1711730e77d1c99b4cf3cbf0b4ebbd32" prot="public">
          <name>efSelection_OnlyStatic</name>
          <initializer>= 1&lt;&lt;0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1af16ecfd69d5704fc5de46b97ceff3b65a0c951633cd5578bc2a060660c7996398" prot="public">
          <name>efSelection_OnlyAtoms</name>
          <initializer>= 1&lt;&lt;1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1af16ecfd69d5704fc5de46b97ceff3b65aba0d6ab7f0530bfd947a3c1c53d8ad2b" prot="public">
          <name>efSelection_OnlySorted</name>
          <initializer>= 1&lt;&lt;2</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1af16ecfd69d5704fc5de46b97ceff3b65ada857974002e1be2413578d8ec3b5e08" prot="public">
          <name>efSelection_DynamicMask</name>
          <initializer>= 1&lt;&lt;3</initializer>
          <briefdescription>
<para>Whether <ref refid="poscalc_8h_1a3586daeaab8b4ff970ae759b3677e7fd" kindref="member">POS_MASKONLY</ref> should be used for output position evaluation. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1af16ecfd69d5704fc5de46b97ceff3b65a3f2acaa6ea6db136e596e29e3c7151af" prot="public">
          <name>efSelection_DisallowEmpty</name>
          <initializer>= 1&lt;&lt;4</initializer>
          <briefdescription>
<para>If set, unconditionally empty selections result in compilation errors. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1af16ecfd69d5704fc5de46b97ceff3b65a692118363f0eefc01d795054271e51c6" prot="public">
          <name>efSelection_EvaluateVelocities</name>
          <initializer>= 1&lt;&lt;5</initializer>
          <briefdescription>
<para>Whether velocities of output positions should be evaluated. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1af16ecfd69d5704fc5de46b97ceff3b65a521142e351d4b23459b1b0c08705cc34" prot="public">
          <name>efSelection_EvaluateForces</name>
          <initializer>= 1&lt;&lt;6</initializer>
          <briefdescription>
<para>Whether forces on output positions should be evaluated. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Flags for options. </para>        </briefdescription>
        <detaileddescription>
<para>These flags are not part of the public interface, even though they are in an installed header. They are needed in the implementation of <ref refid="classgmx_1_1SelectionOption" kindref="compound">SelectionOption</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/selectionenums.h" line="69" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/selectionenums.h" bodystart="68" bodyend="81"/>
      </memberdef>
      <memberdef kind="enum" id="namespacegmx_1aa9e7df55e017bd726d027d65551bbd0c" prot="public" static="no">
        <name>SimdType</name>
        <enumvalue id="namespacegmx_1aa9e7df55e017bd726d027d65551bbd0ca6adf97f83acf6453d4a6a4b1070f3754" prot="public">
          <name>None</name>
          <briefdescription>
<para>Disable all SIMD support. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1aa9e7df55e017bd726d027d65551bbd0ca63d5049791d9d79d86e9a108b0a999ca" prot="public">
          <name>Reference</name>
          <briefdescription>
<para>Gromacs reference software SIMD. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1aa9e7df55e017bd726d027d65551bbd0ca8045a0a6c688b0635e3caccc408a1446" prot="public">
          <name>Generic</name>
          <briefdescription>
<para>Placeholder for future support for gcc generic SIMD. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1aa9e7df55e017bd726d027d65551bbd0ca5c496843e02651870c195534b19d9bbb" prot="public">
          <name>X86_Sse2</name>
          <briefdescription>
<para>SSE2. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1aa9e7df55e017bd726d027d65551bbd0ca64005555216b2f63787c06918e0b4936" prot="public">
          <name>X86_Sse4_1</name>
          <briefdescription>
<para>SSE4.1. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1aa9e7df55e017bd726d027d65551bbd0ca02880dc80ec6734dff5c4453b8a22255" prot="public">
          <name>X86_Avx128Fma</name>
          <briefdescription>
<para>128-bit Avx with FMA (Amd) </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1aa9e7df55e017bd726d027d65551bbd0ca9201c4bc942aaeba69216cfc973795b6" prot="public">
          <name>X86_Avx</name>
          <briefdescription>
<para>256-bit Avx </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1aa9e7df55e017bd726d027d65551bbd0cac8da3ebc9d442eba3f2cb90fbca92140" prot="public">
          <name>X86_Avx2</name>
          <briefdescription>
<para>AVX2. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1aa9e7df55e017bd726d027d65551bbd0ca023ae73ff9edfb62c00415795ff5f570" prot="public">
          <name>X86_Avx512</name>
          <briefdescription>
<para>AVX_512. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1aa9e7df55e017bd726d027d65551bbd0ca62d6b69682baf2b6d044e34d28f40674" prot="public">
          <name>X86_Avx512Knl</name>
          <briefdescription>
<para>AVX_512_KNL. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1aa9e7df55e017bd726d027d65551bbd0ca8c108d62ab2603d3f6e5cd13399fa467" prot="public">
          <name>X86_Mic</name>
          <briefdescription>
<para>Knight&apos;s corner. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1aa9e7df55e017bd726d027d65551bbd0cadb2c254e64bf7eed5a729529fa188099" prot="public">
          <name>Arm_Neon</name>
          <briefdescription>
<para>32-bit ARM NEON </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1aa9e7df55e017bd726d027d65551bbd0ca3a0da0d018906725c11b5ddbb0ce76d8" prot="public">
          <name>Arm_NeonAsimd</name>
          <briefdescription>
<para>64-bit ARM AArch64 Advanced SIMD </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1aa9e7df55e017bd726d027d65551bbd0ca55faf6b41cccf6249fa75a088a0dd988" prot="public">
          <name>Ibm_Qpx</name>
          <briefdescription>
<para>IBM QPX SIMD (BlueGene/Q and later) </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1aa9e7df55e017bd726d027d65551bbd0ca3f9726bfb19d56f774360782846dc77f" prot="public">
          <name>Ibm_Vmx</name>
          <briefdescription>
<para>IBM VMX SIMD (Altivec on Power6 and later) </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1aa9e7df55e017bd726d027d65551bbd0cae2817429950760b6f888ba6a8446fbf5" prot="public">
          <name>Ibm_Vsx</name>
          <briefdescription>
<para>IBM VSX SIMD (Power7 and later) </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacegmx_1aa9e7df55e017bd726d027d65551bbd0ca069e00567050f3e5b804844ed7155bdd" prot="public">
          <name>Fujitsu_HpcAce</name>
          <briefdescription>
<para>Fujitsu K-computer. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enumerated options for SIMD architectures. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/support.h" line="58" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/support.h" bodystart="57" bodyend="76"/>
      </memberdef>
      <memberdef kind="enum" id="group__module__utility_1gac92ff9c7f6f5ed5200b3d8d92a4d53e3" prot="public" static="no">
        <name>ErrorCode</name>
        <enumvalue id="group__module__utility_1ggac92ff9c7f6f5ed5200b3d8d92a4d53e3acacaa10fa7070b0494b30fdc97a7a356" prot="public">
          <name>eeOK</name>
          <briefdescription>
<para>Zero for successful return. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__module__utility_1ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a35a82c5a0f04b6255d3f28d6144dd24e" prot="public">
          <name>eeOutOfMemory</name>
          <briefdescription>
<para>Not enough memory to complete operation. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__module__utility_1ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a444e88ccfbfc246dc671919d0cf127c1" prot="public">
          <name>eeFileNotFound</name>
          <briefdescription>
<para>Provided file could not be opened. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__module__utility_1ggac92ff9c7f6f5ed5200b3d8d92a4d53e3ad0a05315bf704c8457baef6eac42dc4e" prot="public">
          <name>eeFileIO</name>
          <briefdescription>
<para>System I/O error. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__module__utility_1ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a4c2569b29b84eda15a5cf90e28395b21" prot="public">
          <name>eeInvalidInput</name>
          <briefdescription>
<para>Invalid user input (could not be understood). </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__module__utility_1ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a7eb29dbd6ce224f815ba82ddcc3b6f62" prot="public">
          <name>eeInconsistentInput</name>
          <briefdescription>
<para>Invalid user input (conflicting or unsupported settings). </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__module__utility_1ggac92ff9c7f6f5ed5200b3d8d92a4d53e3ac0b348673979b42ebc8df4562b8ebfa4" prot="public">
          <name>eeInstability</name>
          <briefdescription>
<para>Simulation instability detected. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__module__utility_1ggac92ff9c7f6f5ed5200b3d8d92a4d53e3ae958977bd58e97bcc4fd367324c8b21b" prot="public">
          <name>eeNotImplemented</name>
          <briefdescription>
<para>Requested feature not yet implemented. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__module__utility_1ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a71840645faa70349b0e4bede4da4b6d1" prot="public">
          <name>eeInvalidValue</name>
          <briefdescription>
<para>Input value violates API specification. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__module__utility_1ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a40bd4aef44a2ab731b61fb9c9184a3bd" prot="public">
          <name>eeInvalidCall</name>
          <briefdescription>
<para>Invalid routine called or wrong calling sequence detected. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__module__utility_1ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a90b9f0f24cf026b56ebf63d359c5f422" prot="public">
          <name>eeInternalError</name>
          <briefdescription>
<para>Internal consistency check failed. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__module__utility_1ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a414167b1bc702c9e8bb7f91078360845" prot="public">
          <name>eeAPIError</name>
          <briefdescription>
<para>API specification was violated. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__module__utility_1ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a068d9a3d2c79173f39457344cd60380f" prot="public">
          <name>eeRange</name>
          <briefdescription>
<para>Range consistency check failed. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__module__utility_1ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a395dad7e12b144dd6805157e6d92e40f" prot="public">
          <name>eeCommunication</name>
          <briefdescription>
<para>Communication consistency check failed. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__module__utility_1ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a46578ca340e1c440d5f519569e6884fb" prot="public">
          <name>eeUnknownError</name>
          <briefdescription>
<para>Unknown error detected. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Possible error return codes from Gromacs functions. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/errorcodes.h" line="56" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/errorcodes.h" bodystart="55" bodyend="97"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="namespacegmx_1aea400e67c2f38e5bacdf8677f38a61cc" prot="public" static="no">
        <type>std::shared_ptr&lt; <ref refid="classgmx_1_1IAnalysisDataModule" kindref="compound">IAnalysisDataModule</ref> &gt;</type>
        <definition>typedef std::shared_ptr&lt;IAnalysisDataModule&gt; gmx::AnalysisDataModulePointer</definition>
        <argsstring></argsstring>
        <name>AnalysisDataModulePointer</name>
        <briefdescription>
<para>Smart pointer for managing a generic analysis data module. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/abstractdata.h" line="60" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/abstractdata.h" bodystart="57" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1ab5b2ea776c6775a0c958a3750b42a97e" prot="public" static="no">
        <type><ref refid="classgmx_1_1ConstArrayRef" kindref="compound">ConstArrayRef</ref>&lt; <ref refid="classgmx_1_1AnalysisDataValue" kindref="compound">AnalysisDataValue</ref> &gt;</type>
        <definition>typedef ConstArrayRef&lt;AnalysisDataValue&gt; gmx::AnalysisDataValuesRef</definition>
        <argsstring></argsstring>
        <name>AnalysisDataValuesRef</name>
        <briefdescription>
<para>Shorthand for reference to an array of data values. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/dataframe.h" line="176" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/dataframe.h" bodystart="176" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a87e4f5152c736da50dd59275f423a7a3" prot="public" static="no">
        <type>std::shared_ptr&lt; <ref refid="classgmx_1_1AnalysisDataAverageModule" kindref="compound">AnalysisDataAverageModule</ref> &gt;</type>
        <definition>typedef std::shared_ptr&lt;AnalysisDataAverageModule&gt; gmx::AnalysisDataAverageModulePointer</definition>
        <argsstring></argsstring>
        <name>AnalysisDataAverageModulePointer</name>
        <briefdescription>
<para>Smart pointer to manage an <ref refid="classgmx_1_1AnalysisDataAverageModule" kindref="compound">AnalysisDataAverageModule</ref> object. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/modules/average.h" line="146" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/modules/average.h" bodystart="146" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1ad580f7f69fb3536c9cba722587e77e49" prot="public" static="no">
        <type>std::shared_ptr&lt; <ref refid="classgmx_1_1AnalysisDataFrameAverageModule" kindref="compound">AnalysisDataFrameAverageModule</ref> &gt;</type>
        <definition>typedef std::shared_ptr&lt;AnalysisDataFrameAverageModule&gt; gmx::AnalysisDataFrameAverageModulePointer</definition>
        <argsstring></argsstring>
        <name>AnalysisDataFrameAverageModulePointer</name>
        <briefdescription>
<para>Smart pointer to manage an <ref refid="classgmx_1_1AnalysisDataFrameAverageModule" kindref="compound">AnalysisDataFrameAverageModule</ref> object. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/modules/average.h" line="192" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/modules/average.h" bodystart="192" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1aa5dd79fb2cd906b55b386b64084543b9" prot="public" static="no">
        <type>std::shared_ptr&lt; <ref refid="classgmx_1_1AnalysisDataDisplacementModule" kindref="compound">AnalysisDataDisplacementModule</ref> &gt;</type>
        <definition>typedef std::shared_ptr&lt;AnalysisDataDisplacementModule&gt; gmx::AnalysisDataDisplacementModulePointer</definition>
        <argsstring></argsstring>
        <name>AnalysisDataDisplacementModulePointer</name>
        <briefdescription>
<para>Smart pointer to manage an <ref refid="classgmx_1_1AnalysisDataDisplacementModule" kindref="compound">AnalysisDataDisplacementModule</ref> object. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/modules/displacement.h" line="106" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/modules/displacement.h" bodystart="106" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a06c190fcdacd0ca64e4e9026213483cb" prot="public" static="no">
        <type>std::unique_ptr&lt; <ref refid="classgmx_1_1AbstractAverageHistogram" kindref="compound">AbstractAverageHistogram</ref> &gt;</type>
        <definition>typedef std::unique_ptr&lt;AbstractAverageHistogram&gt; gmx::AverageHistogramPointer</definition>
        <argsstring></argsstring>
        <name>AverageHistogramPointer</name>
        <briefdescription>
<para>Smart pointer to manage an <ref refid="classgmx_1_1AbstractAverageHistogram" kindref="compound">AbstractAverageHistogram</ref> object. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/modules/histogram.h" line="243" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/modules/histogram.h" bodystart="240" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a2c928eedc8925c3c437b5362acf30ccd" prot="public" static="no">
        <type>std::shared_ptr&lt; <ref refid="classgmx_1_1AnalysisDataSimpleHistogramModule" kindref="compound">AnalysisDataSimpleHistogramModule</ref> &gt;</type>
        <definition>typedef std::shared_ptr&lt;AnalysisDataSimpleHistogramModule&gt; gmx::AnalysisDataSimpleHistogramModulePointer</definition>
        <argsstring></argsstring>
        <name>AnalysisDataSimpleHistogramModulePointer</name>
        <briefdescription>
<para>Smart pointer to manage an <ref refid="classgmx_1_1AnalysisDataSimpleHistogramModule" kindref="compound">AnalysisDataSimpleHistogramModule</ref> object. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/modules/histogram.h" line="532" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/modules/histogram.h" bodystart="532" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a3a619b397ea8b7a9a81406d36f653b4c" prot="public" static="no">
        <type>std::shared_ptr&lt; <ref refid="classgmx_1_1AnalysisDataWeightedHistogramModule" kindref="compound">AnalysisDataWeightedHistogramModule</ref> &gt;</type>
        <definition>typedef std::shared_ptr&lt;AnalysisDataWeightedHistogramModule&gt; gmx::AnalysisDataWeightedHistogramModulePointer</definition>
        <argsstring></argsstring>
        <name>AnalysisDataWeightedHistogramModulePointer</name>
        <briefdescription>
<para>Smart pointer to manage an <ref refid="classgmx_1_1AnalysisDataWeightedHistogramModule" kindref="compound">AnalysisDataWeightedHistogramModule</ref> object. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/modules/histogram.h" line="535" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/modules/histogram.h" bodystart="535" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a2832966f8a1d1e01888448ce10faa595" prot="public" static="no">
        <type>std::shared_ptr&lt; <ref refid="classgmx_1_1AnalysisDataBinAverageModule" kindref="compound">AnalysisDataBinAverageModule</ref> &gt;</type>
        <definition>typedef std::shared_ptr&lt;AnalysisDataBinAverageModule&gt; gmx::AnalysisDataBinAverageModulePointer</definition>
        <argsstring></argsstring>
        <name>AnalysisDataBinAverageModulePointer</name>
        <briefdescription>
<para>Smart pointer to manage an <ref refid="classgmx_1_1AnalysisDataBinAverageModule" kindref="compound">AnalysisDataBinAverageModule</ref> object. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/modules/histogram.h" line="538" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/modules/histogram.h" bodystart="538" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1af036d959995ac12973db1da85b720bf6" prot="public" static="no">
        <type>std::shared_ptr&lt; <ref refid="classgmx_1_1AnalysisDataLifetimeModule" kindref="compound">AnalysisDataLifetimeModule</ref> &gt;</type>
        <definition>typedef std::shared_ptr&lt;AnalysisDataLifetimeModule&gt; gmx::AnalysisDataLifetimeModulePointer</definition>
        <argsstring></argsstring>
        <name>AnalysisDataLifetimeModulePointer</name>
        <briefdescription>
<para>Smart pointer to manage an <ref refid="classgmx_1_1AnalysisDataLifetimeModule" kindref="compound">AnalysisDataLifetimeModule</ref> object. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/modules/lifetime.h" line="111" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/modules/lifetime.h" bodystart="111" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a38eb9496e0b6e783869001733014b6d0" prot="public" static="no">
        <type>std::shared_ptr&lt; <ref refid="classgmx_1_1AnalysisDataPlotModule" kindref="compound">AnalysisDataPlotModule</ref> &gt;</type>
        <definition>typedef std::shared_ptr&lt;AnalysisDataPlotModule&gt; gmx::AnalysisDataPlotModulePointer</definition>
        <argsstring></argsstring>
        <name>AnalysisDataPlotModulePointer</name>
        <briefdescription>
<para>Smart pointer to manage an <ref refid="classgmx_1_1AnalysisDataPlotModule" kindref="compound">AnalysisDataPlotModule</ref> object. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/modules/plot.h" line="330" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/modules/plot.h" bodystart="330" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1aacd637dfda5b531daec3b8a89f389c10" prot="public" static="no">
        <type>std::shared_ptr&lt; <ref refid="classgmx_1_1AnalysisDataVectorPlotModule" kindref="compound">AnalysisDataVectorPlotModule</ref> &gt;</type>
        <definition>typedef std::shared_ptr&lt;AnalysisDataVectorPlotModule&gt; gmx::AnalysisDataVectorPlotModulePointer</definition>
        <argsstring></argsstring>
        <name>AnalysisDataVectorPlotModulePointer</name>
        <briefdescription>
<para>Smart pointer to manage an <ref refid="classgmx_1_1AnalysisDataVectorPlotModule" kindref="compound">AnalysisDataVectorPlotModule</ref> object. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/modules/plot.h" line="333" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/modules/plot.h" bodystart="333" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__module__commandline_1ga1f47492bbdb0412052613d0096a20c0b" prot="public" static="no">
        <type>std::map&lt; std::string, <ref refid="group__module__commandline_1ga92d17acbe7afad4effeda8d9be200305" kindref="member">CommandLineModulePointer</ref> &gt;</type>
        <definition>typedef std::map&lt;std::string, CommandLineModulePointer&gt; gmx::CommandLineModuleMap</definition>
        <argsstring></argsstring>
        <name>CommandLineModuleMap</name>
        <briefdescription>
<para>Container type for mapping module names to module objects. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/cmdlinemodulemanager-impl.h" line="64" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/cmdlinemodulemanager-impl.h" bodystart="64" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__module__commandline_1gadc9ea6aca3a54c2691284aa39cdd294d" prot="public" static="no">
        <type>std::unique_ptr&lt; <ref refid="classgmx_1_1CommandLineModuleGroupData" kindref="compound">CommandLineModuleGroupData</ref> &gt;</type>
        <definition>typedef std::unique_ptr&lt;CommandLineModuleGroupData&gt; gmx::CommandLineModuleGroupDataPointer</definition>
        <argsstring></argsstring>
        <name>CommandLineModuleGroupDataPointer</name>
        <briefdescription>
<para>Smart pointer type for managing a <ref refid="classgmx_1_1CommandLineModuleGroup" kindref="compound">CommandLineModuleGroup</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/cmdlinemodulemanager-impl.h" line="131" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/cmdlinemodulemanager-impl.h" bodystart="131" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__module__commandline_1ga7098a58b563a17889eef62c80fae42bf" prot="public" static="no">
        <type>std::vector&lt; <ref refid="group__module__commandline_1gadc9ea6aca3a54c2691284aa39cdd294d" kindref="member">CommandLineModuleGroupDataPointer</ref> &gt;</type>
        <definition>typedef std::vector&lt;CommandLineModuleGroupDataPointer&gt; gmx::CommandLineModuleGroupList</definition>
        <argsstring></argsstring>
        <name>CommandLineModuleGroupList</name>
        <briefdescription>
<para>Container type for keeping a list of module groups. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/cmdlinemodulemanager-impl.h" line="134" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/cmdlinemodulemanager-impl.h" bodystart="134" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__module__commandline_1ga92d17acbe7afad4effeda8d9be200305" prot="public" static="no">
        <type>std::unique_ptr&lt; <ref refid="classgmx_1_1ICommandLineModule" kindref="compound">ICommandLineModule</ref> &gt;</type>
        <definition>typedef std::unique_ptr&lt;ICommandLineModule&gt; gmx::CommandLineModulePointer</definition>
        <argsstring></argsstring>
        <name>CommandLineModulePointer</name>
        <briefdescription>
<para>Smart pointer type for managing a <ref refid="classgmx_1_1ICommandLineModule" kindref="compound">ICommandLineModule</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/cmdlinemodulemanager.h" line="66" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/cmdlinemodulemanager.h" bodystart="66" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a682ce4a779fde44ee633b8648eeafe87" prot="public" static="no">
        <type>std::unique_ptr&lt; <ref refid="classgmx_1_1ICommandLineOptionsModule" kindref="compound">ICommandLineOptionsModule</ref> &gt;</type>
        <definition>typedef std::unique_ptr&lt;ICommandLineOptionsModule&gt; gmx::ICommandLineOptionsModulePointer</definition>
        <argsstring></argsstring>
        <name>ICommandLineOptionsModulePointer</name>
        <briefdescription>
<para>Smart pointer to manage an <ref refid="classgmx_1_1ICommandLineOptionsModule" kindref="compound">ICommandLineOptionsModule</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/cmdlineoptionsmodule.h" line="64" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/cmdlineoptionsmodule.h" bodystart="60" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__module__commandline_1gac522eb6a6c382e39345834c796201098" prot="public" static="no">
        <type>std::unique_ptr&lt; <ref refid="classgmx_1_1IExecutableEnvironment" kindref="compound">IExecutableEnvironment</ref> &gt;</type>
        <definition>typedef std::unique_ptr&lt;IExecutableEnvironment&gt; gmx::ExecutableEnvironmentPointer</definition>
        <argsstring></argsstring>
        <name>ExecutableEnvironmentPointer</name>
        <briefdescription>
<para>Shorthand for a smart pointer to <ref refid="classgmx_1_1IExecutableEnvironment" kindref="compound">IExecutableEnvironment</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/cmdlineprogramcontext.h" line="93" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/cmdlineprogramcontext.h" bodystart="93" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a139c1919a9680de4ad1450f42e37d33b" prot="public" static="no">
        <type><ref refid="classgmx_1_1BasicVector" kindref="compound">BasicVector</ref>&lt; <ref refid="real_8h_1a58a0c7cf2501f4492da833421be92547" kindref="member">real</ref> &gt;</type>
        <definition>typedef BasicVector&lt;real&gt; gmx::RVec</definition>
        <argsstring></argsstring>
        <name>RVec</name>
        <briefdescription>
<para>Shorthand for C++ <computeroutput>rvec</computeroutput>-equivalent type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/vectypes.h" line="158" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/vectypes.h" bodystart="158" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a8593c4aa4e1f10f3571c8b8f2cd933a8" prot="public" static="no">
        <type>double</type>
        <definition>typedef double gmx::integrator_t(FILE *fplog, t_commrec *cr, int nfile, const t_filenm fnm[], const gmx_output_env_t *oenv, gmx_bool bVerbose, int nstglobalcomm, gmx_vsite_t *vsite, gmx_constr_t constr, int stepout, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, t_state *state_global, t_mdatoms *mdatoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, t_forcerec *fr, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, gmx_membed_t *membed, real cpt_period, real max_hours, int imdport, unsigned long Flags, gmx_walltime_accounting_t walltime_accounting)</definition>
        <argsstring>(FILE *fplog, t_commrec *cr, int nfile, const t_filenm fnm[], const gmx_output_env_t *oenv, gmx_bool bVerbose, int nstglobalcomm, gmx_vsite_t *vsite, gmx_constr_t constr, int stepout, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, t_state *state_global, t_mdatoms *mdatoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, t_forcerec *fr, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, gmx_membed_t *membed, real cpt_period, real max_hours, int imdport, unsigned long Flags, gmx_walltime_accounting_t walltime_accounting)</argsstring>
        <name>integrator_t</name>
        <briefdescription>
<para>Integrator algorithm implementation. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fplog</parametername>
</parameternamelist>
<parameterdescription>
<para>Log file for output </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cr</parametername>
</parameternamelist>
<parameterdescription>
<para>Communication record </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nfile</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of files </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fnm</parametername>
</parameternamelist>
<parameterdescription>
<para>Filename structure array </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">oenv</parametername>
</parameternamelist>
<parameterdescription>
<para>Output information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">bVerbose</parametername>
</parameternamelist>
<parameterdescription>
<para>Verbose output or not </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nstglobalcomm</parametername>
</parameternamelist>
<parameterdescription>
<para>How often global communication is done </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">vsite</parametername>
</parameternamelist>
<parameterdescription>
<para>Virtual site information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">constr</parametername>
</parameternamelist>
<parameterdescription>
<para>Constraint information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">stepout</parametername>
</parameternamelist>
<parameterdescription>
<para>How often we writen to the console </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">inputrec</parametername>
</parameternamelist>
<parameterdescription>
<para>Input record with mdp options </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">top_global</parametername>
</parameternamelist>
<parameterdescription>
<para>Molecular topology for the whole system </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fcd</parametername>
</parameternamelist>
<parameterdescription>
<para>Force and constraint data </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">state_global</parametername>
</parameternamelist>
<parameterdescription>
<para>The state (x, v, f, box etc.) of the whole system </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">mdatoms</parametername>
</parameternamelist>
<parameterdescription>
<para>Structure containing atom information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nrnb</parametername>
</parameternamelist>
<parameterdescription>
<para>Accounting for floating point operations </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">wcycle</parametername>
</parameternamelist>
<parameterdescription>
<para>Wall cycle timing information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ed</parametername>
</parameternamelist>
<parameterdescription>
<para>Essential dynamics sampling information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fr</parametername>
</parameternamelist>
<parameterdescription>
<para>Force record with cut-off information and more </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">repl_ex_nst</parametername>
</parameternamelist>
<parameterdescription>
<para>How often we do replica exchange (in steps) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">repl_ex_nex</parametername>
</parameternamelist>
<parameterdescription>
<para>How many replicas we have </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">repl_ex_seed</parametername>
</parameternamelist>
<parameterdescription>
<para>The seed for Monte Carlo swaps </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">membed</parametername>
</parameternamelist>
<parameterdescription>
<para>Membrane embedding data structure </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cpt_period</parametername>
</parameternamelist>
<parameterdescription>
<para>How often to checkpoint the simulation </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">max_hours</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximume length of the simulation (wall time) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">imdport</parametername>
</parameternamelist>
<parameterdescription>
<para>Interactive MD port (socket) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">Flags</parametername>
</parameternamelist>
<parameterdescription>
<para>Flags to control mdrun </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">walltime_accounting</parametername>
</parameternamelist>
<parameterdescription>
<para>More timing information </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/mdlib/integrator.h" line="97" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/mdlib/integrator.h" bodystart="97" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a2c0facebaa27d417dcf4d032f2a5725a" prot="public" static="no">
        <type>std::array&lt; <ref refid="classgmx_1_1SimulationSignal" kindref="compound">SimulationSignal</ref>, eglsNR &gt;</type>
        <definition>typedef std::array&lt;SimulationSignal, eglsNR&gt; gmx::SimulationSignals</definition>
        <argsstring></argsstring>
        <name>SimulationSignals</name>
        <briefdescription>
<para>Convenience typedef for the group of signals used. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/mdlib/simulationsignal.h" line="103" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/mdlib/simulationsignal.h" bodystart="103" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__libraryapi_1ga426f73ac74d1891aae96b6f27e2173a6" prot="public" static="no">
        <type>std::unique_ptr&lt; <ref refid="classgmx_1_1AbstractCompositeHelpTopic" kindref="compound">AbstractCompositeHelpTopic</ref> &gt;</type>
        <definition>typedef std::unique_ptr&lt;AbstractCompositeHelpTopic&gt; gmx::CompositeHelpTopicPointer</definition>
        <argsstring></argsstring>
        <name>CompositeHelpTopicPointer</name>
        <briefdescription>
<para>Smart pointer type to manage a <ref refid="classgmx_1_1AbstractCompositeHelpTopic" kindref="compound">AbstractCompositeHelpTopic</ref> object. </para>        </briefdescription>
        <detaileddescription>
<para> <libinternal />  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/onlinehelp/helptopic.h" line="189" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/onlinehelp/helptopic.h" bodystart="189" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1abb455c7711ece592606e70a093ff80b4" prot="public" static="no">
        <type>std::unique_ptr&lt; <ref refid="classgmx_1_1IHelpTopic" kindref="compound">IHelpTopic</ref> &gt;</type>
        <definition>typedef std::unique_ptr&lt;IHelpTopic&gt; gmx::HelpTopicPointer</definition>
        <argsstring></argsstring>
        <name>HelpTopicPointer</name>
        <briefdescription>
<para>Smart pointer type to manage a <ref refid="classgmx_1_1IHelpTopic" kindref="compound">IHelpTopic</ref> object. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/onlinehelp/ihelptopic.h" line="109" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/onlinehelp/ihelptopic.h" bodystart="109" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__module__options_1gafdd645721a8da7d18eec7f0bc84efe29" prot="public" static="no">
        <type><ref refid="classgmx_1_1EnumOption" kindref="compound">EnumOption</ref>&lt; int &gt;</type>
        <definition>typedef EnumOption&lt;int&gt; gmx::EnumIntOption</definition>
        <argsstring></argsstring>
        <name>EnumIntOption</name>
        <briefdescription>
<para>Shorthand for an enumerated option that stores into an <computeroutput>int</computeroutput> variable. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/options/basicoptions.h" line="617" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/options/basicoptions.h" bodystart="617" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__module__options_1ga7552279e0ab63edd1e9324c5786e28e7" prot="public" static="no">
        <type><ref refid="classgmx_1_1FloatOption" kindref="compound">FloatOption</ref></type>
        <definition>gmx::RealOption</definition>
        <argsstring></argsstring>
        <name>RealOption</name>
        <briefdescription>
<para>Typedef for either <ref refid="classgmx_1_1DoubleOption" kindref="compound">DoubleOption</ref> or <ref refid="classgmx_1_1FloatOption" kindref="compound">FloatOption</ref>, depending on precision. </para>        </briefdescription>
        <detaileddescription>
<para>Generally, new would be better using <ref refid="classgmx_1_1DoubleOption" kindref="compound">DoubleOption</ref>, but this is provided for cases where the output value needs to be of type <computeroutput>real</computeroutput> for some reason. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/options/basicoptions.h" line="779" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/options/basicoptions.h" bodystart="779" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__module__options_1gab1c4e0b93e5d22b0c9a534f0235496f5" prot="public" static="no">
        <type><ref refid="classgmx_1_1FloatOptionInfo" kindref="compound">FloatOptionInfo</ref></type>
        <definition>gmx::RealOptionInfo</definition>
        <argsstring></argsstring>
        <name>RealOptionInfo</name>
        <briefdescription>
<para>Typedef for either <ref refid="classgmx_1_1DoubleOptionInfo" kindref="compound">DoubleOptionInfo</ref> or <ref refid="classgmx_1_1FloatOptionInfo" kindref="compound">FloatOptionInfo</ref>, depending on precision. </para>        </briefdescription>
        <detaileddescription>
<para>Generally, new would be better using <ref refid="classgmx_1_1DoubleOption" kindref="compound">DoubleOption</ref>, but this is provided for cases where the output value needs to be of type <computeroutput>real</computeroutput> for some reason. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/options/basicoptions.h" line="780" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/options/basicoptions.h" bodystart="780" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a059233e5e29d17f821d7f56ef3faa7e4" prot="public" static="no">
        <type>std::shared_ptr&lt; <ref refid="classgmx_1_1IOptionsBehavior" kindref="compound">IOptionsBehavior</ref> &gt;</type>
        <definition>typedef std::shared_ptr&lt;IOptionsBehavior&gt; gmx::OptionsBehaviorPointer</definition>
        <argsstring></argsstring>
        <name>OptionsBehaviorPointer</name>
        <briefdescription>
<para>Smart pointer for behaviors stored in <ref refid="classgmx_1_1OptionsBehaviorCollection" kindref="compound">OptionsBehaviorCollection</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/options/behaviorcollection.h" line="58" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/options/behaviorcollection.h" bodystart="55" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a0b60cc84dcdf372e00a5084712630993" prot="public" static="no">
        <type><ref refid="classgmx_1_1FlagsTemplate" kindref="compound">FlagsTemplate</ref>&lt; <ref refid="namespacegmx_1a3f775199bddf83f286ee8172f7dda987" kindref="member">OptionFlag</ref> &gt;</type>
        <definition>typedef FlagsTemplate&lt;OptionFlag&gt; gmx::OptionFlags</definition>
        <argsstring></argsstring>
        <name>OptionFlags</name>
        <briefdescription>
<para> <libinternal />  Holds a combination of <ref refid="namespacegmx_1a3f775199bddf83f286ee8172f7dda987" kindref="member">OptionFlag</ref> values. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/options/optionflags.h" line="109" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/options/optionflags.h" bodystart="109" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1aac44e2bbcc40f48812b6b756a503ea51" prot="public" static="no">
        <type>std::random_device</type>
        <definition>typedef std::random_device gmx::RandomDevice</definition>
        <argsstring></argsstring>
        <name>RandomDevice</name>
        <briefdescription>
<para>Random device. </para>        </briefdescription>
        <detaileddescription>
<para>For now this is identical to the standard library, but since we use the GROMACS random module for all other random engines and distributions it is convenient to have this too in the same module. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/random/seed.h" line="74" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/random/seed.h" bodystart="74" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a7ea21974bdd8acdfa1c344b0945cff1b" prot="public" static="no">
        <type><ref refid="classgmx_1_1ThreeFry2x64Fast" kindref="compound">ThreeFry2x64Fast</ref></type>
        <definition>typedef ThreeFry2x64Fast gmx::DefaultRandomEngine</definition>
        <argsstring></argsstring>
        <name>DefaultRandomEngine</name>
        <briefdescription>
<para>Default fast and accurate random engine in Gromacs. </para>        </briefdescription>
        <detaileddescription>
<para>This engine will return 2*2^64 random results using the default <ref refid="namespacegmx_1a73202d646d57bcc963d8afd5a16015f0a6311ae17c1ee52b36e68aaf4ad066387" kindref="member">gmx::RandomDomain::Other</ref> stream, and can be initialized with a single seed argument without having to remember empty template angle brackets. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/random/threefry.h" line="768" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/random/threefry.h" bodystart="768" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1aec46c9561c55f7595677160ee727395d" prot="public" static="no">
        <type>std::list&lt; <ref refid="classgmx_1_1SelectionParserValue" kindref="compound">SelectionParserValue</ref> &gt;</type>
        <definition>typedef std::list&lt;SelectionParserValue&gt; gmx::SelectionParserValueList</definition>
        <argsstring></argsstring>
        <name>SelectionParserValueList</name>
        <briefdescription>
<para>Container for a list of <ref refid="classgmx_1_1SelectionParserValue" kindref="compound">SelectionParserValue</ref> objects. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/parsetree.h" line="93" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/parsetree.h" bodystart="89" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a043953ace26fa6e1f17f90245e3a29bd" prot="public" static="no">
        <type>std::unique_ptr&lt; <ref refid="namespacegmx_1aec46c9561c55f7595677160ee727395d" kindref="member">SelectionParserValueList</ref> &gt;</type>
        <definition>typedef std::unique_ptr&lt;SelectionParserValueList&gt; gmx::SelectionParserValueListPointer</definition>
        <argsstring></argsstring>
        <name>SelectionParserValueListPointer</name>
        <briefdescription>
<para>Smart pointer type for managing a SelectionParserValueList. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/parsetree.h" line="96" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/parsetree.h" bodystart="96" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a2000e8454576fcfcd5a8fdc5d060da4e" prot="public" static="no">
        <type>std::list&lt; <ref refid="classgmx_1_1SelectionParserParameter" kindref="compound">SelectionParserParameter</ref> &gt;</type>
        <definition>typedef std::list&lt;SelectionParserParameter&gt; gmx::SelectionParserParameterList</definition>
        <argsstring></argsstring>
        <name>SelectionParserParameterList</name>
        <briefdescription>
<para>Container for a list of <ref refid="classgmx_1_1SelectionParserParameter" kindref="compound">SelectionParserParameter</ref> objects. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/parsetree.h" line="291" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/parsetree.h" bodystart="287" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1af69a9fb56d051d95e77a90d57a9fa42e" prot="public" static="no">
        <type>std::unique_ptr&lt; <ref refid="namespacegmx_1a2000e8454576fcfcd5a8fdc5d060da4e" kindref="member">SelectionParserParameterList</ref> &gt;</type>
        <definition>typedef std::unique_ptr&lt;SelectionParserParameterList&gt; gmx::SelectionParserParameterListPointer</definition>
        <argsstring></argsstring>
        <name>SelectionParserParameterListPointer</name>
        <briefdescription>
<para>Smart pointer type for managing a SelectionParserParameterList. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/parsetree.h" line="294" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/parsetree.h" bodystart="294" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1ac852a0801cf49723903e23bc77a32163" prot="public" static="no">
        <type>std::vector&lt; <ref refid="classgmx_1_1Selection" kindref="compound">Selection</ref> &gt;</type>
        <definition>typedef std::vector&lt;Selection&gt; gmx::SelectionList</definition>
        <argsstring></argsstring>
        <name>SelectionList</name>
        <briefdescription>
<para>Container of selections used in public selection interfaces. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/selection.h" line="68" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/selection.h" bodystart="65" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a0e73e50cc7002a24229fa6650b8ccfc8" prot="public" static="no">
        <type>std::unique_ptr&lt; <ref refid="classgmx_1_1internal_1_1SelectionData" kindref="compound">internal::SelectionData</ref> &gt;</type>
        <definition>typedef std::unique_ptr&lt;internal::SelectionData&gt; gmx::SelectionDataPointer</definition>
        <argsstring></argsstring>
        <name>SelectionDataPointer</name>
        <briefdescription>
<para>Smart pointer for managing an internal selection data object. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/selectioncollection-impl.h" line="69" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/selectioncollection-impl.h" bodystart="69" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1ab5559201ddf8596d12d99a3c3e45e989" prot="public" static="no">
        <type>std::vector&lt; <ref refid="namespacegmx_1a0e73e50cc7002a24229fa6650b8ccfc8" kindref="member">SelectionDataPointer</ref> &gt;</type>
        <definition>typedef std::vector&lt;SelectionDataPointer&gt; gmx::SelectionDataList</definition>
        <argsstring></argsstring>
        <name>SelectionDataList</name>
        <briefdescription>
<para>Container for storing a list of selections internally. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/selectioncollection-impl.h" line="71" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/selectioncollection-impl.h" bodystart="71" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a4d80aa80d970cd0d36eeac2f5d146dcf" prot="public" static="no">
        <type><ref refid="classgmx_1_1FlagsTemplate" kindref="compound">FlagsTemplate</ref>&lt; <ref refid="namespacegmx_1af16ecfd69d5704fc5de46b97ceff3b65" kindref="member">SelectionFlag</ref> &gt;</type>
        <definition>typedef FlagsTemplate&lt;SelectionFlag&gt; gmx::SelectionFlags</definition>
        <argsstring></argsstring>
        <name>SelectionFlags</name>
        <briefdescription>
<para>Holds a collection of <ref refid="namespacegmx_1af16ecfd69d5704fc5de46b97ceff3b65" kindref="member">SelectionFlag</ref> values. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/selectionenums.h" line="84" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/selectionenums.h" bodystart="84" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a2804c9c82f2a9bd0ec94d3c2f1003f42" prot="public" static="no">
        <type>std::shared_ptr&lt; <ref refid="classgmx_1_1SelectionTreeElement" kindref="compound">SelectionTreeElement</ref> &gt;</type>
        <definition>typedef std::shared_ptr&lt;SelectionTreeElement&gt; gmx::SelectionTreeElementPointer</definition>
        <argsstring></argsstring>
        <name>SelectionTreeElementPointer</name>
        <briefdescription>
<para>Smart pointer type for selection tree element pointers. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/selelem.h" line="75" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/selelem.h" bodystart="72" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1af63a35a5828a347c7d53a3365de983e9" prot="public" static="no">
        <type>void(*</type>
        <definition>typedef void(* gmx::sel_evalfunc)(struct gmx_sel_evaluate_t *data, const SelectionTreeElementPointer &amp;sel, gmx_ana_index_t *g)</definition>
        <argsstring>)(struct gmx_sel_evaluate_t *data, const SelectionTreeElementPointer &amp;sel, gmx_ana_index_t *g)</argsstring>
        <name>sel_evalfunc</name>
        <briefdescription>
<para>Function pointer for evaluating a <ref refid="classgmx_1_1SelectionTreeElement" kindref="compound">gmx::SelectionTreeElement</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/selelem.h" line="245" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/selelem.h" bodystart="245" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a6f05f1bbb0c205deb47822bce1f626e6" prot="public" static="no">
        <type>std::unique_ptr&lt; <ref refid="classgmx_1_1TrajectoryAnalysisModuleData" kindref="compound">TrajectoryAnalysisModuleData</ref> &gt;</type>
        <definition>typedef std::unique_ptr&lt;TrajectoryAnalysisModuleData&gt; gmx::TrajectoryAnalysisModuleDataPointer</definition>
        <argsstring></argsstring>
        <name>TrajectoryAnalysisModuleDataPointer</name>
        <briefdescription>
<para>Smart pointer to manage a <ref refid="classgmx_1_1TrajectoryAnalysisModuleData" kindref="compound">TrajectoryAnalysisModuleData</ref> object. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/trajectoryanalysis/analysismodule.h" line="182" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/trajectoryanalysis/analysismodule.h" bodystart="182" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a832da3c093109c13cc2369de05e02f3b" prot="public" static="no">
        <type>std::unique_ptr&lt; <ref refid="classgmx_1_1TrajectoryAnalysisModule" kindref="compound">TrajectoryAnalysisModule</ref> &gt;</type>
        <definition>typedef std::unique_ptr&lt;TrajectoryAnalysisModule&gt; gmx::TrajectoryAnalysisModulePointer</definition>
        <argsstring></argsstring>
        <name>TrajectoryAnalysisModulePointer</name>
        <briefdescription>
<para>Smart pointer to manage a <ref refid="classgmx_1_1TrajectoryAnalysisModule" kindref="compound">TrajectoryAnalysisModule</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/trajectoryanalysis/analysismodule.h" line="500" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/trajectoryanalysis/analysismodule.h" bodystart="500" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__module__utility_1ga590b36651977793730ea2413906302cf" prot="public" static="no">
        <type><ref refid="classgmx_1_1ExceptionInfo" kindref="compound">ExceptionInfo</ref>&lt; struct ExceptionInfoErrno_, int &gt;</type>
        <definition>typedef ExceptionInfo&lt;struct ExceptionInfoErrno_, int&gt; gmx::ExceptionInfoErrno</definition>
        <argsstring></argsstring>
        <name>ExceptionInfoErrno</name>
        <briefdescription>
<para>Stores <computeroutput>errno</computeroutput> value that triggered the exception. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/exceptions.h" line="160" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/exceptions.h" bodystart="160" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__module__utility_1ga3c8f9c19c0ed36c16770317afc7c69bb" prot="public" static="no">
        <type><ref refid="classgmx_1_1ExceptionInfo" kindref="compound">ExceptionInfo</ref>&lt; struct ExceptionInfoApiFunc_, const char * &gt;</type>
        <definition>typedef ExceptionInfo&lt;struct ExceptionInfoApiFunc_, const char *&gt; gmx::ExceptionInfoApiFunction</definition>
        <argsstring></argsstring>
        <name>ExceptionInfoApiFunction</name>
        <briefdescription>
<para>Stores the function name that returned the <computeroutput>errno</computeroutput> in ExceptionInfoErrno. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/exceptions.h" line="163" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/exceptions.h" bodystart="163" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__module__utility_1gab5d3ee620090581599c5762270314897" prot="public" static="no">
        <type><ref refid="classgmx_1_1ExceptionInfo" kindref="compound">ExceptionInfo</ref>&lt; struct ExceptionInfoLocation_, <ref refid="structgmx_1_1ThrowLocation" kindref="compound">ThrowLocation</ref> &gt;</type>
        <definition>typedef ExceptionInfo&lt;struct ExceptionInfoLocation_, ThrowLocation&gt; gmx::ExceptionInfoLocation</definition>
        <argsstring></argsstring>
        <name>ExceptionInfoLocation</name>
        <briefdescription>
<para>Stores the location where the exception was thrown. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/exceptions.h" line="166" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/exceptions.h" bodystart="166" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1ab59286953efe778908daa3e5607f0a0e" prot="public" static="no">
        <type>tMPI::mutex</type>
        <definition>typedef tMPI::mutex gmx::Mutex</definition>
        <argsstring></argsstring>
        <name>Mutex</name>
        <briefdescription>
<para>C++11-compatible basic mutex. </para>        </briefdescription>
        <detaileddescription>
<para> <libinternal />  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/mutex.h" line="58" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/mutex.h" bodystart="58" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1af58ef5153befc109091dcbf8a5b2fb1c" prot="public" static="no">
        <type><ref refid="classgmx_1_1scoped__cptr" kindref="compound">scoped_cptr</ref>&lt; void &gt;</type>
        <definition>typedef scoped_cptr&lt;void&gt; gmx::scoped_guard_sfree</definition>
        <argsstring></argsstring>
        <name>scoped_guard_sfree</name>
        <briefdescription>
<para>Simple guard which calls sfree. See <ref refid="classgmx_1_1scoped__cptr" kindref="compound">scoped_cptr</ref> for details. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/scoped_cptr.h" line="103" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/scoped_cptr.h" bodystart="103" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a2fbe80608de8e00e55049289ef0148c1" prot="public" static="no">
        <type>std::shared_ptr&lt; <ref refid="classgmx_1_1TextInputStream" kindref="compound">TextInputStream</ref> &gt;</type>
        <definition>typedef std::shared_ptr&lt;TextInputStream&gt; gmx::TextInputStreamPointer</definition>
        <argsstring></argsstring>
        <name>TextInputStreamPointer</name>
        <briefdescription>
<para>Shorthand for a smart pointer to a <ref refid="classgmx_1_1TextInputStream" kindref="compound">TextInputStream</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/textstream.h" line="142" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/textstream.h" bodystart="142" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacegmx_1a1fdec6c0997f8c033905f1f82f253d25" prot="public" static="no">
        <type>std::shared_ptr&lt; <ref refid="classgmx_1_1TextOutputStream" kindref="compound">TextOutputStream</ref> &gt;</type>
        <definition>typedef std::shared_ptr&lt;TextOutputStream&gt; gmx::TextOutputStreamPointer</definition>
        <argsstring></argsstring>
        <name>TextOutputStreamPointer</name>
        <briefdescription>
<para>Shorthand for a smart pointer to a <ref refid="classgmx_1_1TextOutputStream" kindref="compound">TextOutputStream</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/textstream.h" line="144" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/textstream.h" bodystart="144" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="namespacegmx_1a69d101abde50194b033bd47aca343efb" prot="public" static="no" mutable="no">
        <type><ref refid="namespacegmx_1a8593c4aa4e1f10f3571c8b8f2cd933a8" kindref="member">integrator_t</ref></type>
        <definition>integrator_t gmx::do_steep</definition>
        <argsstring></argsstring>
        <name>do_steep</name>
        <briefdescription>
<para>Steepest descents energy minimization. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/mdlib/minimize.h" line="49" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/mdlib/minimize.h" bodystart="49" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacegmx_1a6b7e06ca1a66d04665db497fe64b8c2c" prot="public" static="no" mutable="no">
        <type><ref refid="namespacegmx_1a8593c4aa4e1f10f3571c8b8f2cd933a8" kindref="member">integrator_t</ref></type>
        <definition>integrator_t gmx::do_cg</definition>
        <argsstring></argsstring>
        <name>do_cg</name>
        <briefdescription>
<para>Conjugate gradient energy minimization. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/mdlib/minimize.h" line="52" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/mdlib/minimize.h" bodystart="52" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacegmx_1ac6a1b057a39053d0c4a28c49285f900e" prot="public" static="no" mutable="no">
        <type><ref refid="namespacegmx_1a8593c4aa4e1f10f3571c8b8f2cd933a8" kindref="member">integrator_t</ref></type>
        <definition>integrator_t gmx::do_lbfgs</definition>
        <argsstring></argsstring>
        <name>do_lbfgs</name>
        <briefdescription>
<para>Conjugate gradient energy minimization using the L-BFGS algorithm. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/mdlib/minimize.h" line="55" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/mdlib/minimize.h" bodystart="55" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacegmx_1aa6872c2f4b813d88a0beccdacfe730c9" prot="public" static="no" mutable="no">
        <type><ref refid="namespacegmx_1a8593c4aa4e1f10f3571c8b8f2cd933a8" kindref="member">integrator_t</ref></type>
        <definition>integrator_t gmx::do_nm</definition>
        <argsstring></argsstring>
        <name>do_nm</name>
        <briefdescription>
<para>Normal mode analysis. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/mdlib/minimize.h" line="58" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/mdlib/minimize.h" bodystart="58" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacegmx_1a1efd8b13fa02f4aebf73a8d8555e81f9" prot="public" static="no" mutable="no">
        <type><ref refid="namespacegmx_1a8593c4aa4e1f10f3571c8b8f2cd933a8" kindref="member">integrator_t</ref></type>
        <definition>integrator_t gmx::do_tpi</definition>
        <argsstring></argsstring>
        <name>do_tpi</name>
        <briefdescription>
<para>Test particle insertion. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/mdlib/tpi.h" line="49" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/mdlib/tpi.h" bodystart="49" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__module__simd_1ga9237b6439778ed0fdfd9008a78c25f3c" prot="public" static="yes" mutable="no">
        <type>const int</type>
        <definition>const int gmx::c_simdBestPairAlignmentDouble</definition>
        <argsstring></argsstring>
        <name>c_simdBestPairAlignmentDouble</name>
        <initializer>= 2</initializer>
        <briefdescription>
<para>Best alignment to use for aligned pairs of double data. </para>        </briefdescription>
        <detaileddescription>
<para>The routines to load and transpose data will work with a wide range of alignments, but some might be faster than others, depending on the load instructions available in the hardware. This specifies the best alignment for each implementation when working with pairs of data.</para><para>To allow each architecture to use the most optimal form, we use a constant that code outside the SIMD module should use to store things properly. It must be at least 2. For example, a value of 2 means the two parameters A &amp; B are stored as [A0 B0 A1 B1] while align-4 means [A0 B0 - - A1 B1 - -].</para><para>This alignment depends on the efficiency of partial-register load/store operations, and will depend on the architecture. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" line="178" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" bodystart="178" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__module__simd_1gacc4ad17022538e3d670e55694e55ccc2" prot="public" static="yes" mutable="no">
        <type>const int</type>
        <definition>const int gmx::c_simdBestPairAlignmentFloat</definition>
        <argsstring></argsstring>
        <name>c_simdBestPairAlignmentFloat</name>
        <initializer>= 2</initializer>
        <briefdescription>
<para>Best alignment to use for aligned pairs of float data. </para>        </briefdescription>
        <detaileddescription>
<para>The routines to load and transpose data will work with a wide range of alignments, but some might be faster than others, depending on the load instructions available in the hardware. This specifies the best alignment for each implementation when working with pairs of data.</para><para>To allow each architecture to use the most optimal form, we use a constant that code outside the SIMD module should use to store things properly. It must be at least 2. For example, a value of 2 means the two parameters A &amp; B are stored as [A0 B0 A1 B1] while align-4 means [A0 B0 - - A1 B1 - -].</para><para>This alignment depends on the efficiency of partial-register load/store operations, and will depend on the architecture. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" line="196" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" bodystart="196" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacegmx_1a19f6a93a5bf9ce1e585bebf205d6f6ea" prot="public" static="no" mutable="no">
        <type><ref refid="namespacegmx_1a8593c4aa4e1f10f3571c8b8f2cd933a8" kindref="member">integrator_t</ref></type>
        <definition>double gmx::do_md</definition>
        <argsstring></argsstring>
        <name>do_md</name>
        <briefdescription>
<para>MD simulations. </para>        </briefdescription>
        <detaileddescription>
<para>Integrator algorithm implementation. (FILE *fplog, <ref refid="structt__commrec" kindref="compound">t_commrec</ref> *cr,</para><para> <libinternal />  <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fplog</parametername>
</parameternamelist>
<parameterdescription>
<para>Log file for output </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cr</parametername>
</parameternamelist>
<parameterdescription>
<para>Communication record </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nfile</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of files </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fnm</parametername>
</parameternamelist>
<parameterdescription>
<para>Filename structure array </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">oenv</parametername>
</parameternamelist>
<parameterdescription>
<para>Output information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">bVerbose</parametername>
</parameternamelist>
<parameterdescription>
<para>Verbose output or not </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nstglobalcomm</parametername>
</parameternamelist>
<parameterdescription>
<para>How often global communication is done </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">vsite</parametername>
</parameternamelist>
<parameterdescription>
<para>Virtual site information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">constr</parametername>
</parameternamelist>
<parameterdescription>
<para>Constraint information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">stepout</parametername>
</parameternamelist>
<parameterdescription>
<para>How often we writen to the console </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">inputrec</parametername>
</parameternamelist>
<parameterdescription>
<para>Input record with mdp options </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">top_global</parametername>
</parameternamelist>
<parameterdescription>
<para>Molecular topology for the whole system </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fcd</parametername>
</parameternamelist>
<parameterdescription>
<para>Force and constraint data </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">state_global</parametername>
</parameternamelist>
<parameterdescription>
<para>The state (x, v, f, box etc.) of the whole system </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">mdatoms</parametername>
</parameternamelist>
<parameterdescription>
<para>Structure containing atom information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nrnb</parametername>
</parameternamelist>
<parameterdescription>
<para>Accounting for floating point operations </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">wcycle</parametername>
</parameternamelist>
<parameterdescription>
<para>Wall cycle timing information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ed</parametername>
</parameternamelist>
<parameterdescription>
<para>Essential dynamics sampling information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fr</parametername>
</parameternamelist>
<parameterdescription>
<para>Force record with cut-off information and more </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">repl_ex_nst</parametername>
</parameternamelist>
<parameterdescription>
<para>How often we do replica exchange (in steps) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">repl_ex_nex</parametername>
</parameternamelist>
<parameterdescription>
<para>How many replicas we have </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">repl_ex_seed</parametername>
</parameternamelist>
<parameterdescription>
<para>The seed for Monte Carlo swaps </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">membed</parametername>
</parameternamelist>
<parameterdescription>
<para>Membrane embedding data structure </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cpt_period</parametername>
</parameternamelist>
<parameterdescription>
<para>How often to checkpoint the simulation </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">max_hours</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximume length of the simulation (wall time) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">imdport</parametername>
</parameternamelist>
<parameterdescription>
<para>Interactive MD port (socket) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">Flags</parametername>
</parameternamelist>
<parameterdescription>
<para>Flags to control mdrun </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">walltime_accounting</parametername>
</parameternamelist>
<parameterdescription>
<para>More timing information (FILE *fplog, <ref refid="structt__commrec" kindref="compound">t_commrec</ref> *cr, int nfile, const <ref refid="structt__filenm" kindref="compound">t_filenm</ref> fnm[], const <ref refid="structgmx__output__env__t" kindref="compound">gmx_output_env_t</ref> *oenv, gmx_bool bVerbose, int nstglobalcomm, <ref refid="structgmx__vsite__t" kindref="compound">gmx_vsite_t</ref> *vsite, gmx_constr_t constr, int stepout, <ref refid="structt__inputrec" kindref="compound">t_inputrec</ref> *inputrec, <ref refid="structgmx__mtop__t" kindref="compound">gmx_mtop_t</ref> *top_global, <ref refid="structt__fcdata" kindref="compound">t_fcdata</ref> *fcd, <ref refid="structt__state" kindref="compound">t_state</ref> *state_global, <ref refid="structt__mdatoms" kindref="compound">t_mdatoms</ref> *mdatoms, <ref refid="structt__nrnb" kindref="compound">t_nrnb</ref> *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, <ref refid="structt__forcerec" kindref="compound">t_forcerec</ref> *fr, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, real cpt_period, real max_hours, int imdport, unsigned long Flags, gmx_walltime_accounting_t walltime_accounting) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/programs/mdrun/md.h" line="51" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/programs/mdrun/md.h" bodystart="51" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__group__publicapi_1gaaf9a9e69ad91172d5f4fba7148280762" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1AnalysisHistogramSettingsInitializer" kindref="compound">AnalysisHistogramSettingsInitializer</ref></type>
        <definition>AnalysisHistogramSettingsInitializer gmx::histogramFromRange</definition>
        <argsstring>(real min, real max)</argsstring>
        <name>histogramFromRange</name>
        <param>
          <type><ref refid="real_8h_1a58a0c7cf2501f4492da833421be92547" kindref="member">real</ref></type>
          <declname>min</declname>
        </param>
        <param>
          <type><ref refid="real_8h_1a58a0c7cf2501f4492da833421be92547" kindref="member">real</ref></type>
          <declname>max</declname>
        </param>
        <briefdescription>
<para>Initializes a histogram using a range and a bin width. </para>        </briefdescription>
        <detaileddescription>
<para>Does not throw. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/modules/histogram.h" line="171" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/modules/histogram.h" bodystart="171" bodyend="174"/>
      </memberdef>
      <memberdef kind="function" id="group__group__publicapi_1ga73a2213cd82e2f915b9f9d65a4b85212" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1AnalysisHistogramSettingsInitializer" kindref="compound">AnalysisHistogramSettingsInitializer</ref></type>
        <definition>AnalysisHistogramSettingsInitializer gmx::histogramFromBins</definition>
        <argsstring>(real start, int nbins, real binwidth)</argsstring>
        <name>histogramFromBins</name>
        <param>
          <type><ref refid="real_8h_1a58a0c7cf2501f4492da833421be92547" kindref="member">real</ref></type>
          <declname>start</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nbins</declname>
        </param>
        <param>
          <type><ref refid="real_8h_1a58a0c7cf2501f4492da833421be92547" kindref="member">real</ref></type>
          <declname>binwidth</declname>
        </param>
        <briefdescription>
<para>Initializes a histogram using bin width and the number of bins. </para>        </briefdescription>
        <detaileddescription>
<para>Does not throw. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/modules/histogram.h" line="184" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/analysisdata/modules/histogram.h" bodystart="184" bodyend="188"/>
      </memberdef>
      <memberdef kind="function" id="group__module__commandline_1ga8c376f5f94bd1a63a3a97e288c4be50d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classgmx_1_1CommandLineProgramContext" kindref="compound">CommandLineProgramContext</ref> &amp;</type>
        <definition>CommandLineProgramContext &amp; gmx::initForCommandLine</definition>
        <argsstring>(int *argc, char ***argv)</argsstring>
        <name>initForCommandLine</name>
        <param>
          <type>int *</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char ***</type>
          <declname>argv</declname>
        </param>
        <briefdescription>
<para>Initializes the GROMACS library for command-line use. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">argc</parametername>
</parameternamelist>
<parameterdescription>
<para>argc value passed to <ref refid="test__selection_8cpp_1a0ddf1224851353fc92bfbff6f499fa97" kindref="member">main()</ref>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">argv</parametername>
</parameternamelist>
<parameterdescription>
<para>argv array passed to <ref refid="test__selection_8cpp_1a0ddf1224851353fc92bfbff6f499fa97" kindref="member">main()</ref>. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Reference to initialized program context object.</para></simplesect>
This function is tailored for use in command line applications. For other usage, combination of <ref refid="group__module__utility_1gae00d174a8ddd5325460d74dc663711c0" kindref="member">gmx::init()</ref> and <ref refid="group__module__utility_1ga2cf34635c815cc712b6291c2c8da2555" kindref="member">gmx::setProgramContext()</ref> provides more flexible initialization alternatives. Unlike <ref refid="group__module__utility_1gae00d174a8ddd5325460d74dc663711c0" kindref="member">gmx::init()</ref>, calls to this method cannot be nested.</para><para>The command line arguments are communicated so that they can be parsed on each processor. <computeroutput>argc</computeroutput> and <computeroutput>argv</computeroutput> are passed to <ref refid="group__module__utility_1gae00d174a8ddd5325460d74dc663711c0" kindref="member">gmx::init()</ref>; see there for additional discussion. This method does not place any additional limitations, but generally there should be no need to pass NULL values.</para><para>Does not throw. Terminates the program on out-of-memory error.</para><para>This method is not thread-safe, since it is intended to be the first method called. See <ref refid="group__module__utility_1ga2cf34635c815cc712b6291c2c8da2555" kindref="member">setProgramContext()</ref> for additional discussion.</para><para><simplesect kind="see"><para><ref refid="group__module__utility_1gae00d174a8ddd5325460d74dc663711c0" kindref="member">gmx::init()</ref> </para><simplesectsep/><para><ref refid="group__module__utility_1ga2cf34635c815cc712b6291c2c8da2555" kindref="member">setProgramContext()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/cmdlineinit.cpp" line="117" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/cmdlineinit.cpp" bodystart="117" bodyend="139"/>
      </memberdef>
      <memberdef kind="function" id="group__module__commandline_1ga49311a4a4e3f3ec07a9ae925fb63151f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void gmx::finalizeForCommandLine</definition>
        <argsstring>()</argsstring>
        <name>finalizeForCommandLine</name>
        <briefdescription>
<para>Deinitializes the GROMACS library after <ref refid="group__module__commandline_1ga8c376f5f94bd1a63a3a97e288c4be50d" kindref="member">initForCommandLine()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>Calls <ref refid="group__module__utility_1gaa0a90b2770cb4b69e16229daa271a1af" kindref="member">gmx::finalize()</ref> and additionally undoes the work done by <ref refid="group__module__commandline_1ga8c376f5f94bd1a63a3a97e288c4be50d" kindref="member">initForCommandLine()</ref>.</para><para><simplesect kind="see"><para><ref refid="group__module__utility_1gaa0a90b2770cb4b69e16229daa271a1af" kindref="member">gmx::finalize()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/cmdlineinit.cpp" line="141" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/cmdlineinit.cpp" bodystart="141" bodyend="148"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ad8fe34835a6e197f2731e7d604f28992" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int gmx::processExceptionAtExitForCommandLine</definition>
        <argsstring>(const std::exception &amp;ex)</argsstring>
        <name>processExceptionAtExitForCommandLine</name>
        <param>
          <type>const std::exception &amp;</type>
          <declname>ex</declname>
        </param>
        <briefdescription>
<para>Handles an exception and deinitializes after initForCommandLine. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ex</parametername>
</parameternamelist>
<parameterdescription>
<para>Exception that is the cause for terminating the program. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Return code to return from <ref refid="test__selection_8cpp_1a0ddf1224851353fc92bfbff6f499fa97" kindref="member">main()</ref>.</para></simplesect>
This method should be called as the last thing before terminating the program because of an exception. See <ref refid="group__module__utility_1ga5a45f49e157fa8e1059d24243283e248" kindref="member">processExceptionAtExit()</ref> for details. Additionally this method undoes the work done by initForCommandLine.</para><para>Does not throw. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/cmdlineinit.cpp" line="150" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/cmdlineinit.cpp" bodystart="150" bodyend="155"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a5a3bc0e66dda7e48091ad129bede7eff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int gmx::runCommandLineModule</definition>
        <argsstring>(int argc, char *argv[], ICommandLineModule *module)</argsstring>
        <name>runCommandLineModule</name>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char *</type>
          <declname>argv</declname>
          <array>[]</array>
        </param>
        <param>
          <type><ref refid="classgmx_1_1ICommandLineModule" kindref="compound">ICommandLineModule</ref> *</type>
          <declname>module</declname>
        </param>
        <briefdescription>
<para>Implements a <ref refid="test__selection_8cpp_1a0ddf1224851353fc92bfbff6f499fa97" kindref="member">main()</ref> method that runs a single module. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para><computeroutput>argc</computeroutput> passed to <ref refid="test__selection_8cpp_1a0ddf1224851353fc92bfbff6f499fa97" kindref="member">main()</ref>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para><computeroutput>argv</computeroutput> passed to <ref refid="test__selection_8cpp_1a0ddf1224851353fc92bfbff6f499fa97" kindref="member">main()</ref>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>module</parametername>
</parameternamelist>
<parameterdescription>
<para>Module to run.</para></parameterdescription>
</parameteritem>
</parameterlist>
This method allows for uniform behavior for binaries that only contain a single module without duplicating any of the implementation from <ref refid="classgmx_1_1CommandLineModuleManager" kindref="compound">CommandLineModuleManager</ref> (startup headers, common options etc.).</para><para>The signature assumes that <computeroutput>module</computeroutput> construction does not throw (because otherwise the caller would need to duplicate all the exception handling code). It is possible to move the construction inside the try/catch in this method using an indirection similar to <ref refid="classgmx_1_1TrajectoryAnalysisCommandLineRunner_1a12cd1b40ed04cda667f315e2adee3337" kindref="member">TrajectoryAnalysisCommandLineRunner::runAsMain()</ref>, but until that is necessary, the current approach leads to simpler code.</para><para>Usage: <programlisting><codeline><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="test__selection_8cpp_1a0ddf1224851353fc92bfbff6f499fa97" kindref="member">main</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CustomCommandLineModule<sp/>module;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="namespacegmx_1a5a3bc0e66dda7e48091ad129bede7eff" kindref="member">gmx::runCommandLineModule</ref>(argc,<sp/>argv,<sp/>&amp;module);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Does not throw. All exceptions are caught and handled internally. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/cmdlineinit.cpp" line="157" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/cmdlineinit.cpp" bodystart="157" bodyend="161"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a8a7a039b6fae746686d472d1fcae6fee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int gmx::runCommandLineModule</definition>
        <argsstring>(int argc, char *argv[], const char *name, const char *description, std::function&lt; std::unique_ptr&lt; ICommandLineOptionsModule &gt;()&gt; factory)</argsstring>
        <name>runCommandLineModule</name>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char *</type>
          <declname>argv</declname>
          <array>[]</array>
        </param>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>description</declname>
        </param>
        <param>
          <type>std::function&lt; std::unique_ptr&lt; <ref refid="classgmx_1_1ICommandLineOptionsModule" kindref="compound">ICommandLineOptionsModule</ref> &gt;()&gt;</type>
          <declname>factory</declname>
        </param>
        <briefdescription>
<para>Implements a <ref refid="test__selection_8cpp_1a0ddf1224851353fc92bfbff6f499fa97" kindref="member">main()</ref> method that runs a single module. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para><computeroutput>argc</computeroutput> passed to <ref refid="test__selection_8cpp_1a0ddf1224851353fc92bfbff6f499fa97" kindref="member">main()</ref>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para><computeroutput>argv</computeroutput> passed to <ref refid="test__selection_8cpp_1a0ddf1224851353fc92bfbff6f499fa97" kindref="member">main()</ref>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">name</parametername>
</parameternamelist>
<parameterdescription>
<para>Name for the module. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">description</parametername>
</parameternamelist>
<parameterdescription>
<para>Short description for the module. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>factory</parametername>
</parameternamelist>
<parameterdescription>
<para>Factory method that creates the module to run.</para></parameterdescription>
</parameteritem>
</parameterlist>
This method allows for uniform behavior for binaries that only contain a single module without duplicating any of the implementation from <ref refid="classgmx_1_1CommandLineModuleManager" kindref="compound">CommandLineModuleManager</ref> (startup headers, common options etc.).</para><para>Usage: <programlisting><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">CustomCommandLineOptionsModule<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>ICommandLineOptionsModule</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>&lt;...&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>ICommandLineOptionsModule<sp/>*create()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>CustomCommandLineOptionsModule();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="test__selection_8cpp_1a0ddf1224851353fc92bfbff6f499fa97" kindref="member">main</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="namespacegmx_1a5a3bc0e66dda7e48091ad129bede7eff" kindref="member">gmx::runCommandLineModule</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>argc,<sp/>argv,<sp/></highlight><highlight class="stringliteral">&quot;mymodule&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;short<sp/>description&quot;</highlight><highlight class="normal">,<sp/>&amp;create);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Does not throw. All exceptions are caught and handled internally. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/cmdlineinit.cpp" line="163" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/cmdlineinit.cpp" bodystart="163" bodyend="169"/>
      </memberdef>
      <memberdef kind="function" id="group__module__commandline_1gaf25f64b0a1dde1a8e6774f93e0bae0e9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void gmx::writeCommandLineHelpCMain</definition>
        <argsstring>(const CommandLineHelpContext &amp;context, const char *name, int(*mainFunction)(int argc, char *argv[]))</argsstring>
        <name>writeCommandLineHelpCMain</name>
        <param>
          <type>const <ref refid="classgmx_1_1CommandLineHelpContext" kindref="compound">CommandLineHelpContext</ref> &amp;</type>
          <declname>context</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int(*)(int argc, char *argv[])</type>
          <declname>mainFunction</declname>
        </param>
        <briefdescription>
<para>Helper to implement <ref refid="classgmx_1_1ICommandLineModule_1a947eea9c2e648aa837d385fcbe01c1bd" kindref="member">ICommandLineModule::writeHelp()</ref> with a C-like <ref refid="test__selection_8cpp_1a0ddf1224851353fc92bfbff6f499fa97" kindref="member">main()</ref> function that calls <ref refid="group__module__commandline_1ga5140c89919960e8e1e218a5b0d881cd5" kindref="member">parse_common_args()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para> <libinternal /> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">context</parametername>
</parameternamelist>
<parameterdescription>
<para>Context object for writing the help. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">name</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of the module. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">mainFunction</parametername>
</parameternamelist>
<parameterdescription>
<para>C-like <ref refid="test__selection_8cpp_1a0ddf1224851353fc92bfbff6f499fa97" kindref="member">main()</ref> function that calls <ref refid="group__module__commandline_1ga5140c89919960e8e1e218a5b0d881cd5" kindref="member">parse_common_args()</ref>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/cmdlinemodule.cpp" line="79" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/commandline/cmdlinemodule.cpp" bodystart="79" bodyend="90"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1af536d7a23a442f3c0876b05ac20d7d40" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool gmx::cpuIsX86Nehalem</definition>
        <argsstring>(const CpuInfo &amp;cpuInfo)</argsstring>
        <name>cpuIsX86Nehalem</name>
        <param>
          <type>const <ref refid="classgmx_1_1CpuInfo" kindref="compound">CpuInfo</ref> &amp;</type>
          <declname>cpuInfo</declname>
        </param>
        <briefdescription>
<para>Return true if the CPU is an Intel x86 Nehalem. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>cpuInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Object with cpu information</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if running on Nehalem CPU </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/hardware/cpuinfo.cpp" line="999" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/hardware/cpuinfo.cpp" bodystart="999" bodyend="1006"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a2b47d79ef735987258c2f601cf2822be" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>unsigned int</type>
        <definition>unsigned int gmx::log2I</definition>
        <argsstring>(std::uint32_t x)</argsstring>
        <name>log2I</name>
        <param>
          <type>std::uint32_t</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Compute floor of logarithm to base 2, 32 bit unsigned argument. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>32-bit unsigned argument</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>log2(x)</para></simplesect>
<simplesect kind="note"><para>This version of the overloaded function uses unsigned arguments to be able to handle arguments using all 32 bits. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.cpp" line="67" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.cpp" bodystart="67" bodyend="119"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aa498ec06db6575ec672e5ba847f086ab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>unsigned int</type>
        <definition>unsigned int gmx::log2I</definition>
        <argsstring>(std::uint64_t x)</argsstring>
        <name>log2I</name>
        <param>
          <type>std::uint64_t</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Compute floor of logarithm to base 2, 64 bit unsigned argument. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>64-bit unsigned argument</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>log2(x)</para></simplesect>
<simplesect kind="note"><para>This version of the overloaded function uses unsigned arguments to be able to handle arguments using all 64 bits. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.cpp" line="123" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.cpp" bodystart="123" bodyend="154"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ab1cadcfe34ba004506db6e0e11f36c95" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>unsigned int</type>
        <definition>unsigned int gmx::log2I</definition>
        <argsstring>(std::int32_t x)</argsstring>
        <name>log2I</name>
        <param>
          <type>std::int32_t</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Compute floor of logarithm to base 2, 32 bit signed argument. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>32-bit signed argument</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>log2(x)</para></simplesect>
<simplesect kind="note"><para>This version of the overloaded function will assert that x is not negative. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.cpp" line="157" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.cpp" bodystart="157" bodyend="161"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1afbfba3f9dd776dc29c1d0a8311ed793f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>unsigned int</type>
        <definition>unsigned int gmx::log2I</definition>
        <argsstring>(std::int64_t x)</argsstring>
        <name>log2I</name>
        <param>
          <type>std::int64_t</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Compute floor of logarithm to base 2, 64 bit signed argument. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>64-bit signed argument</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>log2(x)</para></simplesect>
<simplesect kind="note"><para>This version of the overloaded function will assert that x is not negative. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.cpp" line="164" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.cpp" bodystart="164" bodyend="168"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a87a820e81baebe1c30a4190eb2aa2a64" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::int64_t</type>
        <definition>std::int64_t gmx::greatestCommonDivisor</definition>
        <argsstring>(std::int64_t p, std::int64_t q)</argsstring>
        <name>greatestCommonDivisor</name>
        <param>
          <type>std::int64_t</type>
          <declname>p</declname>
        </param>
        <param>
          <type>std::int64_t</type>
          <declname>q</declname>
        </param>
        <briefdescription>
<para>Find greatest common divisor of two numbers. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>First number, positive </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>q</parametername>
</parameternamelist>
<parameterdescription>
<para>Second number, positive</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Greatest common divisor of p and q </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.cpp" line="171" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.cpp" bodystart="171" bodyend="181"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a2dad03094a0ea5970a5f0977ce5fee84" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double gmx::erfinv</definition>
        <argsstring>(double x)</argsstring>
        <name>erfinv</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Inverse error function, double precision. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument, should be in the range -1.0 &lt; x &lt; 1.0</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The inverse of the error function if the argument is inside the range, +/- infinity if it is exactly 1.0 or -1.0, and NaN otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.cpp" line="184" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.cpp" bodystart="184" bodyend="227"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a85012c7d3609ac21e4052fc3114125a9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>float</type>
        <definition>float gmx::erfinv</definition>
        <argsstring>(float x)</argsstring>
        <name>erfinv</name>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Inverse error function, single precision. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument, should be in the range -1.0 &lt; x &lt; 1.0</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The inverse of the error function if the argument is inside the range, +/- infinity if it is exactly 1.0 or -1.0, and NaN otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.cpp" line="230" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.cpp" bodystart="230" bodyend="272"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a953226d61f6527af6485ea56a8384c85" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::invsqrt</definition>
        <argsstring>(float x)</argsstring>
        <name>invsqrt</name>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate 1.0/sqrt(x) in single precision. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Positive value to calculate inverse square root for</para></parameterdescription>
</parameteritem>
</parameterlist>
For now this is implemented with std::sqrt(x) since gcc seems to do a decent job optimizing it. However, we might decide to use instrinsics or compiler-specific functions in the future.</para><para><simplesect kind="return"><para>1.0/sqrt(x) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" line="167" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" bodystart="167" bodyend="170"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ae26d0b65eb141c73979c5d2f1d0e13fa" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::invsqrt</definition>
        <argsstring>(double x)</argsstring>
        <name>invsqrt</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate 1.0/sqrt(x) in double precision, but single range. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Positive value to calculate inverse square root for, must be in the input domain valid for single precision.</para></parameterdescription>
</parameteritem>
</parameterlist>
For now this is implemented with std::sqrt(x). However, we might decide to use instrinsics or compiler-specific functions in the future, and then we want to have the freedom to do the first step in single precision.</para><para><simplesect kind="return"><para>1.0/sqrt(x) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" line="184" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" bodystart="184" bodyend="187"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aa91cb31b7abc3e020022ac8ce0b1b262" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::invsqrt</definition>
        <argsstring>(int x)</argsstring>
        <name>invsqrt</name>
        <param>
          <type>int</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate 1.0/sqrt(x) for integer x in double precision. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Positive value to calculate inverse square root for.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1.0/sqrt(x) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" line="196" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" bodystart="196" bodyend="199"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1acabf4874cb58de0554f95f69c1768882" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::invcbrt</definition>
        <argsstring>(float x)</argsstring>
        <name>invcbrt</name>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate inverse cube root of x in single precision. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>x^(-1/3)</para></simplesect>
This routine is typically faster than using std::pow(). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" line="210" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" bodystart="210" bodyend="213"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a08d99226376a495b484eccd203d29c8d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::invcbrt</definition>
        <argsstring>(double x)</argsstring>
        <name>invcbrt</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate inverse sixth root of x in double precision. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>x^(-1/3)</para></simplesect>
This routine is typically faster than using std::pow(). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" line="224" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" bodystart="224" bodyend="227"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a1d304cf0e3cac1632695e394077fd2d7" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::invcbrt</definition>
        <argsstring>(int x)</argsstring>
        <name>invcbrt</name>
        <param>
          <type>int</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate inverse sixth root of integer x in double precision. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>x^(-1/3)</para></simplesect>
This routine is typically faster than using std::pow(). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" line="238" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" bodystart="238" bodyend="241"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a12dcc6af3bf2f769ea1e17ed12921e2c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::sixthroot</definition>
        <argsstring>(float x)</argsstring>
        <name>sixthroot</name>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate sixth root of x in single precision. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument, must be greater than or equal to zero.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>x^(1/6)</para></simplesect>
This routine is typically faster than using std::pow(). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" line="252" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" bodystart="252" bodyend="255"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a4cf2628e4b20455d3396e0c2c234b951" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::sixthroot</definition>
        <argsstring>(double x)</argsstring>
        <name>sixthroot</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate sixth root of x in double precision. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument, must be greater than or equal to zero.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>x^(1/6)</para></simplesect>
This routine is typically faster than using std::pow(). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" line="266" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" bodystart="266" bodyend="269"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a02308efcb527a69ce399111550575880" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::sixthroot</definition>
        <argsstring>(int x)</argsstring>
        <name>sixthroot</name>
        <param>
          <type>int</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate sixth root of integer x, return double. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument, must be greater than or equal to zero.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>x^(1/6)</para></simplesect>
This routine is typically faster than using std::pow(). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" line="280" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" bodystart="280" bodyend="283"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ad3aeb9a178f07d4bc64b934555d12842" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::invsixthroot</definition>
        <argsstring>(float x)</argsstring>
        <name>invsixthroot</name>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate inverse sixth root of x in single precision. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument, must be greater than zero.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>x^(-1/6)</para></simplesect>
This routine is typically faster than using std::pow(). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" line="294" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" bodystart="294" bodyend="297"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a2f8b9b01e7c291a443840d4f7af97c5c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::invsixthroot</definition>
        <argsstring>(double x)</argsstring>
        <name>invsixthroot</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate inverse sixth root of x in double precision. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument, must be greater than zero.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>x^(-1/6)</para></simplesect>
This routine is typically faster than using std::pow(). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" line="308" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" bodystart="308" bodyend="311"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a1604baa1a44d1de7bafa433c9443c395" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::invsixthroot</definition>
        <argsstring>(int x)</argsstring>
        <name>invsixthroot</name>
        <param>
          <type>int</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate inverse sixth root of integer x in double precision. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument, must be greater than zero.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>x^(-1/6)</para></simplesect>
This routine is typically faster than using std::pow(). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" line="322" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" bodystart="322" bodyend="325"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a06cbcb5324f3eb428189024f020158ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T gmx::square</definition>
        <argsstring>(T x)</argsstring>
        <name>square</name>
        <param>
          <type>T</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>calculate x^2 </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of argument and return value </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>argument</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>x^2 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" line="336" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" bodystart="336" bodyend="339"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1abda6daf50f5129fb74816db29e411497" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T gmx::power3</definition>
        <argsstring>(T x)</argsstring>
        <name>power3</name>
        <param>
          <type>T</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>calculate x^3 </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of argument and return value </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>argument</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>x^3 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" line="350" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" bodystart="350" bodyend="353"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a304b15bae3a2a8277f686d4dfc9fa946" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T gmx::power4</definition>
        <argsstring>(T x)</argsstring>
        <name>power4</name>
        <param>
          <type>T</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>calculate x^4 </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of argument and return value </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>argument</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>x^4 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" line="364" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" bodystart="364" bodyend="367"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a4bb914d3b8bf083485bb26c88d2b9dda" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T gmx::power5</definition>
        <argsstring>(T x)</argsstring>
        <name>power5</name>
        <param>
          <type>T</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>calculate x^5 </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of argument and return value </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>argument</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>x^5 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" line="378" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" bodystart="378" bodyend="381"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aab162c4ba231de5ffbfc62dc3803e8ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T gmx::power6</definition>
        <argsstring>(T x)</argsstring>
        <name>power6</name>
        <param>
          <type>T</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>calculate x^6 </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of argument and return value </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>argument</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>x^6 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" line="392" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" bodystart="392" bodyend="395"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a800ac84e9ee71a2dc0eedda74bea1513" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T gmx::power12</definition>
        <argsstring>(T x)</argsstring>
        <name>power12</name>
        <param>
          <type>T</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>calculate x^12 </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of argument and return value </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>argument</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>x^12 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" line="406" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" bodystart="406" bodyend="409"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a92d3eb4aaecff5c613995ed4bce22a0a" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="real_8h_1a58a0c7cf2501f4492da833421be92547" kindref="member">real</ref></type>
        <definition>static real gmx::series_sinhx</definition>
        <argsstring>(real x)</argsstring>
        <name>series_sinhx</name>
        <param>
          <type><ref refid="real_8h_1a58a0c7cf2501f4492da833421be92547" kindref="member">real</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Maclaurin series for sinh(x)/x. </para>        </briefdescription>
        <detaileddescription>
<para>Used for NH chains and MTTK pressure control. Here, we compute it to 10th order, which might be an overkill. 8th is probably enough, but it&apos;s not very much more expensive. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" line="417" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/functions.h" bodystart="417" bodyend="421"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a2c4548b5005dd861681ff13e55e5b6f9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void gmx::invertBoxMatrix</definition>
        <argsstring>(const matrix src, matrix dest)</argsstring>
        <name>invertBoxMatrix</name>
        <param>
          <type>const matrix</type>
          <declname>src</declname>
        </param>
        <param>
          <type>matrix</type>
          <declname>dest</declname>
        </param>
        <briefdescription>
<para>Invert a simulation-box matrix in <computeroutput>src</computeroutput>, return in <computeroutput>dest</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>This routine assumes that src is a simulation-box matrix, i.e. has zeroes in the upper-right triangle. A fatal error occurs if the product of the leading diagonal is too small. The inversion can be done &quot;in place&quot;, i.e <computeroutput>src</computeroutput> and <computeroutput>dest</computeroutput> can be the same matrix. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/invertmatrix.cpp" line="54" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/invertmatrix.cpp" bodystart="54" bodyend="72"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a2824e7adcb69e96942fefcb67809ec5e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void gmx::invertMatrix</definition>
        <argsstring>(const matrix src, matrix dest)</argsstring>
        <name>invertMatrix</name>
        <param>
          <type>const matrix</type>
          <declname>src</declname>
        </param>
        <param>
          <type>matrix</type>
          <declname>dest</declname>
        </param>
        <briefdescription>
<para>Invert a general 3x3 matrix in <computeroutput>src</computeroutput>, return in <computeroutput>dest</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>A fatal error occurs if the determinant is too small. <computeroutput>src</computeroutput> and <computeroutput>dest</computeroutput> cannot be the same matrix. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/invertmatrix.cpp" line="74" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/invertmatrix.cpp" bodystart="74" bodyend="98"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a28594b0fbe8151cffa0eb0f3db2a2ce9" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classgmx_1_1BasicVector" kindref="compound">BasicVector</ref>&lt; ValueType &gt;::RawArray *</type>
        <definition>static BasicVector&lt;ValueType&gt;::RawArray* gmx::as_vec_array</definition>
        <argsstring>(BasicVector&lt; ValueType &gt; *x)</argsstring>
        <name>as_vec_array</name>
        <param>
          <type><ref refid="classgmx_1_1BasicVector" kindref="compound">BasicVector</ref>&lt; ValueType &gt; *</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Casts a <ref refid="classgmx_1_1BasicVector" kindref="compound">gmx::BasicVector</ref> array into an equivalent raw C array. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/vectypes.h" line="142" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/vectypes.h" bodystart="142" bodyend="145"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a869efe6effe059ca2a9ebe609d2c30ee" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>const <ref refid="classgmx_1_1BasicVector" kindref="compound">BasicVector</ref>&lt; ValueType &gt;::RawArray *</type>
        <definition>static const BasicVector&lt;ValueType&gt;::RawArray* gmx::as_vec_array</definition>
        <argsstring>(const BasicVector&lt; ValueType &gt; *x)</argsstring>
        <name>as_vec_array</name>
        <param>
          <type>const <ref refid="classgmx_1_1BasicVector" kindref="compound">BasicVector</ref>&lt; ValueType &gt; *</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Casts a <ref refid="classgmx_1_1BasicVector" kindref="compound">gmx::BasicVector</ref> array into an equivalent raw C array. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/vectypes.h" line="152" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/vectypes.h" bodystart="152" bodyend="155"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ac5e7b50af65a3361901a37364ad0fa8d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>rvec *</type>
        <definition>static rvec* gmx::as_rvec_array</definition>
        <argsstring>(RVec *x)</argsstring>
        <name>as_rvec_array</name>
        <param>
          <type><ref refid="namespacegmx_1a139c1919a9680de4ad1450f42e37d33b" kindref="member">RVec</ref> *</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Casts a <ref refid="namespacegmx_1a139c1919a9680de4ad1450f42e37d33b" kindref="member">gmx::RVec</ref> array into an <computeroutput>rvec</computeroutput> array. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/vectypes.h" line="160" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/vectypes.h" bodystart="160" bodyend="163"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aa725d6666d8341042ae4fa3667bf83b1" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const rvec *</type>
        <definition>static const rvec* gmx::as_rvec_array</definition>
        <argsstring>(const RVec *x)</argsstring>
        <name>as_rvec_array</name>
        <param>
          <type>const <ref refid="namespacegmx_1a139c1919a9680de4ad1450f42e37d33b" kindref="member">RVec</ref> *</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Casts a <ref refid="namespacegmx_1a139c1919a9680de4ad1450f42e37d33b" kindref="member">gmx::RVec</ref> array into an <computeroutput>rvec</computeroutput> array. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/vectypes.h" line="165" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/math/vectypes.h" bodystart="165" bodyend="168"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a0b53df1703a70801419ef4f9004454bd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double gmx::do_cg</definition>
        <argsstring>(FILE *fplog, t_commrec *cr, int nfile, const t_filenm fnm[], const gmx_output_env_t *oenv, gmx_bool bVerbose, int nstglobalcomm, gmx_vsite_t *vsite, gmx_constr_t constr, int stepout, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, t_state *state_global, t_mdatoms *mdatoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, t_forcerec *fr, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, gmx_membed_t *membed, real cpt_period, real max_hours, int imdport, unsigned long Flags, gmx_walltime_accounting_t walltime_accounting)</argsstring>
        <name>do_cg</name>
        <param>
          <type>FILE *</type>
          <declname>fplog</declname>
        </param>
        <param>
          <type><ref refid="structt__commrec" kindref="compound">t_commrec</ref> *</type>
          <declname>cr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nfile</declname>
        </param>
        <param>
          <type>const <ref refid="structt__filenm" kindref="compound">t_filenm</ref></type>
          <declname>fnm</declname>
          <array>[]</array>
        </param>
        <param>
          <type>const <ref refid="structgmx__output__env__t" kindref="compound">gmx_output_env_t</ref> *</type>
          <declname>oenv</declname>
        </param>
        <param>
          <type><ref refid="basedefinitions_8h_1a8fddad319f226e856400d190198d5151" kindref="member">gmx_bool</ref></type>
          <declname>bVerbose</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nstglobalcomm</declname>
        </param>
        <param>
          <type><ref refid="structgmx__vsite__t" kindref="compound">gmx_vsite_t</ref> *</type>
          <declname>vsite</declname>
        </param>
        <param>
          <type><ref refid="structgmx__constr" kindref="compound">gmx_constr_t</ref></type>
          <declname>constr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>stepout</declname>
        </param>
        <param>
          <type><ref refid="structt__inputrec" kindref="compound">t_inputrec</ref> *</type>
          <declname>inputrec</declname>
        </param>
        <param>
          <type><ref refid="structgmx__mtop__t" kindref="compound">gmx_mtop_t</ref> *</type>
          <declname>top_global</declname>
        </param>
        <param>
          <type><ref refid="structt__fcdata" kindref="compound">t_fcdata</ref> *</type>
          <declname>fcd</declname>
        </param>
        <param>
          <type><ref refid="structt__state" kindref="compound">t_state</ref> *</type>
          <declname>state_global</declname>
        </param>
        <param>
          <type><ref refid="structt__mdatoms" kindref="compound">t_mdatoms</ref> *</type>
          <declname>mdatoms</declname>
        </param>
        <param>
          <type><ref refid="structt__nrnb" kindref="compound">t_nrnb</ref> *</type>
          <declname>nrnb</declname>
        </param>
        <param>
          <type><ref refid="structgmx__wallcycle" kindref="compound">gmx_wallcycle_t</ref></type>
          <declname>wcycle</declname>
        </param>
        <param>
          <type><ref refid="edsam_8h_1a0fa9ace476add5ee1fd6cd76c870f32e" kindref="member">gmx_edsam_t</ref></type>
          <declname>ed</declname>
        </param>
        <param>
          <type><ref refid="structt__forcerec" kindref="compound">t_forcerec</ref> *</type>
          <declname>fr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>repl_ex_nst</declname>
        </param>
        <param>
          <type>int</type>
          <declname>repl_ex_nex</declname>
        </param>
        <param>
          <type>int</type>
          <declname>repl_ex_seed</declname>
        </param>
        <param>
          <type><ref refid="structgmx__membed__t" kindref="compound">gmx_membed_t</ref> *</type>
          <declname>membed</declname>
        </param>
        <param>
          <type><ref refid="real_8h_1a58a0c7cf2501f4492da833421be92547" kindref="member">real</ref></type>
          <declname>cpt_period</declname>
        </param>
        <param>
          <type><ref refid="real_8h_1a58a0c7cf2501f4492da833421be92547" kindref="member">real</ref></type>
          <declname>max_hours</declname>
        </param>
        <param>
          <type>int</type>
          <declname>imdport</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>Flags</declname>
        </param>
        <param>
          <type><ref refid="structgmx__walltime__accounting" kindref="compound">gmx_walltime_accounting_t</ref></type>
          <declname>walltime_accounting</declname>
        </param>
        <briefdescription>
<para>Do conjugate gradients minimization. </para>        </briefdescription>
        <detaileddescription>
<para>Integrator algorithm implementation. (FILE *fplog, <ref refid="structt__commrec" kindref="compound">t_commrec</ref> *cr, <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fplog</parametername>
</parameternamelist>
<parameterdescription>
<para>Log file for output </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cr</parametername>
</parameternamelist>
<parameterdescription>
<para>Communication record </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nfile</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of files </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fnm</parametername>
</parameternamelist>
<parameterdescription>
<para>Filename structure array </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">oenv</parametername>
</parameternamelist>
<parameterdescription>
<para>Output information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">bVerbose</parametername>
</parameternamelist>
<parameterdescription>
<para>Verbose output or not </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nstglobalcomm</parametername>
</parameternamelist>
<parameterdescription>
<para>How often global communication is done </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">vsite</parametername>
</parameternamelist>
<parameterdescription>
<para>Virtual site information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">constr</parametername>
</parameternamelist>
<parameterdescription>
<para>Constraint information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">stepout</parametername>
</parameternamelist>
<parameterdescription>
<para>How often we writen to the console </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">inputrec</parametername>
</parameternamelist>
<parameterdescription>
<para>Input record with mdp options </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">top_global</parametername>
</parameternamelist>
<parameterdescription>
<para>Molecular topology for the whole system </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fcd</parametername>
</parameternamelist>
<parameterdescription>
<para>Force and constraint data </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">state_global</parametername>
</parameternamelist>
<parameterdescription>
<para>The state (x, v, f, box etc.) of the whole system </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">mdatoms</parametername>
</parameternamelist>
<parameterdescription>
<para>Structure containing atom information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nrnb</parametername>
</parameternamelist>
<parameterdescription>
<para>Accounting for floating point operations </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">wcycle</parametername>
</parameternamelist>
<parameterdescription>
<para>Wall cycle timing information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ed</parametername>
</parameternamelist>
<parameterdescription>
<para>Essential dynamics sampling information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fr</parametername>
</parameternamelist>
<parameterdescription>
<para>Force record with cut-off information and more </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">repl_ex_nst</parametername>
</parameternamelist>
<parameterdescription>
<para>How often we do replica exchange (in steps) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">repl_ex_nex</parametername>
</parameternamelist>
<parameterdescription>
<para>How many replicas we have </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">repl_ex_seed</parametername>
</parameternamelist>
<parameterdescription>
<para>The seed for Monte Carlo swaps </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">membed</parametername>
</parameternamelist>
<parameterdescription>
<para>Membrane embedding data structure </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cpt_period</parametername>
</parameternamelist>
<parameterdescription>
<para>How often to checkpoint the simulation </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">max_hours</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximume length of the simulation (wall time) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">imdport</parametername>
</parameternamelist>
<parameterdescription>
<para>Interactive MD port (socket) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">Flags</parametername>
</parameternamelist>
<parameterdescription>
<para>Flags to control mdrun </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">walltime_accounting</parametername>
</parameternamelist>
<parameterdescription>
<para>More timing information (FILE *fplog, <ref refid="structt__commrec" kindref="compound">t_commrec</ref> *cr, int nfile, const <ref refid="structt__filenm" kindref="compound">t_filenm</ref> fnm[], const <ref refid="structgmx__output__env__t" kindref="compound">gmx_output_env_t</ref> *oenv, gmx_bool bVerbose, int nstglobalcomm, <ref refid="structgmx__vsite__t" kindref="compound">gmx_vsite_t</ref> *vsite, gmx_constr_t constr, int stepout, <ref refid="structt__inputrec" kindref="compound">t_inputrec</ref> *inputrec, <ref refid="structgmx__mtop__t" kindref="compound">gmx_mtop_t</ref> *top_global, <ref refid="structt__fcdata" kindref="compound">t_fcdata</ref> *fcd, <ref refid="structt__state" kindref="compound">t_state</ref> *state_global, <ref refid="structt__mdatoms" kindref="compound">t_mdatoms</ref> *mdatoms, <ref refid="structt__nrnb" kindref="compound">t_nrnb</ref> *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, <ref refid="structt__forcerec" kindref="compound">t_forcerec</ref> *fr, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, <ref refid="structgmx__membed__t" kindref="compound">gmx_membed_t</ref> gmx_unused *membed, real cpt_period, real max_hours, int imdport, unsigned long Flags, gmx_walltime_accounting_t walltime_accounting) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/mdlib/minimize.cpp" line="1019" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/mdlib/minimize.cpp" bodystart="1019" bodyend="1643"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1afaabfc51bc04f2b0de66f075051a610a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double gmx::do_lbfgs</definition>
        <argsstring>(FILE *fplog, t_commrec *cr, int nfile, const t_filenm fnm[], const gmx_output_env_t *oenv, gmx_bool bVerbose, int nstglobalcomm, gmx_vsite_t *vsite, gmx_constr_t constr, int stepout, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, t_state *state_global, t_mdatoms *mdatoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, t_forcerec *fr, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, gmx_membed_t *membed, real cpt_period, real max_hours, int imdport, unsigned long Flags, gmx_walltime_accounting_t walltime_accounting)</argsstring>
        <name>do_lbfgs</name>
        <param>
          <type>FILE *</type>
          <declname>fplog</declname>
        </param>
        <param>
          <type><ref refid="structt__commrec" kindref="compound">t_commrec</ref> *</type>
          <declname>cr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nfile</declname>
        </param>
        <param>
          <type>const <ref refid="structt__filenm" kindref="compound">t_filenm</ref></type>
          <declname>fnm</declname>
          <array>[]</array>
        </param>
        <param>
          <type>const <ref refid="structgmx__output__env__t" kindref="compound">gmx_output_env_t</ref> *</type>
          <declname>oenv</declname>
        </param>
        <param>
          <type><ref refid="basedefinitions_8h_1a8fddad319f226e856400d190198d5151" kindref="member">gmx_bool</ref></type>
          <declname>bVerbose</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nstglobalcomm</declname>
        </param>
        <param>
          <type><ref refid="structgmx__vsite__t" kindref="compound">gmx_vsite_t</ref> *</type>
          <declname>vsite</declname>
        </param>
        <param>
          <type><ref refid="structgmx__constr" kindref="compound">gmx_constr_t</ref></type>
          <declname>constr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>stepout</declname>
        </param>
        <param>
          <type><ref refid="structt__inputrec" kindref="compound">t_inputrec</ref> *</type>
          <declname>inputrec</declname>
        </param>
        <param>
          <type><ref refid="structgmx__mtop__t" kindref="compound">gmx_mtop_t</ref> *</type>
          <declname>top_global</declname>
        </param>
        <param>
          <type><ref refid="structt__fcdata" kindref="compound">t_fcdata</ref> *</type>
          <declname>fcd</declname>
        </param>
        <param>
          <type><ref refid="structt__state" kindref="compound">t_state</ref> *</type>
          <declname>state_global</declname>
        </param>
        <param>
          <type><ref refid="structt__mdatoms" kindref="compound">t_mdatoms</ref> *</type>
          <declname>mdatoms</declname>
        </param>
        <param>
          <type><ref refid="structt__nrnb" kindref="compound">t_nrnb</ref> *</type>
          <declname>nrnb</declname>
        </param>
        <param>
          <type><ref refid="structgmx__wallcycle" kindref="compound">gmx_wallcycle_t</ref></type>
          <declname>wcycle</declname>
        </param>
        <param>
          <type><ref refid="edsam_8h_1a0fa9ace476add5ee1fd6cd76c870f32e" kindref="member">gmx_edsam_t</ref></type>
          <declname>ed</declname>
        </param>
        <param>
          <type><ref refid="structt__forcerec" kindref="compound">t_forcerec</ref> *</type>
          <declname>fr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>repl_ex_nst</declname>
        </param>
        <param>
          <type>int</type>
          <declname>repl_ex_nex</declname>
        </param>
        <param>
          <type>int</type>
          <declname>repl_ex_seed</declname>
        </param>
        <param>
          <type><ref refid="structgmx__membed__t" kindref="compound">gmx_membed_t</ref> *</type>
          <declname>membed</declname>
        </param>
        <param>
          <type><ref refid="real_8h_1a58a0c7cf2501f4492da833421be92547" kindref="member">real</ref></type>
          <declname>cpt_period</declname>
        </param>
        <param>
          <type><ref refid="real_8h_1a58a0c7cf2501f4492da833421be92547" kindref="member">real</ref></type>
          <declname>max_hours</declname>
        </param>
        <param>
          <type>int</type>
          <declname>imdport</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>Flags</declname>
        </param>
        <param>
          <type><ref refid="structgmx__walltime__accounting" kindref="compound">gmx_walltime_accounting_t</ref></type>
          <declname>walltime_accounting</declname>
        </param>
        <briefdescription>
<para>Do L-BFGS conjugate gradients minimization. </para>        </briefdescription>
        <detaileddescription>
<para>Integrator algorithm implementation. (FILE *fplog, <ref refid="structt__commrec" kindref="compound">t_commrec</ref> *cr, <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fplog</parametername>
</parameternamelist>
<parameterdescription>
<para>Log file for output </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cr</parametername>
</parameternamelist>
<parameterdescription>
<para>Communication record </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nfile</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of files </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fnm</parametername>
</parameternamelist>
<parameterdescription>
<para>Filename structure array </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">oenv</parametername>
</parameternamelist>
<parameterdescription>
<para>Output information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">bVerbose</parametername>
</parameternamelist>
<parameterdescription>
<para>Verbose output or not </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nstglobalcomm</parametername>
</parameternamelist>
<parameterdescription>
<para>How often global communication is done </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">vsite</parametername>
</parameternamelist>
<parameterdescription>
<para>Virtual site information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">constr</parametername>
</parameternamelist>
<parameterdescription>
<para>Constraint information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">stepout</parametername>
</parameternamelist>
<parameterdescription>
<para>How often we writen to the console </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">inputrec</parametername>
</parameternamelist>
<parameterdescription>
<para>Input record with mdp options </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">top_global</parametername>
</parameternamelist>
<parameterdescription>
<para>Molecular topology for the whole system </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fcd</parametername>
</parameternamelist>
<parameterdescription>
<para>Force and constraint data </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">state_global</parametername>
</parameternamelist>
<parameterdescription>
<para>The state (x, v, f, box etc.) of the whole system </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">mdatoms</parametername>
</parameternamelist>
<parameterdescription>
<para>Structure containing atom information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nrnb</parametername>
</parameternamelist>
<parameterdescription>
<para>Accounting for floating point operations </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">wcycle</parametername>
</parameternamelist>
<parameterdescription>
<para>Wall cycle timing information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ed</parametername>
</parameternamelist>
<parameterdescription>
<para>Essential dynamics sampling information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fr</parametername>
</parameternamelist>
<parameterdescription>
<para>Force record with cut-off information and more </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">repl_ex_nst</parametername>
</parameternamelist>
<parameterdescription>
<para>How often we do replica exchange (in steps) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">repl_ex_nex</parametername>
</parameternamelist>
<parameterdescription>
<para>How many replicas we have </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">repl_ex_seed</parametername>
</parameternamelist>
<parameterdescription>
<para>The seed for Monte Carlo swaps </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">membed</parametername>
</parameternamelist>
<parameterdescription>
<para>Membrane embedding data structure </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cpt_period</parametername>
</parameternamelist>
<parameterdescription>
<para>How often to checkpoint the simulation </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">max_hours</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximume length of the simulation (wall time) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">imdport</parametername>
</parameternamelist>
<parameterdescription>
<para>Interactive MD port (socket) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">Flags</parametername>
</parameternamelist>
<parameterdescription>
<para>Flags to control mdrun </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">walltime_accounting</parametername>
</parameternamelist>
<parameterdescription>
<para>More timing information (FILE *fplog, <ref refid="structt__commrec" kindref="compound">t_commrec</ref> *cr, int nfile, const <ref refid="structt__filenm" kindref="compound">t_filenm</ref> fnm[], const <ref refid="structgmx__output__env__t" kindref="compound">gmx_output_env_t</ref> *oenv, gmx_bool bVerbose, int nstglobalcomm, <ref refid="structgmx__vsite__t" kindref="compound">gmx_vsite_t</ref> *vsite, gmx_constr_t constr, int stepout, <ref refid="structt__inputrec" kindref="compound">t_inputrec</ref> *inputrec, <ref refid="structgmx__mtop__t" kindref="compound">gmx_mtop_t</ref> *top_global, <ref refid="structt__fcdata" kindref="compound">t_fcdata</ref> *fcd, <ref refid="structt__state" kindref="compound">t_state</ref> *state_global, <ref refid="structt__mdatoms" kindref="compound">t_mdatoms</ref> *mdatoms, <ref refid="structt__nrnb" kindref="compound">t_nrnb</ref> *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, <ref refid="structt__forcerec" kindref="compound">t_forcerec</ref> *fr, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, real cpt_period, real max_hours, int imdport, unsigned long Flags, gmx_walltime_accounting_t walltime_accounting) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/mdlib/minimize.cpp" line="1666" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/mdlib/minimize.cpp" bodystart="1666" bodyend="2472"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ae556e926034aab8ae03d4aa73e2bab4b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double gmx::do_steep</definition>
        <argsstring>(FILE *fplog, t_commrec *cr, int nfile, const t_filenm fnm[], const gmx_output_env_t *oenv, gmx_bool bVerbose, int nstglobalcomm, gmx_vsite_t *vsite, gmx_constr_t constr, int stepout, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, t_state *state_global, t_mdatoms *mdatoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, t_forcerec *fr, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, gmx_membed_t *membed, real cpt_period, real max_hours, int imdport, unsigned long Flags, gmx_walltime_accounting_t walltime_accounting)</argsstring>
        <name>do_steep</name>
        <param>
          <type>FILE *</type>
          <declname>fplog</declname>
        </param>
        <param>
          <type><ref refid="structt__commrec" kindref="compound">t_commrec</ref> *</type>
          <declname>cr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nfile</declname>
        </param>
        <param>
          <type>const <ref refid="structt__filenm" kindref="compound">t_filenm</ref></type>
          <declname>fnm</declname>
          <array>[]</array>
        </param>
        <param>
          <type>const <ref refid="structgmx__output__env__t" kindref="compound">gmx_output_env_t</ref> *</type>
          <declname>oenv</declname>
        </param>
        <param>
          <type><ref refid="basedefinitions_8h_1a8fddad319f226e856400d190198d5151" kindref="member">gmx_bool</ref></type>
          <declname>bVerbose</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nstglobalcomm</declname>
        </param>
        <param>
          <type><ref refid="structgmx__vsite__t" kindref="compound">gmx_vsite_t</ref> *</type>
          <declname>vsite</declname>
        </param>
        <param>
          <type><ref refid="structgmx__constr" kindref="compound">gmx_constr_t</ref></type>
          <declname>constr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>stepout</declname>
        </param>
        <param>
          <type><ref refid="structt__inputrec" kindref="compound">t_inputrec</ref> *</type>
          <declname>inputrec</declname>
        </param>
        <param>
          <type><ref refid="structgmx__mtop__t" kindref="compound">gmx_mtop_t</ref> *</type>
          <declname>top_global</declname>
        </param>
        <param>
          <type><ref refid="structt__fcdata" kindref="compound">t_fcdata</ref> *</type>
          <declname>fcd</declname>
        </param>
        <param>
          <type><ref refid="structt__state" kindref="compound">t_state</ref> *</type>
          <declname>state_global</declname>
        </param>
        <param>
          <type><ref refid="structt__mdatoms" kindref="compound">t_mdatoms</ref> *</type>
          <declname>mdatoms</declname>
        </param>
        <param>
          <type><ref refid="structt__nrnb" kindref="compound">t_nrnb</ref> *</type>
          <declname>nrnb</declname>
        </param>
        <param>
          <type><ref refid="structgmx__wallcycle" kindref="compound">gmx_wallcycle_t</ref></type>
          <declname>wcycle</declname>
        </param>
        <param>
          <type><ref refid="edsam_8h_1a0fa9ace476add5ee1fd6cd76c870f32e" kindref="member">gmx_edsam_t</ref></type>
          <declname>ed</declname>
        </param>
        <param>
          <type><ref refid="structt__forcerec" kindref="compound">t_forcerec</ref> *</type>
          <declname>fr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>repl_ex_nst</declname>
        </param>
        <param>
          <type>int</type>
          <declname>repl_ex_nex</declname>
        </param>
        <param>
          <type>int</type>
          <declname>repl_ex_seed</declname>
        </param>
        <param>
          <type><ref refid="structgmx__membed__t" kindref="compound">gmx_membed_t</ref> *</type>
          <declname>membed</declname>
        </param>
        <param>
          <type><ref refid="real_8h_1a58a0c7cf2501f4492da833421be92547" kindref="member">real</ref></type>
          <declname>cpt_period</declname>
        </param>
        <param>
          <type><ref refid="real_8h_1a58a0c7cf2501f4492da833421be92547" kindref="member">real</ref></type>
          <declname>max_hours</declname>
        </param>
        <param>
          <type>int</type>
          <declname>imdport</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>Flags</declname>
        </param>
        <param>
          <type><ref refid="structgmx__walltime__accounting" kindref="compound">gmx_walltime_accounting_t</ref></type>
          <declname>walltime_accounting</declname>
        </param>
        <briefdescription>
<para>Do steepest descents minimization. </para>        </briefdescription>
        <detaileddescription>
<para>Integrator algorithm implementation. (FILE *fplog, <ref refid="structt__commrec" kindref="compound">t_commrec</ref> *cr, <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fplog</parametername>
</parameternamelist>
<parameterdescription>
<para>Log file for output </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cr</parametername>
</parameternamelist>
<parameterdescription>
<para>Communication record </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nfile</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of files </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fnm</parametername>
</parameternamelist>
<parameterdescription>
<para>Filename structure array </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">oenv</parametername>
</parameternamelist>
<parameterdescription>
<para>Output information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">bVerbose</parametername>
</parameternamelist>
<parameterdescription>
<para>Verbose output or not </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nstglobalcomm</parametername>
</parameternamelist>
<parameterdescription>
<para>How often global communication is done </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">vsite</parametername>
</parameternamelist>
<parameterdescription>
<para>Virtual site information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">constr</parametername>
</parameternamelist>
<parameterdescription>
<para>Constraint information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">stepout</parametername>
</parameternamelist>
<parameterdescription>
<para>How often we writen to the console </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">inputrec</parametername>
</parameternamelist>
<parameterdescription>
<para>Input record with mdp options </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">top_global</parametername>
</parameternamelist>
<parameterdescription>
<para>Molecular topology for the whole system </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fcd</parametername>
</parameternamelist>
<parameterdescription>
<para>Force and constraint data </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">state_global</parametername>
</parameternamelist>
<parameterdescription>
<para>The state (x, v, f, box etc.) of the whole system </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">mdatoms</parametername>
</parameternamelist>
<parameterdescription>
<para>Structure containing atom information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nrnb</parametername>
</parameternamelist>
<parameterdescription>
<para>Accounting for floating point operations </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">wcycle</parametername>
</parameternamelist>
<parameterdescription>
<para>Wall cycle timing information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ed</parametername>
</parameternamelist>
<parameterdescription>
<para>Essential dynamics sampling information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fr</parametername>
</parameternamelist>
<parameterdescription>
<para>Force record with cut-off information and more </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">repl_ex_nst</parametername>
</parameternamelist>
<parameterdescription>
<para>How often we do replica exchange (in steps) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">repl_ex_nex</parametername>
</parameternamelist>
<parameterdescription>
<para>How many replicas we have </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">repl_ex_seed</parametername>
</parameternamelist>
<parameterdescription>
<para>The seed for Monte Carlo swaps </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">membed</parametername>
</parameternamelist>
<parameterdescription>
<para>Membrane embedding data structure </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cpt_period</parametername>
</parameternamelist>
<parameterdescription>
<para>How often to checkpoint the simulation </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">max_hours</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximume length of the simulation (wall time) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">imdport</parametername>
</parameternamelist>
<parameterdescription>
<para>Interactive MD port (socket) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">Flags</parametername>
</parameternamelist>
<parameterdescription>
<para>Flags to control mdrun </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">walltime_accounting</parametername>
</parameternamelist>
<parameterdescription>
<para>More timing information (FILE *fplog, <ref refid="structt__commrec" kindref="compound">t_commrec</ref> *cr, int nfile, const <ref refid="structt__filenm" kindref="compound">t_filenm</ref> fnm[], const <ref refid="structgmx__output__env__t" kindref="compound">gmx_output_env_t</ref> *oenv, gmx_bool bVerbose, int nstglobalcomm, <ref refid="structgmx__vsite__t" kindref="compound">gmx_vsite_t</ref> *vsite, gmx_constr_t constr, int stepout, <ref refid="structt__inputrec" kindref="compound">t_inputrec</ref> *inputrec, <ref refid="structgmx__mtop__t" kindref="compound">gmx_mtop_t</ref> *top_global, <ref refid="structt__fcdata" kindref="compound">t_fcdata</ref> *fcd, <ref refid="structt__state" kindref="compound">t_state</ref> *state_global, <ref refid="structt__mdatoms" kindref="compound">t_mdatoms</ref> *mdatoms, <ref refid="structt__nrnb" kindref="compound">t_nrnb</ref> *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, <ref refid="structt__forcerec" kindref="compound">t_forcerec</ref> *fr, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, real cpt_period, real max_hours, int imdport, unsigned long Flags, gmx_walltime_accounting_t walltime_accounting) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/mdlib/minimize.cpp" line="2494" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/mdlib/minimize.cpp" bodystart="2494" bodyend="2740"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ac8d0485fabdfa4c15b00267ad27d9a0e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double gmx::do_nm</definition>
        <argsstring>(FILE *fplog, t_commrec *cr, int nfile, const t_filenm fnm[], const gmx_output_env_t *oenv, gmx_bool bVerbose, int nstglobalcomm, gmx_vsite_t *vsite, gmx_constr_t constr, int stepout, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, t_state *state_global, t_mdatoms *mdatoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, t_forcerec *fr, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, gmx_membed_t *membed, real cpt_period, real max_hours, int imdport, unsigned long Flags, gmx_walltime_accounting_t walltime_accounting)</argsstring>
        <name>do_nm</name>
        <param>
          <type>FILE *</type>
          <declname>fplog</declname>
        </param>
        <param>
          <type><ref refid="structt__commrec" kindref="compound">t_commrec</ref> *</type>
          <declname>cr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nfile</declname>
        </param>
        <param>
          <type>const <ref refid="structt__filenm" kindref="compound">t_filenm</ref></type>
          <declname>fnm</declname>
          <array>[]</array>
        </param>
        <param>
          <type>const <ref refid="structgmx__output__env__t" kindref="compound">gmx_output_env_t</ref> *</type>
          <declname>oenv</declname>
        </param>
        <param>
          <type><ref refid="basedefinitions_8h_1a8fddad319f226e856400d190198d5151" kindref="member">gmx_bool</ref></type>
          <declname>bVerbose</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nstglobalcomm</declname>
        </param>
        <param>
          <type><ref refid="structgmx__vsite__t" kindref="compound">gmx_vsite_t</ref> *</type>
          <declname>vsite</declname>
        </param>
        <param>
          <type><ref refid="structgmx__constr" kindref="compound">gmx_constr_t</ref></type>
          <declname>constr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>stepout</declname>
        </param>
        <param>
          <type><ref refid="structt__inputrec" kindref="compound">t_inputrec</ref> *</type>
          <declname>inputrec</declname>
        </param>
        <param>
          <type><ref refid="structgmx__mtop__t" kindref="compound">gmx_mtop_t</ref> *</type>
          <declname>top_global</declname>
        </param>
        <param>
          <type><ref refid="structt__fcdata" kindref="compound">t_fcdata</ref> *</type>
          <declname>fcd</declname>
        </param>
        <param>
          <type><ref refid="structt__state" kindref="compound">t_state</ref> *</type>
          <declname>state_global</declname>
        </param>
        <param>
          <type><ref refid="structt__mdatoms" kindref="compound">t_mdatoms</ref> *</type>
          <declname>mdatoms</declname>
        </param>
        <param>
          <type><ref refid="structt__nrnb" kindref="compound">t_nrnb</ref> *</type>
          <declname>nrnb</declname>
        </param>
        <param>
          <type><ref refid="structgmx__wallcycle" kindref="compound">gmx_wallcycle_t</ref></type>
          <declname>wcycle</declname>
        </param>
        <param>
          <type><ref refid="edsam_8h_1a0fa9ace476add5ee1fd6cd76c870f32e" kindref="member">gmx_edsam_t</ref></type>
          <declname>ed</declname>
        </param>
        <param>
          <type><ref refid="structt__forcerec" kindref="compound">t_forcerec</ref> *</type>
          <declname>fr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>repl_ex_nst</declname>
        </param>
        <param>
          <type>int</type>
          <declname>repl_ex_nex</declname>
        </param>
        <param>
          <type>int</type>
          <declname>repl_ex_seed</declname>
        </param>
        <param>
          <type><ref refid="structgmx__membed__t" kindref="compound">gmx_membed_t</ref> *</type>
          <declname>membed</declname>
        </param>
        <param>
          <type><ref refid="real_8h_1a58a0c7cf2501f4492da833421be92547" kindref="member">real</ref></type>
          <declname>cpt_period</declname>
        </param>
        <param>
          <type><ref refid="real_8h_1a58a0c7cf2501f4492da833421be92547" kindref="member">real</ref></type>
          <declname>max_hours</declname>
        </param>
        <param>
          <type>int</type>
          <declname>imdport</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>Flags</declname>
        </param>
        <param>
          <type><ref refid="structgmx__walltime__accounting" kindref="compound">gmx_walltime_accounting_t</ref></type>
          <declname>walltime_accounting</declname>
        </param>
        <briefdescription>
<para>Do normal modes analysis. </para>        </briefdescription>
        <detaileddescription>
<para>Integrator algorithm implementation. (FILE *fplog, <ref refid="structt__commrec" kindref="compound">t_commrec</ref> *cr, <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fplog</parametername>
</parameternamelist>
<parameterdescription>
<para>Log file for output </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cr</parametername>
</parameternamelist>
<parameterdescription>
<para>Communication record </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nfile</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of files </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fnm</parametername>
</parameternamelist>
<parameterdescription>
<para>Filename structure array </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">oenv</parametername>
</parameternamelist>
<parameterdescription>
<para>Output information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">bVerbose</parametername>
</parameternamelist>
<parameterdescription>
<para>Verbose output or not </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nstglobalcomm</parametername>
</parameternamelist>
<parameterdescription>
<para>How often global communication is done </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">vsite</parametername>
</parameternamelist>
<parameterdescription>
<para>Virtual site information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">constr</parametername>
</parameternamelist>
<parameterdescription>
<para>Constraint information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">stepout</parametername>
</parameternamelist>
<parameterdescription>
<para>How often we writen to the console </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">inputrec</parametername>
</parameternamelist>
<parameterdescription>
<para>Input record with mdp options </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">top_global</parametername>
</parameternamelist>
<parameterdescription>
<para>Molecular topology for the whole system </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fcd</parametername>
</parameternamelist>
<parameterdescription>
<para>Force and constraint data </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">state_global</parametername>
</parameternamelist>
<parameterdescription>
<para>The state (x, v, f, box etc.) of the whole system </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">mdatoms</parametername>
</parameternamelist>
<parameterdescription>
<para>Structure containing atom information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nrnb</parametername>
</parameternamelist>
<parameterdescription>
<para>Accounting for floating point operations </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">wcycle</parametername>
</parameternamelist>
<parameterdescription>
<para>Wall cycle timing information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ed</parametername>
</parameternamelist>
<parameterdescription>
<para>Essential dynamics sampling information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fr</parametername>
</parameternamelist>
<parameterdescription>
<para>Force record with cut-off information and more </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">repl_ex_nst</parametername>
</parameternamelist>
<parameterdescription>
<para>How often we do replica exchange (in steps) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">repl_ex_nex</parametername>
</parameternamelist>
<parameterdescription>
<para>How many replicas we have </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">repl_ex_seed</parametername>
</parameternamelist>
<parameterdescription>
<para>The seed for Monte Carlo swaps </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">membed</parametername>
</parameternamelist>
<parameterdescription>
<para>Membrane embedding data structure </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cpt_period</parametername>
</parameternamelist>
<parameterdescription>
<para>How often to checkpoint the simulation </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">max_hours</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximume length of the simulation (wall time) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">imdport</parametername>
</parameternamelist>
<parameterdescription>
<para>Interactive MD port (socket) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">Flags</parametername>
</parameternamelist>
<parameterdescription>
<para>Flags to control mdrun </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">walltime_accounting</parametername>
</parameternamelist>
<parameterdescription>
<para>More timing information (FILE *fplog, <ref refid="structt__commrec" kindref="compound">t_commrec</ref> *cr, int nfile, const <ref refid="structt__filenm" kindref="compound">t_filenm</ref> fnm[], const <ref refid="structgmx__output__env__t" kindref="compound">gmx_output_env_t</ref> *oenv, gmx_bool bVerbose, int nstglobalcomm, <ref refid="structgmx__vsite__t" kindref="compound">gmx_vsite_t</ref> *vsite, gmx_constr_t constr, int stepout, <ref refid="structt__inputrec" kindref="compound">t_inputrec</ref> *inputrec, <ref refid="structgmx__mtop__t" kindref="compound">gmx_mtop_t</ref> *top_global, <ref refid="structt__fcdata" kindref="compound">t_fcdata</ref> *fcd, <ref refid="structt__state" kindref="compound">t_state</ref> *state_global, <ref refid="structt__mdatoms" kindref="compound">t_mdatoms</ref> *mdatoms, <ref refid="structt__nrnb" kindref="compound">t_nrnb</ref> *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, <ref refid="structt__forcerec" kindref="compound">t_forcerec</ref> *fr, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, real cpt_period, real max_hours, int imdport, unsigned long Flags, gmx_walltime_accounting_t walltime_accounting) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/mdlib/minimize.cpp" line="2762" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/mdlib/minimize.cpp" bodystart="2762" bodyend="3076"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a861907c530b5abf0554f48167ebdd2e8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double gmx::do_tpi</definition>
        <argsstring>(FILE *fplog, t_commrec *cr, int nfile, const t_filenm fnm[], const gmx_output_env_t *oenv, gmx_bool bVerbose, int nstglobalcomm, gmx_vsite_t *vsite, gmx_constr_t constr, int stepout, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, t_state *state_global, t_mdatoms *mdatoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, t_forcerec *fr, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, gmx_membed_t *membed, real cpt_period, real max_hours, int imdport, unsigned long Flags, gmx_walltime_accounting_t walltime_accounting)</argsstring>
        <name>do_tpi</name>
        <param>
          <type>FILE *</type>
          <declname>fplog</declname>
        </param>
        <param>
          <type><ref refid="structt__commrec" kindref="compound">t_commrec</ref> *</type>
          <declname>cr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nfile</declname>
        </param>
        <param>
          <type>const <ref refid="structt__filenm" kindref="compound">t_filenm</ref></type>
          <declname>fnm</declname>
          <array>[]</array>
        </param>
        <param>
          <type>const <ref refid="structgmx__output__env__t" kindref="compound">gmx_output_env_t</ref> *</type>
          <declname>oenv</declname>
        </param>
        <param>
          <type><ref refid="basedefinitions_8h_1a8fddad319f226e856400d190198d5151" kindref="member">gmx_bool</ref></type>
          <declname>bVerbose</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nstglobalcomm</declname>
        </param>
        <param>
          <type><ref refid="structgmx__vsite__t" kindref="compound">gmx_vsite_t</ref> *</type>
          <declname>vsite</declname>
        </param>
        <param>
          <type><ref refid="structgmx__constr" kindref="compound">gmx_constr_t</ref></type>
          <declname>constr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>stepout</declname>
        </param>
        <param>
          <type><ref refid="structt__inputrec" kindref="compound">t_inputrec</ref> *</type>
          <declname>inputrec</declname>
        </param>
        <param>
          <type><ref refid="structgmx__mtop__t" kindref="compound">gmx_mtop_t</ref> *</type>
          <declname>top_global</declname>
        </param>
        <param>
          <type><ref refid="structt__fcdata" kindref="compound">t_fcdata</ref> *</type>
          <declname>fcd</declname>
        </param>
        <param>
          <type><ref refid="structt__state" kindref="compound">t_state</ref> *</type>
          <declname>state_global</declname>
        </param>
        <param>
          <type><ref refid="structt__mdatoms" kindref="compound">t_mdatoms</ref> *</type>
          <declname>mdatoms</declname>
        </param>
        <param>
          <type><ref refid="structt__nrnb" kindref="compound">t_nrnb</ref> *</type>
          <declname>nrnb</declname>
        </param>
        <param>
          <type><ref refid="structgmx__wallcycle" kindref="compound">gmx_wallcycle_t</ref></type>
          <declname>wcycle</declname>
        </param>
        <param>
          <type><ref refid="edsam_8h_1a0fa9ace476add5ee1fd6cd76c870f32e" kindref="member">gmx_edsam_t</ref></type>
          <declname>ed</declname>
        </param>
        <param>
          <type><ref refid="structt__forcerec" kindref="compound">t_forcerec</ref> *</type>
          <declname>fr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>repl_ex_nst</declname>
        </param>
        <param>
          <type>int</type>
          <declname>repl_ex_nex</declname>
        </param>
        <param>
          <type>int</type>
          <declname>repl_ex_seed</declname>
        </param>
        <param>
          <type><ref refid="structgmx__membed__t" kindref="compound">gmx_membed_t</ref> *</type>
          <declname>membed</declname>
        </param>
        <param>
          <type><ref refid="real_8h_1a58a0c7cf2501f4492da833421be92547" kindref="member">real</ref></type>
          <declname>cpt_period</declname>
        </param>
        <param>
          <type><ref refid="real_8h_1a58a0c7cf2501f4492da833421be92547" kindref="member">real</ref></type>
          <declname>max_hours</declname>
        </param>
        <param>
          <type>int</type>
          <declname>imdport</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>Flags</declname>
        </param>
        <param>
          <type><ref refid="structgmx__walltime__accounting" kindref="compound">gmx_walltime_accounting_t</ref></type>
          <declname>walltime_accounting</declname>
        </param>
        <briefdescription>
<para>Do test particle insertion. </para>        </briefdescription>
        <detaileddescription>
<para>Integrator algorithm implementation. (FILE *fplog, <ref refid="structt__commrec" kindref="compound">t_commrec</ref> *cr, <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fplog</parametername>
</parameternamelist>
<parameterdescription>
<para>Log file for output </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cr</parametername>
</parameternamelist>
<parameterdescription>
<para>Communication record </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nfile</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of files </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fnm</parametername>
</parameternamelist>
<parameterdescription>
<para>Filename structure array </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">oenv</parametername>
</parameternamelist>
<parameterdescription>
<para>Output information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">bVerbose</parametername>
</parameternamelist>
<parameterdescription>
<para>Verbose output or not </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nstglobalcomm</parametername>
</parameternamelist>
<parameterdescription>
<para>How often global communication is done </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">vsite</parametername>
</parameternamelist>
<parameterdescription>
<para>Virtual site information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">constr</parametername>
</parameternamelist>
<parameterdescription>
<para>Constraint information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">stepout</parametername>
</parameternamelist>
<parameterdescription>
<para>How often we writen to the console </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">inputrec</parametername>
</parameternamelist>
<parameterdescription>
<para>Input record with mdp options </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">top_global</parametername>
</parameternamelist>
<parameterdescription>
<para>Molecular topology for the whole system </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fcd</parametername>
</parameternamelist>
<parameterdescription>
<para>Force and constraint data </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">state_global</parametername>
</parameternamelist>
<parameterdescription>
<para>The state (x, v, f, box etc.) of the whole system </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">mdatoms</parametername>
</parameternamelist>
<parameterdescription>
<para>Structure containing atom information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nrnb</parametername>
</parameternamelist>
<parameterdescription>
<para>Accounting for floating point operations </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">wcycle</parametername>
</parameternamelist>
<parameterdescription>
<para>Wall cycle timing information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ed</parametername>
</parameternamelist>
<parameterdescription>
<para>Essential dynamics sampling information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fr</parametername>
</parameternamelist>
<parameterdescription>
<para>Force record with cut-off information and more </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">repl_ex_nst</parametername>
</parameternamelist>
<parameterdescription>
<para>How often we do replica exchange (in steps) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">repl_ex_nex</parametername>
</parameternamelist>
<parameterdescription>
<para>How many replicas we have </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">repl_ex_seed</parametername>
</parameternamelist>
<parameterdescription>
<para>The seed for Monte Carlo swaps </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">membed</parametername>
</parameternamelist>
<parameterdescription>
<para>Membrane embedding data structure </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cpt_period</parametername>
</parameternamelist>
<parameterdescription>
<para>How often to checkpoint the simulation </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">max_hours</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximume length of the simulation (wall time) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">imdport</parametername>
</parameternamelist>
<parameterdescription>
<para>Interactive MD port (socket) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">Flags</parametername>
</parameternamelist>
<parameterdescription>
<para>Flags to control mdrun </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">walltime_accounting</parametername>
</parameternamelist>
<parameterdescription>
<para>More timing information (FILE *fplog, <ref refid="structt__commrec" kindref="compound">t_commrec</ref> *cr, int nfile, const <ref refid="structt__filenm" kindref="compound">t_filenm</ref> fnm[], const <ref refid="structgmx__output__env__t" kindref="compound">gmx_output_env_t</ref> *oenv, gmx_bool bVerbose, int nstglobalcomm, <ref refid="structgmx__vsite__t" kindref="compound">gmx_vsite_t</ref> *vsite, gmx_constr_t constr, int stepout, <ref refid="structt__inputrec" kindref="compound">t_inputrec</ref> *inputrec, <ref refid="structgmx__mtop__t" kindref="compound">gmx_mtop_t</ref> *top_global, <ref refid="structt__fcdata" kindref="compound">t_fcdata</ref> *fcd, <ref refid="structt__state" kindref="compound">t_state</ref> *state_global, <ref refid="structt__mdatoms" kindref="compound">t_mdatoms</ref> *mdatoms, <ref refid="structt__nrnb" kindref="compound">t_nrnb</ref> *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, <ref refid="structt__forcerec" kindref="compound">t_forcerec</ref> *fr, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, real cpt_period, real max_hours, int imdport, unsigned long Flags, gmx_walltime_accounting_t walltime_accounting) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/mdlib/tpi.cpp" line="148" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/mdlib/tpi.cpp" bodystart="148" bodyend="881"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a8ddacc94505a46b63d40a995556cef32" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>gmx_uint64_t</type>
        <definition>gmx_uint64_t gmx::makeRandomSeed</definition>
        <argsstring>()</argsstring>
        <name>makeRandomSeed</name>
        <briefdescription>
<para>Return 64 random bits from the random device, suitable as seed. </para>        </briefdescription>
        <detaileddescription>
<para>If the internal random device output is smaller than 64 bits, this routine will use multiple calls internally until we have 64 bits of random data.</para><para><simplesect kind="return"><para>64-bit unsigned integer with random bits. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/random/seed.cpp" line="46" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/random/seed.cpp" bodystart="46" bodyend="61"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a7ba622deb792fdc881824ce7a36d8440" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class RealType</type>
            <defval><ref refid="real_8h_1a58a0c7cf2501f4492da833421be92547" kindref="member">real</ref></defval>
          </param>
          <param>
            <type>unsigned int</type>
            <declname>Bits</declname>
            <defname>Bits</defname>
          </param>
          <param>
            <type>class Rng</type>
          </param>
        </templateparamlist>
        <type>RealType</type>
        <definition>RealType gmx::generateCanonical</definition>
        <argsstring>(Rng &amp;g)</argsstring>
        <name>generateCanonical</name>
        <param>
          <type>Rng &amp;</type>
          <declname>g</declname>
        </param>
        <briefdescription>
<para>Generate a floating-point value with specified number of random bits. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>RealType</parametername>
</parameternamelist>
<parameterdescription>
<para>Floating-point type to generate </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Bits</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of random bits to generate </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Random number generator class</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>g</parametername>
</parameternamelist>
<parameterdescription>
<para>Random number generator to use</para></parameterdescription>
</parameteritem>
</parameterlist>
This implementation avoids the bug in libc++ and stdlibc++ (which is due to the C++ standard being unclear) where 1.0 can be returned occasionally. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/random/uniformrealdistribution.h" line="105" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/random/uniformrealdistribution.h" bodystart="105" bodyend="147"/>
      </memberdef>
      <memberdef kind="function" id="group__module__selection_1ga602d5f10c261b4110186f5c1c65c3703" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespacegmx_1abb455c7711ece592606e70a093ff80b4" kindref="member">HelpTopicPointer</ref></type>
        <definition>HelpTopicPointer gmx::createSelectionHelpTopic</definition>
        <argsstring>()</argsstring>
        <name>createSelectionHelpTopic</name>
        <briefdescription>
<para>*/ </para>        </briefdescription>
        <detaileddescription>
<para>Creates a help tree for selections.</para><para> <libinternal /> <parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::bad_alloc</parametername>
</parameternamelist>
<parameterdescription>
<para>if out of memory. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Root topic of the created selection tree. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/selhelp.cpp" line="803" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/selection/selhelp.cpp" bodystart="803" bodyend="815"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a073963d19e7e6337168de8dc0005b7e4" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void gmx::simdPrefetch</definition>
        <argsstring>(void *m)</argsstring>
        <name>simdPrefetch</name>
        <param>
          <type>void *</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Prefetch memory at address m. </para>        </briefdescription>
        <detaileddescription>
<para>This typically prefetches one cache line of memory from address m, usually 64bytes or more, but the exact amount will depend on the implementation. On many platforms this is simply a no-op. Technically it might not be part of the SIMD instruction set, but since it is a hardware-specific function that is normally only used in tight loops where we also apply SIMD, it fits well here.</para><para>There are no guarantees about the level of cache or temporality, but usually we expect stuff to end up in level 2, and be used in a few hundred clock cycles, after which it stays in cache until evicted (normal caching).</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to location prefetch. There are no alignment requirements, but if the pointer is not aligned the prefetch might start at the lower cache line boundary (meaning fewer bytes are prefetched). </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_general.h" line="71" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_general.h" bodystart="71" bodyend="74"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga725596b415f4bca94e71321b6845bed4" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::gatherLoadTranspose</definition>
        <argsstring>(const double *base, const std::int32_t offset[], SimdDouble *v0, SimdDouble *v1, SimdDouble *v2, SimdDouble *v3)</argsstring>
        <name>gatherLoadTranspose</name>
        <param>
          <type>const double *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>const std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>v1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>v2</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>v3</declname>
        </param>
        <briefdescription>
<para>Load 4 consecutive double from each of GMX_SIMD_DOUBLE_WIDTH offsets, and transpose into 4 SIMD double variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 4 for this routine) the input data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are loaded. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the memory area </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Array with offsets to the start of each data point. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st component of data, base[align*offset[i]] for each i. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd component of data, base[align*offset[i] + 1] for each i. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v2</parametername>
</parameternamelist>
<parameterdescription>
<para>3rd component of data, base[align*offset[i] + 2] for each i. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v3</parametername>
</parameternamelist>
<parameterdescription>
<para>4th component of data, base[align*offset[i] + 3] for each i.</para></parameterdescription>
</parameteritem>
</parameterlist>
The floating-point memory locations must be aligned, but only to the smaller of four elements and the floating-point SIMD width.</para><para>The offset memory must be aligned to GMX_SIMD_DINT32_WIDTH.</para><para><simplesect kind="note"><para>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" line="106" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" bodystart="106" bodyend="127"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gad1b51d9220213996033e5dce938c926f" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::gatherLoadTranspose</definition>
        <argsstring>(const double *base, const std::int32_t offset[], SimdDouble *v0, SimdDouble *v1)</argsstring>
        <name>gatherLoadTranspose</name>
        <param>
          <type>const double *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>const std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Load 2 consecutive double from each of GMX_SIMD_DOUBLE_WIDTH offsets, and transpose into 2 SIMD double variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 2 for this routine) the input data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are loaded. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the memory area </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Array with offsets to the start of each data point. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st component of data, base[align*offset[i]] for each i. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd component of data, base[align*offset[i] + 1] for each i.</para></parameterdescription>
</parameteritem>
</parameterlist>
The floating-point memory locations must be aligned, but only to the smaller of two elements and the floating-point SIMD width.</para><para>The offset memory must be aligned to GMX_SIMD_DINT32_WIDTH.</para><para><simplesect kind="note"><para>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" line="154" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" bodystart="154" bodyend="171"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gaafc4e2f213c40bba66c83e6524445523" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::gatherLoadUTranspose</definition>
        <argsstring>(const double *base, const std::int32_t offset[], SimdDouble *v0, SimdDouble *v1, SimdDouble *v2)</argsstring>
        <name>gatherLoadUTranspose</name>
        <param>
          <type>const double *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>const std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>v1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Load 3 consecutive doubles from each of GMX_SIMD_DOUBLE_WIDTH offsets, and transpose into 3 SIMD double variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 3 for this routine) the input data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are loaded. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the memory area </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Array with offsets to the start of each data point. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st component of data, base[align*offset[i]] for each i. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd component of data, base[align*offset[i] + 1] for each i. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v2</parametername>
</parameternamelist>
<parameterdescription>
<para>3rd component of data, base[align*offset[i] + 2] for each i.</para></parameterdescription>
</parameteritem>
</parameterlist>
This function can work with both aligned (better performance) and unaligned memory. When the align parameter is not a power-of-two (align==3 would be normal for packed atomic coordinates) the memory obviously cannot be aligned, and we account for this. However, in the case where align is a power-of-two, we assume the base pointer also has the same alignment, which will enable many platforms to use faster aligned memory load operations. An easy way to think of this is that each triplet of data in memory must be aligned to the align parameter you specify when it&apos;s a power-of-two.</para><para>The offset memory must always be aligned to GMX_SIMD_FINT32_WIDTH, since this enables us to use SIMD loads and gather operations on platforms that support it.</para><para><simplesect kind="note"><para>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </para><simplesectsep/><para>This routine uses a normal array for the offsets, since we typically load this data from memory. On the architectures we have tested this is faster even when a SIMD integer datatype is present. </para><simplesectsep/><para>To improve performance, this function might use full-SIMD-width unaligned loads. This means you need to ensure the memory is padded at the end, so we always can load GMX_SIMD_REAL_WIDTH elements starting at the last offset. If you use the Gromacs aligned memory allocation routines this will always be the case. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" line="222" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" bodystart="222" bodyend="237"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gaa23e5431ddc22611d3304ac96c461cc5" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::transposeScatterStoreU</definition>
        <argsstring>(double *base, const std::int32_t offset[], SimdDouble v0, SimdDouble v1, SimdDouble v2)</argsstring>
        <name>transposeScatterStoreU</name>
        <param>
          <type>double *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>const std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>v1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Transpose and store 3 SIMD doubles to 3 consecutive addresses at GMX_SIMD_DOUBLE_WIDTH offsets. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 3 for this routine) the output data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are written. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the memory area </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Aligned array with offsets to the start of each triplet. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st component of triplets, written to base[align*offset[i]]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd component of triplets, written to base[align*offset[i] + 1]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>3rd component of triplets, written to base[align*offset[i] + 2].</para></parameterdescription>
</parameteritem>
</parameterlist>
This function can work with both aligned (better performance) and unaligned memory. When the align parameter is not a power-of-two (align==3 would be normal for packed atomic coordinates) the memory obviously cannot be aligned, and we account for this. However, in the case where align is a power-of-two, we assume the base pointer also has the same alignment, which will enable many platforms to use faster aligned memory store operations. An easy way to think of this is that each triplet of data in memory must be aligned to the align parameter you specify when it&apos;s a power-of-two.</para><para>The offset memory must always be aligned to GMX_SIMD_FINT32_WIDTH, since this enables us to use SIMD loads and gather operations on platforms that support it.</para><para><simplesect kind="note"><para>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </para><simplesectsep/><para>This routine uses a normal array for the offsets, since we typically load the data from memory. On the architectures we have tested this is faster even when a SIMD integer datatype is present. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" line="275" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" bodystart="275" bodyend="290"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gaecbb196e76a516c1e3672a8fa0df6f87" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::transposeScatterIncrU</definition>
        <argsstring>(double *base, const std::int32_t offset[], SimdDouble v0, SimdDouble v1, SimdDouble v2)</argsstring>
        <name>transposeScatterIncrU</name>
        <param>
          <type>double *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>const std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>v1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Transpose and add 3 SIMD doubles to 3 consecutive addresses at GMX_SIMD_DOUBLE_WIDTH offsets. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 3 for this routine) the output data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are incremented. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the memory area </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Aligned array with offsets to the start of each triplet. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st component of triplets, added to base[align*offset[i]]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd component of triplets, added to base[align*offset[i] + 1]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>3rd component of triplets, added to base[align*offset[i] + 2].</para></parameterdescription>
</parameteritem>
</parameterlist>
This function can work with both aligned (better performance) and unaligned memory. When the align parameter is not a power-of-two (align==3 would be normal for packed atomic coordinates) the memory obviously cannot be aligned, and we account for this. However, in the case where align is a power-of-two, we assume the base pointer also has the same alignment, which will enable many platforms to use faster aligned memory load/store operations. An easy way to think of this is that each triplet of data in memory must be aligned to the align parameter you specify when it&apos;s a power-of-two.</para><para>The offset memory must always be aligned to GMX_SIMD_FINT32_WIDTH, since this enables us to use SIMD loads and gather operations on platforms that support it.</para><para><simplesect kind="note"><para>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </para><simplesectsep/><para>This routine uses a normal array for the offsets, since we typically load the data from memory. On the architectures we have tested this is faster even when a SIMD integer datatype is present. </para><simplesectsep/><para>To improve performance, this function might use full-SIMD-width unaligned load/store, and add 0.0 to the extra elements. This means you need to ensure the memory is padded at the end, so we always can load GMX_SIMD_REAL_WIDTH elements starting at the last offset. If you use the Gromacs aligned memory allocation routines this will always be the case. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" line="335" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" bodystart="335" bodyend="350"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga15283d6034452bcbee9c5f7538d7b560" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::transposeScatterDecrU</definition>
        <argsstring>(double *base, const std::int32_t offset[], SimdDouble v0, SimdDouble v1, SimdDouble v2)</argsstring>
        <name>transposeScatterDecrU</name>
        <param>
          <type>double *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>const std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>v1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Transpose and subtract 3 SIMD doubles to 3 consecutive addresses at GMX_SIMD_DOUBLE_WIDTH offsets. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 3 for this routine) the output data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are decremented. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to start of memory. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Aligned array with offsets to the start of each triplet. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st component, subtracted from base[align*offset[i]] </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd component, subtracted from base[align*offset[i]+1] </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>3rd component, subtracted from base[align*offset[i]+2]</para></parameterdescription>
</parameteritem>
</parameterlist>
This function can work with both aligned (better performance) and unaligned memory. When the align parameter is not a power-of-two (align==3 would be normal for packed atomic coordinates) the memory obviously cannot be aligned, and we account for this. However, in the case where align is a power-of-two, we assume the base pointer also has the same alignment, which will enable many platforms to use faster aligned memory load/store operations. An easy way to think of this is that each triplet of data in memory must be aligned to the align parameter you specify when it&apos;s a power-of-two.</para><para>The offset memory must always be aligned to GMX_SIMD_FINT32_WIDTH, since this enables us to use SIMD loads and gather operations on platforms that support it.</para><para><simplesect kind="note"><para>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </para><simplesectsep/><para>This routine uses a normal array for the offsets, since we typically load the data from memory. On the architectures we have tested this is faster even when a SIMD integer datatype is present. </para><simplesectsep/><para>To improve performance, this function might use full-SIMD-width unaligned load/store, and subtract 0.0 from the extra elements. This means you need to ensure the memory is padded at the end, so we always can load GMX_SIMD_REAL_WIDTH elements starting at the last offset. If you use the Gromacs aligned memory allocation routines this will always be the case. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" line="394" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" bodystart="394" bodyend="409"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gad8d730c26297155e1aa934c2bc91e750" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::expandScalarsToTriplets</definition>
        <argsstring>(SimdDouble scalar, SimdDouble *triplets0, SimdDouble *triplets1, SimdDouble *triplets2)</argsstring>
        <name>expandScalarsToTriplets</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>scalar</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>triplets0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>triplets1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>triplets2</declname>
        </param>
        <briefdescription>
<para>Expand each element of double SIMD variable into three identical consecutive elements in three SIMD outputs. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>scalar</parametername>
</parameternamelist>
<parameterdescription>
<para>Floating-point input, e.g. [s0 s1 s2 s3] if width=4. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">triplets0</parametername>
</parameternamelist>
<parameterdescription>
<para>First output, e.g. [s0 s0 s0 s1] if width=4. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">triplets1</parametername>
</parameternamelist>
<parameterdescription>
<para>Second output, e.g. [s1 s1 s2 s2] if width=4. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">triplets2</parametername>
</parameternamelist>
<parameterdescription>
<para>Third output, e.g. [s2 s3 s3 s3] if width=4.</para></parameterdescription>
</parameteritem>
</parameterlist>
This routine is meant to use for things like scalar-vector multiplication, where the vectors are stored in a merged format like [x0 y0 z0 x1 y1 z1 ...], while the scalars are stored as [s0 s1 s2...], and the data cannot easily be changed to SIMD-friendly layout.</para><para>In this case, load 3 full-width SIMD variables from the vector array (This will always correspond to GMX_SIMD_DOUBLE_WIDTH triplets), load a single full-width variable from the scalar array, and call this routine to expand the data. You can then simply multiply the first, second and third pair of SIMD variables, and store the three results back into a suitable vector-format array. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" line="433" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" bodystart="433" bodyend="444"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga1008329474744f6987edf28c4124ac24" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::gatherLoadBySimdIntTranspose</definition>
        <argsstring>(const double *base, SimdDInt32 offset, SimdDouble *v0, SimdDouble *v1, SimdDouble *v2, SimdDouble *v3)</argsstring>
        <name>gatherLoadBySimdIntTranspose</name>
        <param>
          <type>const double *</type>
          <declname>base</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>offset</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>v1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>v2</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>v3</declname>
        </param>
        <briefdescription>
<para>Load 4 consecutive doubles from each of GMX_SIMD_DOUBLE_WIDTH offsets specified by a SIMD integer, transpose into 4 SIMD double variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 4 for this routine) the input data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are loaded. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>Aligned pointer to the start of the memory. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD integer type with offsets to the start of each triplet. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>First component, base[align*offset[i]] for each i. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>Second component, base[align*offset[i] + 1] for each i. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v2</parametername>
</parameternamelist>
<parameterdescription>
<para>Third component, base[align*offset[i] + 2] for each i. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v3</parametername>
</parameternamelist>
<parameterdescription>
<para>Fourth component, base[align*offset[i] + 3] for each i.</para></parameterdescription>
</parameteritem>
</parameterlist>
The floating-point memory locations must be aligned, but only to the smaller of four elements and the floating-point SIMD width.</para><para><simplesect kind="note"><para>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </para><simplesectsep/><para>This is a special routine primarily intended for loading Gromacs table data as efficiently as possible - this is the reason for using a SIMD offset index, since the result of the real-to-integer conversion is present in a SIMD register just before calling this routine. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" line="475" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" bodystart="475" bodyend="494"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gad15c3a27898a9f9dbb2963dee1a7cacf" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::gatherLoadUBySimdIntTranspose</definition>
        <argsstring>(const double *base, SimdDInt32 offset, SimdDouble *v0, SimdDouble *v1)</argsstring>
        <name>gatherLoadUBySimdIntTranspose</name>
        <param>
          <type>const double *</type>
          <declname>base</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>offset</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Load 2 consecutive doubles from each of GMX_SIMD_DOUBLE_WIDTH offsets (unaligned) specified by SIMD integer, transpose into 2 SIMD doubles. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 2 for this routine) the input data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are loaded. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the memory. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD integer type with offsets to the start of each triplet. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>First component, base[align*offset[i]] for each i. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>Second component, base[align*offset[i] + 1] for each i.</para></parameterdescription>
</parameteritem>
</parameterlist>
Since some SIMD architectures cannot handle any unaligned loads, this routine is only available if GMX_SIMD_HAVE_GATHER_LOADU_BYSIMDINT_TRANSPOSE is 1.</para><para><simplesect kind="note"><para>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </para><simplesectsep/><para>This is a special routine primarily intended for loading Gromacs table data as efficiently as possible - this is the reason for using a SIMD offset index, since the result of the real-to-integer conversion is present in a SIMD register just before calling this routine. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" line="523" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" bodystart="523" bodyend="533"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga11385272a2b5123ca3aa3e5696e55dbc" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::gatherLoadBySimdIntTranspose</definition>
        <argsstring>(const double *base, SimdDInt32 offset, SimdDouble *v0, SimdDouble *v1)</argsstring>
        <name>gatherLoadBySimdIntTranspose</name>
        <param>
          <type>const double *</type>
          <declname>base</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDInt32" kindref="compound">SimdDInt32</ref></type>
          <declname>offset</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Load 2 consecutive doubles from each of GMX_SIMD_DOUBLE_WIDTH offsets specified by a SIMD integer, transpose into 2 SIMD double variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 2 for this routine) the input data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are loaded. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>Aligned pointer to the start of the memory. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD integer type with offsets to the start of each triplet. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>First component, base[align*offset[i]] for each i. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>Second component, base[align*offset[i] + 1] for each i.</para></parameterdescription>
</parameteritem>
</parameterlist>
The floating-point memory locations must be aligned, but only to the smaller of two elements and the floating-point SIMD width.</para><para><simplesect kind="note"><para>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </para><simplesectsep/><para>This is a special routine primarily intended for loading Gromacs table data as efficiently as possible - this is the reason for using a SIMD offset index, since the result of the real-to-integer conversion is present in a SIMD register just before calling this routine. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" line="561" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" bodystart="561" bodyend="576"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gace1c53e05ba045977e06eb98778c0123" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double gmx_simdcall</type>
        <definition>static double gmx_simdcall gmx::reduceIncr4ReturnSum</definition>
        <argsstring>(double *m, SimdDouble v0, SimdDouble v1, SimdDouble v2, SimdDouble v3)</argsstring>
        <name>reduceIncr4ReturnSum</name>
        <param>
          <type>double *</type>
          <declname>m</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>v1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>v2</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>v3</declname>
        </param>
        <briefdescription>
<para>Reduce each of four SIMD doubles, add those values to four consecutive doubles in memory, return sum. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory where four doubles should be incremented </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v0</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD variable whose sum should be added to m[0] </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD variable whose sum should be added to m[1] </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD variable whose sum should be added to m[2] </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v3</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD variable whose sum should be added to m[3]</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Sum of all elements in the four SIMD variables.</para></simplesect>
The pointer m must be aligned to the smaller of four elements and the floating-point SIMD width.</para><para><simplesect kind="note"><para>This is a special routine intended for the Gromacs nonbonded kernels. It is used in the epilogue of the outer loop, where the variables will contain unrolled forces for one outer-loop-particle each, corresponding to a single coordinate (i.e, say, four x-coordinate force variables). These should be summed and added to the force array in memory. Since we always work with contiguous SIMD-layout , we can use efficient aligned loads/stores. When calculating the virial, we also need the total sum of all forces for each coordinate. This is provided as the return value. For routines that do not need these, this extra code will be optimized away completely if you just ignore the return value (Checked with gcc-4.9.1 and clang-3.6 for AVX). </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" line="605" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_double.h" bodystart="605" bodyend="627"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga0f9f9c71226ae1d2f0065dd66e1027f0" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::gatherLoadTranspose</definition>
        <argsstring>(const float *base, const std::int32_t offset[], SimdFloat *v0, SimdFloat *v1, SimdFloat *v2, SimdFloat *v3)</argsstring>
        <name>gatherLoadTranspose</name>
        <param>
          <type>const float *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>const std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>v1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>v2</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>v3</declname>
        </param>
        <briefdescription>
<para>Load 4 consecutive floats from each of GMX_SIMD_FLOAT_WIDTH offsets, and transpose into 4 SIMD float variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 4 for this routine) the input data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are loaded. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the memory area </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Array with offsets to the start of each data point. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st component of data, base[align*offset[i]] for each i. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd component of data, base[align*offset[i] + 1] for each i. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v2</parametername>
</parameternamelist>
<parameterdescription>
<para>3rd component of data, base[align*offset[i] + 2] for each i. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v3</parametername>
</parameternamelist>
<parameterdescription>
<para>4th component of data, base[align*offset[i] + 3] for each i.</para></parameterdescription>
</parameteritem>
</parameterlist>
The floating-point memory locations must be aligned, but only to the smaller of four elements and the floating-point SIMD width.</para><para>The offset memory must be aligned to GMX_SIMD_DINT32_WIDTH.</para><para><simplesect kind="note"><para>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" line="110" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" bodystart="110" bodyend="131"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga6823a0b3cbc43eee3918b137d2b18384" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::gatherLoadTranspose</definition>
        <argsstring>(const float *base, const std::int32_t offset[], SimdFloat *v0, SimdFloat *v1)</argsstring>
        <name>gatherLoadTranspose</name>
        <param>
          <type>const float *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>const std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Load 2 consecutive floats from each of GMX_SIMD_FLOAT_WIDTH offsets, and transpose into 2 SIMD float variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 2 for this routine) the input data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are loaded. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the memory area </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Array with offsets to the start of each data point. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st component of data, base[align*offset[i]] for each i. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd component of data, base[align*offset[i] + 1] for each i.</para></parameterdescription>
</parameteritem>
</parameterlist>
The floating-point memory locations must be aligned, but only to the smaller of two elements and the floating-point SIMD width.</para><para>The offset memory must be aligned to GMX_SIMD_FINT32_WIDTH.</para><para>To achieve the best possible performance, you should store your data with alignment <ref refid="group__module__simd_1gacc4ad17022538e3d670e55694e55ccc2" kindref="member">c_simdBestPairAlignmentFloat</ref> in single, or <ref refid="group__module__simd_1ga9237b6439778ed0fdfd9008a78c25f3c" kindref="member">c_simdBestPairAlignmentDouble</ref> in double.</para><para><simplesect kind="note"><para>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" line="161" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" bodystart="161" bodyend="178"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gaa5581add75787fa1304acdac5af0ad7d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::gatherLoadUTranspose</definition>
        <argsstring>(const float *base, const std::int32_t offset[], SimdFloat *v0, SimdFloat *v1, SimdFloat *v2)</argsstring>
        <name>gatherLoadUTranspose</name>
        <param>
          <type>const float *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>const std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>v1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Load 3 consecutive floats from each of GMX_SIMD_FLOAT_WIDTH offsets, and transpose into 3 SIMD float variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 3 for this routine) the input data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are loaded. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the memory area </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Array with offsets to the start of each data point. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st component of data, base[align*offset[i]] for each i. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd component of data, base[align*offset[i] + 1] for each i. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v2</parametername>
</parameternamelist>
<parameterdescription>
<para>3rd component of data, base[align*offset[i] + 2] for each i.</para></parameterdescription>
</parameteritem>
</parameterlist>
This function can work with both aligned (better performance) and unaligned memory. When the align parameter is not a power-of-two (align==3 would be normal for packed atomic coordinates) the memory obviously cannot be aligned, and we account for this. However, in the case where align is a power-of-two, we assume the base pointer also has the same alignment, which will enable many platforms to use faster aligned memory load operations. An easy way to think of this is that each triplet of data in memory must be aligned to the align parameter you specify when it&apos;s a power-of-two.</para><para>The offset memory must always be aligned to GMX_SIMD_FINT32_WIDTH, since this enables us to use SIMD loads and gather operations on platforms that support it.</para><para><simplesect kind="note"><para>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </para><simplesectsep/><para>This routine uses a normal array for the offsets, since we typically load this data from memory. On the architectures we have tested this is faster even when a SIMD integer datatype is present. </para><simplesectsep/><para>To improve performance, this function might use full-SIMD-width unaligned loads. This means you need to ensure the memory is padded at the end, so we always can load GMX_SIMD_REAL_WIDTH elements starting at the last offset. If you use the Gromacs aligned memory allocation routines this will always be the case. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" line="240" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" bodystart="240" bodyend="255"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gaba67dbea2a790730dfa78999209959b2" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::transposeScatterStoreU</definition>
        <argsstring>(float *base, const std::int32_t offset[], SimdFloat v0, SimdFloat v1, SimdFloat v2)</argsstring>
        <name>transposeScatterStoreU</name>
        <param>
          <type>float *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>const std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>v1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Transpose and store 3 SIMD floats to 3 consecutive addresses at GMX_SIMD_FLOAT_WIDTH offsets. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 3 for this routine) the output data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are written. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the memory area </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Aligned array with offsets to the start of each triplet. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st component of triplets, written to base[align*offset[i]]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd component of triplets, written to base[align*offset[i] + 1]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>3rd component of triplets, written to base[align*offset[i] + 2].</para></parameterdescription>
</parameteritem>
</parameterlist>
This function can work with both aligned (better performance) and unaligned memory. When the align parameter is not a power-of-two (align==3 would be normal for packed atomic coordinates) the memory obviously cannot be aligned, and we account for this. However, in the case where align is a power-of-two, we assume the base pointer also has the same alignment, which will enable many platforms to use faster aligned memory store operations. An easy way to think of this is that each triplet of data in memory must be aligned to the align parameter you specify when it&apos;s a power-of-two.</para><para>The offset memory must always be aligned to GMX_SIMD_FINT32_WIDTH, since this enables us to use SIMD loads and gather operations on platforms that support it.</para><para><simplesect kind="note"><para>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </para><simplesectsep/><para>This routine uses a normal array for the offsets, since we typically load the data from memory. On the architectures we have tested this is faster even when a SIMD integer datatype is present. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" line="294" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" bodystart="294" bodyend="309"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gac36c2fd8a466fb309ba9ae1dbf8dffbd" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::transposeScatterIncrU</definition>
        <argsstring>(float *base, const std::int32_t offset[], SimdFloat v0, SimdFloat v1, SimdFloat v2)</argsstring>
        <name>transposeScatterIncrU</name>
        <param>
          <type>float *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>const std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>v1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Transpose and add 3 SIMD floats to 3 consecutive addresses at GMX_SIMD_FLOAT_WIDTH offsets. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 3 for this routine) the output data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are incremented. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the memory area </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Aligned array with offsets to the start of each triplet. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st component of triplets, added to base[align*offset[i]]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd component of triplets, added to base[align*offset[i] + 1]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>3rd component of triplets, added to base[align*offset[i] + 2].</para></parameterdescription>
</parameteritem>
</parameterlist>
This function can work with both aligned (better performance) and unaligned memory. When the align parameter is not a power-of-two (align==3 would be normal for packed atomic coordinates) the memory obviously cannot be aligned, and we account for this. However, in the case where align is a power-of-two, we assume the base pointer also has the same alignment, which will enable many platforms to use faster aligned memory load/store operations. An easy way to think of this is that each triplet of data in memory must be aligned to the align parameter you specify when it&apos;s a power-of-two.</para><para>The offset memory must always be aligned to GMX_SIMD_FINT32_WIDTH, since this enables us to use SIMD loads and gather operations on platforms that support it.</para><para><simplesect kind="note"><para>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </para><simplesectsep/><para>This routine uses a normal array for the offsets, since we typically load the data from memory. On the architectures we have tested this is faster even when a SIMD integer datatype is present. </para><simplesectsep/><para>To improve performance, this function might use full-SIMD-width unaligned load/store, and add 0.0 to the extra elements. This means you need to ensure the memory is padded at the end, so we always can load GMX_SIMD_REAL_WIDTH elements starting at the last offset. If you use the Gromacs aligned memory allocation routines this will always be the case. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" line="354" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" bodystart="354" bodyend="369"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga6889b6665cbfc5fa0bce09fe5db5e49c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::transposeScatterDecrU</definition>
        <argsstring>(float *base, const std::int32_t offset[], SimdFloat v0, SimdFloat v1, SimdFloat v2)</argsstring>
        <name>transposeScatterDecrU</name>
        <param>
          <type>float *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>const std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>v1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Transpose and subtract 3 SIMD floats to 3 consecutive addresses at GMX_SIMD_FLOAT_WIDTH offsets. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 3 for this routine) the output data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are decremented. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to start of memory. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Aligned array with offsets to the start of each triplet. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st component, subtracted from base[align*offset[i]] </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd component, subtracted from base[align*offset[i]+1] </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>3rd component, subtracted from base[align*offset[i]+2]</para></parameterdescription>
</parameteritem>
</parameterlist>
This function can work with both aligned (better performance) and unaligned memory. When the align parameter is not a power-of-two (align==3 would be normal for packed atomic coordinates) the memory obviously cannot be aligned, and we account for this. However, in the case where align is a power-of-two, we assume the base pointer also has the same alignment, which will enable many platforms to use faster aligned memory load/store operations. An easy way to think of this is that each triplet of data in memory must be aligned to the align parameter you specify when it&apos;s a power-of-two.</para><para>The offset memory must always be aligned to GMX_SIMD_FINT32_WIDTH, since this enables us to use SIMD loads and gather operations on platforms that support it.</para><para><simplesect kind="note"><para>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </para><simplesectsep/><para>This routine uses a normal array for the offsets, since we typically load the data from memory. On the architectures we have tested this is faster even when a SIMD integer datatype is present. </para><simplesectsep/><para>To improve performance, this function might use full-SIMD-width unaligned load/store, and subtract 0.0 from the extra elements. This means you need to ensure the memory is padded at the end, so we always can load GMX_SIMD_REAL_WIDTH elements starting at the last offset. If you use the Gromacs aligned memory allocation routines this will always be the case. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" line="414" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" bodystart="414" bodyend="429"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga82af54acc2b9eae6e58b646b5022aef5" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::expandScalarsToTriplets</definition>
        <argsstring>(SimdFloat scalar, SimdFloat *triplets0, SimdFloat *triplets1, SimdFloat *triplets2)</argsstring>
        <name>expandScalarsToTriplets</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>scalar</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>triplets0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>triplets1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>triplets2</declname>
        </param>
        <briefdescription>
<para>Expand each element of float SIMD variable into three identical consecutive elements in three SIMD outputs. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>scalar</parametername>
</parameternamelist>
<parameterdescription>
<para>Floating-point input, e.g. [s0 s1 s2 s3] if width=4. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">triplets0</parametername>
</parameternamelist>
<parameterdescription>
<para>First output, e.g. [s0 s0 s0 s1] if width=4. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">triplets1</parametername>
</parameternamelist>
<parameterdescription>
<para>Second output, e.g. [s1 s1 s2 s2] if width=4. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">triplets2</parametername>
</parameternamelist>
<parameterdescription>
<para>Third output, e.g. [s2 s3 s3 s3] if width=4.</para></parameterdescription>
</parameteritem>
</parameterlist>
This routine is meant to use for things like scalar-vector multiplication, where the vectors are stored in a merged format like [x0 y0 z0 x1 y1 z1 ...], while the scalars are stored as [s0 s1 s2...], and the data cannot easily be changed to SIMD-friendly layout.</para><para>In this case, load 3 full-width SIMD variables from the vector array (This will always correspond to GMX_SIMD_FLOAT_WIDTH triplets), load a single full-width variable from the scalar array, and call this routine to expand the data. You can then simply multiply the first, second and third pair of SIMD variables, and store the three results back into a suitable vector-format array. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" line="453" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" bodystart="453" bodyend="464"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gac7ba60b7340036a984888bbca43616e4" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::gatherLoadBySimdIntTranspose</definition>
        <argsstring>(const float *base, SimdFInt32 offset, SimdFloat *v0, SimdFloat *v1, SimdFloat *v2, SimdFloat *v3)</argsstring>
        <name>gatherLoadBySimdIntTranspose</name>
        <param>
          <type>const float *</type>
          <declname>base</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>offset</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>v1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>v2</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>v3</declname>
        </param>
        <briefdescription>
<para>Load 4 consecutive floats from each of GMX_SIMD_FLOAT_WIDTH offsets specified by a SIMD integer, transpose into 4 SIMD float variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 4 for this routine) the input data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are loaded. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>Aligned pointer to the start of the memory. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD integer type with offsets to the start of each triplet. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>First component, base[align*offset[i]] for each i. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>Second component, base[align*offset[i] + 1] for each i. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v2</parametername>
</parameternamelist>
<parameterdescription>
<para>Third component, base[align*offset[i] + 2] for each i. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v3</parametername>
</parameternamelist>
<parameterdescription>
<para>Fourth component, base[align*offset[i] + 3] for each i.</para></parameterdescription>
</parameteritem>
</parameterlist>
The floating-point memory locations must be aligned, but only to the smaller of four elements and the floating-point SIMD width.</para><para><simplesect kind="note"><para>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </para><simplesectsep/><para>This is a special routine primarily intended for loading Gromacs table data as efficiently as possible - this is the reason for using a SIMD offset index, since the result of the real-to-integer conversion is present in a SIMD register just before calling this routine. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" line="494" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" bodystart="494" bodyend="513"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga4b26c79db832542ab73a692f7db941c2" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::gatherLoadUBySimdIntTranspose</definition>
        <argsstring>(const float *base, SimdFInt32 offset, SimdFloat *v0, SimdFloat *v1)</argsstring>
        <name>gatherLoadUBySimdIntTranspose</name>
        <param>
          <type>const float *</type>
          <declname>base</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>offset</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Load 2 consecutive floats from each of GMX_SIMD_FLOAT_WIDTH offsets (unaligned) specified by SIMD integer, transpose into 2 SIMD floats. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 2 for this routine) the input data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are loaded. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the memory. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD integer type with offsets to the start of each triplet. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>First component, base[align*offset[i]] for each i. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>Second component, base[align*offset[i] + 1] for each i.</para></parameterdescription>
</parameteritem>
</parameterlist>
Since some SIMD architectures cannot handle any unaligned loads, this routine is only available if GMX_SIMD_HAVE_GATHER_LOADU_BYSIMDINT_TRANSPOSE is 1.</para><para><simplesect kind="note"><para>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </para><simplesectsep/><para>This is a special routine primarily intended for loading Gromacs table data as efficiently as possible - this is the reason for using a SIMD offset index, since the result of the real-to-integer conversion is present in a SIMD register just before calling this routine. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" line="542" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" bodystart="542" bodyend="552"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga98bde531b096434095b228308e7a3025" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::gatherLoadBySimdIntTranspose</definition>
        <argsstring>(const float *base, SimdFInt32 offset, SimdFloat *v0, SimdFloat *v1)</argsstring>
        <name>gatherLoadBySimdIntTranspose</name>
        <param>
          <type>const float *</type>
          <declname>base</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFInt32" kindref="compound">SimdFInt32</ref></type>
          <declname>offset</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Load 2 consecutive floats from each of GMX_SIMD_FLOAT_WIDTH offsets specified by a SIMD integer, transpose into 2 SIMD float variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 2 for this routine) the input data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are loaded. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>Aligned pointer to the start of the memory. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD integer type with offsets to the start of each triplet. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>First component, base[align*offset[i]] for each i. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>Second component, base[align*offset[i] + 1] for each i.</para></parameterdescription>
</parameteritem>
</parameterlist>
The floating-point memory locations must be aligned, but only to the smaller of two elements and the floating-point SIMD width.</para><para><simplesect kind="note"><para>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </para><simplesectsep/><para>This is a special routine primarily intended for loading Gromacs table data as efficiently as possible - this is the reason for using a SIMD offset index, since the result of the real-to-integer conversion is present in a SIMD register just before calling this routine. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" line="580" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" bodystart="580" bodyend="595"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga1e64aefa14afa2f473c4db52e82d4a99" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float gmx_simdcall</type>
        <definition>static float gmx_simdcall gmx::reduceIncr4ReturnSum</definition>
        <argsstring>(float *m, SimdFloat v0, SimdFloat v1, SimdFloat v2, SimdFloat v3)</argsstring>
        <name>reduceIncr4ReturnSum</name>
        <param>
          <type>float *</type>
          <declname>m</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>v0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>v1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>v2</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>v3</declname>
        </param>
        <briefdescription>
<para>Reduce each of four SIMD floats, add those values to four consecutive floats in memory, return sum. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory where four floats should be incremented </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v0</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD variable whose sum should be added to m[0] </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD variable whose sum should be added to m[1] </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD variable whose sum should be added to m[2] </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v3</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD variable whose sum should be added to m[3]</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Sum of all elements in the four SIMD variables.</para></simplesect>
The pointer m must be aligned to the smaller of four elements and the floating-point SIMD width.</para><para><simplesect kind="note"><para>This is a special routine intended for the Gromacs nonbonded kernels. It is used in the epilogue of the outer loop, where the variables will contain unrolled forces for one outer-loop-particle each, corresponding to a single coordinate (i.e, say, four x-coordinate force variables). These should be summed and added to the force array in memory. Since we always work with contiguous SIMD-layout , we can use efficient aligned loads/stores. When calculating the virial, we also need the total sum of all forces for each coordinate. This is provided as the return value. For routines that do not need these, this extra code will be optimized away completely if you just ignore the return value (Checked with gcc-4.9.1 and clang-3.6 for AVX). </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" line="624" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/impl_reference/impl_reference_util_float.h" bodystart="624" bodyend="646"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a5ba56cff453ff9a1f21a11d72358592a" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void gmx::store</definition>
        <argsstring>(float *m, float a)</argsstring>
        <name>store</name>
        <param>
          <type>float *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Store contents of float variable to aligned memory m. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>float variable to store</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="79" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="79" bodyend="82"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1af3a3dcd7322b5b2555938fe1c05be15f" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void gmx::storeU</definition>
        <argsstring>(float *m, float a)</argsstring>
        <name>storeU</name>
        <param>
          <type>float *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Store contents of float variable to unaligned memory m. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory, no alignment requirement. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>float variable to store.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="94" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="94" bodyend="97"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a183d89182d418bb66a668104978af5bf" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::fma</definition>
        <argsstring>(float a, float b, float c)</argsstring>
        <name>fma</name>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <param>
          <type>float</type>
          <declname>b</declname>
        </param>
        <param>
          <type>float</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>Float Fused-multiply-add. Result is a*b + c. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b + c</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="114" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="114" bodyend="119"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1afad947f51589a3a9eef2f8364ab62c19" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::fms</definition>
        <argsstring>(float a, float b, float c)</argsstring>
        <name>fms</name>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <param>
          <type>float</type>
          <declname>b</declname>
        </param>
        <param>
          <type>float</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>Float Fused-multiply-subtract. Result is a*b - c. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b - c</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="133" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="133" bodyend="136"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a55183d689ab9328c18c3b3f819bd7266" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::fnma</definition>
        <argsstring>(float a, float b, float c)</argsstring>
        <name>fnma</name>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <param>
          <type>float</type>
          <declname>b</declname>
        </param>
        <param>
          <type>float</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>Float Fused-negated-multiply-add. Result is -a*b + c. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>-a*b + c</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="150" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="150" bodyend="153"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aa6e6950597f4833fa93b09a94e7b0e16" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::fnms</definition>
        <argsstring>(float a, float b, float c)</argsstring>
        <name>fnms</name>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <param>
          <type>float</type>
          <declname>b</declname>
        </param>
        <param>
          <type>float</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>Float Fused-negated-multiply-subtract. Result is -a*b - c. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>-a*b - c</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="167" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="167" bodyend="170"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a0178a127dde331652ab015323ae622f2" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::maskAdd</definition>
        <argsstring>(float a, float b, float m)</argsstring>
        <name>maskAdd</name>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <param>
          <type>float</type>
          <declname>b</declname>
        </param>
        <param>
          <type>float</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Add two float variables, masked version. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>term1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>term2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a+b where mask is true, a otherwise.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="184" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="184" bodyend="187"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a1e3c4084e25d298f95003df8e9aeffa1" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::maskzMul</definition>
        <argsstring>(float a, float b, float m)</argsstring>
        <name>maskzMul</name>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <param>
          <type>float</type>
          <declname>b</declname>
        </param>
        <param>
          <type>float</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Multiply two float variables, masked version. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b where mask is true, 0.0 otherwise.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="201" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="201" bodyend="204"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a8151e61ef06e30e360c03bba6fb5e2ab" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::maskzFma</definition>
        <argsstring>(float a, float b, float c, float m)</argsstring>
        <name>maskzFma</name>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <param>
          <type>float</type>
          <declname>b</declname>
        </param>
        <param>
          <type>float</type>
          <declname>c</declname>
        </param>
        <param>
          <type>float</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Float fused multiply-add, masked version. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b+c where mask is true, 0.0 otherwise.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="219" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="219" bodyend="222"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a5dc46e83d110b8c81339683bf748fc81" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::abs</definition>
        <argsstring>(float a)</argsstring>
        <name>abs</name>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Float Floating-point <ref refid="group__module__simd_1ga9339c53d13a59e946834c14d565f1e18" kindref="member">abs()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>any floating point values </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>abs(a) for each element.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="234" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="234" bodyend="237"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a35c7b010fbd32f5424afa0de0c70db6f" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::max</definition>
        <argsstring>(float a, float b)</argsstring>
        <name>max</name>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <param>
          <type>float</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Set each float element to the largest from two variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>max(a,b) for each element.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="250" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="250" bodyend="253"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aa6d21dccd9a94698363bdb1943f139bb" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::min</definition>
        <argsstring>(float a, float b)</argsstring>
        <name>min</name>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <param>
          <type>float</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Set each float element to the smallest from two variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>min(a,b) for each element.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="266" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="266" bodyend="269"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a1c0a061335a242530d8d791459a8e2d0" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::round</definition>
        <argsstring>(float a)</argsstring>
        <name>round</name>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Float round to nearest integer value (in floating-point format). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The nearest integer, represented in floating-point format.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="281" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="281" bodyend="284"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a4323d38c16cd7ce6b1ae9df62e94ef2a" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::trunc</definition>
        <argsstring>(float a)</argsstring>
        <name>trunc</name>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Truncate float, i.e. round towards zero - common hardware instruction. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Any floating-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Integer rounded towards zero, represented in floating-point format.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="296" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="296" bodyend="299"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aa4a37558328ab029203170ad4c6c4d01" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::reduce</definition>
        <argsstring>(float a)</argsstring>
        <name>reduce</name>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Return sum of all elements in float variable (i.e., the variable itself). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>variable to reduce/sum. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The argument variable itself.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="311" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="311" bodyend="314"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aaec39ef87dbec92292cd5954c922be6d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::andNot</definition>
        <argsstring>(float a, float b)</argsstring>
        <name>andNot</name>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <param>
          <type>float</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Bitwise andnot for two scalar float variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>data1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>data2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(~data1) &amp; data2</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="327" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="327" bodyend="341"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1af6a3628d9b9ddc7900590f963be7bbf0" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool gmx::testBits</definition>
        <argsstring>(float a)</argsstring>
        <name>testBits</name>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Return true if any bits are set in the float variable. </para>        </briefdescription>
        <detaileddescription>
<para>This function is used to handle bitmasks, mainly for exclusions in the inner kernels. Note that it will return true even for -0.0f (sign bit set), so it is not identical to not-equal.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if any bit in a is nonzero.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="357" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="357" bodyend="367"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1af90cd5d709899e47809553109383299e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool gmx::anyTrue</definition>
        <argsstring>(bool a)</argsstring>
        <name>anyTrue</name>
        <param>
          <type>bool</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns if the boolean is true. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Logical variable. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if a is true, otherwise false.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="379" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="379" bodyend="382"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1af47eb155075f6f9aa99ecca11825b021" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::selectByMask</definition>
        <argsstring>(float a, bool mask)</argsstring>
        <name>selectByMask</name>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>mask</declname>
        </param>
        <briefdescription>
<para>Select from single precision variable where boolean is true. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Floating-point variable to select from </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a is selected for true, 0 for false.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="395" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="395" bodyend="398"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a76f8ccf8f582242260b4e785ebf48e3a" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::selectByNotMask</definition>
        <argsstring>(float a, bool mask)</argsstring>
        <name>selectByNotMask</name>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>mask</declname>
        </param>
        <briefdescription>
<para>Select from single precision variable where boolean is false. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Floating-point variable to select from </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a is selected for false, 0 for true.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="411" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="411" bodyend="414"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a31c5db5940f1fed568d8d6a0dbe7ec1a" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::blend</definition>
        <argsstring>(float a, float b, float sel)</argsstring>
        <name>blend</name>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <param>
          <type>float</type>
          <declname>b</declname>
        </param>
        <param>
          <type>float</type>
          <declname>sel</declname>
        </param>
        <briefdescription>
<para>Blend float selection. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>First source </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Second source </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sel</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Select b if sel is true, a otherwise.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="428" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="428" bodyend="431"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a2136f5684897fc7ea139039eba172629" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::int32_t</type>
        <definition>static std::int32_t gmx::cvtR2I</definition>
        <argsstring>(float a)</argsstring>
        <name>cvtR2I</name>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Round single precision floating point to integer. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>float </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Integer format, a rounded to nearest integer.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="443" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="443" bodyend="446"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a7c74ba54abe2627167abfc0df7286f5d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::int32_t</type>
        <definition>static std::int32_t gmx::cvttR2I</definition>
        <argsstring>(float a)</argsstring>
        <name>cvttR2I</name>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Truncate single precision floating point to integer. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>float </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Integer format, a truncated to integer.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="458" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="458" bodyend="461"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a69388fb35cb4b891c7517554e4500615" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::int32_t</type>
        <definition>static std::int32_t gmx::cvtI2R</definition>
        <argsstring>(std::int32_t a)</argsstring>
        <name>cvtI2R</name>
        <param>
          <type>std::int32_t</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Return integer. </para>        </briefdescription>
        <detaileddescription>
<para>This function mimicks the SIMD integer-to-real conversion routines. By simply returning an integer, we let the compiler sort out whether the conversion should be to float or double rather than using proxy objects.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>integer </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>same value (a)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="477" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="477" bodyend="480"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aea1d0d7a9f81e8e5cac19a3b66f0170e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void gmx::store</definition>
        <argsstring>(double *m, double a)</argsstring>
        <name>store</name>
        <param>
          <type>double *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Store contents of double variable to aligned memory m. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>double variable to store</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="496" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="496" bodyend="499"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aea9644fa777bc5e47ff9d3e2bdde34e0" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void gmx::storeU</definition>
        <argsstring>(double *m, double a)</argsstring>
        <name>storeU</name>
        <param>
          <type>double *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Store contents of double variable to unaligned memory m. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory, no alignment requirement. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>double variable to store.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="511" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="511" bodyend="514"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a79e2ba07938cafa28c0988ba52874f46" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::fma</definition>
        <argsstring>(double a, double b, double c)</argsstring>
        <name>fma</name>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <param>
          <type>double</type>
          <declname>b</declname>
        </param>
        <param>
          <type>double</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>double Fused-multiply-add. Result is a*b + c. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b + c</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="531" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="531" bodyend="536"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1abcb2c8942d173c6a9964940f90c55b2a" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::fms</definition>
        <argsstring>(double a, double b, double c)</argsstring>
        <name>fms</name>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <param>
          <type>double</type>
          <declname>b</declname>
        </param>
        <param>
          <type>double</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>double Fused-multiply-subtract. Result is a*b - c. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b - c</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="550" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="550" bodyend="553"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1adcf7849c8ce1bbbe3e2fecffedfc05e8" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::fnma</definition>
        <argsstring>(double a, double b, double c)</argsstring>
        <name>fnma</name>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <param>
          <type>double</type>
          <declname>b</declname>
        </param>
        <param>
          <type>double</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>double Fused-negated-multiply-add. Result is - a*b + c. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>-a*b + c</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="567" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="567" bodyend="570"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ad9bd8328d5cbdb7f6a054b877183f277" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::fnms</definition>
        <argsstring>(double a, double b, double c)</argsstring>
        <name>fnms</name>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <param>
          <type>double</type>
          <declname>b</declname>
        </param>
        <param>
          <type>double</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>double Fused-negated-multiply-subtract. Result is -a*b - c. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>-a*b - c</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="584" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="584" bodyend="587"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a68b090d0e3ab5695c508453406ee43c8" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::maskAdd</definition>
        <argsstring>(double a, double b, double m)</argsstring>
        <name>maskAdd</name>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <param>
          <type>double</type>
          <declname>b</declname>
        </param>
        <param>
          <type>double</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Add two double variables, masked version. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>term1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>term2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a+b where mask is true, a otherwise.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="601" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="601" bodyend="604"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a7e4ab8b1ab046ff242d32ab93366bfde" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::maskzMul</definition>
        <argsstring>(double a, double b, double m)</argsstring>
        <name>maskzMul</name>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <param>
          <type>double</type>
          <declname>b</declname>
        </param>
        <param>
          <type>double</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Multiply two double variables, masked version. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b where mask is true, 0.0 otherwise.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="618" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="618" bodyend="621"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aa3cf4eaad108887d2462f5beecd4db62" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::maskzFma</definition>
        <argsstring>(double a, double b, double c, double m)</argsstring>
        <name>maskzFma</name>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <param>
          <type>double</type>
          <declname>b</declname>
        </param>
        <param>
          <type>double</type>
          <declname>c</declname>
        </param>
        <param>
          <type>double</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>double fused multiply-add, masked version. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>factor1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>factor2 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>term </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a*b+c where mask is true, 0.0 otherwise.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="636" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="636" bodyend="639"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ac85ea3af684916aee86e2674a6bd81e5" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::abs</definition>
        <argsstring>(double a)</argsstring>
        <name>abs</name>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>double doubleing-point <ref refid="group__module__simd_1ga9339c53d13a59e946834c14d565f1e18" kindref="member">abs()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>any doubleing point values </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>abs(a) for each element.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="651" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="651" bodyend="654"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a16f6bf4a20b14262f28168596d5bb8b9" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::max</definition>
        <argsstring>(double a, double b)</argsstring>
        <name>max</name>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <param>
          <type>double</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Set each double element to the largest from two variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Any doubleing-point value </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Any doubleing-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>max(a,b) for each element.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="667" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="667" bodyend="670"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a65fb0c7aa84962905d3d78a913c787c3" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::min</definition>
        <argsstring>(double a, double b)</argsstring>
        <name>min</name>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <param>
          <type>double</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Set each double element to the smallest from two variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Any doubleing-point value </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Any doubleing-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>min(a,b) for each element.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="683" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="683" bodyend="686"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a15179b513c1ec4ec0b9090e57b76bac4" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::round</definition>
        <argsstring>(double a)</argsstring>
        <name>round</name>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>double round to nearest integer value (in doubleing-point format). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Any doubleing-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The nearest integer, represented in doubleing-point format.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="698" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="698" bodyend="701"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a00d84f65dae98aeb02816975f5045eed" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::trunc</definition>
        <argsstring>(double a)</argsstring>
        <name>trunc</name>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Truncate double, i.e. round towards zero - common hardware instruction. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Any doubleing-point value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Integer rounded towards zero, represented in doubleing-point format.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="713" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="713" bodyend="716"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a157983d90620412d404e8a77d1ddbd0f" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::reduce</definition>
        <argsstring>(double a)</argsstring>
        <name>reduce</name>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Return sum of all elements in double variable (i.e., the variable itself). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>variable to reduce/sum. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The argument variable itself.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="728" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="728" bodyend="731"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aebb0315d31c3c818a738bdc153397365" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::andNot</definition>
        <argsstring>(double a, double b)</argsstring>
        <name>andNot</name>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <param>
          <type>double</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Bitwise andnot for two scalar double variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>data1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>data2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(~data1) &amp; data2</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="744" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="744" bodyend="758"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ae58ba299df96ee6c45043e646a1d01dc" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool gmx::testBits</definition>
        <argsstring>(double a)</argsstring>
        <name>testBits</name>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Return true if any bits are set in the double variable. </para>        </briefdescription>
        <detaileddescription>
<para>This function is used to handle bitmasks, mainly for exclusions in the inner kernels. Note that it will return true even for -0.0 (sign bit set), so it is not identical to not-equal.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if any bit in a is nonzero.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="774" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="774" bodyend="784"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aa1449de9307a87e0c5946fd9cab43b35" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::selectByMask</definition>
        <argsstring>(double a, bool mask)</argsstring>
        <name>selectByMask</name>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>mask</declname>
        </param>
        <briefdescription>
<para>Select from double precision variable where boolean is true. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>double variable to select from </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a is selected for true, 0 for false.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="797" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="797" bodyend="800"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a2f03ad3380ef6213c5459051c3268ba7" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::selectByNotMask</definition>
        <argsstring>(double a, bool mask)</argsstring>
        <name>selectByNotMask</name>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>mask</declname>
        </param>
        <briefdescription>
<para>Select from double precision variable where boolean is false. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>double variable to select from </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a is selected for false, 0 for true.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="813" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="813" bodyend="816"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a90aa803db2a6a8c9dbb22395dcaf4532" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::blend</definition>
        <argsstring>(double a, double b, double sel)</argsstring>
        <name>blend</name>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <param>
          <type>double</type>
          <declname>b</declname>
        </param>
        <param>
          <type>double</type>
          <declname>sel</declname>
        </param>
        <briefdescription>
<para>Blend double selection. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>First source </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Second source </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sel</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Select b if sel is true, a otherwise.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="830" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="830" bodyend="833"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1acc9f420c1d0c099cc58ac3ae5fcb1ace" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::int32_t</type>
        <definition>static std::int32_t gmx::cvtR2I</definition>
        <argsstring>(double a)</argsstring>
        <name>cvtR2I</name>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Round single precision doubleing point to integer. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>double </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Integer format, a rounded to nearest integer.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="845" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="845" bodyend="848"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ac0fb4318cc5c14075330d52382e6bdd4" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::int32_t</type>
        <definition>static std::int32_t gmx::cvttR2I</definition>
        <argsstring>(double a)</argsstring>
        <name>cvttR2I</name>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Truncate single precision doubleing point to integer. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>double </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Integer format, a truncated to integer.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="860" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="860" bodyend="863"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ac575d3b81809b71e414755dc8acf3317" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::cvtF2D</definition>
        <argsstring>(float a)</argsstring>
        <name>cvtF2D</name>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Convert float to double (mimicks SIMD conversion) </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>float </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a, as double double</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="880" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="880" bodyend="883"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a22401779c65549d3061b4fdd5290ef19" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::cvtD2F</definition>
        <argsstring>(double a)</argsstring>
        <name>cvtD2F</name>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Convert double to float (mimicks SIMD conversion) </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>double </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a, as float</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="895" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="895" bodyend="898"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aa169afcbfb3992ab9fde1ed5beee8b06" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void gmx::store</definition>
        <argsstring>(std::int32_t *m, std::int32_t a)</argsstring>
        <name>store</name>
        <param>
          <type>std::int32_t *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>std::int32_t</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Store contents of integer variable to aligned memory m. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>integer variable to store</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="914" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="914" bodyend="917"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a43354d3d210193bcf5316234dc7d93ae" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void gmx::storeU</definition>
        <argsstring>(std::int32_t *m, std::int32_t a)</argsstring>
        <name>storeU</name>
        <param>
          <type>std::int32_t *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>std::int32_t</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Store contents of integer variable to unaligned memory m. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory, no alignment requirement. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>integer variable to store.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="929" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="929" bodyend="932"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a880a42645963c52980a5790f09e3bd18" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::int32_t</type>
        <definition>static std::int32_t gmx::andNot</definition>
        <argsstring>(std::int32_t a, std::int32_t b)</argsstring>
        <name>andNot</name>
        <param>
          <type>std::int32_t</type>
          <declname>a</declname>
        </param>
        <param>
          <type>std::int32_t</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Bitwise andnot for two scalar integer variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>data1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>data2 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(~data1) &amp; data2</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="945" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="945" bodyend="948"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ae2a03b61db6a3ed3e8c2d5e1b3acc9a8" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool gmx::testBits</definition>
        <argsstring>(std::int32_t a)</argsstring>
        <name>testBits</name>
        <param>
          <type>std::int32_t</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Return true if any bits are set in the integer variable. </para>        </briefdescription>
        <detaileddescription>
<para>This function is used to handle bitmasks, mainly for exclusions in the inner kernels.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if any bit in a is nonzero.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="963" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="963" bodyend="966"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a543420229312467871aaa26ea79f5a5d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::int32_t</type>
        <definition>static std::int32_t gmx::selectByMask</definition>
        <argsstring>(std::int32_t a, bool mask)</argsstring>
        <name>selectByMask</name>
        <param>
          <type>std::int32_t</type>
          <declname>a</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>mask</declname>
        </param>
        <briefdescription>
<para>Select from integer variable where boolean is true. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Integer variable to select from </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a is selected for true, 0 for false.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="979" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="979" bodyend="982"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aa1c7d81b9ba8302dadcbdded4fcd4399" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::int32_t</type>
        <definition>static std::int32_t gmx::selectByNotMask</definition>
        <argsstring>(std::int32_t a, bool mask)</argsstring>
        <name>selectByNotMask</name>
        <param>
          <type>std::int32_t</type>
          <declname>a</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>mask</declname>
        </param>
        <briefdescription>
<para>Select from integer variable where boolean is false. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Integer variable to select from </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a is selected for false, 0 for true.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="995" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="995" bodyend="998"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1acf33872c1b22ffd9340e77410c693083" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::int32_t</type>
        <definition>static std::int32_t gmx::blend</definition>
        <argsstring>(std::int32_t a, std::int32_t b, float sel)</argsstring>
        <name>blend</name>
        <param>
          <type>std::int32_t</type>
          <declname>a</declname>
        </param>
        <param>
          <type>std::int32_t</type>
          <declname>b</declname>
        </param>
        <param>
          <type>float</type>
          <declname>sel</declname>
        </param>
        <briefdescription>
<para>Blend integer selection. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>First source </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Second source </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sel</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Select b if sel is true, a otherwise.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="1012" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="1012" bodyend="1015"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a27254f29caa9fd12a6e774bf7a13502c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool gmx::cvtB2IB</definition>
        <argsstring>(bool a)</argsstring>
        <name>cvtB2IB</name>
        <param>
          <type>bool</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Just return a boolean (mimicks SIMD real-to-int bool conversions) </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>boolean </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>same boolean</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="1027" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="1027" bodyend="1030"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a2a600fa6a48b5df753c2fcc99c47f3f3" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool gmx::cvtIB2B</definition>
        <argsstring>(bool a)</argsstring>
        <name>cvtIB2B</name>
        <param>
          <type>bool</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Just return a boolean (mimicks SIMD int-to-real bool conversions) </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>boolean </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>same boolean</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" line="1042" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar.h" bodystart="1042" bodyend="1045"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a8ef5f6af06e493a4ae2d47109ee0e723" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::copysign</definition>
        <argsstring>(float x, float y)</argsstring>
        <name>copysign</name>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <param>
          <type>float</type>
          <declname>y</declname>
        </param>
        <briefdescription>
<para>Composes single value with the magnitude of x and the sign of y. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to set sign for </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>Value used to set sign </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Magnitude of x, sign of y</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="77" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="77" bodyend="80"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aba2ac92d9abba8296506e281dc66c47a" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void gmx::invsqrtPair</definition>
        <argsstring>(float x0, float x1, float *out0, float *out1)</argsstring>
        <name>invsqrtPair</name>
        <param>
          <type>float</type>
          <declname>x0</declname>
        </param>
        <param>
          <type>float</type>
          <declname>x1</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>out0</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>out1</declname>
        </param>
        <briefdescription>
<para>Calculate 1/sqrt(x) for two floats. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x0</parametername>
</parameternamelist>
<parameterdescription>
<para>First argument, x0 must be positive - no argument checking. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x1</parametername>
</parameternamelist>
<parameterdescription>
<para>Second argument, x1 must be positive - no argument checking. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out0</parametername>
</parameternamelist>
<parameterdescription>
<para>Result 1/sqrt(x0) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out1</parametername>
</parameternamelist>
<parameterdescription>
<para>Result 1/sqrt(x1)</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="96" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="96" bodyend="101"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a6cd74be08263227a2b2f4405dee6a359" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::inv</definition>
        <argsstring>(float x)</argsstring>
        <name>inv</name>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate 1/x for float. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be nonzero. This routine does not check arguments. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/x. Result is undefined if your argument was invalid.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="113" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="113" bodyend="116"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aa182f9ceead92b3055e6ae5903994651" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::maskzInvsqrt</definition>
        <argsstring>(float x, bool m)</argsstring>
        <name>maskzInvsqrt</name>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Calculate 1/sqrt(x) for masked entry of float. </para>        </briefdescription>
        <detaileddescription>
<para>This routine only evaluates 1/sqrt(x) if mask is true. Illegal values for a masked-out float will not lead to floating-point exceptions.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be &gt;0 if masked-in. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/sqrt(x). Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="134" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="134" bodyend="137"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a582d71ff8e7d51cbd2386e29935e89ef" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::maskzInv</definition>
        <argsstring>(float x, bool m)</argsstring>
        <name>maskzInv</name>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Calculate 1/x for masked entry of float. </para>        </briefdescription>
        <detaileddescription>
<para>This routine only evaluates 1/x if mask is true. Illegal values for a masked-out float will not lead to floating-point exceptions.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be nonzero if masked-in. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/x. Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="155" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="155" bodyend="158"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a7b0a25f25b649f59d96b67f2d73c8ad8" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::log</definition>
        <argsstring>(float x)</argsstring>
        <name>log</name>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Float log(x). This is the natural logarithm. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument, should be &gt;0. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The natural logarithm of x. Undefined if argument is invalid.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="172" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="172" bodyend="175"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aed7303338070cf13c11a8b765017a182" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::exp2</definition>
        <argsstring>(float x)</argsstring>
        <name>exp2</name>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Float 2^x. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>2^x. Undefined if input argument caused overflow.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="187" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="187" bodyend="190"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a8b3a53c1076c47dbbef4e6ec2d3191ce" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::exp</definition>
        <argsstring>(float x)</argsstring>
        <name>exp</name>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Float exp(x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>exp(x). Undefined if input argument caused overflow.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="202" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="202" bodyend="205"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a9a81ecdda73e384cd4e6896492144529" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::erf</definition>
        <argsstring>(float x)</argsstring>
        <name>erf</name>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Float erf(x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>erf(x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="217" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="217" bodyend="220"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aad005ed4133f5a01702c63a9440feab7" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::erfc</definition>
        <argsstring>(float x)</argsstring>
        <name>erfc</name>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Float erfc(x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>erfc(x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="232" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="232" bodyend="235"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a3191310c1a122aafe946f0caf2fdf364" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void gmx::sincos</definition>
        <argsstring>(float x, float *sinval, float *cosval)</argsstring>
        <name>sincos</name>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>sinval</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>cosval</declname>
        </param>
        <briefdescription>
<para>Float sin &amp; cos. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate sin/cos for </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">sinval</parametername>
</parameternamelist>
<parameterdescription>
<para>Sin(x) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">cosval</parametername>
</parameternamelist>
<parameterdescription>
<para>Cos(x)</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="249" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="249" bodyend="253"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1af85c54a566c85f916aaa2561d12fa851" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::sin</definition>
        <argsstring>(float x)</argsstring>
        <name>sin</name>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Float sin. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate sin for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Sin(x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="265" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="265" bodyend="268"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a16c6356a58f3d2c2fe6d2f50afc0c686" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::cos</definition>
        <argsstring>(float x)</argsstring>
        <name>cos</name>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Float cos. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate cos for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Cos(x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="280" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="280" bodyend="283"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a7063173231453ec737688c8d91aa0749" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::tan</definition>
        <argsstring>(float x)</argsstring>
        <name>tan</name>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Float tan. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate tan for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Tan(x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="295" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="295" bodyend="298"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a3d5120df9c0bf437e64c806a7cfdad02" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::asin</definition>
        <argsstring>(float x)</argsstring>
        <name>asin</name>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>float asin. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate asin for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Asin(x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="310" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="310" bodyend="313"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ab102173c68c06e7a340e4eebbf6c3492" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::acos</definition>
        <argsstring>(float x)</argsstring>
        <name>acos</name>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Float acos. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate acos for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Acos(x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="325" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="325" bodyend="328"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a1afbc2ada56f899a8d3dc5c61530e28b" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::atan</definition>
        <argsstring>(float x)</argsstring>
        <name>atan</name>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Float atan. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate atan for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Atan(x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="340" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="340" bodyend="343"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aed8336a58abddcdb6afa7835138ecf46" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::atan2</definition>
        <argsstring>(float y, float x)</argsstring>
        <name>atan2</name>
        <param>
          <type>float</type>
          <declname>y</declname>
        </param>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Float atan2(y,x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>Y component of vector, any quartile </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>X component of vector, any quartile </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Atan(y,x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="356" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="356" bodyend="359"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a1e5b1230d0301fa6760e34d7641ca7e4" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::pmeForceCorrection</definition>
        <argsstring>(float z2)</argsstring>
        <name>pmeForceCorrection</name>
        <param>
          <type>float</type>
          <declname>z2</declname>
        </param>
        <briefdescription>
<para>Calculate the force correction due to PME analytically in float. </para>        </briefdescription>
        <detaileddescription>
<para>See the SIMD version of this function for details.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>z2</parametername>
</parameternamelist>
<parameterdescription>
<para>input parameter </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Correction to use on force</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="373" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="373" bodyend="407"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ac54e81f11cb53c7d68ff7dab05bd6afd" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::pmePotentialCorrection</definition>
        <argsstring>(float z2)</argsstring>
        <name>pmePotentialCorrection</name>
        <param>
          <type>float</type>
          <declname>z2</declname>
        </param>
        <briefdescription>
<para>Calculate the potential correction due to PME analytically in float. </para>        </briefdescription>
        <detaileddescription>
<para>See the SIMD version of this function for details.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>z2</parametername>
</parameternamelist>
<parameterdescription>
<para>input parameter </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Correction to use on potential.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="421" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="421" bodyend="453"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1af6cfb56189c360e005911247ebf5fd42" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::copysign</definition>
        <argsstring>(double x, double y)</argsstring>
        <name>copysign</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <param>
          <type>double</type>
          <declname>y</declname>
        </param>
        <briefdescription>
<para>Composes double value with the magnitude of x and the sign of y. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to set sign for </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>Value used to set sign </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Magnitude of x, sign of y</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="471" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="471" bodyend="474"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1abb50fcc000a2c2d4b8446fc17a5695e0" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void gmx::invsqrtPair</definition>
        <argsstring>(double x0, double x1, double *out0, double *out1)</argsstring>
        <name>invsqrtPair</name>
        <param>
          <type>double</type>
          <declname>x0</declname>
        </param>
        <param>
          <type>double</type>
          <declname>x1</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>out0</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>out1</declname>
        </param>
        <briefdescription>
<para>Calculate 1/sqrt(x) for two doubles. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x0</parametername>
</parameternamelist>
<parameterdescription>
<para>First argument, x0 must be positive - no argument checking. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x1</parametername>
</parameternamelist>
<parameterdescription>
<para>Second argument, x1 must be positive - no argument checking. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out0</parametername>
</parameternamelist>
<parameterdescription>
<para>Result 1/sqrt(x0) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out1</parametername>
</parameternamelist>
<parameterdescription>
<para>Result 1/sqrt(x1)</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="490" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="490" bodyend="495"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a8ed9172c60ed326ca31f64a490fabe17" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::inv</definition>
        <argsstring>(double x)</argsstring>
        <name>inv</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate 1/x for double. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be nonzero. This routine does not check arguments. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/x. Result is undefined if your argument was invalid.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="507" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="507" bodyend="510"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aa5b5a9766964a2b854f493fd783bb63d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::maskzInvsqrt</definition>
        <argsstring>(double x, bool m)</argsstring>
        <name>maskzInvsqrt</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Calculate 1/sqrt(x) for masked entry of double. </para>        </briefdescription>
        <detaileddescription>
<para>This routine only evaluates 1/sqrt(x) if mask is true. Illegal values for a masked-out double will not lead to floating-point exceptions.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be &gt;0 if masked-in. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/sqrt(x). Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="528" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="528" bodyend="531"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1af5cc89f64ab845f88816a9cbb16d467c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::maskzInv</definition>
        <argsstring>(double x, bool m)</argsstring>
        <name>maskzInv</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Calculate 1/x for masked entry of double. </para>        </briefdescription>
        <detaileddescription>
<para>This routine only evaluates 1/x if mask is true. Illegal values for a masked-out double will not lead to floating-point exceptions.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be nonzero if masked-in. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/x. Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="549" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="549" bodyend="552"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a398a52e25652367446f9180a50343885" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::log</definition>
        <argsstring>(double x)</argsstring>
        <name>log</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Double log(x). This is the natural logarithm. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument, should be &gt;0. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The natural logarithm of x. Undefined if argument is invalid.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="566" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="566" bodyend="569"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a8793845dd7a03f8e3d00bde1b04a2785" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::exp2</definition>
        <argsstring>(double x)</argsstring>
        <name>exp2</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Double 2^x. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>2^x. Undefined if input argument caused overflow.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="581" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="581" bodyend="584"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a2ed21bd309bf862089f430402b8fd8b9" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::exp</definition>
        <argsstring>(double x)</argsstring>
        <name>exp</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Double exp(x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>exp(x). Undefined if input argument caused overflow.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="596" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="596" bodyend="599"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a6a3fe934a0b6419312a82b6bb6b8b6ff" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::erf</definition>
        <argsstring>(double x)</argsstring>
        <name>erf</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Double erf(x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>erf(x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="611" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="611" bodyend="614"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a56c071a6a14720e2b94e4b034e110614" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::erfc</definition>
        <argsstring>(double x)</argsstring>
        <name>erfc</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Double erfc(x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>erfc(x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="626" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="626" bodyend="629"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a0a5923534ff59a386ae0579eb4196b1e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void gmx::sincos</definition>
        <argsstring>(double x, double *sinval, double *cosval)</argsstring>
        <name>sincos</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>sinval</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>cosval</declname>
        </param>
        <briefdescription>
<para>Double sin &amp; cos. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate sin/cos for </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">sinval</parametername>
</parameternamelist>
<parameterdescription>
<para>Sin(x) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">cosval</parametername>
</parameternamelist>
<parameterdescription>
<para>Cos(x)</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="643" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="643" bodyend="647"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a6579216abaac018cb0bc59e9183f99ba" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::sin</definition>
        <argsstring>(double x)</argsstring>
        <name>sin</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Double sin. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate sin for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Sin(x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="659" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="659" bodyend="662"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aeda573e9aa3efa5d223c9fe39f682cfd" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::cos</definition>
        <argsstring>(double x)</argsstring>
        <name>cos</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Double cos. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate cos for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Cos(x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="674" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="674" bodyend="677"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a45e727a4960ac7f8ba5149f9b251c520" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::tan</definition>
        <argsstring>(double x)</argsstring>
        <name>tan</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Double tan. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate tan for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Tan(x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="689" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="689" bodyend="692"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ab02c7d47595f11074fbfedff40145544" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::asin</definition>
        <argsstring>(double x)</argsstring>
        <name>asin</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Double asin. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate asin for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Asin(x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="704" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="704" bodyend="707"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a5b534003a0dba716c08d6053e0514311" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::acos</definition>
        <argsstring>(double x)</argsstring>
        <name>acos</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Double acos. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate acos for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Acos(x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="719" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="719" bodyend="722"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1af15e6f3962e035d69013bd91621fd9f8" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::atan</definition>
        <argsstring>(double x)</argsstring>
        <name>atan</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Double atan. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate atan for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Atan(x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="734" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="734" bodyend="737"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aa70a1aa5e9c161a2770d0f9b7eca1805" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::atan2</definition>
        <argsstring>(double y, double x)</argsstring>
        <name>atan2</name>
        <param>
          <type>double</type>
          <declname>y</declname>
        </param>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Double atan2(y,x). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>Y component of vector, any quartile </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>X component of vector, any quartile </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Atan(y,x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="750" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="750" bodyend="753"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a5275f264f1c6da2502ec03e8fbf855a4" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::pmeForceCorrection</definition>
        <argsstring>(double z2)</argsstring>
        <name>pmeForceCorrection</name>
        <param>
          <type>double</type>
          <declname>z2</declname>
        </param>
        <briefdescription>
<para>Calculate the force correction due to PME analytically in double. </para>        </briefdescription>
        <detaileddescription>
<para>See the SIMD version of this function for details.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>z2</parametername>
</parameternamelist>
<parameterdescription>
<para>input parameter </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Correction to use on force</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="767" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="767" bodyend="814"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1acba0166c05fec69dd4a2624ed8dcff95" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::pmePotentialCorrection</definition>
        <argsstring>(double z2)</argsstring>
        <name>pmePotentialCorrection</name>
        <param>
          <type>double</type>
          <declname>z2</declname>
        </param>
        <briefdescription>
<para>Calculate the potential correction due to PME analytically in double. </para>        </briefdescription>
        <detaileddescription>
<para>See the SIMD version of this function for details.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>z2</parametername>
</parameternamelist>
<parameterdescription>
<para>input parameter </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Correction to use on potential.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="828" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="828" bodyend="872"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a44adc739c8fb319abe1b6769f39e9341" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::invsqrtSingleAccuracy</definition>
        <argsstring>(double x)</argsstring>
        <name>invsqrtSingleAccuracy</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate 1/sqrt(x) for double, but with single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be &gt;0. This routine does not check arguments. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/sqrt(x). Result is undefined if your argument was invalid.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="891" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="891" bodyend="894"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a18f2d71567d1b88689c8498f3592b386" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void gmx::invsqrtPairSingleAccuracy</definition>
        <argsstring>(double x0, double x1, double *out0, double *out1)</argsstring>
        <name>invsqrtPairSingleAccuracy</name>
        <param>
          <type>double</type>
          <declname>x0</declname>
        </param>
        <param>
          <type>double</type>
          <declname>x1</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>out0</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>out1</declname>
        </param>
        <briefdescription>
<para>Calculate 1/sqrt(x) for two doubles, but with single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x0</parametername>
</parameternamelist>
<parameterdescription>
<para>First argument, x0 must be positive - no argument checking. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x1</parametername>
</parameternamelist>
<parameterdescription>
<para>Second argument, x1 must be positive - no argument checking. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out0</parametername>
</parameternamelist>
<parameterdescription>
<para>Result 1/sqrt(x0) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out1</parametername>
</parameternamelist>
<parameterdescription>
<para>Result 1/sqrt(x1)</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="908" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="908" bodyend="913"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a8ac51c492a5589e075b7b8ebda5a8cbd" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::invSingleAccuracy</definition>
        <argsstring>(double x)</argsstring>
        <name>invSingleAccuracy</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate 1/x for double, but with single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be nonzero. This routine does not check arguments. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/x. Result is undefined if your argument was invalid.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="925" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="925" bodyend="928"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a1fdaf91102db0bfbc6fd440524b15199" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::maskzInvsqrtSingleAccuracy</definition>
        <argsstring>(double x, bool m)</argsstring>
        <name>maskzInvsqrtSingleAccuracy</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Calculate 1/sqrt(x) for masked entry of double, but with single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para>This routine only evaluates 1/sqrt(x) if mask is true. Illegal values for a masked-out double will not lead to floating-point exceptions.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be &gt;0 if masked-in. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/sqrt(x). Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="946" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="946" bodyend="949"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a2433c82892495a73bf41de15f5e8908f" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::maskzInvSingleAccuracy</definition>
        <argsstring>(double x, bool m)</argsstring>
        <name>maskzInvSingleAccuracy</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Calculate 1/x for masked entry of double, but with single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para>This routine only evaluates 1/x if mask is true. Illegal values for a masked-out double will not lead to floating-point exceptions.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be nonzero if masked-in. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/x. Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="967" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="967" bodyend="970"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a2d6d95fd83052d09775c976a961eee29" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::sqrtSingleAccuracy</definition>
        <argsstring>(double x)</argsstring>
        <name>sqrtSingleAccuracy</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate sqrt(x) for double, but with single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be &gt;=0. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>sqrt(x).</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="982" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="982" bodyend="985"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a54c2c975d7e597b08a67d85920d4f562" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::logSingleAccuracy</definition>
        <argsstring>(double x)</argsstring>
        <name>logSingleAccuracy</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Double log(x), but with single accuracy. This is the natural logarithm. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument, should be &gt;0. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The natural logarithm of x. Undefined if argument is invalid.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="997" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="997" bodyend="1000"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a119f14f4a364f71eb9273b5dd8c927cd" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::exp2SingleAccuracy</definition>
        <argsstring>(double x)</argsstring>
        <name>exp2SingleAccuracy</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Double 2^x, but with single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>2^x. Undefined if input argument caused overflow.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="1012" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="1012" bodyend="1015"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1afa6d2866bd8be11dce227ad0e26511a4" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::expSingleAccuracy</definition>
        <argsstring>(double x)</argsstring>
        <name>expSingleAccuracy</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Double exp(x), but with single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>exp(x). Undefined if input argument caused overflow.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="1027" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="1027" bodyend="1030"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a2491a7f4b92881d4887491a532e8e5f7" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::erfSingleAccuracy</definition>
        <argsstring>(double x)</argsstring>
        <name>erfSingleAccuracy</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Double erf(x), but with single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>erf(x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="1042" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="1042" bodyend="1045"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a56d277c19df61f3b0176da88ba40b53a" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::erfcSingleAccuracy</definition>
        <argsstring>(double x)</argsstring>
        <name>erfcSingleAccuracy</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Double erfc(x), but with single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>erfc(x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="1057" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="1057" bodyend="1060"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a200455e2d7401d66cac8e39b4c8142bf" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void gmx::sincosSingleAccuracy</definition>
        <argsstring>(double x, double *sinval, double *cosval)</argsstring>
        <name>sincosSingleAccuracy</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>sinval</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>cosval</declname>
        </param>
        <briefdescription>
<para>Double sin &amp; cos, but with single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate sin/cos for </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">sinval</parametername>
</parameternamelist>
<parameterdescription>
<para>Sin(x) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">cosval</parametername>
</parameternamelist>
<parameterdescription>
<para>Cos(x)</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="1074" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="1074" bodyend="1080"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a810c7b2f5d8f267f421f2c59a308c11d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::sinSingleAccuracy</definition>
        <argsstring>(double x)</argsstring>
        <name>sinSingleAccuracy</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Double sin, but with single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate sin for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Sin(x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="1092" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="1092" bodyend="1095"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a2e717707cf40d6bbacf8752cf28de422" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::cosSingleAccuracy</definition>
        <argsstring>(double x)</argsstring>
        <name>cosSingleAccuracy</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Double cos, but with single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate cos for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Cos(x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="1107" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="1107" bodyend="1110"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a0f979f3defa4f725cfce2d7e93fc0d9e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::tanSingleAccuracy</definition>
        <argsstring>(double x)</argsstring>
        <name>tanSingleAccuracy</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Double tan, but with single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate tan for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Tan(x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="1122" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="1122" bodyend="1125"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a98465e562d7b1b24755bc693db04c8f5" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::asinSingleAccuracy</definition>
        <argsstring>(double x)</argsstring>
        <name>asinSingleAccuracy</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Double asin, but with single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate asin for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Asin(x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="1137" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="1137" bodyend="1140"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a72f487fc13f5bd1b83417f108a74f5a0" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::acosSingleAccuracy</definition>
        <argsstring>(double x)</argsstring>
        <name>acosSingleAccuracy</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Double acos, but with single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate acos for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Acos(x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="1152" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="1152" bodyend="1155"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a44ca54cb014d2f33b98f3d523d90a2f5" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::atanSingleAccuracy</definition>
        <argsstring>(double x)</argsstring>
        <name>atanSingleAccuracy</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Double atan, but with single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate atan for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Atan(x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="1167" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="1167" bodyend="1170"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a2552094c1be29e087e1e85ae02fb0c7a" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::atan2SingleAccuracy</definition>
        <argsstring>(double y, double x)</argsstring>
        <name>atan2SingleAccuracy</name>
        <param>
          <type>double</type>
          <declname>y</declname>
        </param>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Double atan2(y,x), but with single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>Y component of vector, any quartile </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>X component of vector, any quartile </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Atan(y,x)</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="1183" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="1183" bodyend="1186"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1abd18f07b8fd19f03f12442211982db53" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::pmeForceCorrectionSingleAccuracy</definition>
        <argsstring>(double z2)</argsstring>
        <name>pmeForceCorrectionSingleAccuracy</name>
        <param>
          <type>double</type>
          <declname>z2</declname>
        </param>
        <briefdescription>
<para>Force correction due to PME in double, but with single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para>See the SIMD version of this function for details.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>z2</parametername>
</parameternamelist>
<parameterdescription>
<para>input parameter </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Correction to use on force</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="1200" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="1200" bodyend="1236"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ab8004b2507f7192ead653fcdcb6735fe" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>static double gmx::pmePotentialCorrectionSingleAccuracy</definition>
        <argsstring>(double z2)</argsstring>
        <name>pmePotentialCorrectionSingleAccuracy</name>
        <param>
          <type>double</type>
          <declname>z2</declname>
        </param>
        <briefdescription>
<para>Potential correction due to PME in double, but with single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para>See the SIMD version of this function for details.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>z2</parametername>
</parameternamelist>
<parameterdescription>
<para>input parameter </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Correction to use on potential.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" line="1250" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_math.h" bodystart="1250" bodyend="1284"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aba7ff3639534a22d4b9c7a834d7584fd" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>static void gmx::gatherLoadTranspose</definition>
        <argsstring>(const float *base, const std::int32_t offset[], float *v0, float *v1, float *v2, float *v3)</argsstring>
        <name>gatherLoadTranspose</name>
        <param>
          <type>const float *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>const std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type>float *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>v2</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>v3</declname>
        </param>
        <briefdescription>
<para>Load 4 consecutive floats from base/offset into four variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory from which we read. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the memory area </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Index to data. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st float, base[align*offset[0]]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd float, base[align*offset[0] + 1]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v2</parametername>
</parameternamelist>
<parameterdescription>
<para>3rd float, base[align*offset[0] + 2]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v3</parametername>
</parameternamelist>
<parameterdescription>
<para>4th float, base[align*offset[0] + 3].</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" line="78" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" bodystart="78" bodyend="89"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a4c0cda66eba19ad12a50e48f848f268f" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>static void gmx::gatherLoadTranspose</definition>
        <argsstring>(const float *base, const std::int32_t offset[], float *v0, float *v1)</argsstring>
        <name>gatherLoadTranspose</name>
        <param>
          <type>const float *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>const std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type>float *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Load 2 consecutive floats from base/offset into four variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory from which we read. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the memory area </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Index to data. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st float, base[align*offset[0]]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd float, base[align*offset[0] + 1].</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" line="105" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" bodystart="105" bodyend="112"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1acfefc291c66a8404f2aad767af91cb21" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>static void gmx::gatherLoadUTranspose</definition>
        <argsstring>(const float *base, const std::int32_t offset[], float *v0, float *v1, float *v2)</argsstring>
        <name>gatherLoadUTranspose</name>
        <param>
          <type>const float *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>const std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type>float *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Load 3 consecutive floats from base/offsets, store into three vars. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the memory area </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Offset to the start of data. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st value, base[align*offset[0]]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd value, base[align*offset[0] + 1]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v2</parametername>
</parameternamelist>
<parameterdescription>
<para>3rd value, base[align*offset[0] + 2].</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" line="131" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" bodystart="131" bodyend="140"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a65d8dd5e7a4ade4e3750b48e2a95b308" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>static void gmx::transposeScatterStoreU</definition>
        <argsstring>(float *base, const std::int32_t offset[], float v0, float v1, float v2)</argsstring>
        <name>transposeScatterStoreU</name>
        <param>
          <type>float *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>const std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type>float</type>
          <declname>v0</declname>
        </param>
        <param>
          <type>float</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>float</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Store 3 floats to 3 to base/offset. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the memory area </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Offset to the start of triplet. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st value, written to base[align*offset[0]]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd value, written to base[align*offset[0] + 1]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>3rd value, written to base[align*offset[0] + 2].</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" line="158" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" bodystart="158" bodyend="167"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a12069a0402115678c9c39b303585917d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>static void gmx::transposeScatterIncrU</definition>
        <argsstring>(float *base, const std::int32_t offset[], float v0, float v1, float v2)</argsstring>
        <name>transposeScatterIncrU</name>
        <param>
          <type>float *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>const std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type>float</type>
          <declname>v0</declname>
        </param>
        <param>
          <type>float</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>float</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Add 3 floats to base/offset. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the memory area </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Offset to the start of triplet. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st value, added to base[align*offset[0]]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd value, added to base[align*offset[0] + 1]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>3rd value, added to base[align*offset[0] + 2].</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" line="185" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" bodystart="185" bodyend="194"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1af7e302c7dcfb8d4937c4388d77057435" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>static void gmx::transposeScatterDecrU</definition>
        <argsstring>(float *base, const std::int32_t offset[], float v0, float v1, float v2)</argsstring>
        <name>transposeScatterDecrU</name>
        <param>
          <type>float *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>const std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type>float</type>
          <declname>v0</declname>
        </param>
        <param>
          <type>float</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>float</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Subtract 3 floats from base/offset. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the memory area </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Offset to the start of triplet. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st value, subtracted from base[align*offset[0]]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd value, subtracted from base[align*offset[0] + 1]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>3rd value, subtracted from base[align*offset[0] + 2].</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" line="212" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" bodystart="212" bodyend="221"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a6b19d8b9f07e36c8152b30d4b3caaad6" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void gmx::expandScalarsToTriplets</definition>
        <argsstring>(float scalar, float *triplets0, float *triplets1, float *triplets2)</argsstring>
        <name>expandScalarsToTriplets</name>
        <param>
          <type>float</type>
          <declname>scalar</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>triplets0</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>triplets1</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>triplets2</declname>
        </param>
        <briefdescription>
<para>Copy single float to three variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>scalar</parametername>
</parameternamelist>
<parameterdescription>
<para>Floating-point input. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">triplets0</parametername>
</parameternamelist>
<parameterdescription>
<para>Copy 1. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">triplets1</parametername>
</parameternamelist>
<parameterdescription>
<para>Copy 2. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">triplets2</parametername>
</parameternamelist>
<parameterdescription>
<para>Copy 3.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" line="235" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" bodystart="235" bodyend="243"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a179f05bc9899fe2b7e71d53a1a95b629" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>static void gmx::gatherLoadBySimdIntTranspose</definition>
        <argsstring>(const float *base, std::int32_t offset, float *v0, float *v1, float *v2, float *v3)</argsstring>
        <name>gatherLoadBySimdIntTranspose</name>
        <param>
          <type>const float *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>std::int32_t</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>v2</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>v3</declname>
        </param>
        <briefdescription>
<para>Load 4 floats from base/offsets and store into variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>Aligned pointer to the start of the memory. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Integer type with offset to the start of each triplet. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>First float, base[align*offset[0]]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>Second float, base[align*offset[0] + 1]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v2</parametername>
</parameternamelist>
<parameterdescription>
<para>Third float, base[align*offset[0] + 2]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v3</parametername>
</parameternamelist>
<parameterdescription>
<para>Fourth float, base[align*offset[0] + 3].</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" line="262" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" bodystart="262" bodyend="273"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a29c67b43b26cfba5ec360bf020df4c8a" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>static void gmx::gatherLoadUBySimdIntTranspose</definition>
        <argsstring>(const float *base, std::int32_t offset, float *v0, float *v1)</argsstring>
        <name>gatherLoadUBySimdIntTranspose</name>
        <param>
          <type>const float *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>std::int32_t</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Load 2 floats from base/offsets and store into variables (unaligned). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>Aligned pointer to the start of the memory. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Integer type with offset to the start of each triplet. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>First float, base[align*offset[0]]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>Second float, base[align*offset[0] + 1].</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" line="290" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" bodystart="290" bodyend="297"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a0614e0463cccdf97cec36fffb2b24764" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>static void gmx::gatherLoadBySimdIntTranspose</definition>
        <argsstring>(const float *base, std::int32_t offset, float *v0, float *v1)</argsstring>
        <name>gatherLoadBySimdIntTranspose</name>
        <param>
          <type>const float *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>std::int32_t</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Load 2 floats from base/offsets and store into variables (aligned). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>Aligned pointer to the start of the memory. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Integer type with offset to the start of each triplet. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>First float, base[align*offset[0]]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>Second float, base[align*offset[0] + 1].</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" line="314" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" bodystart="314" bodyend="321"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a6eac2eb3581affdefb5b3e79e000cf84" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::reduceIncr4ReturnSum</definition>
        <argsstring>(float *m, float v0, float v1, float v2, float v3)</argsstring>
        <name>reduceIncr4ReturnSum</name>
        <param>
          <type>float *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>float</type>
          <declname>v0</declname>
        </param>
        <param>
          <type>float</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>float</type>
          <declname>v2</declname>
        </param>
        <param>
          <type>float</type>
          <declname>v3</declname>
        </param>
        <briefdescription>
<para>Add each float to four consecutive memory locations, return sum. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory where four floats should be incremented </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v0</parametername>
</parameternamelist>
<parameterdescription>
<para>float to be added to m[0] </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>float to be added to m[1] </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>float to be added to m[2] </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v3</parametername>
</parameternamelist>
<parameterdescription>
<para>float to be added to m[3]</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>v0+v1+v2+v3.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" line="338" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" bodystart="338" bodyend="350"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a94e990607fd4d48ca160fbc380597f5a" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>static void gmx::gatherLoadTranspose</definition>
        <argsstring>(const double *base, const std::int32_t offset[], double *v0, double *v1, double *v2, double *v3)</argsstring>
        <name>gatherLoadTranspose</name>
        <param>
          <type>const double *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>const std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type>double *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>v2</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>v3</declname>
        </param>
        <briefdescription>
<para>Load 4 consecutive doubles from base/offset into four variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory from which we read. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the memory area </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Index to data. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st double, base[align*offset[0]]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd double, base[align*offset[0] + 1]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v2</parametername>
</parameternamelist>
<parameterdescription>
<para>3rd double, base[align*offset[0] + 2]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v3</parametername>
</parameternamelist>
<parameterdescription>
<para>4th double, base[align*offset[0] + 3].</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" line="373" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" bodystart="373" bodyend="384"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a0c464ebd492587005bb4baefb4293072" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>static void gmx::gatherLoadTranspose</definition>
        <argsstring>(const double *base, const std::int32_t offset[], double *v0, double *v1)</argsstring>
        <name>gatherLoadTranspose</name>
        <param>
          <type>const double *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>const std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type>double *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Load 2 consecutive doubles from base/offset into four variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory from which we read. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the memory area </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Index to data. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st double, base[align*offset[0]]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd double, base[align*offset[0] + 1].</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" line="400" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" bodystart="400" bodyend="407"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a0502844193d9fcf13648a4165a67a1a3" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>static void gmx::gatherLoadUTranspose</definition>
        <argsstring>(const double *base, const std::int32_t offset[], double *v0, double *v1, double *v2)</argsstring>
        <name>gatherLoadUTranspose</name>
        <param>
          <type>const double *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>const std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type>double *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Load 3 consecutive doubles from base/offsets, store into three vars. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the memory area </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Offset to the start of data. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st double, base[align*offset[0]]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd double, base[align*offset[0] + 1]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v2</parametername>
</parameternamelist>
<parameterdescription>
<para>3rd double, base[align*offset[0] + 2].</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" line="426" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" bodystart="426" bodyend="435"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ab5d74c633ff138def6fa648441c5decf" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>static void gmx::transposeScatterStoreU</definition>
        <argsstring>(double *base, const std::int32_t offset[], double v0, double v1, double v2)</argsstring>
        <name>transposeScatterStoreU</name>
        <param>
          <type>double *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>const std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type>double</type>
          <declname>v0</declname>
        </param>
        <param>
          <type>double</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>double</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Store 3 doubles to 3 to base/offset. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the memory area </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Offset to the start of triplet. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st value, written to base[align*offset[0]]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd value, written to base[align*offset[0] + 1]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>3rd value, written to base[align*offset[0] + 2].</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" line="453" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" bodystart="453" bodyend="462"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a83e3f241eaafa47cfa9258ec9efec8d0" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>static void gmx::transposeScatterIncrU</definition>
        <argsstring>(double *base, const std::int32_t offset[], double v0, double v1, double v2)</argsstring>
        <name>transposeScatterIncrU</name>
        <param>
          <type>double *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>const std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type>double</type>
          <declname>v0</declname>
        </param>
        <param>
          <type>double</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>double</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Add 3 doubles to base/offset. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the memory area </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Offset to the start of triplet. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st value, added to base[align*offset[0]]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd value, added to base[align*offset[0] + 1]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>3rd value, added to base[align*offset[0] + 2].</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" line="480" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" bodystart="480" bodyend="489"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a812731a42d1358e6a06f81848a67eeb7" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>static void gmx::transposeScatterDecrU</definition>
        <argsstring>(double *base, const std::int32_t offset[], double v0, double v1, double v2)</argsstring>
        <name>transposeScatterDecrU</name>
        <param>
          <type>double *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>const std::int32_t</type>
          <declname>offset</declname>
          <array>[]</array>
        </param>
        <param>
          <type>double</type>
          <declname>v0</declname>
        </param>
        <param>
          <type>double</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>double</type>
          <declname>v2</declname>
        </param>
        <briefdescription>
<para>Subtract 3 doubles from base/offset. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">base</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the memory area </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Offset to the start of triplet. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v0</parametername>
</parameternamelist>
<parameterdescription>
<para>1st value, subtracted from base[align*offset[0]]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd value, subtracted from base[align*offset[0] + 1]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>3rd value, subtracted from base[align*offset[0] + 2].</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" line="507" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" bodystart="507" bodyend="516"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1af8a2ae7f742d7612f2808bfd39b0f975" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void gmx::expandScalarsToTriplets</definition>
        <argsstring>(double scalar, double *triplets0, double *triplets1, double *triplets2)</argsstring>
        <name>expandScalarsToTriplets</name>
        <param>
          <type>double</type>
          <declname>scalar</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>triplets0</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>triplets1</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>triplets2</declname>
        </param>
        <briefdescription>
<para>Copy single double to three variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>scalar</parametername>
</parameternamelist>
<parameterdescription>
<para>Floating-point input. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">triplets0</parametername>
</parameternamelist>
<parameterdescription>
<para>Copy 1. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">triplets1</parametername>
</parameternamelist>
<parameterdescription>
<para>Copy 2. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">triplets2</parametername>
</parameternamelist>
<parameterdescription>
<para>Copy 3.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" line="530" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" bodystart="530" bodyend="538"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a92c67d959864d2549a679f0f2245bacb" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>static void gmx::gatherLoadBySimdIntTranspose</definition>
        <argsstring>(const double *base, std::int32_t offset, double *v0, double *v1, double *v2, double *v3)</argsstring>
        <name>gatherLoadBySimdIntTranspose</name>
        <param>
          <type>const double *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>std::int32_t</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>v2</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>v3</declname>
        </param>
        <briefdescription>
<para>Load 4 doubles from base/offsets and store into variables. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>Aligned pointer to the start of the memory. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Integer type with offset to the start of each triplet. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>First double, base[align*offset[0]]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>Second double, base[align*offset[0] + 1]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v2</parametername>
</parameternamelist>
<parameterdescription>
<para>Third double, base[align*offset[0] + 2]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v3</parametername>
</parameternamelist>
<parameterdescription>
<para>Fourth double, base[align*offset[0] + 3].</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" line="557" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" bodystart="557" bodyend="568"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1af74c58ce1915c6a25061153cd3b4bde8" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>static void gmx::gatherLoadUBySimdIntTranspose</definition>
        <argsstring>(const double *base, std::int32_t offset, double *v0, double *v1)</argsstring>
        <name>gatherLoadUBySimdIntTranspose</name>
        <param>
          <type>const double *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>std::int32_t</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Load 2 doubles from base/offsets and store into variables (unaligned). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>Aligned pointer to the start of the memory. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Integer type with offset to the start of each triplet. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>First double, base[align*offset[0]]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>Second double, base[align*offset[0] + 1].</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" line="585" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" bodystart="585" bodyend="592"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a6bb92443ba8da5d878c1dd85b2bcde8d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>align</declname>
            <defname>align</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>static void gmx::gatherLoadBySimdIntTranspose</definition>
        <argsstring>(const double *base, std::int32_t offset, double *v0, double *v1)</argsstring>
        <name>gatherLoadBySimdIntTranspose</name>
        <param>
          <type>const double *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>std::int32_t</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>v0</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>v1</declname>
        </param>
        <briefdescription>
<para>Load 2 doubles from base/offsets and store into variables (aligned). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>Aligned pointer to the start of the memory. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>Integer type with offset to the start of each triplet. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v0</parametername>
</parameternamelist>
<parameterdescription>
<para>First double, base[align*offset[0]]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">v1</parametername>
</parameternamelist>
<parameterdescription>
<para>Second double, base[align*offset[0] + 1].</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" line="609" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" bodystart="609" bodyend="616"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ad7989807401d15a5d7b360b91a7dbe04" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>static float gmx::reduceIncr4ReturnSum</definition>
        <argsstring>(double *m, double v0, double v1, double v2, double v3)</argsstring>
        <name>reduceIncr4ReturnSum</name>
        <param>
          <type>double *</type>
          <declname>m</declname>
        </param>
        <param>
          <type>double</type>
          <declname>v0</declname>
        </param>
        <param>
          <type>double</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>double</type>
          <declname>v2</declname>
        </param>
        <param>
          <type>double</type>
          <declname>v3</declname>
        </param>
        <briefdescription>
<para>Add each double to four consecutive memory locations, return sum. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory where four floats should be incremented </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v0</parametername>
</parameternamelist>
<parameterdescription>
<para>double to be added to m[0] </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v1</parametername>
</parameternamelist>
<parameterdescription>
<para>double to be added to m[1] </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v2</parametername>
</parameternamelist>
<parameterdescription>
<para>double to be added to m[2] </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v3</parametername>
</parameternamelist>
<parameterdescription>
<para>double to be added to m[3]</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>v0+v1+v2+v3.</para></simplesect>
<simplesect kind="note"><para>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" line="633" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/scalar/scalar_util.h" bodystart="633" bodyend="645"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga8e9692244890665c6dc8f81fc3536f38" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::invsqrtSingleAccuracy</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>invsqrtSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate 1/sqrt(x) for SIMD float, only targeting single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be &gt;0. This routine does not check arguments. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/sqrt(x). Result is undefined if your argument was invalid. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="3916" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="3916" bodyend="3919"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga7e6086a4db51ceeeb8fe18e8884248f4" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
        <definition>static SimdFloat gmx::maskzInvsqrtSingleAccuracy</definition>
        <argsstring>(SimdFloat x, SimdFBool m)</argsstring>
        <name>maskzInvsqrtSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref></type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Calculate 1/sqrt(x) for masked SIMD floats, only targeting single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para>This routine only evaluates 1/sqrt(x) for elements for which mask is true. Illegal values in the masked-out elements will not lead to floating-point exceptions.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be &gt;0 for masked-in entries </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/sqrt(x). Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="3933" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="3933" bodyend="3936"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga3685e3466dd242fee652e51ff27decc7" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::invsqrtPairSingleAccuracy</definition>
        <argsstring>(SimdFloat x0, SimdFloat x1, SimdFloat *out0, SimdFloat *out1)</argsstring>
        <name>invsqrtPairSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x1</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>out0</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>out1</declname>
        </param>
        <briefdescription>
<para>Calculate 1/sqrt(x) for two SIMD floats, only targeting single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x0</parametername>
</parameternamelist>
<parameterdescription>
<para>First set of arguments, x0 must be positive - no argument checking. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x1</parametername>
</parameternamelist>
<parameterdescription>
<para>Second set of arguments, x1 must be positive - no argument checking. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out0</parametername>
</parameternamelist>
<parameterdescription>
<para>Result 1/sqrt(x0) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out1</parametername>
</parameternamelist>
<parameterdescription>
<para>Result 1/sqrt(x1)</para></parameterdescription>
</parameteritem>
</parameterlist>
In particular for double precision we can sometimes calculate square root pairs slightly faster by using single precision until the very last step. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="3949" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="3949" bodyend="3953"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga8db3b7c11cb80b5baca2cd42463e5c8e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::invSingleAccuracy</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>invSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate 1/x for SIMD float, only targeting single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be nonzero. This routine does not check arguments. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/x. Result is undefined if your argument was invalid. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="3961" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="3961" bodyend="3964"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gac6704608858869fb062f53fcc40d7642" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
        <definition>static SimdFloat gmx::maskzInvSingleAccuracy</definition>
        <argsstring>(SimdFloat x, SimdFBool m)</argsstring>
        <name>maskzInvSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFBool" kindref="compound">SimdFBool</ref></type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Calculate 1/x for masked SIMD floats, only targeting single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be nonzero for non-masked entries. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Mask </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/x for elements where m is true, or 0.0 for masked-out entries. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="3974" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="3974" bodyend="3977"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga38459bf2cc4d1da4e8c391a4114af932" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::sqrtSingleAccuracy</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>sqrtSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate sqrt(x) for SIMD float, only targeting single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be &gt;=0. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>sqrt(x). If x=0, the result will correctly be set to 0. The result is undefined if the input value is negative. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="3986" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="3986" bodyend="3989"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga6f81e3b80f7edc6e4f2722a6ee94a5de" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::logSingleAccuracy</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>logSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float log(x), only targeting single accuracy. This is the natural logarithm. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument, should be &gt;0. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The natural logarithm of x. Undefined if argument is invalid. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="3997" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="3997" bodyend="4000"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga09aa937158e1be4d1f62ccd9e231a1bf" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::exp2SingleAccuracy</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>exp2SingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float 2^x, only targeting single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>2^x. Undefined if input argument caused overflow. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="4008" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="4008" bodyend="4011"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga6d1245393d4848801a19f03a6bbdb9d7" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::expSingleAccuracy</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>expSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float e^x, only targeting single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>exp(x). Undefined if input argument caused overflow. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="4019" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="4019" bodyend="4022"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga6b00659cd28d0255ee51fcfd9693209f" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::erfSingleAccuracy</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>erfSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float erf(x), only targeting single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to calculate erf(x) for. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>erf(x)</para></simplesect>
This routine achieves very close to single precision, but we do not care about the last bit or the subnormal result range. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="4033" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="4033" bodyend="4036"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga606009ab68825981a67be586f77fb38e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::erfcSingleAccuracy</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>erfcSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float erfc(x), only targeting single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to calculate erfc(x) for. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>erfc(x)</para></simplesect>
This routine achieves singleprecision (bar the last bit) over most of the input range, but for large arguments where the result is getting close to the minimum representable numbers we accept slightly larger errors (think results that are in the ballpark of 10^-30) since that is not relevant for MD. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="4050" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="4050" bodyend="4053"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga6afcbeed45441fb9624fece5906b8a17" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::sinCosSingleAccuracy</definition>
        <argsstring>(SimdFloat x, SimdFloat *sinval, SimdFloat *cosval)</argsstring>
        <name>sinCosSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>sinval</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>cosval</declname>
        </param>
        <briefdescription>
<para>SIMD float sin &amp; cos, only targeting single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate sin/cos for </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">sinval</parametername>
</parameternamelist>
<parameterdescription>
<para>Sin(x) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">cosval</parametername>
</parameternamelist>
<parameterdescription>
<para>Cos(x) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="4062" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="4062" bodyend="4065"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga0ba00dcc0a9e1342d1af6952e0d2e1e7" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::sinSingleAccuracy</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>sinSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float sin(x), only targeting single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate sin for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Sin(x)</para></simplesect>
<simplesect kind="attention"><para>Do NOT call both sin &amp; cos if you need both results, since each of them will then call <ref refid="namespacegmx_1a3191310c1a122aafe946f0caf2fdf364" kindref="member">sincos</ref> and waste a factor 2 in performance. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="4076" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="4076" bodyend="4079"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gaa1ecd6647f33b8bd12c43a3f3de95fb3" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::cosSingleAccuracy</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>cosSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float cos(x), only targeting single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate cos for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Cos(x)</para></simplesect>
<simplesect kind="attention"><para>Do NOT call both sin &amp; cos if you need both results, since each of them will then call <ref refid="namespacegmx_1a3191310c1a122aafe946f0caf2fdf364" kindref="member">sincos</ref> and waste a factor 2 in performance. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="4090" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="4090" bodyend="4093"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga6a534183c1fe54e0eccabbff0000990b" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::tanSingleAccuracy</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>tanSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float tan(x), only targeting single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate tan for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Tan(x) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="4101" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="4101" bodyend="4104"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga50ad685f412725bacde7687e43bab092" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::asinSingleAccuracy</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>asinSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float asin(x), only targeting single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate asin for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Asin(x) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="4112" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="4112" bodyend="4115"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga79f0bb956500fceaff7db7c496cb8dde" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::acosSingleAccuracy</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>acosSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float acos(x), only targeting single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate acos for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Acos(x) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="4123" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="4123" bodyend="4126"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga94615aced90295d0c008dbe576bfb535" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::atanSingleAccuracy</definition>
        <argsstring>(SimdFloat x)</argsstring>
        <name>atanSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float atan(x), only targeting single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to evaluate atan for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Atan(x), same argument/value range as standard math library. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="4134" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="4134" bodyend="4137"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga73a666e50ed9883d77a2664cd9f9768c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::atan2SingleAccuracy</definition>
        <argsstring>(SimdFloat y, SimdFloat x)</argsstring>
        <name>atan2SingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>y</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>SIMD float atan2(y,x), only targeting single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>Y component of vector, any quartile </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>X component of vector, any quartile </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Atan(y,x), same argument/value range as standard math library.</para></simplesect>
<simplesect kind="note"><para>This routine should provide correct results for all finite non-zero or positive-zero arguments. However, negative zero arguments will be treated as positive zero, which means the return value will deviate from the standard math library atan2(y,x) for those cases. That should not be of any concern in Gromacs, and in particular it will not affect calculations of angles from vectors. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="4153" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="4153" bodyend="4156"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga50c70d6df3435d9235cdf34589f9225c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::pmeForceCorrectionSingleAccuracy</definition>
        <argsstring>(SimdFloat z2)</argsstring>
        <name>pmeForceCorrectionSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>z2</declname>
        </param>
        <briefdescription>
<para>SIMD Analytic PME force correction, only targeting single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>z2</parametername>
</parameternamelist>
<parameterdescription>
<para><formula id="19">$(r \beta)^2$</formula> - see default single precision version for details. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Correction factor to coulomb force. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="4164" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="4164" bodyend="4167"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gaf555c7f9fb09586e8c809283b8210ed0" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::pmePotentialCorrectionSingleAccuracy</definition>
        <argsstring>(SimdFloat z2)</argsstring>
        <name>pmePotentialCorrectionSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>z2</declname>
        </param>
        <briefdescription>
<para>SIMD Analytic PME potential correction, only targeting single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>z2</parametername>
</parameternamelist>
<parameterdescription>
<para><formula id="19">$(r \beta)^2$</formula> - see default single precision version for details. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Correction factor to coulomb force. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="4175" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="4175" bodyend="4178"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga63a4c301efefb218bd1256e877610c1e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::invsqrtSingleAccuracy</definition>
        <argsstring>(Simd4Float x)</argsstring>
        <name>invsqrtSingleAccuracy</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Calculate 1/sqrt(x) for SIMD4 float, only targeting single accuracy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument that must be &gt;0. This routine does not check arguments. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1/sqrt(x). Result is undefined if your argument was invalid. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" line="4188" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/simd_math.h" bodystart="4188" bodyend="4191"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a4c9dbda372b70531a9c407fa8727930b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const std::string &amp;</type>
        <definition>const std::string &amp; gmx::simdString</definition>
        <argsstring>(SimdType s)</argsstring>
        <name>simdString</name>
        <param>
          <type><ref refid="namespacegmx_1aa9e7df55e017bd726d027d65551bbd0c" kindref="member">SimdType</ref></type>
          <declname>s</declname>
        </param>
        <briefdescription>
<para>Return a string with the name of a SIMD type. </para>        </briefdescription>
        <detaileddescription>
<para> <libinternal /> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD type to turn into string </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/support.cpp" line="65" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/support.cpp" bodystart="65" bodyend="89"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1afb849452876bebac9fbff66b765ad1f5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespacegmx_1aa9e7df55e017bd726d027d65551bbd0c" kindref="member">SimdType</ref></type>
        <definition>SimdType gmx::simdSuggested</definition>
        <argsstring>(const CpuInfo &amp;c)</argsstring>
        <name>simdSuggested</name>
        <param>
          <type>const <ref refid="classgmx_1_1CpuInfo" kindref="compound">CpuInfo</ref> &amp;</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>Return the SIMD type that would fit this hardware best. </para>        </briefdescription>
        <detaileddescription>
<para> <libinternal />  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/support.cpp" line="92" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/support.cpp" bodystart="92" bodyend="189"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1af8b39eae7004973e8ecfc847934e6774" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespacegmx_1aa9e7df55e017bd726d027d65551bbd0c" kindref="member">SimdType</ref></type>
        <definition>SimdType gmx::simdCompiled</definition>
        <argsstring>()</argsstring>
        <name>simdCompiled</name>
        <briefdescription>
<para>Return the SIMD type the library was compiled with. </para>        </briefdescription>
        <detaileddescription>
<para> <libinternal />  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/support.cpp" line="192" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/support.cpp" bodystart="192" bodyend="227"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a621eef8998b02f36f8a6352658aab7a5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool gmx::simdCheck</definition>
        <argsstring>(SimdType s, FILE *log, bool warnToStdErr)</argsstring>
        <name>simdCheck</name>
        <param>
          <type><ref refid="namespacegmx_1aa9e7df55e017bd726d027d65551bbd0c" kindref="member">SimdType</ref></type>
          <declname>s</declname>
          <defname>wanted</defname>
        </param>
        <param>
          <type>FILE *</type>
          <declname>log</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>warnToStdErr</declname>
        </param>
        <briefdescription>
<para>Check if binary was compiled with the provided SIMD type. </para>        </briefdescription>
        <detaileddescription>
<para> <libinternal /> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD type to query. If this matches the suggested type for this cpu, the routine returns quietly. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>log</parametername>
</parameternamelist>
<parameterdescription>
<para>If not nullptr, statistics will be printed to the file. If we do not have a match there will also be a warning. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>warnToStdErr</parametername>
</parameternamelist>
<parameterdescription>
<para>If true, warnings will also be printed to stderr. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/support.cpp" line="230" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/support.cpp" bodystart="230" bodyend="267"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga0087673fec98bdc89b553f7f349e22d2" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::iprod</definition>
        <argsstring>(SimdFloat ax, SimdFloat ay, SimdFloat az, SimdFloat bx, SimdFloat by, SimdFloat bz)</argsstring>
        <name>iprod</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>ax</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>ay</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>az</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>bx</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>by</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>bz</declname>
        </param>
        <briefdescription>
<para>SIMD float inner product of multiple float vectors. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ax</parametername>
</parameternamelist>
<parameterdescription>
<para>X components of first vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ay</parametername>
</parameternamelist>
<parameterdescription>
<para>Y components of first vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>az</parametername>
</parameternamelist>
<parameterdescription>
<para>Z components of first vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bx</parametername>
</parameternamelist>
<parameterdescription>
<para>X components of second vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>by</parametername>
</parameternamelist>
<parameterdescription>
<para>Y components of second vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bz</parametername>
</parameternamelist>
<parameterdescription>
<para>Z components of second vectors</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Element i will be res[i] = ax[i]*bx[i]+ay[i]*by[i]+az[i]*bz[i].</para></simplesect>
<simplesect kind="note"><para>The SIMD part is that we calculate many scalar products in one call. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/vector_operations.h" line="84" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/vector_operations.h" bodystart="84" bodyend="94"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga86f01f74a7ab4156ec123146fd0b7de7" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> gmx_simdcall</type>
        <definition>static SimdFloat gmx_simdcall gmx::norm2</definition>
        <argsstring>(SimdFloat ax, SimdFloat ay, SimdFloat az)</argsstring>
        <name>norm2</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>ax</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>ay</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>az</declname>
        </param>
        <briefdescription>
<para>SIMD float norm squared of multiple vectors. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ax</parametername>
</parameternamelist>
<parameterdescription>
<para>X components of vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ay</parametername>
</parameternamelist>
<parameterdescription>
<para>Y components of vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>az</parametername>
</parameternamelist>
<parameterdescription>
<para>Z components of vectors</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Element i will be res[i] = ax[i]*ax[i]+ay[i]*ay[i]+az[i]*az[i].</para></simplesect>
<simplesect kind="note"><para>This corresponds to the scalar product of the vector with itself, but the compiler might be able to optimize it better with identical vectors. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/vector_operations.h" line="108" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/vector_operations.h" bodystart="108" bodyend="117"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga54124af0ff118d3f171b0eef07105c76" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::cprod</definition>
        <argsstring>(SimdFloat ax, SimdFloat ay, SimdFloat az, SimdFloat bx, SimdFloat by, SimdFloat bz, SimdFloat *cx, SimdFloat *cy, SimdFloat *cz)</argsstring>
        <name>cprod</name>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>ax</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>ay</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>az</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>bx</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>by</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref></type>
          <declname>bz</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>cx</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>cy</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdFloat" kindref="compound">SimdFloat</ref> *</type>
          <declname>cz</declname>
        </param>
        <briefdescription>
<para>SIMD float cross-product of multiple vectors. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ax</parametername>
</parameternamelist>
<parameterdescription>
<para>X components of first vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ay</parametername>
</parameternamelist>
<parameterdescription>
<para>Y components of first vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>az</parametername>
</parameternamelist>
<parameterdescription>
<para>Z components of first vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bx</parametername>
</parameternamelist>
<parameterdescription>
<para>X components of second vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>by</parametername>
</parameternamelist>
<parameterdescription>
<para>Y components of second vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bz</parametername>
</parameternamelist>
<parameterdescription>
<para>Z components of second vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">cx</parametername>
</parameternamelist>
<parameterdescription>
<para>X components of cross product vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">cy</parametername>
</parameternamelist>
<parameterdescription>
<para>Y components of cross product vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">cz</parametername>
</parameternamelist>
<parameterdescription>
<para>Z components of cross product vectors</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>void</para></simplesect>
This calculates C = A x B, where the cross denotes the cross product. The arguments x/y/z denotes the different components, and each element corresponds to a separate vector. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/vector_operations.h" line="138" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/vector_operations.h" bodystart="138" bodyend="150"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gacc26031cf2fbf6cb1cee4e38d4cf6e3b" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::iprod</definition>
        <argsstring>(SimdDouble ax, SimdDouble ay, SimdDouble az, SimdDouble bx, SimdDouble by, SimdDouble bz)</argsstring>
        <name>iprod</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>ax</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>ay</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>az</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>bx</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>by</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>bz</declname>
        </param>
        <briefdescription>
<para>SIMD double inner product of multiple double vectors. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ax</parametername>
</parameternamelist>
<parameterdescription>
<para>X components of first vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ay</parametername>
</parameternamelist>
<parameterdescription>
<para>Y components of first vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>az</parametername>
</parameternamelist>
<parameterdescription>
<para>Z components of first vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bx</parametername>
</parameternamelist>
<parameterdescription>
<para>X components of second vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>by</parametername>
</parameternamelist>
<parameterdescription>
<para>Y components of second vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bz</parametername>
</parameternamelist>
<parameterdescription>
<para>Z components of second vectors</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Element i will be res[i] = ax[i]*bx[i]+ay[i]*by[i]+az[i]*bz[i].</para></simplesect>
<simplesect kind="note"><para>The SIMD part is that we calculate many scalar products in one call. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/vector_operations.h" line="168" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/vector_operations.h" bodystart="168" bodyend="178"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga689e3ff037f04bcf9d3c3bfc896d50f6" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> gmx_simdcall</type>
        <definition>static SimdDouble gmx_simdcall gmx::norm2</definition>
        <argsstring>(SimdDouble ax, SimdDouble ay, SimdDouble az)</argsstring>
        <name>norm2</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>ax</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>ay</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>az</declname>
        </param>
        <briefdescription>
<para>SIMD double norm squared of multiple vectors. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ax</parametername>
</parameternamelist>
<parameterdescription>
<para>X components of vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ay</parametername>
</parameternamelist>
<parameterdescription>
<para>Y components of vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>az</parametername>
</parameternamelist>
<parameterdescription>
<para>Z components of vectors</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Element i will be res[i] = ax[i]*ax[i]+ay[i]*ay[i]+az[i]*az[i].</para></simplesect>
<simplesect kind="note"><para>This corresponds to the scalar product of the vector with itself, but the compiler might be able to optimize it better with identical vectors. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/vector_operations.h" line="192" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/vector_operations.h" bodystart="192" bodyend="201"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga5bda1e7f61ac88be5176195e3676a6d4" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void gmx_simdcall</type>
        <definition>static void gmx_simdcall gmx::cprod</definition>
        <argsstring>(SimdDouble ax, SimdDouble ay, SimdDouble az, SimdDouble bx, SimdDouble by, SimdDouble bz, SimdDouble *cx, SimdDouble *cy, SimdDouble *cz)</argsstring>
        <name>cprod</name>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>ax</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>ay</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>az</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>bx</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>by</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref></type>
          <declname>bz</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>cx</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>cy</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1SimdDouble" kindref="compound">SimdDouble</ref> *</type>
          <declname>cz</declname>
        </param>
        <briefdescription>
<para>SIMD double cross-product of multiple vectors. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ax</parametername>
</parameternamelist>
<parameterdescription>
<para>X components of first vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ay</parametername>
</parameternamelist>
<parameterdescription>
<para>Y components of first vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>az</parametername>
</parameternamelist>
<parameterdescription>
<para>Z components of first vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bx</parametername>
</parameternamelist>
<parameterdescription>
<para>X components of second vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>by</parametername>
</parameternamelist>
<parameterdescription>
<para>Y components of second vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bz</parametername>
</parameternamelist>
<parameterdescription>
<para>Z components of second vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">cx</parametername>
</parameternamelist>
<parameterdescription>
<para>X components of cross product vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">cy</parametername>
</parameternamelist>
<parameterdescription>
<para>Y components of cross product vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">cz</parametername>
</parameternamelist>
<parameterdescription>
<para>Z components of cross product vectors</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>void</para></simplesect>
This calculates C = A x B, where the cross denotes the cross product. The arguments x/y/z denotes the different components, and each element corresponds to a separate vector. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/vector_operations.h" line="222" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/vector_operations.h" bodystart="222" bodyend="234"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1ga5aaaf08ce309b237501775f56590ee53" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref> gmx_simdcall</type>
        <definition>static Simd4Float gmx_simdcall gmx::norm2</definition>
        <argsstring>(Simd4Float ax, Simd4Float ay, Simd4Float az)</argsstring>
        <name>norm2</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>ax</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>ay</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Float" kindref="compound">Simd4Float</ref></type>
          <declname>az</declname>
        </param>
        <briefdescription>
<para>SIMD4 float norm squared of multiple vectors. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ax</parametername>
</parameternamelist>
<parameterdescription>
<para>X components of vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ay</parametername>
</parameternamelist>
<parameterdescription>
<para>Y components of vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>az</parametername>
</parameternamelist>
<parameterdescription>
<para>Z components of vectors</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Element i will be res[i] = ax[i]*ax[i]+ay[i]*ay[i]+az[i]*az[i].</para></simplesect>
<simplesect kind="note"><para>This corresponds to the scalar product of the vector with itself, but the compiler might be able to optimize it better with identical vectors. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/vector_operations.h" line="251" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/vector_operations.h" bodystart="251" bodyend="260"/>
      </memberdef>
      <memberdef kind="function" id="group__module__simd_1gae78d49a68930c6290f4fadd7f02b77e4" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref> gmx_simdcall</type>
        <definition>static Simd4Double gmx_simdcall gmx::norm2</definition>
        <argsstring>(Simd4Double ax, Simd4Double ay, Simd4Double az)</argsstring>
        <name>norm2</name>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>ax</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>ay</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1Simd4Double" kindref="compound">Simd4Double</ref></type>
          <declname>az</declname>
        </param>
        <briefdescription>
<para>SIMD4 double norm squared of multiple vectors. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ax</parametername>
</parameternamelist>
<parameterdescription>
<para>X components of vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ay</parametername>
</parameternamelist>
<parameterdescription>
<para>Y components of vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>az</parametername>
</parameternamelist>
<parameterdescription>
<para>Z components of vectors</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Element i will be res[i] = ax[i]*ax[i]+ay[i]*ay[i]+az[i]*az[i].</para></simplesect>
<simplesect kind="note"><para>This corresponds to the scalar product of the vector with itself, but the compiler might be able to optimize it better with identical vectors. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/vector_operations.h" line="277" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/simd/vector_operations.h" bodystart="277" bodyend="286"/>
      </memberdef>
      <memberdef kind="function" id="group__module__trajectoryanalysis_1ga7a18c2c956e97306dcac66b006c34435" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void gmx::registerTrajectoryAnalysisModules</definition>
        <argsstring>(CommandLineModuleManager *manager)</argsstring>
        <name>registerTrajectoryAnalysisModules</name>
        <param>
          <type><ref refid="classgmx_1_1CommandLineModuleManager" kindref="compound">CommandLineModuleManager</ref> *</type>
          <declname>manager</declname>
        </param>
        <briefdescription>
<para>Registers all trajectory analysis command-line modules. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">manager</parametername>
</parameternamelist>
<parameterdescription>
<para>Command-line module manager to receive the modules. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::bad_alloc</parametername>
</parameternamelist>
<parameterdescription>
<para>if out of memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
Registers all trajectory analysis modules declared in the library such that they can be run through <computeroutput>manager</computeroutput>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/trajectoryanalysis/modules.cpp" line="88" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/trajectoryanalysis/modules.cpp" bodystart="88" bodyend="99"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1ga6f21654b9945d04d277523f6c8ab1d11" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void gmx::swap</definition>
        <argsstring>(ArrayRef&lt; T &gt; &amp;a, ArrayRef&lt; T &gt; &amp;b)</argsstring>
        <name>swap</name>
        <param>
          <type><ref refid="classgmx_1_1ArrayRef" kindref="compound">ArrayRef</ref>&lt; T &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1ArrayRef" kindref="compound">ArrayRef</ref>&lt; T &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Simple swap method for <ref refid="classgmx_1_1ArrayRef" kindref="compound">ArrayRef</ref> objects. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ref refid="classgmx_1_1ArrayRef_1a6b0d543799e64b307d4832545e16f6f7" kindref="member">ArrayRef::swap()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/arrayref.h" line="584" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/arrayref.h" bodystart="584" bodyend="587"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1ga3faec92610cb1ba29dfdf35a05e794cd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void gmx::swap</definition>
        <argsstring>(ConstArrayRef&lt; T &gt; &amp;a, ConstArrayRef&lt; T &gt; &amp;b)</argsstring>
        <name>swap</name>
        <param>
          <type><ref refid="classgmx_1_1ConstArrayRef" kindref="compound">ConstArrayRef</ref>&lt; T &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classgmx_1_1ConstArrayRef" kindref="compound">ConstArrayRef</ref>&lt; T &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Simple swap method for <ref refid="classgmx_1_1ConstArrayRef" kindref="compound">ConstArrayRef</ref> objects. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ref refid="classgmx_1_1ConstArrayRef_1af9c00ef92094cc2a1f725f64b8dec471" kindref="member">ConstArrayRef::swap()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/arrayref.h" line="597" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/arrayref.h" bodystart="597" bodyend="600"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aff67fcd64bdaa64a3823cc1a322a6783" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void gmx::printBinaryInformation</definition>
        <argsstring>(FILE *fp, const IProgramContext &amp;programContext)</argsstring>
        <name>printBinaryInformation</name>
        <param>
          <type>FILE *</type>
          <declname>fp</declname>
        </param>
        <param>
          <type>const <ref refid="classgmx_1_1IProgramContext" kindref="compound">IProgramContext</ref> &amp;</type>
          <declname>programContext</declname>
        </param>
        <briefdescription>
<para>Print basic information about the executable. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fp</parametername>
</parameternamelist>
<parameterdescription>
<para>Where to print the information to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">programContext</parametername>
</parameternamelist>
<parameterdescription>
<para>Program information object to use. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/binaryinformation.cpp" line="323" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/binaryinformation.cpp" bodystart="323" bodyend="327"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1ad0c6bc3dc4ee812f31a6076c7d4f42a9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void gmx::printBinaryInformation</definition>
        <argsstring>(FILE *fp, const IProgramContext &amp;programContext, const BinaryInformationSettings &amp;settings)</argsstring>
        <name>printBinaryInformation</name>
        <param>
          <type>FILE *</type>
          <declname>fp</declname>
        </param>
        <param>
          <type>const <ref refid="classgmx_1_1IProgramContext" kindref="compound">IProgramContext</ref> &amp;</type>
          <declname>programContext</declname>
        </param>
        <param>
          <type>const <ref refid="classgmx_1_1BinaryInformationSettings" kindref="compound">BinaryInformationSettings</ref> &amp;</type>
          <declname>settings</declname>
        </param>
        <briefdescription>
<para>Print basic information about the executable with custom settings. </para>        </briefdescription>
        <detaileddescription>
<para>Needed to read the members without otherwise unnecessary accessors.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fp</parametername>
</parameternamelist>
<parameterdescription>
<para>Where to print the information to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">programContext</parametername>
</parameternamelist>
<parameterdescription>
<para>Program information object to use. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">settings</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies what to print.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="classgmx_1_1BinaryInformationSettings" kindref="compound">BinaryInformationSettings</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/binaryinformation.cpp" line="329" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/binaryinformation.cpp" bodystart="329" bodyend="396"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a0211f291fe376a0bcf8f12e382620495" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string gmx::bromacs</definition>
        <argsstring>()</argsstring>
        <name>bromacs</name>
        <briefdescription>
<para>Return a cool definition for the acronym GROMACS. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/coolstuff.cpp" line="86" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/coolstuff.cpp" bodystart="86" bodyend="125"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a7a579db3d112ccecde57a054f288216c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string gmx::getCoolQuote</definition>
        <argsstring>()</argsstring>
        <name>getCoolQuote</name>
        <briefdescription>
<para>Return a string with a cool quote. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/coolstuff.cpp" line="127" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/coolstuff.cpp" bodystart="127" bodyend="750"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1gaac30db5a87fa0f55776bc8a3dcef0d67" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const char *</type>
        <definition>const char * gmx::getErrorCodeString</definition>
        <argsstring>(int errorcode)</argsstring>
        <name>getErrorCodeString</name>
        <param>
          <type>int</type>
          <declname>errorcode</declname>
        </param>
        <briefdescription>
<para>Returns a short string description of an error code. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">errorcode</parametername>
</parameternamelist>
<parameterdescription>
<para>Error code to retrieve the string for. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A constant string corresponding to <computeroutput>errorcode</computeroutput>.</para></simplesect>
If <computeroutput>errorcode</computeroutput> is not one of those defined for <ref refid="group__module__utility_1gac92ff9c7f6f5ed5200b3d8d92a4d53e3" kindref="member">gmx::ErrorCode</ref>, the string corresponding to <ref refid="group__module__utility_1ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a46578ca340e1c440d5f519569e6884fb" kindref="member">eeUnknownError</ref> is returned.</para><para>This function does not throw. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/errorcodes.cpp" line="82" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/errorcodes.cpp" bodystart="82" bodyend="89"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1gac6287dc8a550a2d54429e44994e00e58" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void gmx::printFatalErrorMessage</definition>
        <argsstring>(FILE *fp, const std::exception &amp;ex)</argsstring>
        <name>printFatalErrorMessage</name>
        <param>
          <type>FILE *</type>
          <declname>fp</declname>
        </param>
        <param>
          <type>const std::exception &amp;</type>
          <declname>ex</declname>
        </param>
        <briefdescription>
<para>Formats a standard fatal error message for reporting an exception. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fp</parametername>
</parameternamelist>
<parameterdescription>
<para>File to format the message to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ex</parametername>
</parameternamelist>
<parameterdescription>
<para>Exception to format.</para></parameterdescription>
</parameteritem>
</parameterlist>
Does not throw. If memory allocation fails or some other error occurs while formatting the error, tries to print a reasonable alternative message.</para><para>Normal usage in Gromacs command-line programs is like this: <programlisting><codeline><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="test__selection_8cpp_1a0ddf1224851353fc92bfbff6f499fa97" kindref="member">main</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__module__utility_1gae00d174a8ddd5325460d74dc663711c0" kindref="member">gmx::init</ref>(&amp;argc,<sp/>&amp;argv);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">try</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>actual<sp/>code<sp/>for<sp/>the<sp/>program</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">catch</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::exception<sp/>&amp;ex)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__module__utility_1gac6287dc8a550a2d54429e44994e00e58" kindref="member">gmx::printFatalErrorMessage</ref>(stderr,<sp/>ex);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__module__utility_1ga5a45f49e157fa8e1059d24243283e248" kindref="member">gmx::processExceptionAtExit</ref>(ex);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/exceptions.cpp" line="506" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/exceptions.cpp" bodystart="506" bodyend="559"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1gac7703ad35b606758d2d12edc0a3d5217" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string gmx::formatExceptionMessageToString</definition>
        <argsstring>(const std::exception &amp;ex)</argsstring>
        <name>formatExceptionMessageToString</name>
        <param>
          <type>const std::exception &amp;</type>
          <declname>ex</declname>
        </param>
        <briefdescription>
<para>Formats an error message for reporting an exception. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ex</parametername>
</parameternamelist>
<parameterdescription>
<para>Exception to format. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Formatted string containing details of <computeroutput>ex</computeroutput>. </para></simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::bad_alloc</parametername>
</parameternamelist>
<parameterdescription>
<para>if out of memory. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/exceptions.cpp" line="561" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/exceptions.cpp" bodystart="561" bodyend="567"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1gac5e6f6ec944fb2484d6f273c9a0ff495" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void gmx::formatExceptionMessageToFile</definition>
        <argsstring>(FILE *fp, const std::exception &amp;ex)</argsstring>
        <name>formatExceptionMessageToFile</name>
        <param>
          <type>FILE *</type>
          <declname>fp</declname>
        </param>
        <param>
          <type>const std::exception &amp;</type>
          <declname>ex</declname>
        </param>
        <briefdescription>
<para>Formats an error message for reporting an exception. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fp</parametername>
</parameternamelist>
<parameterdescription>
<para>File to write the message to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ex</parametername>
</parameternamelist>
<parameterdescription>
<para>Exception to format. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::bad_alloc</parametername>
</parameternamelist>
<parameterdescription>
<para>if out of memory. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/exceptions.cpp" line="569" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/exceptions.cpp" bodystart="569" bodyend="573"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1gaacf6bfb81220e44ed1bf73f0a44d9926" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void gmx::formatExceptionMessageToWriter</definition>
        <argsstring>(TextWriter *writer, const std::exception &amp;ex)</argsstring>
        <name>formatExceptionMessageToWriter</name>
        <param>
          <type><ref refid="classgmx_1_1TextWriter" kindref="compound">TextWriter</ref> *</type>
          <declname>writer</declname>
        </param>
        <param>
          <type>const std::exception &amp;</type>
          <declname>ex</declname>
        </param>
        <briefdescription>
<para>Formats an error message for reporting an exception. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>writer</parametername>
</parameternamelist>
<parameterdescription>
<para>Writer to use for writing the message. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ex</parametername>
</parameternamelist>
<parameterdescription>
<para>Exception to format. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::bad_alloc</parametername>
</parameternamelist>
<parameterdescription>
<para>if out of memory. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/exceptions.cpp" line="575" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/exceptions.cpp" bodystart="575" bodyend="580"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1ga5a45f49e157fa8e1059d24243283e248" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int gmx::processExceptionAtExit</definition>
        <argsstring>(const std::exception &amp;ex)</argsstring>
        <name>processExceptionAtExit</name>
        <param>
          <type>const std::exception &amp;</type>
          <declname>ex</declname>
        </param>
        <briefdescription>
<para>Handles an exception that is causing the program to terminate. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ex</parametername>
</parameternamelist>
<parameterdescription>
<para>Exception that is the cause for terminating the program. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Return code to return from <ref refid="test__selection_8cpp_1a0ddf1224851353fc92bfbff6f499fa97" kindref="member">main()</ref>.</para></simplesect>
This method should be called as the last thing before terminating the program because of an exception. It exists to terminate the program as gracefully as possible in the case of MPI processing (but the current implementation always calls MPI_Abort()).</para><para>See <ref refid="group__module__utility_1gac6287dc8a550a2d54429e44994e00e58" kindref="member">printFatalErrorMessage()</ref> for example usage.</para><para>Does not throw. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/exceptions.cpp" line="582" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/exceptions.cpp" bodystart="582" bodyend="595"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1ga13076c5bb17dd3bf90f683af835b8b62" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void gmx::processExceptionAsFatalError</definition>
        <argsstring>(const std::exception &amp;ex)</argsstring>
        <name>processExceptionAsFatalError</name>
        <param>
          <type>const std::exception &amp;</type>
          <declname>ex</declname>
        </param>
        <briefdescription>
<para>Helper function for terminating the program on an exception. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ex</parametername>
</parameternamelist>
<parameterdescription>
<para>Exception that is the cause for terminating the program.</para></parameterdescription>
</parameteritem>
</parameterlist>
Does not throw, and does not return. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/exceptions.cpp" line="597" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/exceptions.cpp" bodystart="597" bodyend="601"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1ga1b9a1e3988a89d1b90944c6ff6c3e794" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Exception</type>
          </param>
          <param>
            <type>class Tag</type>
          </param>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; std::is_base_of&lt; <ref refid="classgmx_1_1GromacsException" kindref="compound">GromacsException</ref>, Exception &gt;::value, const Exception &amp; &gt;::type</type>
        <definition>std::enable_if&lt;std::is_base_of&lt;GromacsException, Exception&gt;::value, const Exception &amp;&gt;::type gmx::operator&lt;&lt;</definition>
        <argsstring>(const Exception &amp;ex, const ExceptionInfo&lt; Tag, T &gt; &amp;item)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>const Exception &amp;</type>
          <declname>ex</declname>
        </param>
        <param>
          <type>const <ref refid="classgmx_1_1ExceptionInfo" kindref="compound">ExceptionInfo</ref>&lt; Tag, T &gt; &amp;</type>
          <declname>item</declname>
        </param>
        <briefdescription>
<para>Associates extra information with an exception. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Exception</parametername>
</parameternamelist>
<parameterdescription>
<para>Exception type (must be derived from <ref refid="classgmx_1_1GromacsException" kindref="compound">GromacsException</ref>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tag</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classgmx_1_1ExceptionInfo" kindref="compound">ExceptionInfo</ref> tag. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classgmx_1_1ExceptionInfo" kindref="compound">ExceptionInfo</ref> value type. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">ex</parametername>
</parameternamelist>
<parameterdescription>
<para>Exception to associate the information to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">item</parametername>
</parameternamelist>
<parameterdescription>
<para>Information to associate.</para></parameterdescription>
</parameteritem>
</parameterlist>
</para><internal><para>The association is done with a templated non-member operator of exactly this form to make the simple syntax of <ref refid="group__module__utility_1gaed2c1af17dbda0e02e8cfd2c3d7e7096" kindref="member">GMX_THROW()</ref> possible. To support this, this operation needs to:<itemizedlist>
<listitem><para>Allow setting information in a temporary to support <computeroutput>GMX_THROW(InvalidInputError(ex))</computeroutput>. This is the reason for taking a const reference and the <computeroutput>const_cast</computeroutput>.</para></listitem><listitem><para>Return the same reference it takes in, instead of a base class. The compiler needs this information to throw the correct type of exception. This would be tedious to achieve with a member function (without a lot of code duplication).</para></listitem><listitem><para>Provide convenient syntax for adding multiple items. A non-member function that would require nested calls would look ugly for such cases.</para></listitem></itemizedlist>
</para><para>The reason for the enable_if is that this way, it does not conflict with other overloads of <computeroutput>operator&lt;&lt;</computeroutput> for <ref refid="classgmx_1_1ExceptionInfo" kindref="compound">ExceptionInfo</ref> objects, in case someone would like to declare those. But currently we do not have such overloads, so if the enable_if causes problems with some compilers, it can be removed. </para></internal>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/exceptions.h" line="388" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/exceptions.h" bodystart="389" bodyend="393"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1ga4feb866d293acd99eeedc50da2747350" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classgmx_1_1IFileInputRedirector" kindref="compound">IFileInputRedirector</ref> &amp;</type>
        <definition>IFileInputRedirector &amp; gmx::defaultFileInputRedirector</definition>
        <argsstring>()</argsstring>
        <name>defaultFileInputRedirector</name>
        <briefdescription>
<para>Returns default implementation for <ref refid="classgmx_1_1IFileInputRedirector" kindref="compound">IFileInputRedirector</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>The returned implementation does not redirect anything, but just uses the file system normally.</para><para>Does not throw. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/fileredirector.cpp" line="106" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/fileredirector.cpp" bodystart="106" bodyend="110"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1ga1cf24ed90164cc80604e8be18103fe02" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classgmx_1_1IFileOutputRedirector" kindref="compound">IFileOutputRedirector</ref> &amp;</type>
        <definition>IFileOutputRedirector &amp; gmx::defaultFileOutputRedirector</definition>
        <argsstring>()</argsstring>
        <name>defaultFileOutputRedirector</name>
        <briefdescription>
<para>Returns default implementation for <ref refid="classgmx_1_1IFileOutputRedirector" kindref="compound">IFileOutputRedirector</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>The returned implementation does not redirect anything, but just opens the files at requested locations.</para><para>Does not throw. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/fileredirector.cpp" line="112" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/fileredirector.cpp" bodystart="112" bodyend="116"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1ga312499e4abb409ad85844d83e52d795b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classgmx_1_1DataFileFinder" kindref="compound">DataFileFinder</ref> &amp;</type>
        <definition>const DataFileFinder &amp; gmx::getLibraryFileFinder</definition>
        <argsstring>()</argsstring>
        <name>getLibraryFileFinder</name>
        <briefdescription>
<para>Gets a finder for locating data files from share/top/. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>Finder set with <ref refid="namespacegmx_1a106cb113fd73e054dbb8dfa2118d7153" kindref="member">setLibraryFileFinder()</ref>, or a default finder.</para></simplesect>
If <ref refid="namespacegmx_1a106cb113fd73e054dbb8dfa2118d7153" kindref="member">setLibraryFileFinder()</ref> has not been called (or a <computeroutput>NULL</computeroutput> finder has been set), a default finder is returned. The default finder searches data files from the directory identified by the global program context; it does not respect GMXLIB environment variable. Calling <ref refid="group__module__commandline_1ga8c376f5f94bd1a63a3a97e288c4be50d" kindref="member">initForCommandLine()</ref> sets a finder that respects GMXLIB.</para><para>Does not throw.</para><para>See <ref refid="namespacegmx_1a106cb113fd73e054dbb8dfa2118d7153" kindref="member">setLibraryFileFinder()</ref> for thread safety. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/futil.cpp" line="100" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/futil.cpp" bodystart="100" bodyend="107"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a106cb113fd73e054dbb8dfa2118d7153" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void gmx::setLibraryFileFinder</definition>
        <argsstring>(const DataFileFinder *finder)</argsstring>
        <name>setLibraryFileFinder</name>
        <param>
          <type>const <ref refid="classgmx_1_1DataFileFinder" kindref="compound">DataFileFinder</ref> *</type>
          <declname>finder</declname>
        </param>
        <briefdescription>
<para>Sets a finder for location data files from share/top/. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">finder</parametername>
</parameternamelist>
<parameterdescription>
<para>finder to set (can be NULL to restore the default finder).</para></parameterdescription>
</parameteritem>
</parameterlist>
The library does not take ownership of <computeroutput>finder</computeroutput>. The provided object must remain valid until the global instance is changed by another call to <ref refid="namespacegmx_1a106cb113fd73e054dbb8dfa2118d7153" kindref="member">setLibraryFileFinder()</ref>.</para><para>The global instance is used by <ref refid="futil_8h_1a07349956250b160526d32b00d15a544c" kindref="member">gmxlibfn()</ref> and <ref refid="futil_8h_1a5be6c498c4e4820ead110d48b4587210" kindref="member">libopen()</ref>.</para><para>This method is not thread-safe. See <ref refid="group__module__utility_1ga2cf34635c815cc712b6291c2c8da2555" kindref="member">setProgramContext()</ref>; the same constraints apply here as well.</para><para>Does not throw. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/futil.cpp" line="109" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/futil.cpp" bodystart="109" bodyend="112"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1gafa2ad45af8fbb383a015e1ed18e08fdf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool gmx::regexMatch</definition>
        <argsstring>(const char *str, const Regex &amp;regex)</argsstring>
        <name>regexMatch</name>
        <param>
          <type>const char *</type>
          <declname>str</declname>
        </param>
        <param>
          <type>const <ref refid="classgmx_1_1Regex" kindref="compound">Regex</ref> &amp;</type>
          <declname>regex</declname>
        </param>
        <briefdescription>
<para>Matches a string with a regular expression. </para>        </briefdescription>
        <detaileddescription>
<para> <libinternal /> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">str</parametername>
</parameternamelist>
<parameterdescription>
<para>String to match. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">regex</parametername>
</parameternamelist>
<parameterdescription>
<para>Regular expression to match. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if <computeroutput>regex</computeroutput> matches the whole <computeroutput>str</computeroutput>.</para></simplesect>
Does not throw currently, but this is subject to change if/when better error handling is implemented (currently, it returns false if the matching fails, e.g., because of out-of-memory). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/gmxregex.cpp" line="199" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/gmxregex.cpp" bodystart="199" bodyend="206"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aef8f91b0f9628e42c2809d541ca8b01e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool gmx::regexMatch</definition>
        <argsstring>(const std::string &amp;str, const Regex &amp;regex)</argsstring>
        <name>regexMatch</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>str</declname>
        </param>
        <param>
          <type>const <ref refid="classgmx_1_1Regex" kindref="compound">Regex</ref> &amp;</type>
          <declname>regex</declname>
        </param>
        <briefdescription>
<para>Matches a string with a regular expression. </para>        </briefdescription>
        <detaileddescription>
<para> <libinternal /> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">str</parametername>
</parameternamelist>
<parameterdescription>
<para>String to match. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">regex</parametername>
</parameternamelist>
<parameterdescription>
<para>Regular expression to match. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if <computeroutput>regex</computeroutput> matches the whole <computeroutput>str</computeroutput>.</para></simplesect>
Does not throw currently, but this is subject to change if/when better error handling is implemented (currently, it returns false if the matching fails, e.g., because of out-of-memory). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/gmxregex.cpp" line="208" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/gmxregex.cpp" bodystart="208" bodyend="211"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1gae00d174a8ddd5325460d74dc663711c0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void gmx::init</definition>
        <argsstring>(int *argc, char ***argv)</argsstring>
        <name>init</name>
        <param>
          <type>int *</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char ***</type>
          <declname>argv</declname>
        </param>
        <briefdescription>
<para>Initializes the GROMACS library. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">argc</parametername>
</parameternamelist>
<parameterdescription>
<para>argc value passed to <ref refid="test__selection_8cpp_1a0ddf1224851353fc92bfbff6f499fa97" kindref="member">main()</ref>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">argv</parametername>
</parameternamelist>
<parameterdescription>
<para>argv array passed to <ref refid="test__selection_8cpp_1a0ddf1224851353fc92bfbff6f499fa97" kindref="member">main()</ref>.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>argc</computeroutput> and <computeroutput>argv</computeroutput> are the command line arguments passed to <ref refid="test__selection_8cpp_1a0ddf1224851353fc92bfbff6f499fa97" kindref="member">main()</ref>. They are allowed to be NULL if GROMACS is not compiled with MPI, MPI_Init() has already been called, or if the MPI library GROMACS is compiled against allows it.</para><para>Does not throw. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/init.cpp" line="66" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/init.cpp" bodystart="66" bodyend="126"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1gaa0a90b2770cb4b69e16229daa271a1af" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void gmx::finalize</definition>
        <argsstring>()</argsstring>
        <name>finalize</name>
        <briefdescription>
<para>Deinitializes the GROMACS library. </para>        </briefdescription>
        <detaileddescription>
<para>Decrements the initialization counter, and calls MPI_Finalize() if GROMACS is compiled with MPI support and the counter has reached zero. In that case, it is not possible to reinitialize GROMACS after calling this function. Instead, call <ref refid="group__module__utility_1gae00d174a8ddd5325460d74dc663711c0" kindref="member">gmx::init()</ref> at a higher level, and note that calls to init can be nested safely. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/init.cpp" line="128" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/init.cpp" bodystart="128" bodyend="149"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1ga5ac09bdfd662fa49b0426432744f57be" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classgmx_1_1IProgramContext" kindref="compound">IProgramContext</ref> &amp;</type>
        <definition>const IProgramContext &amp; gmx::getProgramContext</definition>
        <argsstring>()</argsstring>
        <name>getProgramContext</name>
        <briefdescription>
<para>Returns the global <ref refid="classgmx_1_1IProgramContext" kindref="compound">IProgramContext</ref> instance. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The context set with <ref refid="group__module__utility_1ga2cf34635c815cc712b6291c2c8da2555" kindref="member">setProgramContext()</ref>.</para></simplesect>
If nothing has been set with <ref refid="group__module__utility_1ga2cf34635c815cc712b6291c2c8da2555" kindref="member">setProgramContext()</ref>, returns a default implementation that returns <computeroutput>&quot;GROMACS&quot;</computeroutput> for the program and display names, and empty strings for other values. The default implementation never throws.</para><para>Does not throw.</para><para>See <ref refid="group__module__utility_1ga2cf34635c815cc712b6291c2c8da2555" kindref="member">setProgramContext()</ref> for thread safety notes. You should not call this method in global deinitialization methods (e.g., destructors of global variables), since it is very difficult to clean up the state correctly in the presence of such calls. For example, <ref refid="group__module__commandline_1ga8c376f5f94bd1a63a3a97e288c4be50d" kindref="member">initForCommandLine()</ref> assumes that such calls do not exist to be able to free the context before exiting.</para><para><simplesect kind="see"><para><ref refid="classgmx_1_1IProgramContext" kindref="compound">IProgramContext</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/programcontext.cpp" line="89" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/programcontext.cpp" bodystart="89" bodyend="96"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1ga2cf34635c815cc712b6291c2c8da2555" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void gmx::setProgramContext</definition>
        <argsstring>(const IProgramContext *context)</argsstring>
        <name>setProgramContext</name>
        <param>
          <type>const <ref refid="classgmx_1_1IProgramContext" kindref="compound">IProgramContext</ref> *</type>
          <declname>context</declname>
        </param>
        <briefdescription>
<para>Sets the global <ref refid="classgmx_1_1IProgramContext" kindref="compound">IProgramContext</ref> instance. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">context</parametername>
</parameternamelist>
<parameterdescription>
<para>Program context to set (can be NULL to restore the default context).</para></parameterdescription>
</parameteritem>
</parameterlist>
The library does not take ownership of <computeroutput>context</computeroutput>. The provided object must remain valid until the global instance is changed by another call to <ref refid="group__module__utility_1ga2cf34635c815cc712b6291c2c8da2555" kindref="member">setProgramContext()</ref>.</para><para>This method is not thread-safe. It must be the first call to the library after <ref refid="group__module__utility_1gae00d174a8ddd5325460d74dc663711c0" kindref="member">gmx::init()</ref>, and multi-threaded access is only supported after the call completes. If GROMACS is getting called from multiple threads, or uses multiple threads simultaneously, changing the program context is not supported once it is set. If the context is cleared at the end of the program, the caller must ensure that all other threads have been terminated at this point. These constraints simplify the implementation significantly.</para><para>Does not throw.</para><para><simplesect kind="see"><para><ref refid="classgmx_1_1IProgramContext" kindref="compound">IProgramContext</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/programcontext.cpp" line="98" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/programcontext.cpp" bodystart="98" bodyend="101"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1aa097a11e79b9b187cadef998470f4e54" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void gmx::sfree_wrapper</definition>
        <argsstring>(T *p)</argsstring>
        <name>sfree_wrapper</name>
        <param>
          <type>T *</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>sfree wrapper to be used as <ref refid="classgmx_1_1scoped__cptr" kindref="compound">scoped_cptr</ref> deleter </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/scoped_cptr.h" line="54" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/scoped_cptr.h" bodystart="54" bodyend="57"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1gaea61e0b5bfc1f24f51a9eb5272b51603" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::size_t</type>
        <definition>std::size_t gmx::countWords</definition>
        <argsstring>(const char *s)</argsstring>
        <name>countWords</name>
        <param>
          <type>const char *</type>
          <declname>s</declname>
        </param>
        <briefdescription>
<para>Returns number of space-separated words in zero-terminated char ptr. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>Character pointer to zero-terminated, which will not be changed.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>number of words in string.</para></simplesect>
<simplesect kind="note"><para>This routine is mainly meant to support legacy code in GROMACS. For new source you should try hard to use C++ string objects instead. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.cpp" line="61" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.cpp" bodystart="61" bodyend="84"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1gae837a92609acdf559a6b8587e9233008" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::size_t</type>
        <definition>std::size_t gmx::countWords</definition>
        <argsstring>(const std::string &amp;str)</argsstring>
        <name>countWords</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>str</declname>
        </param>
        <briefdescription>
<para>Returns the number of space-separated words in a string object. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>str</parametername>
</parameternamelist>
<parameterdescription>
<para>Reference to string object, which will not be changed.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>number of words in string. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.cpp" line="88" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.cpp" bodystart="88" bodyend="92"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1ga8b22d1fd014cc09c9cf7c4c1615c0a1b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool gmx::endsWith</definition>
        <argsstring>(const char *str, const char *suffix)</argsstring>
        <name>endsWith</name>
        <param>
          <type>const char *</type>
          <declname>str</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>suffix</declname>
        </param>
        <briefdescription>
<para>Tests whether a string ends with another string. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">str</parametername>
</parameternamelist>
<parameterdescription>
<para>String to process. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">suffix</parametername>
</parameternamelist>
<parameterdescription>
<para>Suffix to find. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if <computeroutput>str</computeroutput> ends with <computeroutput>suffix</computeroutput>.</para></simplesect>
Returns true if <computeroutput>suffix</computeroutput> is NULL or empty. Does not throw. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.cpp" line="94" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.cpp" bodystart="94" bodyend="104"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1gaea84ff4850c382e09a3e158939b34b3e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string gmx::stripSuffixIfPresent</definition>
        <argsstring>(const std::string &amp;str, const char *suffix)</argsstring>
        <name>stripSuffixIfPresent</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>str</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>suffix</declname>
        </param>
        <briefdescription>
<para>Removes a suffix from a string. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">str</parametername>
</parameternamelist>
<parameterdescription>
<para>String to process. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">suffix</parametername>
</parameternamelist>
<parameterdescription>
<para>Suffix to remove. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>str</computeroutput> with <computeroutput>suffix</computeroutput> removed, or <computeroutput>str</computeroutput> unmodified if it does not end with <computeroutput>suffix</computeroutput>. </para></simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::bad_alloc</parametername>
</parameternamelist>
<parameterdescription>
<para>if out of memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
Returns <computeroutput>str</computeroutput> if <computeroutput>suffix</computeroutput> is NULL or empty. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.cpp" line="106" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.cpp" bodystart="106" bodyend="117"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1ga5f31464a19604fde038dba36307ac066" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string gmx::stripString</definition>
        <argsstring>(const std::string &amp;str)</argsstring>
        <name>stripString</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>str</declname>
        </param>
        <briefdescription>
<para>Removes leading and trailing whitespace from a string. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">str</parametername>
</parameternamelist>
<parameterdescription>
<para>String to process. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>str</computeroutput> with leading and trailing whitespaces removed. </para></simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::bad_alloc</parametername>
</parameternamelist>
<parameterdescription>
<para>if out of memory. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.cpp" line="119" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.cpp" bodystart="119" bodyend="132"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1gaed06df18ca6f9fc3f42bad9ea4d7e025" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string gmx::formatString</definition>
        <argsstring>(const char *fmt,...)</argsstring>
        <name>formatString</name>
        <param>
          <type>const char *</type>
          <declname>fmt</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
<para>Formats a string (snprintf() wrapper). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::bad_alloc</parametername>
</parameternamelist>
<parameterdescription>
<para>if out of memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
This function works like sprintf(), except that it returns an std::string instead of requiring a preallocated buffer. Arbitrary length output is supported. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.cpp" line="134" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.cpp" bodystart="134" bodyend="165"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1ga720e46b4a7625c675507adbea1df3f96" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::string &gt;</type>
        <definition>std::vector&lt; std::string &gt; gmx::splitString</definition>
        <argsstring>(const std::string &amp;str)</argsstring>
        <name>splitString</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>str</declname>
        </param>
        <briefdescription>
<para>Splits a string to whitespace separated tokens. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">str</parametername>
</parameternamelist>
<parameterdescription>
<para>String to process. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>str</computeroutput> split into tokens at each whitespace sequence. </para></simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::bad_alloc</parametername>
</parameternamelist>
<parameterdescription>
<para>if out of memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
This function works like <computeroutput>split</computeroutput> in Python, i.e., leading and trailing whitespace is ignored, and consecutive whitespaces are treated as a single separator. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.cpp" line="167" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.cpp" bodystart="167" bodyend="189"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1ga1e4d61dba5d6fb924b8888e5597d2d0f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string gmx::replaceAll</definition>
        <argsstring>(const std::string &amp;input, const char *from, const char *to)</argsstring>
        <name>replaceAll</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>input</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>from</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>to</declname>
        </param>
        <briefdescription>
<para>Replace all occurrences of a string with another string. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">input</parametername>
</parameternamelist>
<parameterdescription>
<para>Input string. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">from</parametername>
</parameternamelist>
<parameterdescription>
<para>String to find. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">to</parametername>
</parameternamelist>
<parameterdescription>
<para>String to use to replace <computeroutput>from</computeroutput>. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Copy of <computeroutput>input</computeroutput> with all occurrences of <computeroutput>from</computeroutput> replaced with <computeroutput>to</computeroutput>. </para></simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::bad_alloc</parametername>
</parameternamelist>
<parameterdescription>
<para>if out of memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
The replacement is greedy and not recursive: starting from the beginning of <computeroutput>input</computeroutput>, each match of <computeroutput>from</computeroutput> is replaced with <computeroutput>to</computeroutput>, and the search for the next match begins after the end of the previous match.</para><para>Compexity is O(N), where N is length of output.</para><para><simplesect kind="see"><para><ref refid="group__module__utility_1gaacdb65ab5673b946ea9764f708a4afcc" kindref="member">replaceAllWords()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.cpp" line="253" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.cpp" bodystart="253" bodyend="256"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1gaba6fb72c71891e47fc68c36167bee72e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string gmx::replaceAll</definition>
        <argsstring>(const std::string &amp;input, const std::string &amp;from, const std::string &amp;to)</argsstring>
        <name>replaceAll</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>input</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
<para>Replace all occurrences of a string with another string. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">input</parametername>
</parameternamelist>
<parameterdescription>
<para>Input string. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">from</parametername>
</parameternamelist>
<parameterdescription>
<para>String to find. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">to</parametername>
</parameternamelist>
<parameterdescription>
<para>String to use to replace <computeroutput>from</computeroutput>. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Copy of <computeroutput>input</computeroutput> with all occurrences of <computeroutput>from</computeroutput> replaced with <computeroutput>to</computeroutput>. </para></simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::bad_alloc</parametername>
</parameternamelist>
<parameterdescription>
<para>if out of memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
The replacement is greedy and not recursive: starting from the beginning of <computeroutput>input</computeroutput>, each match of <computeroutput>from</computeroutput> is replaced with <computeroutput>to</computeroutput>, and the search for the next match begins after the end of the previous match.</para><para>Compexity is O(N), where N is length of output.</para><para><simplesect kind="see"><para><ref refid="group__module__utility_1gaacdb65ab5673b946ea9764f708a4afcc" kindref="member">replaceAllWords()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.cpp" line="259" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.cpp" bodystart="259" bodyend="263"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1gaacdb65ab5673b946ea9764f708a4afcc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string gmx::replaceAllWords</definition>
        <argsstring>(const std::string &amp;input, const char *from, const char *to)</argsstring>
        <name>replaceAllWords</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>input</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>from</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>to</declname>
        </param>
        <briefdescription>
<para>Replace whole words with others. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">input</parametername>
</parameternamelist>
<parameterdescription>
<para>Input string. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">from</parametername>
</parameternamelist>
<parameterdescription>
<para>String to find. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">to</parametername>
</parameternamelist>
<parameterdescription>
<para>String to use to replace <computeroutput>from</computeroutput>. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Copy of <computeroutput>input</computeroutput> with all <computeroutput>from</computeroutput> words replaced with <computeroutput>to</computeroutput>. </para></simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::bad_alloc</parametername>
</parameternamelist>
<parameterdescription>
<para>if out of memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
Works as <ref refid="group__module__utility_1ga1e4d61dba5d6fb924b8888e5597d2d0f" kindref="member">replaceAll()</ref>, but a match is only considered if it is delimited by non-alphanumeric characters.</para><para><simplesect kind="see"><para><ref refid="group__module__utility_1ga1e4d61dba5d6fb924b8888e5597d2d0f" kindref="member">replaceAll()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.cpp" line="266" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.cpp" bodystart="266" bodyend="269"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1ga2df338df2e0b32b8c1fd032452409d57" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string gmx::replaceAllWords</definition>
        <argsstring>(const std::string &amp;input, const std::string &amp;from, const std::string &amp;to)</argsstring>
        <name>replaceAllWords</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>input</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
<para>Replace whole words with others. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">input</parametername>
</parameternamelist>
<parameterdescription>
<para>Input string. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">from</parametername>
</parameternamelist>
<parameterdescription>
<para>String to find. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">to</parametername>
</parameternamelist>
<parameterdescription>
<para>String to use to replace <computeroutput>from</computeroutput>. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Copy of <computeroutput>input</computeroutput> with all <computeroutput>from</computeroutput> words replaced with <computeroutput>to</computeroutput>. </para></simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::bad_alloc</parametername>
</parameternamelist>
<parameterdescription>
<para>if out of memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
Works as <ref refid="group__module__utility_1ga1e4d61dba5d6fb924b8888e5597d2d0f" kindref="member">replaceAll()</ref>, but a match is only considered if it is delimited by non-alphanumeric characters.</para><para><simplesect kind="see"><para><ref refid="group__module__utility_1ga1e4d61dba5d6fb924b8888e5597d2d0f" kindref="member">replaceAll()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.cpp" line="272" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.cpp" bodystart="272" bodyend="276"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1ga2f35bd1d4a654edabc2a3aaf6f6bccea" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool gmx::isNullOrEmpty</definition>
        <argsstring>(const char *str)</argsstring>
        <name>isNullOrEmpty</name>
        <param>
          <type>const char *</type>
          <declname>str</declname>
        </param>
        <briefdescription>
<para>Tests whether a string is null or empty. </para>        </briefdescription>
        <detaileddescription>
<para>Does not throw. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" line="62" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" bodystart="62" bodyend="65"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1ga8adb72aeb7775a649d7378c8e51321e6" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool gmx::startsWith</definition>
        <argsstring>(const std::string &amp;str, const std::string &amp;prefix)</argsstring>
        <name>startsWith</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>str</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>prefix</declname>
        </param>
        <briefdescription>
<para>Tests whether a string starts with another string. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">str</parametername>
</parameternamelist>
<parameterdescription>
<para>String to process. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">prefix</parametername>
</parameternamelist>
<parameterdescription>
<para>Prefix to find. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if <computeroutput>str</computeroutput> starts with <computeroutput>prefix</computeroutput>.</para></simplesect>
Returns true if <computeroutput>prefix</computeroutput> is empty. Does not throw. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" line="77" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" bodystart="77" bodyend="80"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1ga87824e9b26adc46671ccffa89f3985d0" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool gmx::startsWith</definition>
        <argsstring>(const char *str, const char *prefix)</argsstring>
        <name>startsWith</name>
        <param>
          <type>const char *</type>
          <declname>str</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>prefix</declname>
        </param>
        <briefdescription>
<para>Tests whether a string starts with another string. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">str</parametername>
</parameternamelist>
<parameterdescription>
<para>String to process. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">prefix</parametername>
</parameternamelist>
<parameterdescription>
<para>Prefix to find. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if <computeroutput>str</computeroutput> starts with <computeroutput>prefix</computeroutput>.</para></simplesect>
Returns true if <computeroutput>prefix</computeroutput> is empty. Does not throw. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" line="82" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" bodystart="82" bodyend="85"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1gaa1e33d963e2538664428c8db95ca564e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool gmx::endsWith</definition>
        <argsstring>(const std::string &amp;str, const char *suffix)</argsstring>
        <name>endsWith</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>str</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>suffix</declname>
        </param>
        <briefdescription>
<para>Tests whether a string ends with another string. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">str</parametername>
</parameternamelist>
<parameterdescription>
<para>String to process. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">suffix</parametername>
</parameternamelist>
<parameterdescription>
<para>Suffix to find. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if <computeroutput>str</computeroutput> ends with <computeroutput>suffix</computeroutput>.</para></simplesect>
Returns true if <computeroutput>suffix</computeroutput> is NULL or empty. Does not throw. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" line="99" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" bodystart="99" bodyend="102"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1ga5d6c1daa93bf46a2c397d179e007e3e8" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool gmx::contains</definition>
        <argsstring>(const std::string &amp;str, const char *substr)</argsstring>
        <name>contains</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>str</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>substr</declname>
        </param>
        <briefdescription>
<para>Tests whether a string contains another as a substring. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">str</parametername>
</parameternamelist>
<parameterdescription>
<para>String to process. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">substr</parametername>
</parameternamelist>
<parameterdescription>
<para>Substring to find. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if <computeroutput>str</computeroutput> contains <computeroutput>substr</computeroutput>.</para></simplesect>
Does not throw. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" line="113" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" bodystart="113" bodyend="116"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1gac0bef974d105fbfcc7e5362111eafed5" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool gmx::contains</definition>
        <argsstring>(const std::string &amp;str, const std::string &amp;substr)</argsstring>
        <name>contains</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>str</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>substr</declname>
        </param>
        <briefdescription>
<para>Tests whether a string contains another as a substring. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">str</parametername>
</parameternamelist>
<parameterdescription>
<para>String to process. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">substr</parametername>
</parameternamelist>
<parameterdescription>
<para>Substring to find. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if <computeroutput>str</computeroutput> contains <computeroutput>substr</computeroutput>.</para></simplesect>
Does not throw. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" line="118" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" bodystart="118" bodyend="121"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1ga555d78d19565dec63c740318187b4d0d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool gmx::endsWith</definition>
        <argsstring>(const std::string &amp;str, const std::string &amp;suffix)</argsstring>
        <name>endsWith</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>str</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>suffix</declname>
        </param>
        <briefdescription>
<para>Tests whether a string ends with another string. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">str</parametername>
</parameternamelist>
<parameterdescription>
<para>String to process. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">suffix</parametername>
</parameternamelist>
<parameterdescription>
<para>Suffix to find. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if <computeroutput>str</computeroutput> ends with <computeroutput>suffix</computeroutput>.</para></simplesect>
Returns true if <computeroutput>suffix</computeroutput> is NULL or empty. Does not throw. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" line="145" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" bodystart="145" bodyend="148"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1gaa21c247b747e12412da58cb9f6d500ef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename InputIterator</type>
          </param>
          <param>
            <type>typename FormatterType</type>
          </param>
        </templateparamlist>
        <type>std::string</type>
        <definition>std::string gmx::formatAndJoin</definition>
        <argsstring>(InputIterator begin, InputIterator end, const char *separator, const FormatterType &amp;formatter)</argsstring>
        <name>formatAndJoin</name>
        <param>
          <type>InputIterator</type>
          <declname>begin</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>end</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>separator</declname>
        </param>
        <param>
          <type>const FormatterType &amp;</type>
          <declname>formatter</declname>
        </param>
        <briefdescription>
<para>Formats all the range as strings, and then joins them with a separator in between. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">begin</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator the beginning of the range to join. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">end</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator the end of the range to join. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">separator</parametername>
</parameternamelist>
<parameterdescription>
<para>String to put in between the joined strings. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">formatter</parametername>
</parameternamelist>
<parameterdescription>
<para>Function object to format the objects in <computeroutput>container</computeroutput> as strings </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>All objects in the range from <computeroutput>begin</computeroutput> to <computeroutput>end</computeroutput> formatted as strings and concatenated with <computeroutput>separator</computeroutput> between each pair. </para></simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::bad_alloc</parametername>
</parameternamelist>
<parameterdescription>
<para>if out of memory. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" line="235" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" bodystart="235" bodyend="246"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1ga8e151e320e4072b2cc254b653077bb68" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ContainerType</type>
          </param>
          <param>
            <type>typename FormatterType</type>
          </param>
        </templateparamlist>
        <type>std::string</type>
        <definition>std::string gmx::formatAndJoin</definition>
        <argsstring>(const ContainerType &amp;container, const char *separator, const FormatterType &amp;formatter)</argsstring>
        <name>formatAndJoin</name>
        <param>
          <type>const ContainerType &amp;</type>
          <declname>container</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>separator</declname>
        </param>
        <param>
          <type>const FormatterType &amp;</type>
          <declname>formatter</declname>
        </param>
        <briefdescription>
<para>Formats all elements of the container as strings, and then joins them with a separator in between. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">container</parametername>
</parameternamelist>
<parameterdescription>
<para>Objects to join. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">separator</parametername>
</parameternamelist>
<parameterdescription>
<para>String to put in between the joined strings. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">formatter</parametername>
</parameternamelist>
<parameterdescription>
<para>Function object to format the objects in <computeroutput>container</computeroutput> as strings </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>All objects from <computeroutput>container</computeroutput> formatted as strings and concatenated with <computeroutput>separator</computeroutput> between each pair. </para></simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::bad_alloc</parametername>
</parameternamelist>
<parameterdescription>
<para>if out of memory. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" line="260" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" bodystart="260" bodyend="263"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1gae0ae45171d0f46a06095bf86855a8b28" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename InputIterator</type>
          </param>
        </templateparamlist>
        <type>std::string</type>
        <definition>std::string gmx::joinStrings</definition>
        <argsstring>(InputIterator begin, InputIterator end, const char *separator)</argsstring>
        <name>joinStrings</name>
        <param>
          <type>InputIterator</type>
          <declname>begin</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>end</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>separator</declname>
        </param>
        <briefdescription>
<para>Joins strings from a range with a separator in between. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">begin</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator the beginning of the range to join. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">end</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator the end of the range to join. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">separator</parametername>
</parameternamelist>
<parameterdescription>
<para>String to put in between the joined strings. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>All strings from (<computeroutput>begin</computeroutput>, <computeroutput>end</computeroutput>) concatenated with <computeroutput>separator</computeroutput> between each pair. </para></simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::bad_alloc</parametername>
</parameternamelist>
<parameterdescription>
<para>if out of memory. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" line="276" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" bodystart="276" bodyend="280"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1ga7dec76a57e8089a89f9298fb2fbaf2ed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ContainerType</type>
          </param>
        </templateparamlist>
        <type>std::string</type>
        <definition>std::string gmx::joinStrings</definition>
        <argsstring>(const ContainerType &amp;container, const char *separator)</argsstring>
        <name>joinStrings</name>
        <param>
          <type>const ContainerType &amp;</type>
          <declname>container</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>separator</declname>
        </param>
        <briefdescription>
<para>Joins strings from a container with a separator in between. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">container</parametername>
</parameternamelist>
<parameterdescription>
<para>Strings to join. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">separator</parametername>
</parameternamelist>
<parameterdescription>
<para>String to put in between the joined strings. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>All strings from <computeroutput>container</computeroutput> concatenated with <computeroutput>separator</computeroutput> between each pair. </para></simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::bad_alloc</parametername>
</parameternamelist>
<parameterdescription>
<para>if out of memory. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" line="292" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" bodystart="292" bodyend="295"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1ga31335553bd6174a68ad8d30c48de3df5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>size_t</type>
            <declname>count</declname>
            <defname>count</defname>
          </param>
        </templateparamlist>
        <type>std::string</type>
        <definition>std::string gmx::joinStrings</definition>
        <argsstring>(const char *const (&amp;array)[count], const char *separator)</argsstring>
        <name>joinStrings</name>
        <param>
          <type>const char *const (&amp;)</type>
          <declname>array</declname>
          <array>[count]</array>
        </param>
        <param>
          <type>const char *</type>
          <declname>separator</declname>
        </param>
        <briefdescription>
<para>Joins strings from an array with a separator in between. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">array</parametername>
</parameternamelist>
<parameterdescription>
<para>Array of strings to join. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">separator</parametername>
</parameternamelist>
<parameterdescription>
<para>String to put in between the joined strings. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>Deduced number of elements in <computeroutput>array</computeroutput>. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>All strings from <computeroutput>aray</computeroutput> concatenated with <computeroutput>separator</computeroutput> between each pair. </para></simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::bad_alloc</parametername>
</parameternamelist>
<parameterdescription>
<para>if out of memory. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" line="308" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" bodystart="308" bodyend="311"/>
      </memberdef>
      <memberdef kind="function" id="group__module__utility_1ga3862c8128924c3311429a4dadf075ecc" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const char *</type>
        <definition>static const char* gmx::boolToString</definition>
        <argsstring>(bool value)</argsstring>
        <name>boolToString</name>
        <param>
          <type>bool</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Converts a boolean to a &quot;true&quot;/&quot;false&quot; string. </para>        </briefdescription>
        <detaileddescription>
<para>Does not throw. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" line="318" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/gromacs/utility/stringutil.h" bodystart="318" bodyend="321"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a79ab84fc76c89c13dcc7bd753a720d90" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespacegmx_1a8593c4aa4e1f10f3571c8b8f2cd933a8" kindref="member">integrator_t</ref> *</type>
        <definition>static integrator_t* gmx::my_integrator</definition>
        <argsstring>(unsigned int ei)</argsstring>
        <name>my_integrator</name>
        <param>
          <type>unsigned int</type>
          <declname>ei</declname>
        </param>
        <briefdescription>
<para>Return the correct integrator function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/programs/mdrun/runner.cpp" line="641" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/programs/mdrun/runner.cpp" bodystart="641" bodyend="675"/>
      </memberdef>
      <memberdef kind="function" id="namespacegmx_1a112ad714d9aa4e824fdad2c3b4ed75db" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int gmx::mdrunner</definition>
        <argsstring>(gmx_hw_opt_t *hw_opt, FILE *fplog, struct t_commrec *cr, int nfile, const t_filenm fnm[], const gmx_output_env_t *oenv, gmx_bool bVerbose, int nstglobalcomm, ivec ddxyz, int dd_rank_order, int npme, real rdd, real rconstr, const char *dddlb_opt, real dlb_scale, const char *ddcsx, const char *ddcsy, const char *ddcsz, const char *nbpu_opt, int nstlist_cmdline, gmx_int64_t nsteps_cmdline, int nstepout, int resetstep, int nmultisim, int repl_ex_nst, int repl_ex_nex, int repl_ex_seed, real pforce, real cpt_period, real max_hours, int imdport, unsigned long Flags)</argsstring>
        <name>mdrunner</name>
        <param>
          <type><ref refid="structgmx__hw__opt__t" kindref="compound">gmx_hw_opt_t</ref> *</type>
          <declname>hw_opt</declname>
        </param>
        <param>
          <type>FILE *</type>
          <declname>fplog</declname>
        </param>
        <param>
          <type>struct <ref refid="structt__commrec" kindref="compound">t_commrec</ref> *</type>
          <declname>cr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nfile</declname>
        </param>
        <param>
          <type>const <ref refid="structt__filenm" kindref="compound">t_filenm</ref></type>
          <declname>fnm</declname>
          <array>[]</array>
        </param>
        <param>
          <type>const <ref refid="structgmx__output__env__t" kindref="compound">gmx_output_env_t</ref> *</type>
          <declname>oenv</declname>
        </param>
        <param>
          <type><ref refid="basedefinitions_8h_1a8fddad319f226e856400d190198d5151" kindref="member">gmx_bool</ref></type>
          <declname>bVerbose</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nstglobalcomm</declname>
        </param>
        <param>
          <type>ivec</type>
          <declname>ddxyz</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dd_rank_order</declname>
        </param>
        <param>
          <type>int</type>
          <declname>npme</declname>
        </param>
        <param>
          <type><ref refid="real_8h_1a58a0c7cf2501f4492da833421be92547" kindref="member">real</ref></type>
          <declname>rdd</declname>
        </param>
        <param>
          <type><ref refid="real_8h_1a58a0c7cf2501f4492da833421be92547" kindref="member">real</ref></type>
          <declname>rconstr</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>dddlb_opt</declname>
        </param>
        <param>
          <type><ref refid="real_8h_1a58a0c7cf2501f4492da833421be92547" kindref="member">real</ref></type>
          <declname>dlb_scale</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>ddcsx</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>ddcsy</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>ddcsz</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>nbpu_opt</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nstlist_cmdline</declname>
        </param>
        <param>
          <type>gmx_int64_t</type>
          <declname>nsteps_cmdline</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nstepout</declname>
        </param>
        <param>
          <type>int</type>
          <declname>resetstep</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nmultisim</declname>
        </param>
        <param>
          <type>int</type>
          <declname>repl_ex_nst</declname>
        </param>
        <param>
          <type>int</type>
          <declname>repl_ex_nex</declname>
        </param>
        <param>
          <type>int</type>
          <declname>repl_ex_seed</declname>
        </param>
        <param>
          <type><ref refid="real_8h_1a58a0c7cf2501f4492da833421be92547" kindref="member">real</ref></type>
          <declname>pforce</declname>
        </param>
        <param>
          <type><ref refid="real_8h_1a58a0c7cf2501f4492da833421be92547" kindref="member">real</ref></type>
          <declname>cpt_period</declname>
        </param>
        <param>
          <type><ref refid="real_8h_1a58a0c7cf2501f4492da833421be92547" kindref="member">real</ref></type>
          <declname>max_hours</declname>
        </param>
        <param>
          <type>int</type>
          <declname>imdport</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>Flags</declname>
        </param>
        <briefdescription>
<para>Driver routine, that calls the different methods. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">hw_opt</parametername>
</parameternamelist>
<parameterdescription>
<para>Hardware detection structure </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fplog</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classgmx_1_1File" kindref="compound">File</ref> pointer for log file </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cr</parametername>
</parameternamelist>
<parameterdescription>
<para>Communication data </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nfile</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of files </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fnm</parametername>
</parameternamelist>
<parameterdescription>
<para>Array of filenames and file properties </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">oenv</parametername>
</parameternamelist>
<parameterdescription>
<para>Output variables for storing xvg files etc. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">bVerbose</parametername>
</parameternamelist>
<parameterdescription>
<para>Verbose output or not </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nstglobalcomm</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of steps between global communication </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ddxyz</parametername>
</parameternamelist>
<parameterdescription>
<para>Division of sub-boxes over processors for use in domain decomposition parallellization </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">dd_rank_order</parametername>
</parameternamelist>
<parameterdescription>
<para>Ordering of the PP and PME ranks </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">npme</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of separate PME ranks requested, -1 = auto </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">rdd</parametername>
</parameternamelist>
<parameterdescription>
<para>The maximum distance for bonded interactions with DD (nm) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">rconstr</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximum distance for P-LINCS (nm) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">dddlb_opt</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classgmx_1_1File" kindref="compound">File</ref> name for debugging </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">dlb_scale</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classgmx_1_1File" kindref="compound">File</ref> name for debugging </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ddcsx</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classgmx_1_1File" kindref="compound">File</ref> name for debugging </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ddcsy</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classgmx_1_1File" kindref="compound">File</ref> name for debugging </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ddcsz</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classgmx_1_1File" kindref="compound">File</ref> name for debugging </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nbpu_opt</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of nonbonded processing unit </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nstlist_cmdline</parametername>
</parameternamelist>
<parameterdescription>
<para>Override neighbor search frequency </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nsteps_cmdline</parametername>
</parameternamelist>
<parameterdescription>
<para>Override number of simulation steps </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nstepout</parametername>
</parameternamelist>
<parameterdescription>
<para>How often to write to the console </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">resetstep</parametername>
</parameternamelist>
<parameterdescription>
<para>Reset the step counter </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">nmultisim</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of parallel simulations to run </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">repl_ex_nst</parametername>
</parameternamelist>
<parameterdescription>
<para>Number steps between replica exchange attempts </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">repl_ex_nex</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of replicas in REMD </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">repl_ex_seed</parametername>
</parameternamelist>
<parameterdescription>
<para>The seed for Monte Carlo swaps </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">pforce</parametername>
</parameternamelist>
<parameterdescription>
<para>Minimum force for printing (for debugging) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cpt_period</parametername>
</parameternamelist>
<parameterdescription>
<para>How often to checkpoint the simulation </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">max_hours</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximume length of the simulation (wall time) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">imdport</parametername>
</parameternamelist>
<parameterdescription>
<para>Interactive MD port (socket) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">Flags</parametername>
</parameternamelist>
<parameterdescription>
<para>More command line options </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/programs/mdrun/runner.cpp" line="677" column="1" bodyfile="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/src/programs/mdrun/runner.cpp" bodystart="677" bodyend="1408"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Generic GROMACS namespace. </para>    </briefdescription>
    <detaileddescription>
<para>Functionality for testing whether calls to mdrun produce the same energy and force quantities when they should do so.</para><para>Declares registerLegacyModules().</para><para>Declares the integrator for test particle insertion.</para><para>Declares the integrators for energy minimization and NMA.</para><para>Convenience macro to help us avoid ifdefs each time we use sysconf.</para><para><simplesect kind="author"><para>David van der Spoel <ulink url="mailto:david.vanderspoel@icm.uu.se">david.vanderspoel@icm.uu.se</ulink></para><simplesectsep/><para>Berk Hess <ulink url="mailto:hess@kth.se">hess@kth.se</ulink></para></simplesect>
</para><internal><para><simplesect kind="author"><para>Teemu Murtola <ulink url="mailto:teemu.murtola@gmail.com">teemu.murtola@gmail.com</ulink></para></simplesect>
 <libinternal />  </para></internal>
    </detaileddescription>
    <location file="/mnt/workspace/Release_workflow_2016/gromacs-2016.3/docs/doxygen/misc.cpp" line="46" column="1"/>
  </compounddef>
</doxygen>
