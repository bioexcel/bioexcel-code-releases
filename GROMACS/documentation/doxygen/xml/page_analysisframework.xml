<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.5">
  <compounddef id="page_analysisframework" kind="page">
    <compoundname>page_analysisframework</compoundname>
    <title>Framework for trajectory analysis</title>
    <innerpage refid="page_analysisnbsearch">Neighborhood search for analysis tools</innerpage>
    <innerpage refid="page_analysistemplate">Example code for writing trajectory analysis tools</innerpage>
    <innerpage refid="page_selections">Dynamic selections</innerpage>
    <innerpage refid="page_analysisdata">Analysis output data handling</innerpage>
    <detaileddescription>
<para>GROMACS provides a framework for implementing flexible trajectory analysis routines. It consists of a few components that can also be used individually, but in most cases it is desirable to use features from all of them to get most out of the framework. The main features are:</para><para><itemizedlist>
<listitem><para>Support for flexible selections that can be used to provide the set of coordinates to analyze. They can be dynamic, i.e., select different atoms for different trajectory frames, and also support evaluation of center-of-mass/center-of-geometry coordinates for a group of atoms. The latter means that a tool written to use the framework can automatically analyze also center-of-mass positions (or a mixture of center-of-mass and atomic positions) in addition to real atomic positions.</para></listitem><listitem><para>Support for per-frame parallelization. The framework is designed to support running the analysis in parallel for multiple frames for cases where different frames can be analyzed (mostly) independently. At this time, the actual parallelization is not implemented, but tools written to use the framework should be able to take advantage of it as soon as it materializes with no or minimal changes.</para></listitem><listitem><para>Access to a library of basic analysis routines. Things such as computing averages and histogramming are provided as reusable modules.</para></listitem><listitem><para>Tool code can focus on the actual analysis. Tools are implemented by subclassing an abstract class and providing an implementation for selected pure virtual methods. The framework takes care of initialization tasks, loading the trajectory and looping over it, evaluating selections, and also provides basic features like making molecules whole before passing the frame to the analysis code. This approach also makes it possible to reuse the same tool code from a scripting language such as Python simply by implementing general support for such language bindings in the framework (no such integration is implemented at this time, though).</para></listitem></itemizedlist>
</para><para>There are also some reusable analysis routines that can be used independent of the framework:<itemizedlist>
<listitem><para><ref refid="page_analysisnbsearch" kindref="compound">Neighborhood search for analysis tools</ref></para></listitem></itemizedlist>
</para><para>For a crash course on how to implement an analysis tool using the framework, see <ref refid="page_analysistemplate" kindref="compound">Example code for writing trajectory analysis tools</ref>.</para><para><heading level="1">High-level framework </heading>
</para><para>The <ref refid="group__module__trajectoryanalysis" kindref="compound">Framework for Trajectory Analysis (trajectoryanalysis)</ref> module provides the high-level framework that integrates all the pieces together. It provides the abstract base class for analysis tool modules (<ref refid="classgmx_1_1TrajectoryAnalysisModule" kindref="compound">gmx::TrajectoryAnalysisModule</ref>), and the code that runs such a module as a command-line tool (<ref refid="classgmx_1_1TrajectoryAnalysisCommandLineRunner" kindref="compound">gmx::TrajectoryAnalysisCommandLineRunner</ref>). See the <ref refid="page_analysistemplate" kindref="compound">analysis template</ref> and the <ref refid="group__module__trajectoryanalysis" kindref="compound">trajectoryanalysis module documentation</ref> for more details.</para><para><heading level="1">Selections </heading>
</para><para>The <ref refid="group__module__selection" kindref="compound">Parsing and Evaluation of Analysis Selections (selection)</ref> module provides the support for selections. Most of the work of managing the selections is taken care by the command-line runner and the framework, and the analysis tool code only sees two main classes:</para><para><itemizedlist>
<listitem><para><ref refid="classgmx_1_1SelectionOption" kindref="compound">gmx::SelectionOption</ref> and associated classes are used to declare the number and type of selections the tool accepts (see below for <ulink url="#section_analysisframework_options">details of the option support</ulink>).</para></listitem><listitem><para>The tool receives a set of <ref refid="classgmx_1_1Selection" kindref="compound">gmx::Selection</ref> objects as a value of the selection option. These classes provide the evaluated values for the selections during the analysis. The framework evaluates them for each frame such that when the tool is called, it can access the selections for the current frame in the <ref refid="classgmx_1_1Selection" kindref="compound">gmx::Selection</ref> objects it owns.</para></listitem></itemizedlist>
</para><para>A conceptual overview of the selection engine is available on a separate page: <ref refid="page_selections" kindref="compound">Dynamic selections</ref>. In the full internal documentation, this page also provides an overview of the implementation of the selections.</para><para>More technical details of the selection engine are also available in the <ref refid="group__module__selection" kindref="compound">selection module documentation</ref>. This is useful in particular for understanding how the selections work in detail, or if you want to use the selection code outside the trajectory analysis framework.</para><para>The selection module also provides functionality to do neighborhood searching in analysis tools. For the most common case of full 3D periodic boundary conditions, grid-based searching is implemented. See <ref refid="classgmx_1_1AnalysisNeighborhood" kindref="compound">gmx::AnalysisNeighborhood</ref> for more details. This class can be used independently of other selection functionality.</para><para><heading level="1">Output data handling </heading>
</para><para>The <ref refid="group__module__analysisdata" kindref="compound">Parallelizable Handling of Output Data (analysisdata)</ref> module provides two things:</para><para><itemizedlist>
<listitem><para>Support for uniformly providing output data from analysis tools. Tools compute their output values and place them into a <emphasis>data object</emphasis> for further processing. This allows two things:<itemizedlist>
<listitem><para>Reusable data modules can be applied across different tools to do common post-processing.</para></listitem><listitem><para>The data object provides parallelization support.</para></listitem></itemizedlist>
</para></listitem><listitem><para>Set of reusable data modules for post-processing the data. These include functionality like averaging data, computing histograms, and plotting the data into a file. Many of these modules also provide their output as a data object, allowing further data modules to be attached to them.</para></listitem></itemizedlist>
</para><para>The general concept is explained in more detail on a separate page: <ref refid="page_analysisdata" kindref="compound">Analysis output data handling</ref>. The <ref refid="group__module__analysisdata" kindref="compound">analysisdata module documentation</ref> provides more technical details.</para><sect1 id="page_analysisframework_1section_analysisframework_options">
<title>Input options </title>
<para>To declare input data for the tool (typically, command-line options, including input files and selections), <ref refid="group__module__options" kindref="compound">Extensible Handling of Options (options)</ref> module is used. The analysis tool code receives an instance of <ref refid="classgmx_1_1IOptionsContainer" kindref="compound">gmx::IOptionsContainer</ref> for one of its initialization methods, and uses it to provide its input options. Basic options are declared in <ref refid="basicoptions_8h" kindref="compound">basicoptions.h</ref>, and also <ref refid="classgmx_1_1SelectionOption" kindref="compound">gmx::SelectionOption</ref> is used in the same manner. For each option, the tool declares a local variable that will receive the value for that option. After the options are parsed from the command line (by the framework), the tool code can read the values from these variables. The option declarations filled into the <ref refid="classgmx_1_1IOptionsContainer" kindref="compound">gmx::IOptionsContainer</ref> object are also used to provide help to the user (also handled by the framework). See the documentation for <ref refid="classgmx_1_1TrajectoryAnalysisModule" kindref="compound">gmx::TrajectoryAnalysisModule</ref> and the <ref refid="group__module__options" kindref="compound">options module documentation</ref> for more details. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
