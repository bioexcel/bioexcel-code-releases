<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Gromacs: gmx Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Gromacs
   &#160;<span id="projectnumber">2018.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.xhtml"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.xhtml"><span>Modules</span></a></li>
      <li><a href="pages.xhtml"><span>Other&#160;Docs</span></a></li>
      <li class="current"><a href="namespaces.xhtml"><span>Namespaces</span></a></li>
      <li><a href="annotated.xhtml"><span>Classes</span></a></li>
      <li><a href="files.xhtml"><span>Files</span></a></li>
      <li><a href="examples.xhtml"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.xhtml"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.xhtml"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">gmx Namespace Reference<div class="ingroups"><a class="el" href="group__group__publicapi.xhtml">Public API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Generic GROMACS namespace. </p>
<p>Declares the integrator for test particle insertion.</p>
<p>Declares the integrators for energy minimization and NMA.</p>
<p>Convenience macro to help us avoid ifdefs each time we use sysconf.</p>
<dl class="section author"><dt>Author</dt><dd>David van der Spoel <a href="#" onclick="location.href='mai'+'lto:'+'dav'+'id'+'.va'+'nd'+'ers'+'po'+'el@'+'ic'+'m.u'+'u.'+'se'; return false;">david<span style="display: none;">.nosp@m.</span>.van<span style="display: none;">.nosp@m.</span>dersp<span style="display: none;">.nosp@m.</span>oel@<span style="display: none;">.nosp@m.</span>icm.u<span style="display: none;">.nosp@m.</span>u.se</a></dd>
<dd>
Berk Hess <a href="#" onclick="location.href='mai'+'lto:'+'hes'+'s@'+'kth'+'.s'+'e'; return false;">hess@<span style="display: none;">.nosp@m.</span>kth.<span style="display: none;">.nosp@m.</span>se</a> </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AbstractAnalysisData.xhtml">AbstractAnalysisData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for all objects that provide data.  <a href="classgmx_1_1AbstractAnalysisData.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisData.xhtml">AnalysisData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelizable data container for raw data.  <a href="classgmx_1_1AnalysisData.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataHandle.xhtml">AnalysisDataHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle for inserting data into <a class="el" href="classgmx_1_1AnalysisData.xhtml" title="Parallelizable data container for raw data. ">AnalysisData</a>.  <a href="classgmx_1_1AnalysisDataHandle.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AbstractAnalysisArrayData.xhtml">AbstractAnalysisArrayData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for data objects that present in-memory data.  <a href="classgmx_1_1AbstractAnalysisArrayData.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisArrayData.xhtml">AnalysisArrayData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple in-memory data array.  <a href="classgmx_1_1AnalysisArrayData.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataValue.xhtml">AnalysisDataValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type for representing a single value in analysis data objects.  <a href="classgmx_1_1AnalysisDataValue.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataFrameHeader.xhtml">AnalysisDataFrameHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type for storing frame-level information for analysis data.  <a href="classgmx_1_1AnalysisDataFrameHeader.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataPointSetRef.xhtml">AnalysisDataPointSetRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type wrapper for non-mutable access to a set of data column values.  <a href="classgmx_1_1AnalysisDataPointSetRef.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataFrameRef.xhtml">AnalysisDataFrameRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type wrapper for non-mutable access to a data frame.  <a href="classgmx_1_1AnalysisDataFrameRef.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1IAnalysisDataModule.xhtml">IAnalysisDataModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for a module that gets notified whenever data is added.  <a href="classgmx_1_1IAnalysisDataModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataModuleSerial.xhtml">AnalysisDataModuleSerial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience base class for serial analysis data modules.  <a href="classgmx_1_1AnalysisDataModuleSerial.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataModuleParallel.xhtml">AnalysisDataModuleParallel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience base class for parallel analysis data modules.  <a href="classgmx_1_1AnalysisDataModuleParallel.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataAverageModule.xhtml">AnalysisDataAverageModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data module for independently averaging each column in input data.  <a href="classgmx_1_1AnalysisDataAverageModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataFrameAverageModule.xhtml">AnalysisDataFrameAverageModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data module for averaging of columns for each frame.  <a href="classgmx_1_1AnalysisDataFrameAverageModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataDisplacementModule.xhtml">AnalysisDataDisplacementModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data module for calculating displacements.  <a href="classgmx_1_1AnalysisDataDisplacementModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisHistogramSettingsInitializer.xhtml">AnalysisHistogramSettingsInitializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides "named parameter" idiom for constructing histograms.  <a href="classgmx_1_1AnalysisHistogramSettingsInitializer.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisHistogramSettings.xhtml">AnalysisHistogramSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains parameters that specify histogram bin locations.  <a href="classgmx_1_1AnalysisHistogramSettings.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AbstractAverageHistogram.xhtml">AbstractAverageHistogram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for representing histograms averaged over frames.  <a href="classgmx_1_1AbstractAverageHistogram.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataSimpleHistogramModule.xhtml">AnalysisDataSimpleHistogramModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data module for per-frame histograms.  <a href="classgmx_1_1AnalysisDataSimpleHistogramModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataWeightedHistogramModule.xhtml">AnalysisDataWeightedHistogramModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data module for per-frame weighted histograms.  <a href="classgmx_1_1AnalysisDataWeightedHistogramModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataBinAverageModule.xhtml">AnalysisDataBinAverageModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data module for bin averages.  <a href="classgmx_1_1AnalysisDataBinAverageModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataLifetimeModule.xhtml">AnalysisDataLifetimeModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data module for computing lifetime histograms for columns in input data.  <a href="classgmx_1_1AnalysisDataLifetimeModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataPlotSettings.xhtml">AnalysisDataPlotSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common settings for data plots.  <a href="classgmx_1_1AnalysisDataPlotSettings.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AbstractPlotModule.xhtml">AbstractPlotModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract data module for writing data into a file.  <a href="classgmx_1_1AbstractPlotModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataPlotModule.xhtml">AnalysisDataPlotModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting module for straightforward plotting of data.  <a href="classgmx_1_1AnalysisDataPlotModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisDataVectorPlotModule.xhtml">AnalysisDataVectorPlotModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting module specifically for data consisting of vectors.  <a href="classgmx_1_1AnalysisDataVectorPlotModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1ArrayRef.xhtml">ArrayRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like container for an interface to a C array of T (or part of a std::vector&lt;T, A&gt; or std::array&lt;T&gt;).  <a href="classgmx_1_1ArrayRef.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1CommandLineHelpWriter.xhtml">CommandLineHelpWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes help information for <a class="el" href="classgmx_1_1Options.xhtml" title="Collection of options. ">Options</a>.  <a href="classgmx_1_1CommandLineHelpWriter.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1CommandLineModuleSettings.xhtml">CommandLineModuleSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Settings to pass information between a module and the general runner.  <a href="classgmx_1_1CommandLineModuleSettings.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1ICommandLineModule.xhtml">ICommandLineModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module that can be run from command line using CommandLineModuleManager.  <a href="classgmx_1_1ICommandLineModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1ICommandLineOptionsModuleSettings.xhtml">ICommandLineOptionsModuleSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Settings to pass information between a CommandLineOptionsModule and generic code that runs it.  <a href="classgmx_1_1ICommandLineOptionsModuleSettings.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1ICommandLineOptionsModule.xhtml">ICommandLineOptionsModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module that can be run from a command line and uses <a class="el" href="classgmx_1_1Options.xhtml" title="Collection of options. ">gmx::Options</a> for argument processing.  <a href="classgmx_1_1ICommandLineOptionsModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1CommandLineParser.xhtml">CommandLineParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements command-line parsing for <a class="el" href="classgmx_1_1Options.xhtml" title="Collection of options. ">Options</a> objects.  <a href="classgmx_1_1CommandLineParser.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgmx_1_1StaticLog2.xhtml">StaticLog2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate log2(n) for integer n statically at compile time.  <a href="structgmx_1_1StaticLog2.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgmx_1_1StaticLog2_3_011_01_4.xhtml">StaticLog2&lt; 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of StaticLog2&lt;n&gt; for n==1.  <a href="structgmx_1_1StaticLog2_3_011_01_4.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgmx_1_1StaticLog2_3_010_01_4.xhtml">StaticLog2&lt; 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of StaticLog2&lt;n&gt; for n==0.  <a href="structgmx_1_1StaticLog2_3_010_01_4.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1BasicVector.xhtml">BasicVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ class for 3D vectors.  <a href="classgmx_1_1BasicVector.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AbstractOption.xhtml">AbstractOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for specifying option properties.  <a href="classgmx_1_1AbstractOption.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1OptionTemplate.xhtml">OptionTemplate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated base class for constructing concrete option settings classes.  <a href="classgmx_1_1OptionTemplate.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1OptionInfo.xhtml">OptionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives information and allows modifications to an option after creation.  <a href="classgmx_1_1OptionInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AbstractOptionSection.xhtml">AbstractOptionSection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for specifying option section properties.  <a href="classgmx_1_1AbstractOptionSection.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AbstractOptionSectionHandle.xhtml">AbstractOptionSectionHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for handles to option sections.  <a href="classgmx_1_1AbstractOptionSectionHandle.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1BooleanOption.xhtml">BooleanOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies an option that provides boolean values.  <a href="classgmx_1_1BooleanOption.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1IntegerOption.xhtml">IntegerOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies an option that provides integer values.  <a href="classgmx_1_1IntegerOption.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Int64Option.xhtml">Int64Option</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies an option that provides 64-bit integer values.  <a href="classgmx_1_1Int64Option.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1DoubleOption.xhtml">DoubleOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies an option that provides floating-point (double) values.  <a href="classgmx_1_1DoubleOption.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1FloatOption.xhtml">FloatOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies an option that provides floating-point (float) values.  <a href="classgmx_1_1FloatOption.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1StringOption.xhtml">StringOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies an option that provides string values.  <a href="classgmx_1_1StringOption.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1EnumOption.xhtml">EnumOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies an option that accepts enumerated string values and writes the selected index into an <code>enum</code> variable.  <a href="classgmx_1_1EnumOption.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1BooleanOptionInfo.xhtml">BooleanOptionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for accessing boolean option information.  <a href="classgmx_1_1BooleanOptionInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1IntegerOptionInfo.xhtml">IntegerOptionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for accessing integer option information.  <a href="classgmx_1_1IntegerOptionInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Int64OptionInfo.xhtml">Int64OptionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for accessing 64-bit integer option information.  <a href="classgmx_1_1Int64OptionInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1DoubleOptionInfo.xhtml">DoubleOptionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for accessing floating-point option information.  <a href="classgmx_1_1DoubleOptionInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1FloatOptionInfo.xhtml">FloatOptionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for accessing floating-point option information.  <a href="classgmx_1_1FloatOptionInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1StringOptionInfo.xhtml">StringOptionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for accessing string option information.  <a href="classgmx_1_1StringOptionInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1EnumOptionInfo.xhtml">EnumOptionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for accessing enum option information.  <a href="classgmx_1_1EnumOptionInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1FileNameOption.xhtml">FileNameOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies an option that provides file names.  <a href="classgmx_1_1FileNameOption.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1FileNameOptionInfo.xhtml">FileNameOptionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for accessing file name option information.  <a href="classgmx_1_1FileNameOptionInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1FileNameOptionManager.xhtml">FileNameOptionManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles interaction of file name options with global options.  <a href="classgmx_1_1FileNameOptionManager.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1IOptionsBehavior.xhtml">IOptionsBehavior</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to provide extension points for options parsing.  <a href="classgmx_1_1IOptionsBehavior.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1IOptionsContainer.xhtml">IOptionsContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for adding input options.  <a href="classgmx_1_1IOptionsContainer.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1IOptionsContainerWithSections.xhtml">IOptionsContainerWithSections</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for adding input options with sections.  <a href="classgmx_1_1IOptionsContainerWithSections.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1IOptionManager.xhtml">IOptionManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for option managers.  <a href="classgmx_1_1IOptionManager.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Options.xhtml">Options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of options.  <a href="classgmx_1_1Options.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1OptionSection.xhtml">OptionSection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a simple option section.  <a href="classgmx_1_1OptionSection.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1OptionSectionHandle.xhtml">OptionSectionHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows adding options to an <a class="el" href="classgmx_1_1OptionSection.xhtml" title="Declares a simple option section. ">OptionSection</a>.  <a href="classgmx_1_1OptionSectionHandle.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1RepeatingOptionSectionHandle.xhtml">RepeatingOptionSectionHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows adding options to an <a class="el" href="classgmx_1_1RepeatingOptionSection.xhtml" title="Declares an option section that creates a structure for each instance. ">RepeatingOptionSection</a>.  <a href="classgmx_1_1RepeatingOptionSectionHandle.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1RepeatingOptionSection.xhtml">RepeatingOptionSection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares an option section that creates a structure for each instance.  <a href="classgmx_1_1RepeatingOptionSection.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1TimeUnitManager.xhtml">TimeUnitManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides common functionality for time unit conversions.  <a href="classgmx_1_1TimeUnitManager.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1TimeUnitBehavior.xhtml">TimeUnitBehavior</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgmx_1_1Options.xhtml" title="Collection of options. ">Options</a> behavior to add a time unit option.  <a href="classgmx_1_1TimeUnitBehavior.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1ExponentialDistribution.xhtml">ExponentialDistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponential distribution.  <a href="classgmx_1_1ExponentialDistribution.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1GammaDistribution.xhtml">GammaDistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gamma distribution.  <a href="classgmx_1_1GammaDistribution.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1NormalDistribution.xhtml">NormalDistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal distribution.  <a href="classgmx_1_1NormalDistribution.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1TabulatedNormalDistribution.xhtml">TabulatedNormalDistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tabulated normal random distribution.  <a href="classgmx_1_1TabulatedNormalDistribution.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1ThreeFry2x64General.xhtml">ThreeFry2x64General</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General implementation class for ThreeFry counter-based random engines.  <a href="classgmx_1_1ThreeFry2x64General.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1ThreeFry2x64.xhtml">ThreeFry2x64</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgmx_1_1ThreeFry2x64.xhtml" title="ThreeFry2x64 random engine with 20 iteractions. ">ThreeFry2x64</a> random engine with 20 iteractions.  <a href="classgmx_1_1ThreeFry2x64.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1ThreeFry2x64Fast.xhtml">ThreeFry2x64Fast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgmx_1_1ThreeFry2x64.xhtml" title="ThreeFry2x64 random engine with 20 iteractions. ">ThreeFry2x64</a> random engine with 13 iteractions.  <a href="classgmx_1_1ThreeFry2x64Fast.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1UniformIntDistribution.xhtml">UniformIntDistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform integer distribution.  <a href="classgmx_1_1UniformIntDistribution.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1UniformRealDistribution.xhtml">UniformRealDistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform real distribution.  <a href="classgmx_1_1UniformRealDistribution.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisNeighborhoodPositions.xhtml">AnalysisNeighborhoodPositions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input positions for neighborhood searching.  <a href="classgmx_1_1AnalysisNeighborhoodPositions.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisNeighborhood.xhtml">AnalysisNeighborhood</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighborhood searching for analysis tools.  <a href="classgmx_1_1AnalysisNeighborhood.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisNeighborhoodPair.xhtml">AnalysisNeighborhoodPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type to represent a pair of positions found in neighborhood searching.  <a href="classgmx_1_1AnalysisNeighborhoodPair.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisNeighborhoodSearch.xhtml">AnalysisNeighborhoodSearch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialized neighborhood search with a fixed set of reference positions.  <a href="classgmx_1_1AnalysisNeighborhoodSearch.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1AnalysisNeighborhoodPairSearch.xhtml">AnalysisNeighborhoodPairSearch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialized neighborhood pair search with a fixed set of positions.  <a href="classgmx_1_1AnalysisNeighborhoodPairSearch.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Selection.xhtml">Selection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to a single selection.  <a href="classgmx_1_1Selection.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1SelectionPosition.xhtml">SelectionPosition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to information about a single selected position.  <a href="classgmx_1_1SelectionPosition.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1SelectionCollection.xhtml">SelectionCollection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of selections.  <a href="classgmx_1_1SelectionCollection.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgmx_1_1SelectionTopologyProperties.xhtml">SelectionTopologyProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes topology properties required for selection evaluation.  <a href="structgmx_1_1SelectionTopologyProperties.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1SelectionOption.xhtml">SelectionOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies an option that provides selection(s).  <a href="classgmx_1_1SelectionOption.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1SelectionOptionInfo.xhtml">SelectionOptionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for accessing and modifying selection option information.  <a href="classgmx_1_1SelectionOptionInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1ITopologyProvider.xhtml">ITopologyProvider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides topology information to <a class="el" href="classgmx_1_1SelectionOptionBehavior.xhtml" title="Options behavior to allow using SelectionOptions. ">SelectionOptionBehavior</a>.  <a href="classgmx_1_1ITopologyProvider.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1SelectionOptionBehavior.xhtml">SelectionOptionBehavior</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgmx_1_1Options.xhtml" title="Collection of options. ">Options</a> behavior to allow using SelectionOptions.  <a href="classgmx_1_1SelectionOptionBehavior.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1SelectionOptionManager.xhtml">SelectionOptionManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles interaction of selection options with other options and user input.  <a href="classgmx_1_1SelectionOptionManager.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1TrajectoryAnalysisModuleData.xhtml">TrajectoryAnalysisModuleData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for thread-local data storage during trajectory analysis.  <a href="classgmx_1_1TrajectoryAnalysisModuleData.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1TrajectoryAnalysisModule.xhtml">TrajectoryAnalysisModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for trajectory analysis modules.  <a href="classgmx_1_1TrajectoryAnalysisModule.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1TrajectoryAnalysisSettings.xhtml">TrajectoryAnalysisSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trajectory analysis module configuration object.  <a href="classgmx_1_1TrajectoryAnalysisSettings.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1TopologyInformation.xhtml">TopologyInformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topology information passed to a trajectory analysis module.  <a href="classgmx_1_1TopologyInformation.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1TrajectoryAnalysisCommandLineRunner.xhtml">TrajectoryAnalysisCommandLineRunner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runner for command-line trajectory analysis tools.  <a href="classgmx_1_1TrajectoryAnalysisCommandLineRunner.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgmx_1_1EmptyArrayRef.xhtml">EmptyArrayRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type to initialize empty array references.  <a href="structgmx_1_1EmptyArrayRef.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1PrivateImplPointer.xhtml">PrivateImplPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to manage a pointer to a private implementation class.  <a href="classgmx_1_1PrivateImplPointer.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1DataFileOptions.xhtml">DataFileOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search parameters for <a class="el" href="classgmx_1_1DataFileFinder.xhtml" title="Searches data files from a set of paths. ">DataFileFinder</a>.  <a href="classgmx_1_1DataFileOptions.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgmx_1_1DataFileInfo.xhtml">DataFileInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a data file found by <a class="el" href="classgmx_1_1DataFileFinder.xhtml#a45d2ecd3b688a1432fb94d9632de232a" title="Enumerates files in the data directories. ">DataFileFinder::enumerateFiles()</a>.  <a href="structgmx_1_1DataFileInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1DataFileFinder.xhtml">DataFileFinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches data files from a set of paths.  <a href="classgmx_1_1DataFileFinder.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1ExceptionInfo.xhtml">ExceptionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores additional context information for exceptions.  <a href="classgmx_1_1ExceptionInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1ExceptionInitializer.xhtml">ExceptionInitializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides information for Gromacs exception constructors.  <a href="classgmx_1_1ExceptionInitializer.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1GromacsException.xhtml">GromacsException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all exception objects in Gromacs.  <a href="classgmx_1_1GromacsException.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1FileIOError.xhtml">FileIOError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class for file I/O errors.  <a href="classgmx_1_1FileIOError.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1UserInputError.xhtml">UserInputError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class for user input errors.  <a href="classgmx_1_1UserInputError.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1InvalidInputError.xhtml">InvalidInputError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class for situations where user input cannot be parsed/understood.  <a href="classgmx_1_1InvalidInputError.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1InconsistentInputError.xhtml">InconsistentInputError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class for situations where user input is inconsistent.  <a href="classgmx_1_1InconsistentInputError.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1ToleranceError.xhtml">ToleranceError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class when a specified tolerance cannot be achieved.  <a href="classgmx_1_1ToleranceError.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1SimulationInstabilityError.xhtml">SimulationInstabilityError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class for simulation instabilities.  <a href="classgmx_1_1SimulationInstabilityError.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1InternalError.xhtml">InternalError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class for internal errors.  <a href="classgmx_1_1InternalError.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1APIError.xhtml">APIError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class for incorrect use of an API.  <a href="classgmx_1_1APIError.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1RangeError.xhtml">RangeError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class for out-of-range values or indices.  <a href="classgmx_1_1RangeError.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1NotImplementedError.xhtml">NotImplementedError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class for use of an unimplemented feature.  <a href="classgmx_1_1NotImplementedError.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1FlagsTemplate.xhtml">FlagsTemplate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class for typesafe handling of combination of flags.  <a href="classgmx_1_1FlagsTemplate.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgmx_1_1InstallationPrefixInfo.xhtml">InstallationPrefixInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides information about installation prefix (see <a class="el" href="classgmx_1_1IProgramContext.xhtml#ada732144a05c8faa224b5ad0d904df6f" title="Returns the installation prefix for GROMACS. ">IProgramContext::installationPrefix()</a>).  <a href="structgmx_1_1InstallationPrefixInfo.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1IProgramContext.xhtml">IProgramContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides context information about the program that is calling the library.  <a href="classgmx_1_1IProgramContext.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1StringFormatter.xhtml">StringFormatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object that wraps a call to <a class="el" href="group__module__utility.xhtml#gaed06df18ca6f9fc3f42bad9ea4d7e025" title="Formats a string (snprintf() wrapper). ">formatString()</a> that expects a single conversion argument, for use with algorithms.  <a href="classgmx_1_1StringFormatter.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1IdentityFormatter.xhtml">IdentityFormatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object to implement the same interface as <code><a class="el" href="classgmx_1_1StringFormatter.xhtml" title="Function object that wraps a call to formatString() that expects a single conversion argument...">StringFormatter</a></code> to use with strings that should not be formatted further.  <a href="classgmx_1_1IdentityFormatter.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1TextLineWrapperSettings.xhtml">TextLineWrapperSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores settings for line wrapping.  <a href="classgmx_1_1TextLineWrapperSettings.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1TextLineWrapper.xhtml">TextLineWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps lines to a predefined length.  <a href="classgmx_1_1TextLineWrapper.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aea400e67c2f38e5bacdf8677f38a61cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea400e67c2f38e5bacdf8677f38a61cc"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1IAnalysisDataModule.xhtml">IAnalysisDataModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aea400e67c2f38e5bacdf8677f38a61cc">AnalysisDataModulePointer</a></td></tr>
<tr class="memdesc:aea400e67c2f38e5bacdf8677f38a61cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer for managing a generic analysis data module. <br/></td></tr>
<tr class="separator:aea400e67c2f38e5bacdf8677f38a61cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bac49f23828f0a0d0642fe123bc870"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2bac49f23828f0a0d0642fe123bc870"></a>
typedef <a class="el" href="classgmx_1_1ArrayRef.xhtml">ArrayRef</a>&lt; const <br class="typebreak"/>
<a class="el" href="classgmx_1_1AnalysisDataValue.xhtml">AnalysisDataValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af2bac49f23828f0a0d0642fe123bc870">AnalysisDataValuesRef</a></td></tr>
<tr class="memdesc:af2bac49f23828f0a0d0642fe123bc870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for reference to an array of data values. <br/></td></tr>
<tr class="separator:af2bac49f23828f0a0d0642fe123bc870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e4f5152c736da50dd59275f423a7a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87e4f5152c736da50dd59275f423a7a3"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1AnalysisDataAverageModule.xhtml">AnalysisDataAverageModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a87e4f5152c736da50dd59275f423a7a3">AnalysisDataAverageModulePointer</a></td></tr>
<tr class="memdesc:a87e4f5152c736da50dd59275f423a7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage an <a class="el" href="classgmx_1_1AnalysisDataAverageModule.xhtml" title="Data module for independently averaging each column in input data. ">AnalysisDataAverageModule</a> object. <br/></td></tr>
<tr class="separator:a87e4f5152c736da50dd59275f423a7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad580f7f69fb3536c9cba722587e77e49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad580f7f69fb3536c9cba722587e77e49"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1AnalysisDataFrameAverageModule.xhtml">AnalysisDataFrameAverageModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ad580f7f69fb3536c9cba722587e77e49">AnalysisDataFrameAverageModulePointer</a></td></tr>
<tr class="memdesc:ad580f7f69fb3536c9cba722587e77e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage an <a class="el" href="classgmx_1_1AnalysisDataFrameAverageModule.xhtml" title="Data module for averaging of columns for each frame. ">AnalysisDataFrameAverageModule</a> object. <br/></td></tr>
<tr class="separator:ad580f7f69fb3536c9cba722587e77e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5dd79fb2cd906b55b386b64084543b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5dd79fb2cd906b55b386b64084543b9"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1AnalysisDataDisplacementModule.xhtml">AnalysisDataDisplacementModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa5dd79fb2cd906b55b386b64084543b9">AnalysisDataDisplacementModulePointer</a></td></tr>
<tr class="memdesc:aa5dd79fb2cd906b55b386b64084543b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage an <a class="el" href="classgmx_1_1AnalysisDataDisplacementModule.xhtml" title="Data module for calculating displacements. ">AnalysisDataDisplacementModule</a> object. <br/></td></tr>
<tr class="separator:aa5dd79fb2cd906b55b386b64084543b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c190fcdacd0ca64e4e9026213483cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06c190fcdacd0ca64e4e9026213483cb"></a>
typedef std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1AbstractAverageHistogram.xhtml">AbstractAverageHistogram</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a06c190fcdacd0ca64e4e9026213483cb">AverageHistogramPointer</a></td></tr>
<tr class="memdesc:a06c190fcdacd0ca64e4e9026213483cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage an <a class="el" href="classgmx_1_1AbstractAverageHistogram.xhtml" title="Base class for representing histograms averaged over frames. ">AbstractAverageHistogram</a> object. <br/></td></tr>
<tr class="separator:a06c190fcdacd0ca64e4e9026213483cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c928eedc8925c3c437b5362acf30ccd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c928eedc8925c3c437b5362acf30ccd"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1AnalysisDataSimpleHistogramModule.xhtml">AnalysisDataSimpleHistogramModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2c928eedc8925c3c437b5362acf30ccd">AnalysisDataSimpleHistogramModulePointer</a></td></tr>
<tr class="memdesc:a2c928eedc8925c3c437b5362acf30ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage an <a class="el" href="classgmx_1_1AnalysisDataSimpleHistogramModule.xhtml" title="Data module for per-frame histograms. ">AnalysisDataSimpleHistogramModule</a> object. <br/></td></tr>
<tr class="separator:a2c928eedc8925c3c437b5362acf30ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a619b397ea8b7a9a81406d36f653b4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a619b397ea8b7a9a81406d36f653b4c"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1AnalysisDataWeightedHistogramModule.xhtml">AnalysisDataWeightedHistogramModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a3a619b397ea8b7a9a81406d36f653b4c">AnalysisDataWeightedHistogramModulePointer</a></td></tr>
<tr class="memdesc:a3a619b397ea8b7a9a81406d36f653b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage an <a class="el" href="classgmx_1_1AnalysisDataWeightedHistogramModule.xhtml" title="Data module for per-frame weighted histograms. ">AnalysisDataWeightedHistogramModule</a> object. <br/></td></tr>
<tr class="separator:a3a619b397ea8b7a9a81406d36f653b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2832966f8a1d1e01888448ce10faa595"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2832966f8a1d1e01888448ce10faa595"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1AnalysisDataBinAverageModule.xhtml">AnalysisDataBinAverageModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2832966f8a1d1e01888448ce10faa595">AnalysisDataBinAverageModulePointer</a></td></tr>
<tr class="memdesc:a2832966f8a1d1e01888448ce10faa595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage an <a class="el" href="classgmx_1_1AnalysisDataBinAverageModule.xhtml" title="Data module for bin averages. ">AnalysisDataBinAverageModule</a> object. <br/></td></tr>
<tr class="separator:a2832966f8a1d1e01888448ce10faa595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af036d959995ac12973db1da85b720bf6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af036d959995ac12973db1da85b720bf6"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1AnalysisDataLifetimeModule.xhtml">AnalysisDataLifetimeModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af036d959995ac12973db1da85b720bf6">AnalysisDataLifetimeModulePointer</a></td></tr>
<tr class="memdesc:af036d959995ac12973db1da85b720bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage an <a class="el" href="classgmx_1_1AnalysisDataLifetimeModule.xhtml" title="Data module for computing lifetime histograms for columns in input data. ">AnalysisDataLifetimeModule</a> object. <br/></td></tr>
<tr class="separator:af036d959995ac12973db1da85b720bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38eb9496e0b6e783869001733014b6d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38eb9496e0b6e783869001733014b6d0"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1AnalysisDataPlotModule.xhtml">AnalysisDataPlotModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a38eb9496e0b6e783869001733014b6d0">AnalysisDataPlotModulePointer</a></td></tr>
<tr class="memdesc:a38eb9496e0b6e783869001733014b6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage an <a class="el" href="classgmx_1_1AnalysisDataPlotModule.xhtml" title="Plotting module for straightforward plotting of data. ">AnalysisDataPlotModule</a> object. <br/></td></tr>
<tr class="separator:a38eb9496e0b6e783869001733014b6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd637dfda5b531daec3b8a89f389c10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacd637dfda5b531daec3b8a89f389c10"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1AnalysisDataVectorPlotModule.xhtml">AnalysisDataVectorPlotModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aacd637dfda5b531daec3b8a89f389c10">AnalysisDataVectorPlotModulePointer</a></td></tr>
<tr class="memdesc:aacd637dfda5b531daec3b8a89f389c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage an <a class="el" href="classgmx_1_1AnalysisDataVectorPlotModule.xhtml" title="Plotting module specifically for data consisting of vectors. ">AnalysisDataVectorPlotModule</a> object. <br/></td></tr>
<tr class="separator:aacd637dfda5b531daec3b8a89f389c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079fa4aee8e4c6663f35aa1d0f4bac4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a079fa4aee8e4c6663f35aa1d0f4bac4b"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a079fa4aee8e4c6663f35aa1d0f4bac4b">awh_dvec</a> [<a class="el" href="namespacegmx.xhtml#a4b52689d9c5c9740cdc1074d344377e2">c_biasMaxNumDim</a>]</td></tr>
<tr class="memdesc:a079fa4aee8e4c6663f35aa1d0f4bac4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A real vector in AWH coordinate space. <br/></td></tr>
<tr class="separator:a079fa4aee8e4c6663f35aa1d0f4bac4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74baae008f9132c5e0daf2a02b122b3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74baae008f9132c5e0daf2a02b122b3b"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a74baae008f9132c5e0daf2a02b122b3b">awh_ivec</a> [<a class="el" href="namespacegmx.xhtml#a4b52689d9c5c9740cdc1074d344377e2">c_biasMaxNumDim</a>]</td></tr>
<tr class="memdesc:a74baae008f9132c5e0daf2a02b122b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer vector in AWH coordinate space. <br/></td></tr>
<tr class="separator:a74baae008f9132c5e0daf2a02b122b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f47492bbdb0412052613d0096a20c0b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1f47492bbdb0412052613d0096a20c0b"></a>
typedef std::map&lt; std::string, <br class="typebreak"/>
<a class="el" href="group__module__commandline.xhtml#ga92d17acbe7afad4effeda8d9be200305">CommandLineModulePointer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__commandline.xhtml#ga1f47492bbdb0412052613d0096a20c0b">CommandLineModuleMap</a></td></tr>
<tr class="memdesc:ga1f47492bbdb0412052613d0096a20c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container type for mapping module names to module objects. <br/></td></tr>
<tr class="separator:ga1f47492bbdb0412052613d0096a20c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc9ea6aca3a54c2691284aa39cdd294d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadc9ea6aca3a54c2691284aa39cdd294d"></a>
typedef std::unique_ptr<br class="typebreak"/>
&lt; CommandLineModuleGroupData &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__commandline.xhtml#gadc9ea6aca3a54c2691284aa39cdd294d">CommandLineModuleGroupDataPointer</a></td></tr>
<tr class="memdesc:gadc9ea6aca3a54c2691284aa39cdd294d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer type for managing a CommandLineModuleGroup. <br/></td></tr>
<tr class="separator:gadc9ea6aca3a54c2691284aa39cdd294d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7098a58b563a17889eef62c80fae42bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7098a58b563a17889eef62c80fae42bf"></a>
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="group__module__commandline.xhtml#gadc9ea6aca3a54c2691284aa39cdd294d">CommandLineModuleGroupDataPointer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__commandline.xhtml#ga7098a58b563a17889eef62c80fae42bf">CommandLineModuleGroupList</a></td></tr>
<tr class="memdesc:ga7098a58b563a17889eef62c80fae42bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container type for keeping a list of module groups. <br/></td></tr>
<tr class="separator:ga7098a58b563a17889eef62c80fae42bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92d17acbe7afad4effeda8d9be200305"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga92d17acbe7afad4effeda8d9be200305"></a>
typedef std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1ICommandLineModule.xhtml">ICommandLineModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__commandline.xhtml#ga92d17acbe7afad4effeda8d9be200305">CommandLineModulePointer</a></td></tr>
<tr class="memdesc:ga92d17acbe7afad4effeda8d9be200305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer type for managing a <a class="el" href="classgmx_1_1ICommandLineModule.xhtml" title="Module that can be run from command line using CommandLineModuleManager. ">ICommandLineModule</a>. <br/></td></tr>
<tr class="separator:ga92d17acbe7afad4effeda8d9be200305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682ce4a779fde44ee633b8648eeafe87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a682ce4a779fde44ee633b8648eeafe87"></a>
typedef std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1ICommandLineOptionsModule.xhtml">ICommandLineOptionsModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a682ce4a779fde44ee633b8648eeafe87">ICommandLineOptionsModulePointer</a></td></tr>
<tr class="memdesc:a682ce4a779fde44ee633b8648eeafe87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage an <a class="el" href="classgmx_1_1ICommandLineOptionsModule.xhtml" title="Module that can be run from a command line and uses gmx::Options for argument processing. ">ICommandLineOptionsModule</a>. <br/></td></tr>
<tr class="separator:a682ce4a779fde44ee633b8648eeafe87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac522eb6a6c382e39345834c796201098"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac522eb6a6c382e39345834c796201098"></a>
typedef std::unique_ptr<br class="typebreak"/>
&lt; IExecutableEnvironment &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__commandline.xhtml#gac522eb6a6c382e39345834c796201098">ExecutableEnvironmentPointer</a></td></tr>
<tr class="memdesc:gac522eb6a6c382e39345834c796201098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for a smart pointer to IExecutableEnvironment. <br/></td></tr>
<tr class="separator:gac522eb6a6c382e39345834c796201098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae347fd6abaab2e4d8278bf17973b664"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aae347fd6abaab2e4d8278bf17973b664"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aae347fd6abaab2e4d8278bf17973b664">HostAllocator</a> = Allocator&lt; T, HostAllocationPolicy &gt;</td></tr>
<tr class="memdesc:aae347fd6abaab2e4d8278bf17973b664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory allocator that uses HostAllocationPolicy.  <a href="#aae347fd6abaab2e4d8278bf17973b664">More...</a><br/></td></tr>
<tr class="separator:aae347fd6abaab2e4d8278bf17973b664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15043f587f8595747fbc7c4dee890cb2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a15043f587f8595747fbc7c4dee890cb2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a15043f587f8595747fbc7c4dee890cb2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a15043f587f8595747fbc7c4dee890cb2">HostVector</a> = std::vector&lt; T, <a class="el" href="namespacegmx.xhtml#aae347fd6abaab2e4d8278bf17973b664">HostAllocator</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a15043f587f8595747fbc7c4dee890cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for std::vector that uses HostAllocator. <br/></td></tr>
<tr class="separator:a15043f587f8595747fbc7c4dee890cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5162006582f166d58667a890f462eba"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ab5162006582f166d58667a890f462eba">PaddedRVecVector</a> = std::vector&lt; <a class="el" href="namespacegmx.xhtml#a139c1919a9680de4ad1450f42e37d33b">RVec</a>, Allocator&lt; <a class="el" href="namespacegmx.xhtml#a139c1919a9680de4ad1450f42e37d33b">RVec</a>, AlignedAllocationPolicy &gt; &gt;</td></tr>
<tr class="memdesc:ab5162006582f166d58667a890f462eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary definition of a type usable for SIMD-style loads of RVec quantities.  <a href="#ab5162006582f166d58667a890f462eba">More...</a><br/></td></tr>
<tr class="separator:ab5162006582f166d58667a890f462eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed9d94613445e3a616e7116786ed534"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7ed9d94613445e3a616e7116786ed534"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a7ed9d94613445e3a616e7116786ed534">PaddedArrayRef</a> = <a class="el" href="classgmx_1_1ArrayRef.xhtml">ArrayRef</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a7ed9d94613445e3a616e7116786ed534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary definition of a type usable for SIMD-style loads of RVec quantities from a view.  <a href="#a7ed9d94613445e3a616e7116786ed534">More...</a><br/></td></tr>
<tr class="separator:a7ed9d94613445e3a616e7116786ed534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139c1919a9680de4ad1450f42e37d33b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a139c1919a9680de4ad1450f42e37d33b"></a>
typedef <a class="el" href="classgmx_1_1BasicVector.xhtml">BasicVector</a>&lt; <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a139c1919a9680de4ad1450f42e37d33b">RVec</a></td></tr>
<tr class="memdesc:a139c1919a9680de4ad1450f42e37d33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for C++ <code>rvec</code>-equivalent type. <br/></td></tr>
<tr class="separator:a139c1919a9680de4ad1450f42e37d33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9699d31c62e2a4cc2c730793a1224411"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9699d31c62e2a4cc2c730793a1224411"></a>
typedef <a class="el" href="classgmx_1_1BasicVector.xhtml">BasicVector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a9699d31c62e2a4cc2c730793a1224411">IVec</a></td></tr>
<tr class="memdesc:a9699d31c62e2a4cc2c730793a1224411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for C++ <code>ivec</code>-equivalent type. <br/></td></tr>
<tr class="separator:a9699d31c62e2a4cc2c730793a1224411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c220170a68ad4867d5cb6b89bdec4b"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a24c220170a68ad4867d5cb6b89bdec4b">integrator_t</a> (FILE *fplog, t_commrec *cr, const gmx::MDLogger &amp;mdlog, int nfile, const <a class="el" href="structt__filenm.xhtml">t_filenm</a> fnm[], const gmx_output_env_t *oenv, const MdrunOptions &amp;mdrunOptions, gmx_vsite_t *vsite, gmx_constr_t constr, gmx::IMDOutputProvider *outputProvider, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, <a class="el" href="classt__state.xhtml">t_state</a> *state_global, ObservablesHistory *observablesHistory, MDAtoms *mdatoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, t_forcerec *fr, const ReplicaExchangeParameters &amp;replExParams, gmx_membed_t *membed, gmx_walltime_accounting_t walltime_accounting)</td></tr>
<tr class="memdesc:a24c220170a68ad4867d5cb6b89bdec4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrator algorithm implementation.  <a href="#a24c220170a68ad4867d5cb6b89bdec4b">More...</a><br/></td></tr>
<tr class="separator:a24c220170a68ad4867d5cb6b89bdec4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0facebaa27d417dcf4d032f2a5725a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c0facebaa27d417dcf4d032f2a5725a"></a>
typedef std::array<br class="typebreak"/>
&lt; SimulationSignal, eglsNR &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2c0facebaa27d417dcf4d032f2a5725a">SimulationSignals</a></td></tr>
<tr class="memdesc:a2c0facebaa27d417dcf4d032f2a5725a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience typedef for the group of signals used. <br/></td></tr>
<tr class="separator:a2c0facebaa27d417dcf4d032f2a5725a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb455c7711ece592606e70a093ff80b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb455c7711ece592606e70a093ff80b4"></a>
typedef std::unique_ptr<br class="typebreak"/>
&lt; IHelpTopic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#abb455c7711ece592606e70a093ff80b4">HelpTopicPointer</a></td></tr>
<tr class="memdesc:abb455c7711ece592606e70a093ff80b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer type to manage a IHelpTopic object. <br/></td></tr>
<tr class="separator:abb455c7711ece592606e70a093ff80b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdd645721a8da7d18eec7f0bc84efe29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafdd645721a8da7d18eec7f0bc84efe29"></a>
typedef <a class="el" href="classgmx_1_1EnumOption.xhtml">EnumOption</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__options.xhtml#gafdd645721a8da7d18eec7f0bc84efe29">EnumIntOption</a></td></tr>
<tr class="memdesc:gafdd645721a8da7d18eec7f0bc84efe29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for an enumerated option that stores into an <code>int</code> variable. <br/></td></tr>
<tr class="separator:gafdd645721a8da7d18eec7f0bc84efe29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7552279e0ab63edd1e9324c5786e28e7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classgmx_1_1FloatOption.xhtml">FloatOption</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__options.xhtml#ga7552279e0ab63edd1e9324c5786e28e7">RealOption</a></td></tr>
<tr class="memdesc:ga7552279e0ab63edd1e9324c5786e28e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for either <a class="el" href="classgmx_1_1DoubleOption.xhtml" title="Specifies an option that provides floating-point (double) values. ">DoubleOption</a> or <a class="el" href="classgmx_1_1FloatOption.xhtml" title="Specifies an option that provides floating-point (float) values. ">FloatOption</a>, depending on precision.  <a href="group__module__options.xhtml#ga7552279e0ab63edd1e9324c5786e28e7">More...</a><br/></td></tr>
<tr class="separator:ga7552279e0ab63edd1e9324c5786e28e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1c4e0b93e5d22b0c9a534f0235496f5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classgmx_1_1FloatOptionInfo.xhtml">FloatOptionInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__options.xhtml#gab1c4e0b93e5d22b0c9a534f0235496f5">RealOptionInfo</a></td></tr>
<tr class="memdesc:gab1c4e0b93e5d22b0c9a534f0235496f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for either <a class="el" href="classgmx_1_1DoubleOptionInfo.xhtml" title="Wrapper class for accessing floating-point option information. ">DoubleOptionInfo</a> or <a class="el" href="classgmx_1_1FloatOptionInfo.xhtml" title="Wrapper class for accessing floating-point option information. ">FloatOptionInfo</a>, depending on precision.  <a href="group__module__options.xhtml#gab1c4e0b93e5d22b0c9a534f0235496f5">More...</a><br/></td></tr>
<tr class="separator:gab1c4e0b93e5d22b0c9a534f0235496f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059233e5e29d17f821d7f56ef3faa7e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a059233e5e29d17f821d7f56ef3faa7e4"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1IOptionsBehavior.xhtml">IOptionsBehavior</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a059233e5e29d17f821d7f56ef3faa7e4">OptionsBehaviorPointer</a></td></tr>
<tr class="memdesc:a059233e5e29d17f821d7f56ef3faa7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer for behaviors stored in OptionsBehaviorCollection. <br/></td></tr>
<tr class="separator:a059233e5e29d17f821d7f56ef3faa7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac44e2bbcc40f48812b6b756a503ea51"><td class="memItemLeft" align="right" valign="top">typedef std::random_device&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aac44e2bbcc40f48812b6b756a503ea51">RandomDevice</a></td></tr>
<tr class="memdesc:aac44e2bbcc40f48812b6b756a503ea51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random device.  <a href="#aac44e2bbcc40f48812b6b756a503ea51">More...</a><br/></td></tr>
<tr class="separator:aac44e2bbcc40f48812b6b756a503ea51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea21974bdd8acdfa1c344b0945cff1b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classgmx_1_1ThreeFry2x64Fast.xhtml">ThreeFry2x64Fast</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a7ea21974bdd8acdfa1c344b0945cff1b">DefaultRandomEngine</a></td></tr>
<tr class="memdesc:a7ea21974bdd8acdfa1c344b0945cff1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default fast and accurate random engine in Gromacs.  <a href="#a7ea21974bdd8acdfa1c344b0945cff1b">More...</a><br/></td></tr>
<tr class="separator:a7ea21974bdd8acdfa1c344b0945cff1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec46c9561c55f7595677160ee727395d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec46c9561c55f7595677160ee727395d"></a>
typedef std::list<br class="typebreak"/>
&lt; SelectionParserValue &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aec46c9561c55f7595677160ee727395d">SelectionParserValueList</a></td></tr>
<tr class="memdesc:aec46c9561c55f7595677160ee727395d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for a list of SelectionParserValue objects. <br/></td></tr>
<tr class="separator:aec46c9561c55f7595677160ee727395d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043953ace26fa6e1f17f90245e3a29bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a043953ace26fa6e1f17f90245e3a29bd"></a>
typedef std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="namespacegmx.xhtml#aec46c9561c55f7595677160ee727395d">SelectionParserValueList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a043953ace26fa6e1f17f90245e3a29bd">SelectionParserValueListPointer</a></td></tr>
<tr class="memdesc:a043953ace26fa6e1f17f90245e3a29bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer type for managing a SelectionParserValueList. <br/></td></tr>
<tr class="separator:a043953ace26fa6e1f17f90245e3a29bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2000e8454576fcfcd5a8fdc5d060da4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2000e8454576fcfcd5a8fdc5d060da4e"></a>
typedef std::list<br class="typebreak"/>
&lt; SelectionParserParameter &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2000e8454576fcfcd5a8fdc5d060da4e">SelectionParserParameterList</a></td></tr>
<tr class="memdesc:a2000e8454576fcfcd5a8fdc5d060da4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for a list of SelectionParserParameter objects. <br/></td></tr>
<tr class="separator:a2000e8454576fcfcd5a8fdc5d060da4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69a9fb56d051d95e77a90d57a9fa42e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af69a9fb56d051d95e77a90d57a9fa42e"></a>
typedef std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="namespacegmx.xhtml#a2000e8454576fcfcd5a8fdc5d060da4e">SelectionParserParameterList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af69a9fb56d051d95e77a90d57a9fa42e">SelectionParserParameterListPointer</a></td></tr>
<tr class="memdesc:af69a9fb56d051d95e77a90d57a9fa42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer type for managing a SelectionParserParameterList. <br/></td></tr>
<tr class="separator:af69a9fb56d051d95e77a90d57a9fa42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac852a0801cf49723903e23bc77a32163"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac852a0801cf49723903e23bc77a32163"></a>
typedef std::vector&lt; <a class="el" href="classgmx_1_1Selection.xhtml">Selection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ac852a0801cf49723903e23bc77a32163">SelectionList</a></td></tr>
<tr class="memdesc:ac852a0801cf49723903e23bc77a32163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of selections used in public selection interfaces. <br/></td></tr>
<tr class="separator:ac852a0801cf49723903e23bc77a32163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e73e50cc7002a24229fa6650b8ccfc8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e73e50cc7002a24229fa6650b8ccfc8"></a>
typedef std::unique_ptr<br class="typebreak"/>
&lt; internal::SelectionData &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a0e73e50cc7002a24229fa6650b8ccfc8">SelectionDataPointer</a></td></tr>
<tr class="memdesc:a0e73e50cc7002a24229fa6650b8ccfc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer for managing an internal selection data object. <br/></td></tr>
<tr class="separator:a0e73e50cc7002a24229fa6650b8ccfc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5559201ddf8596d12d99a3c3e45e989"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5559201ddf8596d12d99a3c3e45e989"></a>
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="namespacegmx.xhtml#a0e73e50cc7002a24229fa6650b8ccfc8">SelectionDataPointer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ab5559201ddf8596d12d99a3c3e45e989">SelectionDataList</a></td></tr>
<tr class="memdesc:ab5559201ddf8596d12d99a3c3e45e989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for storing a list of selections internally. <br/></td></tr>
<tr class="separator:ab5559201ddf8596d12d99a3c3e45e989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2804c9c82f2a9bd0ec94d3c2f1003f42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2804c9c82f2a9bd0ec94d3c2f1003f42"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; SelectionTreeElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2804c9c82f2a9bd0ec94d3c2f1003f42">SelectionTreeElementPointer</a></td></tr>
<tr class="memdesc:a2804c9c82f2a9bd0ec94d3c2f1003f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer type for selection tree element pointers. <br/></td></tr>
<tr class="separator:a2804c9c82f2a9bd0ec94d3c2f1003f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9592d982901517ae8e8f9e6d3222a91f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9592d982901517ae8e8f9e6d3222a91f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a9592d982901517ae8e8f9e6d3222a91f">GpuTaskAssignment</a> = std::vector&lt; GpuTaskMapping &gt;</td></tr>
<tr class="memdesc:a9592d982901517ae8e8f9e6d3222a91f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of GPU tasks on a rank, specifying the task type and GPU device ID, e.g. potentially ready for consumption by the modules on that rank. <br/></td></tr>
<tr class="separator:a9592d982901517ae8e8f9e6d3222a91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b141a05049b61c32b587e8d19e8947"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01b141a05049b61c32b587e8d19e8947"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a01b141a05049b61c32b587e8d19e8947">GpuTasksOnRanks</a> = std::vector&lt; std::vector&lt; <a class="el" href="namespacegmx.xhtml#a6efc2e8f104eb3699bc82c2b8984cedb">GpuTask</a> &gt; &gt;</td></tr>
<tr class="memdesc:a01b141a05049b61c32b587e8d19e8947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of compute tasks suitable to run on a GPU e.g. on each rank of a node. <br/></td></tr>
<tr class="separator:a01b141a05049b61c32b587e8d19e8947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a41b5592e3e9de8d1c1cba2901a7ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40a41b5592e3e9de8d1c1cba2901a7ef"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a40a41b5592e3e9de8d1c1cba2901a7ef">GpuTaskAssignments</a> = std::vector&lt; <a class="el" href="namespacegmx.xhtml#a9592d982901517ae8e8f9e6d3222a91f">GpuTaskAssignment</a> &gt;</td></tr>
<tr class="memdesc:a40a41b5592e3e9de8d1c1cba2901a7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of RankGpuTaskAssignments e.g. for all ranks on a node. <br/></td></tr>
<tr class="separator:a40a41b5592e3e9de8d1c1cba2901a7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f05f1bbb0c205deb47822bce1f626e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f05f1bbb0c205deb47822bce1f626e6"></a>
typedef std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1TrajectoryAnalysisModuleData.xhtml">TrajectoryAnalysisModuleData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a6f05f1bbb0c205deb47822bce1f626e6">TrajectoryAnalysisModuleDataPointer</a></td></tr>
<tr class="memdesc:a6f05f1bbb0c205deb47822bce1f626e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage a <a class="el" href="classgmx_1_1TrajectoryAnalysisModuleData.xhtml" title="Base class for thread-local data storage during trajectory analysis. ">TrajectoryAnalysisModuleData</a> object. <br/></td></tr>
<tr class="separator:a6f05f1bbb0c205deb47822bce1f626e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832da3c093109c13cc2369de05e02f3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a832da3c093109c13cc2369de05e02f3b"></a>
typedef std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1TrajectoryAnalysisModule.xhtml">TrajectoryAnalysisModule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a832da3c093109c13cc2369de05e02f3b">TrajectoryAnalysisModulePointer</a></td></tr>
<tr class="memdesc:a832da3c093109c13cc2369de05e02f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to manage a <a class="el" href="classgmx_1_1TrajectoryAnalysisModule.xhtml" title="Base class for trajectory analysis modules. ">TrajectoryAnalysisModule</a>. <br/></td></tr>
<tr class="separator:a832da3c093109c13cc2369de05e02f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ca6adcfda5170180c2140c7b2f9d47"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac3ca6adcfda5170180c2140c7b2f9d47"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ac3ca6adcfda5170180c2140c7b2f9d47">AlignedAllocator</a> = Allocator&lt; T, AlignedAllocationPolicy &gt;</td></tr>
<tr class="memdesc:ac3ca6adcfda5170180c2140c7b2f9d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned memory allocator.  <a href="#ac3ca6adcfda5170180c2140c7b2f9d47">More...</a><br/></td></tr>
<tr class="separator:ac3ca6adcfda5170180c2140c7b2f9d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01c69345463ebb433d1fedfd356b74a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af01c69345463ebb433d1fedfd356b74a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af01c69345463ebb433d1fedfd356b74a">PageAlignedAllocator</a> = Allocator&lt; T, PageAlignedAllocationPolicy &gt;</td></tr>
<tr class="memdesc:af01c69345463ebb433d1fedfd356b74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">PageAligned memory allocator.  <a href="#af01c69345463ebb433d1fedfd356b74a">More...</a><br/></td></tr>
<tr class="separator:af01c69345463ebb433d1fedfd356b74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga590b36651977793730ea2413906302cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga590b36651977793730ea2413906302cf"></a>
typedef <a class="el" href="classgmx_1_1ExceptionInfo.xhtml">ExceptionInfo</a>&lt; struct <br class="typebreak"/>
ExceptionInfoErrno_, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga590b36651977793730ea2413906302cf">ExceptionInfoErrno</a></td></tr>
<tr class="memdesc:ga590b36651977793730ea2413906302cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores <code>errno</code> value that triggered the exception. <br/></td></tr>
<tr class="separator:ga590b36651977793730ea2413906302cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c8f9c19c0ed36c16770317afc7c69bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3c8f9c19c0ed36c16770317afc7c69bb"></a>
typedef <a class="el" href="classgmx_1_1ExceptionInfo.xhtml">ExceptionInfo</a>&lt; struct <br class="typebreak"/>
ExceptionInfoApiFunc_, const <br class="typebreak"/>
char * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga3c8f9c19c0ed36c16770317afc7c69bb">ExceptionInfoApiFunction</a></td></tr>
<tr class="memdesc:ga3c8f9c19c0ed36c16770317afc7c69bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the function name that returned the <code>errno</code> in ExceptionInfoErrno. <br/></td></tr>
<tr class="separator:ga3c8f9c19c0ed36c16770317afc7c69bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5d3ee620090581599c5762270314897"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab5d3ee620090581599c5762270314897"></a>
typedef <a class="el" href="classgmx_1_1ExceptionInfo.xhtml">ExceptionInfo</a>&lt; struct <br class="typebreak"/>
ExceptionInfoLocation_, <br class="typebreak"/>
ThrowLocation &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gab5d3ee620090581599c5762270314897">ExceptionInfoLocation</a></td></tr>
<tr class="memdesc:gab5d3ee620090581599c5762270314897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the location where the exception was thrown. <br/></td></tr>
<tr class="separator:gab5d3ee620090581599c5762270314897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbe80608de8e00e55049289ef0148c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fbe80608de8e00e55049289ef0148c1"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; TextInputStream &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2fbe80608de8e00e55049289ef0148c1">TextInputStreamPointer</a></td></tr>
<tr class="memdesc:a2fbe80608de8e00e55049289ef0148c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for a smart pointer to a TextInputStream. <br/></td></tr>
<tr class="separator:a2fbe80608de8e00e55049289ef0148c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdec6c0997f8c033905f1f82f253d25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fdec6c0997f8c033905f1f82f253d25"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; TextOutputStream &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a1fdec6c0997f8c033905f1f82f253d25">TextOutputStreamPointer</a></td></tr>
<tr class="memdesc:a1fdec6c0997f8c033905f1f82f253d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for a smart pointer to a TextOutputStream. <br/></td></tr>
<tr class="separator:a1fdec6c0997f8c033905f1f82f253d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d1da25b1e1f9331f1fe99b15072eac"><td class="memTemplParams" colspan="2"><a class="anchor" id="a89d1da25b1e1f9331f1fe99b15072eac"></a>
template&lt;typename T , void  D = sfree_wrapper&gt; </td></tr>
<tr class="memitem:a89d1da25b1e1f9331f1fe99b15072eac"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a89d1da25b1e1f9331f1fe99b15072eac">unique_cptr</a> = std::unique_ptr&lt; T, functor_wrapper&lt; T, D &gt; &gt;</td></tr>
<tr class="memdesc:a89d1da25b1e1f9331f1fe99b15072eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">unique_ptr which takes function pointer (has to return void) as template argument <br/></td></tr>
<tr class="separator:a89d1da25b1e1f9331f1fe99b15072eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48049c20e985f7cfbe33e8a8467cd3db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48049c20e985f7cfbe33e8a8467cd3db"></a>
typedef <a class="el" href="namespacegmx.xhtml#a89d1da25b1e1f9331f1fe99b15072eac">unique_cptr</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a48049c20e985f7cfbe33e8a8467cd3db">sfree_guard</a></td></tr>
<tr class="memdesc:a48049c20e985f7cfbe33e8a8467cd3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple guard which calls sfree. See unique_cptr for details. <br/></td></tr>
<tr class="separator:a48049c20e985f7cfbe33e8a8467cd3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aed0429233bc357e419dafee7b8bd1344"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aed0429233bc357e419dafee7b8bd1344">AwhOutputEntryType</a> { <br/>
&#160;&#160;<a class="el" href="namespacegmx.xhtml#aed0429233bc357e419dafee7b8bd1344a02104739967781f89c6b0e63dd2147ca">AwhOutputEntryType::MetaData</a>, 
<a class="el" href="namespacegmx.xhtml#aed0429233bc357e419dafee7b8bd1344a720c5bc3c2ea29a296e3461990c4899b">AwhOutputEntryType::CoordValue</a>, 
<a class="el" href="namespacegmx.xhtml#aed0429233bc357e419dafee7b8bd1344a84c75a906e1e7548f6df1e4e3aa3af52">AwhOutputEntryType::Pmf</a>, 
<a class="el" href="namespacegmx.xhtml#aed0429233bc357e419dafee7b8bd1344a4ad6b9e6418fd2d739906bd47e887ae3">AwhOutputEntryType::Bias</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacegmx.xhtml#aed0429233bc357e419dafee7b8bd1344ad7e637a6e9ff116de2fa89551240a94d">AwhOutputEntryType::Visits</a>, 
<a class="el" href="namespacegmx.xhtml#aed0429233bc357e419dafee7b8bd1344a8831731b52fdc6cb7f162f9767d66e4d">AwhOutputEntryType::Weights</a>, 
<a class="el" href="namespacegmx.xhtml#aed0429233bc357e419dafee7b8bd1344ac41a31890959544c6523af684561abe5">AwhOutputEntryType::Target</a>, 
<a class="el" href="namespacegmx.xhtml#aed0429233bc357e419dafee7b8bd1344a9e3dc756a9b59b3b98e12633705af8a2">AwhOutputEntryType::ForceCorrelationVolume</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacegmx.xhtml#aed0429233bc357e419dafee7b8bd1344a8a0a3ea3dad6182f51bbbdaf5a244d9a">AwhOutputEntryType::FrictionTensor</a>
<br/>
 }</td></tr>
<tr class="memdesc:aed0429233bc357e419dafee7b8bd1344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum with the AWH variables to write.  <a href="namespacegmx.xhtml#aed0429233bc357e419dafee7b8bd1344">More...</a><br/></td></tr>
<tr class="separator:aed0429233bc357e419dafee7b8bd1344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78c6481d10a93316c155ffdf021e581"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa78c6481d10a93316c155ffdf021e581">AwhOutputMetaData</a> { <a class="el" href="namespacegmx.xhtml#aa78c6481d10a93316c155ffdf021e581a03c23956aa8e12507d6d59be8a983a13">AwhOutputMetaData::NumBlock</a>, 
<a class="el" href="namespacegmx.xhtml#aa78c6481d10a93316c155ffdf021e581a461586ff73a95486e167031a14a63505">AwhOutputMetaData::TargetError</a>, 
<a class="el" href="namespacegmx.xhtml#aa78c6481d10a93316c155ffdf021e581a7cffc85b2f1c2177a818913479ea4f18">AwhOutputMetaData::ScaledSampleWeight</a>, 
<a class="el" href="namespacegmx.xhtml#aa78c6481d10a93316c155ffdf021e581ae93f994f01c537c4e2f7d8528c3eb5e9">AwhOutputMetaData::Count</a>
 }</td></tr>
<tr class="memdesc:aa78c6481d10a93316c155ffdf021e581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum with the types of metadata to write.  <a href="namespacegmx.xhtml#aa78c6481d10a93316c155ffdf021e581">More...</a><br/></td></tr>
<tr class="separator:aa78c6481d10a93316c155ffdf021e581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a656f58d79c7258c8b6e0141bd440b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a35a656f58d79c7258c8b6e0141bd440b">Normalization</a> { <a class="el" href="namespacegmx.xhtml#a35a656f58d79c7258c8b6e0141bd440ba6adf97f83acf6453d4a6a4b1070f3754">Normalization::None</a>, 
<a class="el" href="namespacegmx.xhtml#a35a656f58d79c7258c8b6e0141bd440bac7c60dd55c0cd4692587f5e9dc114ae9">Normalization::Coordinate</a>, 
<a class="el" href="namespacegmx.xhtml#a35a656f58d79c7258c8b6e0141bd440baf17c26adf091ff1700432cd9fb5e6906">Normalization::FreeEnergy</a>, 
<a class="el" href="namespacegmx.xhtml#a35a656f58d79c7258c8b6e0141bd440baf0bac093bb884df2891d32385d053788">Normalization::Distribution</a>
 }</td></tr>
<tr class="memdesc:a35a656f58d79c7258c8b6e0141bd440b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum with different ways of normalizing the output.  <a href="namespacegmx.xhtml#a35a656f58d79c7258c8b6e0141bd440b">More...</a><br/></td></tr>
<tr class="separator:a35a656f58d79c7258c8b6e0141bd440b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4caed0469c0de84e0c1c1a81972b38"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#abe4caed0469c0de84e0c1c1a81972b38">PinningPolicy</a> : int { <b>CannotBePinned</b>, 
<b>CanBePinned</b>
 }</td></tr>
<tr class="memdesc:abe4caed0469c0de84e0c1c1a81972b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper enum for pinning policy of the allocation of HostAllocationPolicy.  <a href="namespacegmx.xhtml#abe4caed0469c0de84e0c1c1a81972b38">More...</a><br/></td></tr>
<tr class="separator:abe4caed0469c0de84e0c1c1a81972b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e189e3f31f5f1e8581a5cc84063453"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a20e189e3f31f5f1e8581a5cc84063453">Architecture</a> { <b>Unknown</b>, 
<a class="el" href="namespacegmx.xhtml#a20e189e3f31f5f1e8581a5cc84063453afd1a4608b5b463bc7a41d86a1662d3b7">Architecture::X86</a>, 
<a class="el" href="namespacegmx.xhtml#a20e189e3f31f5f1e8581a5cc84063453a551c5c03a1a91f2cf90e0d9a9b6dd378">Architecture::Arm</a>, 
<a class="el" href="namespacegmx.xhtml#a20e189e3f31f5f1e8581a5cc84063453a1c020c7b78f5c449ffbe479f3b1aaa82">Architecture::PowerPC</a>
 }</td></tr>
<tr class="memdesc:a20e189e3f31f5f1e8581a5cc84063453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for GROMACS CPU hardware detection support.  <a href="namespacegmx.xhtml#a20e189e3f31f5f1e8581a5cc84063453">More...</a><br/></td></tr>
<tr class="separator:a20e189e3f31f5f1e8581a5cc84063453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b36e8f76d518d40f903d19520aec0e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<b>eawhtargetCONSTANT</b>, 
<b>eawhtargetCUTOFF</b>, 
<b>eawhtargetBOLTZMANN</b>, 
<b>eawhtargetLOCALBOLTZMANN</b>, 
<br/>
&#160;&#160;<b>eawhtargetNR</b>
<br/>
 }</td></tr>
<tr class="memdesc:a67b36e8f76d518d40f903d19520aec0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Target distribution enum. <br/></td></tr>
<tr class="separator:a67b36e8f76d518d40f903d19520aec0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b90c5f8e19cccb8279880ab5735144c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>eawhgrowthEXP_LINEAR</b>, 
<b>eawhgrowthLINEAR</b>, 
<b>eawhgrowthNR</b>
 }</td></tr>
<tr class="memdesc:a0b90c5f8e19cccb8279880ab5735144c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weight histogram growth enum. <br/></td></tr>
<tr class="separator:a0b90c5f8e19cccb8279880ab5735144c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976766b4feee44cdfe19fe2f6216f5cf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>eawhpotentialCONVOLVED</b>, 
<b>eawhpotentialUMBRELLA</b>, 
<b>eawhpotentialNR</b>
 }</td></tr>
<tr class="memdesc:a976766b4feee44cdfe19fe2f6216f5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">AWH potential type enum. <br/></td></tr>
<tr class="separator:a976766b4feee44cdfe19fe2f6216f5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4318a9db5effac9a2468334e5fa33a49"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>eawhcoordproviderPULL</b>, 
<b>eawhcoordproviderNR</b>
 }</td></tr>
<tr class="memdesc:a4318a9db5effac9a2468334e5fa33a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">AWH bias reaction coordinate provider. <br/></td></tr>
<tr class="separator:a4318a9db5effac9a2468334e5fa33a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89f55fd684646bb146f99a8c6c18569b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__options.xhtml#ga89f55fd684646bb146f99a8c6c18569b">OptionFileType</a> { <br/>
&#160;&#160;<b>eftUnknown</b>, 
<b>eftTopology</b>, 
<b>eftTrajectory</b>, 
<b>eftEnergy</b>, 
<br/>
&#160;&#160;<b>eftPDB</b>, 
<b>eftIndex</b>, 
<b>eftPlot</b>, 
<b>eftGenericData</b>, 
<br/>
&#160;&#160;<b>eftOptionFileType_NR</b>
<br/>
 }</td></tr>
<tr class="memdesc:ga89f55fd684646bb146f99a8c6c18569b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Purpose of file(s) provided through an option. <br/></td></tr>
<tr class="separator:ga89f55fd684646bb146f99a8c6c18569b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c22d32956f25d2432d5a6870983d5cb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__publicapi.xhtml#ga1c22d32956f25d2432d5a6870983d5cb">TimeUnit</a> { <br/>
&#160;&#160;<a class="el" href="group__group__publicapi.xhtml#gga1c22d32956f25d2432d5a6870983d5cbaf62491a2d381280231fdb1d87c3788be">TimeUnit_fs</a>, 
<a class="el" href="group__group__publicapi.xhtml#gga1c22d32956f25d2432d5a6870983d5cbaa937a11ed8176ada593733a46cd985dd">TimeUnit_ps</a>, 
<a class="el" href="group__group__publicapi.xhtml#gga1c22d32956f25d2432d5a6870983d5cbaee83c8ee85640f404d1da7f659c74e0b">TimeUnit_ns</a>, 
<a class="el" href="group__group__publicapi.xhtml#gga1c22d32956f25d2432d5a6870983d5cba788b558db3581dbb3c4929e73be61226">TimeUnit_us</a>, 
<br/>
&#160;&#160;<a class="el" href="group__group__publicapi.xhtml#gga1c22d32956f25d2432d5a6870983d5cbac129739439b285acd9608020af58baaf">TimeUnit_ms</a>, 
<a class="el" href="group__group__publicapi.xhtml#gga1c22d32956f25d2432d5a6870983d5cbae96310bb9de653e86c390aa0f081b0ce">TimeUnit_s</a>, 
<a class="el" href="group__group__publicapi.xhtml#gga1c22d32956f25d2432d5a6870983d5cba7c00d373b2fbd17b4236fc8636ed52ce">TimeUnit_Default</a> = TimeUnit_ps
<br/>
 }</td></tr>
<tr class="memdesc:ga1c22d32956f25d2432d5a6870983d5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time values for TimeUnitManager.  <a href="group__group__publicapi.xhtml#ga1c22d32956f25d2432d5a6870983d5cb">More...</a><br/></td></tr>
<tr class="separator:ga1c22d32956f25d2432d5a6870983d5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73202d646d57bcc963d8afd5a16015f0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0">RandomDomain</a> { <br/>
&#160;&#160;<a class="el" href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0a6311ae17c1ee52b36e68aaf4ad066387">RandomDomain::Other</a> = 0x00000000, 
<a class="el" href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0accb9e34a240647891f931e772cad80ef">RandomDomain::MaxwellVelocities</a> = 0x00001000, 
<a class="el" href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0aa42c5450c670a7ecbea5532bde9c0c65">RandomDomain::TestParticleInsertion</a> = 0x00002000, 
<a class="el" href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0a23714d9a49cc46ca81ad32670bde8b5e">RandomDomain::UpdateCoordinates</a> = 0x00003000, 
<br/>
&#160;&#160;<a class="el" href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0ab0634f71dbc527342668f2a63f1b3510">RandomDomain::UpdateConstraints</a> = 0x00004000, 
<a class="el" href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0a91e0b95db0c752d879aebd0ac65a7fb9">RandomDomain::Thermostat</a> = 0x00005000, 
<a class="el" href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0a79248e4db93ba16182fd3bf1c8e2fda7">RandomDomain::Barostat</a> = 0x00006000, 
<a class="el" href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0ada8008568302912872628be09e68fb84">RandomDomain::ReplicaExchange</a> = 0x00007000, 
<br/>
&#160;&#160;<a class="el" href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0a19bd460326d41817323764fa9e4287ff">RandomDomain::ExpandedEnsemble</a> = 0x00008000, 
<a class="el" href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0a447fab9cec8aab189be326d1cc099a3c">RandomDomain::AwhBiasing</a> = 0x00009000
<br/>
 }</td></tr>
<tr class="memdesc:a73202d646d57bcc963d8afd5a16015f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated values for fixed part of random seed (domain)  <a href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0">More...</a><br/></td></tr>
<tr class="separator:a73202d646d57bcc963d8afd5a16015f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf83788a301a602c40e8a49fce9c5e8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aacf83788a301a602c40e8a49fce9c5e8">TaskTarget</a> : int { <b>Auto</b>, 
<b>Cpu</b>, 
<b>Gpu</b>
 }</td></tr>
<tr class="memdesc:aacf83788a301a602c40e8a49fce9c5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record where a compute task is targetted. <br/></td></tr>
<tr class="separator:aacf83788a301a602c40e8a49fce9c5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6efc2e8f104eb3699bc82c2b8984cedb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a6efc2e8f104eb3699bc82c2b8984cedb">GpuTask</a> : int { <a class="el" href="namespacegmx.xhtml#a6efc2e8f104eb3699bc82c2b8984cedba661e23745453f323614a6316657bcbde">GpuTask::Nonbonded</a>, 
<a class="el" href="namespacegmx.xhtml#a6efc2e8f104eb3699bc82c2b8984cedba4792b2e853b980eb284e82db5ad5f4d5">GpuTask::Pme</a>
 }</td></tr>
<tr class="memdesc:a6efc2e8f104eb3699bc82c2b8984cedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of compute tasks that can be run on a GPU.  <a href="namespacegmx.xhtml#a6efc2e8f104eb3699bc82c2b8984cedb">More...</a><br/></td></tr>
<tr class="separator:a6efc2e8f104eb3699bc82c2b8984cedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac92ff9c7f6f5ed5200b3d8d92a4d53e3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gac92ff9c7f6f5ed5200b3d8d92a4d53e3">ErrorCode</a> { <br/>
&#160;&#160;<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3acacaa10fa7070b0494b30fdc97a7a356">eeOK</a>, 
<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a35a82c5a0f04b6255d3f28d6144dd24e">eeOutOfMemory</a>, 
<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a444e88ccfbfc246dc671919d0cf127c1">eeFileNotFound</a>, 
<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3ad0a05315bf704c8457baef6eac42dc4e">eeFileIO</a>, 
<br/>
&#160;&#160;<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a4c2569b29b84eda15a5cf90e28395b21">eeInvalidInput</a>, 
<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a7eb29dbd6ce224f815ba82ddcc3b6f62">eeInconsistentInput</a>, 
<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a11857eba83b9ec26fa530c71d5e3cdc8">eeTolerance</a>, 
<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3ac0b348673979b42ebc8df4562b8ebfa4">eeInstability</a>, 
<br/>
&#160;&#160;<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3ae958977bd58e97bcc4fd367324c8b21b">eeNotImplemented</a>, 
<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a71840645faa70349b0e4bede4da4b6d1">eeInvalidValue</a>, 
<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a40bd4aef44a2ab731b61fb9c9184a3bd">eeInvalidCall</a>, 
<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a90b9f0f24cf026b56ebf63d359c5f422">eeInternalError</a>, 
<br/>
&#160;&#160;<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a414167b1bc702c9e8bb7f91078360845">eeAPIError</a>, 
<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a068d9a3d2c79173f39457344cd60380f">eeRange</a>, 
<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a395dad7e12b144dd6805157e6d92e40f">eeCommunication</a>, 
<a class="el" href="group__module__utility.xhtml#ggac92ff9c7f6f5ed5200b3d8d92a4d53e3a46578ca340e1c440d5f519569e6884fb">eeUnknownError</a>
<br/>
 }</td></tr>
<tr class="memdesc:gac92ff9c7f6f5ed5200b3d8d92a4d53e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible error return codes from Gromacs functions.  <a href="group__module__utility.xhtml#gac92ff9c7f6f5ed5200b3d8d92a4d53e3">More...</a><br/></td></tr>
<tr class="separator:gac92ff9c7f6f5ed5200b3d8d92a4d53e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaf9a9e69ad91172d5f4fba7148280762"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgmx_1_1AnalysisHistogramSettingsInitializer.xhtml">AnalysisHistogramSettingsInitializer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__publicapi.xhtml#gaaf9a9e69ad91172d5f4fba7148280762">histogramFromRange</a> (<a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> <a class="el" href="namespacegmx.xhtml#aa6d21dccd9a94698363bdb1943f139bb">min</a>, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> <a class="el" href="namespacegmx.xhtml#a35c7b010fbd32f5424afa0de0c70db6f">max</a>)</td></tr>
<tr class="memdesc:gaaf9a9e69ad91172d5f4fba7148280762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a histogram using a range and a bin width.  <a href="group__group__publicapi.xhtml#gaaf9a9e69ad91172d5f4fba7148280762">More...</a><br/></td></tr>
<tr class="separator:gaaf9a9e69ad91172d5f4fba7148280762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73a2213cd82e2f915b9f9d65a4b85212"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgmx_1_1AnalysisHistogramSettingsInitializer.xhtml">AnalysisHistogramSettingsInitializer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__publicapi.xhtml#ga73a2213cd82e2f915b9f9d65a4b85212">histogramFromBins</a> (<a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> start, int nbins, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> binwidth)</td></tr>
<tr class="memdesc:ga73a2213cd82e2f915b9f9d65a4b85212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a histogram using bin width and the number of bins.  <a href="group__group__publicapi.xhtml#ga73a2213cd82e2f915b9f9d65a4b85212">More...</a><br/></td></tr>
<tr class="separator:ga73a2213cd82e2f915b9f9d65a4b85212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71df1e05c861d1f59d7185d9577e7944"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; IMDModule &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a71df1e05c861d1f59d7185d9577e7944">createElectricFieldModule</a> ()</td></tr>
<tr class="memdesc:a71df1e05c861d1f59d7185d9577e7944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a module for an external electric field.  <a href="#a71df1e05c861d1f59d7185d9577e7944">More...</a><br/></td></tr>
<tr class="separator:a71df1e05c861d1f59d7185d9577e7944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed28e758d06a65093782945f720a305"><td class="memItemLeft" align="right" valign="top">static gmx_int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a0ed28e758d06a65093782945f720a305">countSamples</a> (const std::vector&lt; PointState &gt; &amp;pointState)</td></tr>
<tr class="memdesc:a0ed28e758d06a65093782945f720a305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the total number of samples / sample weight over all grid points.  <a href="#a0ed28e758d06a65093782945f720a305">More...</a><br/></td></tr>
<tr class="separator:a0ed28e758d06a65093782945f720a305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf06e7cadddc4762cf22625a990a97e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aabf06e7cadddc4762cf22625a990a97e">ensureStateAndRunConsistency</a> (const BiasParams &amp;params, const BiasState &amp;state)</td></tr>
<tr class="memdesc:aabf06e7cadddc4762cf22625a990a97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the state (loaded from checkpoint) and the run are consistent.  <a href="#aabf06e7cadddc4762cf22625a990a97e">More...</a><br/></td></tr>
<tr class="separator:aabf06e7cadddc4762cf22625a990a97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e36f9644573f5a5a187ada06cc52e46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a1e36f9644573f5a5a187ada06cc52e46">haveBiasSharingWithinSimulation</a> (const AwhParams &amp;awhParams)</td></tr>
<tr class="memdesc:a1e36f9644573f5a5a187ada06cc52e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if any bias is sharing within a simulation.  <a href="#a1e36f9644573f5a5a187ada06cc52e46">More...</a><br/></td></tr>
<tr class="separator:a1e36f9644573f5a5a187ada06cc52e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa9d80fa7714a4342b4e28cff1e636d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a7fa9d80fa7714a4342b4e28cff1e636d">biasesAreCompatibleForSharingBetweenSimulations</a> (const AwhParams &amp;awhParams, const std::vector&lt; size_t &gt; &amp;pointSize, const gmx_multisim_t *multiSimComm)</td></tr>
<tr class="memdesc:a7fa9d80fa7714a4342b4e28cff1e636d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if biases are compatible for sharing between simulations, throws if not.  <a href="#a7fa9d80fa7714a4342b4e28cff1e636d">More...</a><br/></td></tr>
<tr class="separator:a7fa9d80fa7714a4342b4e28cff1e636d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a9213632dd1a11d0ad5eb64eb211cc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ac1a9213632dd1a11d0ad5eb64eb211cc">normalizeFreeEnergyAndPmfSum</a> (std::vector&lt; PointState &gt; *pointState)</td></tr>
<tr class="memdesc:ac1a9213632dd1a11d0ad5eb64eb211cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the free energy and PMF sum.  <a href="#ac1a9213632dd1a11d0ad5eb64eb211cc">More...</a><br/></td></tr>
<tr class="separator:ac1a9213632dd1a11d0ad5eb64eb211cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3a624cce03f1a33bca6a9d70e8c3a7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#abb3a624cce03f1a33bca6a9d70e8c3a7">countTrailingZeroRows</a> (const double *const *data, int numRows, int numColumns)</td></tr>
<tr class="memdesc:abb3a624cce03f1a33bca6a9d70e8c3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count trailing data rows containing only zeros.  <a href="#abb3a624cce03f1a33bca6a9d70e8c3a7">More...</a><br/></td></tr>
<tr class="separator:abb3a624cce03f1a33bca6a9d70e8c3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89c1ec80da5f3b1d759be2ce01993fa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ac89c1ec80da5f3b1d759be2ce01993fa">readUserPmfAndTargetDistribution</a> (const std::vector&lt; DimParams &gt; &amp;dimParams, const Grid &amp;grid, const std::string &amp;filename, int numBias, int biasIndex, std::vector&lt; PointState &gt; *pointState)</td></tr>
<tr class="memdesc:ac89c1ec80da5f3b1d759be2ce01993fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the PMF and target with data read from an input table.  <a href="#ac89c1ec80da5f3b1d759be2ce01993fa">More...</a><br/></td></tr>
<tr class="separator:ac89c1ec80da5f3b1d759be2ce01993fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bac9d01a06d35dc45d86a6bdba4f06"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a70bac9d01a06d35dc45d86a6bdba4f06">normalizeBlock</a> (AwhEnergyBlock *block, const Bias &amp;bias)</td></tr>
<tr class="memdesc:a70bac9d01a06d35dc45d86a6bdba4f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes block data for output.  <a href="#a70bac9d01a06d35dc45d86a6bdba4f06">More...</a><br/></td></tr>
<tr class="separator:a70bac9d01a06d35dc45d86a6bdba4f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6f64a0b469be5da3207e0855763183"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aaf6f64a0b469be5da3207e0855763183">initCorrelationGridHistory</a> (CorrelationGridHistory *correlationGridHistory, int numCorrelationTensors, int tensorSize, int blockDataListSize)</td></tr>
<tr class="memdesc:aaf6f64a0b469be5da3207e0855763183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize correlation grid history, sets all sizes.  <a href="#aaf6f64a0b469be5da3207e0855763183">More...</a><br/></td></tr>
<tr class="separator:aaf6f64a0b469be5da3207e0855763183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01b9aad76f60c5c887139e4644fd079"><td class="memItemLeft" align="right" valign="top">CorrelationGridHistory&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa01b9aad76f60c5c887139e4644fd079">initCorrelationGridHistoryFromState</a> (const CorrelationGrid &amp;corrGrid)</td></tr>
<tr class="memdesc:aa01b9aad76f60c5c887139e4644fd079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a correlation grid history with the same structure as the given correlation grid.  <a href="#aa01b9aad76f60c5c887139e4644fd079">More...</a><br/></td></tr>
<tr class="separator:aa01b9aad76f60c5c887139e4644fd079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25892b094f85a4d534ed625143b489e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a25892b094f85a4d534ed625143b489e2">updateCorrelationGridHistory</a> (CorrelationGridHistory *corrGridHist, const CorrelationGrid &amp;corrGrid)</td></tr>
<tr class="memdesc:a25892b094f85a4d534ed625143b489e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the correlation grid history for checkpointing.  <a href="#a25892b094f85a4d534ed625143b489e2">More...</a><br/></td></tr>
<tr class="separator:a25892b094f85a4d534ed625143b489e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf507d7b44182c8c37cbcd937c1c7599"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#acf507d7b44182c8c37cbcd937c1c7599">restoreCorrelationGridStateFromHistory</a> (const CorrelationGridHistory &amp;corrGridHist, CorrelationGrid *corrGrid)</td></tr>
<tr class="memdesc:acf507d7b44182c8c37cbcd937c1c7599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores the correlation grid state from the correlation grid history.  <a href="#acf507d7b44182c8c37cbcd937c1c7599">More...</a><br/></td></tr>
<tr class="separator:acf507d7b44182c8c37cbcd937c1c7599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4309ee8c0866fc1d57d89a3b0a4fdfb8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a4309ee8c0866fc1d57d89a3b0a4fdfb8">getDeviationFromPointAlongGridAxis</a> (const Grid &amp;grid, int dimIndex, int pointIndex, double value)</td></tr>
<tr class="memdesc:a4309ee8c0866fc1d57d89a3b0a4fdfb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the deviation along one dimension from the given value to a point in the grid.  <a href="#a4309ee8c0866fc1d57d89a3b0a4fdfb8">More...</a><br/></td></tr>
<tr class="separator:a4309ee8c0866fc1d57d89a3b0a4fdfb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1bde42dccd13214cf4944199d9046a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a6a1bde42dccd13214cf4944199d9046a">linearArrayIndexToMultiDim</a> (int indexLinear, int ndim, const <a class="el" href="namespacegmx.xhtml#a74baae008f9132c5e0daf2a02b122b3b">awh_ivec</a> numPointsDim, <a class="el" href="namespacegmx.xhtml#a74baae008f9132c5e0daf2a02b122b3b">awh_ivec</a> indexMulti)</td></tr>
<tr class="memdesc:a6a1bde42dccd13214cf4944199d9046a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a linear array index to a multidimensional one.  <a href="#a6a1bde42dccd13214cf4944199d9046a">More...</a><br/></td></tr>
<tr class="separator:a6a1bde42dccd13214cf4944199d9046a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ebe3ce6ae05dc90ba9d59d5e09cb39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ac4ebe3ce6ae05dc90ba9d59d5e09cb39">linearGridindexToMultiDim</a> (const Grid &amp;grid, int indexLinear, <a class="el" href="namespacegmx.xhtml#a74baae008f9132c5e0daf2a02b122b3b">awh_ivec</a> indexMulti)</td></tr>
<tr class="memdesc:ac4ebe3ce6ae05dc90ba9d59d5e09cb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a linear grid point index to a multidimensional one.  <a href="#ac4ebe3ce6ae05dc90ba9d59d5e09cb39">More...</a><br/></td></tr>
<tr class="separator:ac4ebe3ce6ae05dc90ba9d59d5e09cb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3c14f0aeb1baca8c9c7e874f83a9ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a7d3c14f0aeb1baca8c9c7e874f83a9ac">multiDimArrayIndexToLinear</a> (const <a class="el" href="namespacegmx.xhtml#a74baae008f9132c5e0daf2a02b122b3b">awh_ivec</a> indexMulti, int numDim, const <a class="el" href="namespacegmx.xhtml#a74baae008f9132c5e0daf2a02b122b3b">awh_ivec</a> numPointsDim)</td></tr>
<tr class="memdesc:a7d3c14f0aeb1baca8c9c7e874f83a9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert multidimensional array index to a linear one.  <a href="#a7d3c14f0aeb1baca8c9c7e874f83a9ac">More...</a><br/></td></tr>
<tr class="separator:a7d3c14f0aeb1baca8c9c7e874f83a9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf57aec6fb404cfd80fef4fb95610f49"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#adf57aec6fb404cfd80fef4fb95610f49">multiDimGridIndexToLinear</a> (const Grid &amp;grid, const <a class="el" href="namespacegmx.xhtml#a74baae008f9132c5e0daf2a02b122b3b">awh_ivec</a> indexMulti)</td></tr>
<tr class="memdesc:adf57aec6fb404cfd80fef4fb95610f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a multidimensional grid point index to a linear one.  <a href="#adf57aec6fb404cfd80fef4fb95610f49">More...</a><br/></td></tr>
<tr class="separator:adf57aec6fb404cfd80fef4fb95610f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94faad595233e4c3ca46c42dc1c1b5e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a94faad595233e4c3ca46c42dc1c1b5e4">advancePointInSubgrid</a> (const Grid &amp;grid, const <a class="el" href="namespacegmx.xhtml#a74baae008f9132c5e0daf2a02b122b3b">awh_ivec</a> subgridOrigin, const <a class="el" href="namespacegmx.xhtml#a74baae008f9132c5e0daf2a02b122b3b">awh_ivec</a> subgridNpoints, int *gridPointIndex)</td></tr>
<tr class="memdesc:a94faad595233e4c3ca46c42dc1c1b5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the next grid point in the sub-part of the grid given a starting point.  <a href="#a94faad595233e4c3ca46c42dc1c1b5e4">More...</a><br/></td></tr>
<tr class="separator:a94faad595233e4c3ca46c42dc1c1b5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9980e0f1eac7ff209652d8cecb1eca36"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a9980e0f1eac7ff209652d8cecb1eca36">pointDistanceAlongAxis</a> (const GridAxis &amp;axis, double x, double x0)</td></tr>
<tr class="memdesc:a9980e0f1eac7ff209652d8cecb1eca36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the point distance between from value x to value x0 along the given axis.  <a href="#a9980e0f1eac7ff209652d8cecb1eca36">More...</a><br/></td></tr>
<tr class="separator:a9980e0f1eac7ff209652d8cecb1eca36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c9ffd9ce10581a97bb93f064c6c98c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ae3c9ffd9ce10581a97bb93f064c6c98c">valueIsInGrid</a> (const <a class="el" href="namespacegmx.xhtml#a079fa4aee8e4c6663f35aa1d0f4bac4b">awh_dvec</a> value, const std::vector&lt; GridAxis &gt; &amp;axis)</td></tr>
<tr class="memdesc:ae3c9ffd9ce10581a97bb93f064c6c98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if a value is in range of the grid.  <a href="#ae3c9ffd9ce10581a97bb93f064c6c98c">More...</a><br/></td></tr>
<tr class="separator:ae3c9ffd9ce10581a97bb93f064c6c98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1a7538a2bc458730d961649ae007d4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a7b1a7538a2bc458730d961649ae007d4">getNearestIndexInGrid</a> (const <a class="el" href="namespacegmx.xhtml#a079fa4aee8e4c6663f35aa1d0f4bac4b">awh_dvec</a> value, const std::vector&lt; GridAxis &gt; &amp;axis)</td></tr>
<tr class="memdesc:a7b1a7538a2bc458730d961649ae007d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a value to the nearest point in the grid.  <a href="#a7b1a7538a2bc458730d961649ae007d4">More...</a><br/></td></tr>
<tr class="separator:a7b1a7538a2bc458730d961649ae007d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5f6c6b181970bbba2ecf4d61f49b4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2a5f6c6b181970bbba2ecf4d61f49b4c">mapGridToDataGrid</a> (std::vector&lt; int &gt; *gridpointToDatapoint, const double *const *data, int numDataPoints, const std::string &amp;dataFilename, const Grid &amp;grid, const std::string &amp;correctFormatMessage)</td></tr>
<tr class="memdesc:a2a5f6c6b181970bbba2ecf4d61f49b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps each point in the grid to a point in the data grid.  <a href="#a2a5f6c6b181970bbba2ecf4d61f49b4c">More...</a><br/></td></tr>
<tr class="separator:a2a5f6c6b181970bbba2ecf4d61f49b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106f95fbad0f5e464f5af96026421175"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a106f95fbad0f5e464f5af96026421175">readDimParams</a> (int *ninp_p, t_inpfile **inp_p, const char *prefix, AwhDimParams *dimParams, const pull_params_t *pull_params, warninp_t wi, bool bComment)</td></tr>
<tr class="memdesc:a106f95fbad0f5e464f5af96026421175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read parameters of an AWH bias dimension.  <a href="#a106f95fbad0f5e464f5af96026421175">More...</a><br/></td></tr>
<tr class="separator:a106f95fbad0f5e464f5af96026421175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85717d4bd89406922cfa1fd7c92c9485"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a85717d4bd89406922cfa1fd7c92c9485">checkInputConsistencyAwhBias</a> (const AwhBiasParams &amp;awhBiasParams, warninp_t wi)</td></tr>
<tr class="memdesc:a85717d4bd89406922cfa1fd7c92c9485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check consistency of input at the AWH bias level.  <a href="#a85717d4bd89406922cfa1fd7c92c9485">More...</a><br/></td></tr>
<tr class="separator:a85717d4bd89406922cfa1fd7c92c9485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9efd8200514249693d8d5e78b365d02"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af9efd8200514249693d8d5e78b365d02">read_bias_params</a> (int *ninp_p, t_inpfile **inp_p, AwhBiasParams *awhBiasParams, const char *prefix, const t_inputrec *ir, warninp_t wi, bool bComment)</td></tr>
<tr class="memdesc:af9efd8200514249693d8d5e78b365d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read parameters of an AWH bias.  <a href="#af9efd8200514249693d8d5e78b365d02">More...</a><br/></td></tr>
<tr class="separator:af9efd8200514249693d8d5e78b365d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff52fcc642134b6d46c014f4dbb2969"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a8ff52fcc642134b6d46c014f4dbb2969">checkInputConsistencyAwh</a> (const AwhParams &amp;awhParams, warninp_t wi)</td></tr>
<tr class="memdesc:a8ff52fcc642134b6d46c014f4dbb2969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check consistency of input at the AWH level.  <a href="#a8ff52fcc642134b6d46c014f4dbb2969">More...</a><br/></td></tr>
<tr class="separator:a8ff52fcc642134b6d46c014f4dbb2969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1ab815522d5c19977d39108b4d5e8a"><td class="memItemLeft" align="right" valign="top">AwhParams *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a0b1ab815522d5c19977d39108b4d5e8a">readAndCheckAwhParams</a> (int *ninp_p, t_inpfile **inp_p, const t_inputrec *inputrec, warninp_t wi)</td></tr>
<tr class="memdesc:a0b1ab815522d5c19977d39108b4d5e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate, initialize and check the AWH parameters with values from the input file.  <a href="#a0b1ab815522d5c19977d39108b4d5e8a">More...</a><br/></td></tr>
<tr class="separator:a0b1ab815522d5c19977d39108b4d5e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4208e61154b60990cfabb18cb8a48a84"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a4208e61154b60990cfabb18cb8a48a84">get_pull_coord_period</a> (const pull_params_t *pull_params, int coord_ind, const matrix box)</td></tr>
<tr class="memdesc:a4208e61154b60990cfabb18cb8a48a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the period of a pull coordinate.  <a href="#a4208e61154b60990cfabb18cb8a48a84">More...</a><br/></td></tr>
<tr class="separator:a4208e61154b60990cfabb18cb8a48a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc67674eebce1fa4cc561927ba73ccda"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#adc67674eebce1fa4cc561927ba73ccda">intervalIsInPeriodicInterval</a> (double origin, double end, double period)</td></tr>
<tr class="memdesc:adc67674eebce1fa4cc561927ba73ccda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given interval is defined in the correct periodic interval.  <a href="#adc67674eebce1fa4cc561927ba73ccda">More...</a><br/></td></tr>
<tr class="separator:adc67674eebce1fa4cc561927ba73ccda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee766424804cf631da09f2368073fe9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a3ee766424804cf631da09f2368073fe9">valueIsInInterval</a> (double origin, double end, double period, double value)</td></tr>
<tr class="memdesc:a3ee766424804cf631da09f2368073fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a value is within an interval.  <a href="#a3ee766424804cf631da09f2368073fe9">More...</a><br/></td></tr>
<tr class="separator:a3ee766424804cf631da09f2368073fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49931df65c6a671dc8b4f2ea519b7b3e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a49931df65c6a671dc8b4f2ea519b7b3e">checkInputConsistencyInterval</a> (const AwhParams *awhParams, warninp_t wi)</td></tr>
<tr class="memdesc:a49931df65c6a671dc8b4f2ea519b7b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the starting configuration is consistent with the given interval.  <a href="#a49931df65c6a671dc8b4f2ea519b7b3e">More...</a><br/></td></tr>
<tr class="separator:a49931df65c6a671dc8b4f2ea519b7b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff25434ee8b48eac9e2d95c5ebbbaf87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aff25434ee8b48eac9e2d95c5ebbbaf87">setStateDependentAwhParams</a> (AwhParams *awhParams, const pull_params_t *pull_params, pull_t *pull_work, const matrix box, int ePBC, const t_grpopts *inputrecGroupOptions, warninp_t wi)</td></tr>
<tr class="memdesc:aff25434ee8b48eac9e2d95c5ebbbaf87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets AWH parameters that need state parameters such as the box vectors.  <a href="#aff25434ee8b48eac9e2d95c5ebbbaf87">More...</a><br/></td></tr>
<tr class="separator:aff25434ee8b48eac9e2d95c5ebbbaf87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c376f5f94bd1a63a3a97e288c4be50d"><td class="memItemLeft" align="right" valign="top">CommandLineProgramContext &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__commandline.xhtml#ga8c376f5f94bd1a63a3a97e288c4be50d">initForCommandLine</a> (int *argc, char ***argv)</td></tr>
<tr class="memdesc:ga8c376f5f94bd1a63a3a97e288c4be50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the GROMACS library for command-line use.  <a href="group__module__commandline.xhtml#ga8c376f5f94bd1a63a3a97e288c4be50d">More...</a><br/></td></tr>
<tr class="separator:ga8c376f5f94bd1a63a3a97e288c4be50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49311a4a4e3f3ec07a9ae925fb63151f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__commandline.xhtml#ga49311a4a4e3f3ec07a9ae925fb63151f">finalizeForCommandLine</a> ()</td></tr>
<tr class="memdesc:ga49311a4a4e3f3ec07a9ae925fb63151f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitializes the GROMACS library after <a class="el" href="group__module__commandline.xhtml#ga8c376f5f94bd1a63a3a97e288c4be50d" title="Initializes the GROMACS library for command-line use. ">initForCommandLine()</a>.  <a href="group__module__commandline.xhtml#ga49311a4a4e3f3ec07a9ae925fb63151f">More...</a><br/></td></tr>
<tr class="separator:ga49311a4a4e3f3ec07a9ae925fb63151f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fe34835a6e197f2731e7d604f28992"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ad8fe34835a6e197f2731e7d604f28992">processExceptionAtExitForCommandLine</a> (const std::exception &amp;ex)</td></tr>
<tr class="memdesc:ad8fe34835a6e197f2731e7d604f28992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles an exception and deinitializes after initForCommandLine.  <a href="#ad8fe34835a6e197f2731e7d604f28992">More...</a><br/></td></tr>
<tr class="separator:ad8fe34835a6e197f2731e7d604f28992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3bc0e66dda7e48091ad129bede7eff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a5a3bc0e66dda7e48091ad129bede7eff">runCommandLineModule</a> (int argc, char *argv[], <a class="el" href="classgmx_1_1ICommandLineModule.xhtml">ICommandLineModule</a> *module)</td></tr>
<tr class="memdesc:a5a3bc0e66dda7e48091ad129bede7eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a <a class="el" href="template_8cpp.xhtml#a0ddf1224851353fc92bfbff6f499fa97" title="The main function for the analysis template. ">main()</a> method that runs a single module.  <a href="#a5a3bc0e66dda7e48091ad129bede7eff">More...</a><br/></td></tr>
<tr class="separator:a5a3bc0e66dda7e48091ad129bede7eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7a039b6fae746686d472d1fcae6fee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a8a7a039b6fae746686d472d1fcae6fee">runCommandLineModule</a> (int argc, char *argv[], const char *name, const char *description, std::function&lt; std::unique_ptr&lt; <a class="el" href="classgmx_1_1ICommandLineOptionsModule.xhtml">ICommandLineOptionsModule</a> &gt;()&gt; factory)</td></tr>
<tr class="memdesc:a8a7a039b6fae746686d472d1fcae6fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a <a class="el" href="template_8cpp.xhtml#a0ddf1224851353fc92bfbff6f499fa97" title="The main function for the analysis template. ">main()</a> method that runs a single module.  <a href="#a8a7a039b6fae746686d472d1fcae6fee">More...</a><br/></td></tr>
<tr class="separator:a8a7a039b6fae746686d472d1fcae6fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ced30f5b4f4e3a6b3d2192040a135dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2ced30f5b4f4e3a6b3d2192040a135dc">writeKeyValueTreeAsMdp</a> (TextWriter *writer, const KeyValueTreeObject &amp;tree)</td></tr>
<tr class="memdesc:a2ced30f5b4f4e3a6b3d2192040a135dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a flat key-value <code>tree</code> to <code>writer</code> in mdp style.  <a href="#a2ced30f5b4f4e3a6b3d2192040a135dc">More...</a><br/></td></tr>
<tr class="separator:a2ced30f5b4f4e3a6b3d2192040a135dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242c17b1eeb8720c0e6324d098810ac8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a242c17b1eeb8720c0e6324d098810ac8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a242c17b1eeb8720c0e6324d098810ac8">changePinningPolicy</a> (<a class="el" href="namespacegmx.xhtml#a15043f587f8595747fbc7c4dee890cb2">HostVector</a>&lt; T &gt; *v, <a class="el" href="namespacegmx.xhtml#abe4caed0469c0de84e0c1c1a81972b38">PinningPolicy</a> pinningPolicy)</td></tr>
<tr class="memdesc:a242c17b1eeb8720c0e6324d098810ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for changing the pinning policy of a HostVector.  <a href="#a242c17b1eeb8720c0e6324d098810ac8">More...</a><br/></td></tr>
<tr class="separator:a242c17b1eeb8720c0e6324d098810ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7baa17fdd5339a2faa2e0427bde6dea9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a7baa17fdd5339a2faa2e0427bde6dea9">pinBuffer</a> (void *pointer, std::size_t numBytes) noexcept</td></tr>
<tr class="memdesc:a7baa17fdd5339a2faa2e0427bde6dea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pin the allocation to physical memory.  <a href="#a7baa17fdd5339a2faa2e0427bde6dea9">More...</a><br/></td></tr>
<tr class="separator:a7baa17fdd5339a2faa2e0427bde6dea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a29f07fcc6fe2c674e57357ca36327"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a89a29f07fcc6fe2c674e57357ca36327">unpinBuffer</a> (void *pointer) noexcept</td></tr>
<tr class="memdesc:a89a29f07fcc6fe2c674e57357ca36327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpin the allocation.  <a href="#a89a29f07fcc6fe2c674e57357ca36327">More...</a><br/></td></tr>
<tr class="separator:a89a29f07fcc6fe2c674e57357ca36327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70063f05c46b838ac5aab645dff410c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a70063f05c46b838ac5aab645dff410c0">doDeviceTransfers</a> (const gmx_gpu_info_t &amp;gpuInfo, <a class="el" href="classgmx_1_1ArrayRef.xhtml">ArrayRef</a>&lt; const char &gt; input, <a class="el" href="classgmx_1_1ArrayRef.xhtml">ArrayRef</a>&lt; char &gt; output)</td></tr>
<tr class="memdesc:a70063f05c46b838ac5aab645dff410c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for GPU test code to be platform agnostic.  <a href="#a70063f05c46b838ac5aab645dff410c0">More...</a><br/></td></tr>
<tr class="separator:a70063f05c46b838ac5aab645dff410c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af536d7a23a442f3c0876b05ac20d7d40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af536d7a23a442f3c0876b05ac20d7d40">cpuIsX86Nehalem</a> (const CpuInfo &amp;cpuInfo)</td></tr>
<tr class="memdesc:af536d7a23a442f3c0876b05ac20d7d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the CPU is an Intel x86 Nehalem.  <a href="#af536d7a23a442f3c0876b05ac20d7d40">More...</a><br/></td></tr>
<tr class="separator:af536d7a23a442f3c0876b05ac20d7d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657dcdb623893eee2bb6aec9bc109f75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a657dcdb623893eee2bb6aec9bc109f75"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a657dcdb623893eee2bb6aec9bc109f75">gmx_detect_gpus</a> (const gmx::MDLogger &amp;mdlog, const t_commrec *cr)</td></tr>
<tr class="memdesc:a657dcdb623893eee2bb6aec9bc109f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect GPUs, if that makes sense to attempt. <br/></td></tr>
<tr class="separator:a657dcdb623893eee2bb6aec9bc109f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cdeae0fc4dfeec86bb2ede898469c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50cdeae0fc4dfeec86bb2ede898469c0"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a50cdeae0fc4dfeec86bb2ede898469c0">gmx_collect_hardware_mpi</a> (const gmx::CpuInfo &amp;cpuInfo)</td></tr>
<tr class="memdesc:a50cdeae0fc4dfeec86bb2ede898469c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce the locally collected <code>hwinfo_g</code> over MPI ranks. <br/></td></tr>
<tr class="separator:a50cdeae0fc4dfeec86bb2ede898469c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd311127349695578cbf6fd8d1e0c0b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a5dd311127349695578cbf6fd8d1e0c0b">spinUpCore</a> () noexcept</td></tr>
<tr class="memdesc:a5dd311127349695578cbf6fd8d1e0c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility that does dummy computing for max 2 seconds to spin up cores.  <a href="#a5dd311127349695578cbf6fd8d1e0c0b">More...</a><br/></td></tr>
<tr class="separator:a5dd311127349695578cbf6fd8d1e0c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94df5cf90664201e85bedaa913dff674"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a94df5cf90664201e85bedaa913dff674">hardwareTopologyPrepareDetection</a> ()</td></tr>
<tr class="memdesc:a94df5cf90664201e85bedaa913dff674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare the system before hardware topology detection.  <a href="#a94df5cf90664201e85bedaa913dff674">More...</a><br/></td></tr>
<tr class="separator:a94df5cf90664201e85bedaa913dff674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe4ce4fbd2881cc0c7a1aebfb93cf50"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a0fe4ce4fbd2881cc0c7a1aebfb93cf50">hardwareTopologyDoubleCheckDetection</a> (const gmx::MDLogger &amp;mdlog, const gmx::HardwareTopology &amp;hardwareTopology)</td></tr>
<tr class="memdesc:a0fe4ce4fbd2881cc0c7a1aebfb93cf50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sanity check hardware topology and print some notes to log.  <a href="#a0fe4ce4fbd2881cc0c7a1aebfb93cf50">More...</a><br/></td></tr>
<tr class="separator:a0fe4ce4fbd2881cc0c7a1aebfb93cf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1528c07c49b94c33fc51f681f8ba170"><td class="memItemLeft" align="right" valign="top">gmx_hw_info_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ac1528c07c49b94c33fc51f681f8ba170">gmx_detect_hardware</a> (const gmx::MDLogger &amp;mdlog, const t_commrec *cr)</td></tr>
<tr class="memdesc:ac1528c07c49b94c33fc51f681f8ba170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run detection, consistency checks, and make available on all ranks.  <a href="#ac1528c07c49b94c33fc51f681f8ba170">More...</a><br/></td></tr>
<tr class="separator:ac1528c07c49b94c33fc51f681f8ba170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c49c11017f2f037f35f795232ed32a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33c49c11017f2f037f35f795232ed32a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a33c49c11017f2f037f35f795232ed32a">compatibleGpusFound</a> (const gmx_gpu_info_t &amp;gpu_info)</td></tr>
<tr class="memdesc:a33c49c11017f2f037f35f795232ed32a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether compatible GPUs were found. <br/></td></tr>
<tr class="separator:a33c49c11017f2f037f35f795232ed32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34312071a6a3659084534504aeef089"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af34312071a6a3659084534504aeef089"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af34312071a6a3659084534504aeef089">gmx_hardware_info_free</a> ()</td></tr>
<tr class="memdesc:af34312071a6a3659084534504aeef089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the hwinfo structure. <br/></td></tr>
<tr class="separator:af34312071a6a3659084534504aeef089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6edee513f8fdeaffb9094124f58ba270"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a6edee513f8fdeaffb9094124f58ba270">identifyAvx512FmaUnits</a> ()</td></tr>
<tr class="memdesc:a6edee513f8fdeaffb9094124f58ba270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether machine has dual AVX512 FMA units.  <a href="#a6edee513f8fdeaffb9094124f58ba270">More...</a><br/></td></tr>
<tr class="separator:a6edee513f8fdeaffb9094124f58ba270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b47d79ef735987258c2f601cf2822be"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2b47d79ef735987258c2f601cf2822be">log2I</a> (std::uint32_t x)</td></tr>
<tr class="memdesc:a2b47d79ef735987258c2f601cf2822be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute floor of logarithm to base 2, 32 bit unsigned argument.  <a href="#a2b47d79ef735987258c2f601cf2822be">More...</a><br/></td></tr>
<tr class="separator:a2b47d79ef735987258c2f601cf2822be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa498ec06db6575ec672e5ba847f086ab"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa498ec06db6575ec672e5ba847f086ab">log2I</a> (std::uint64_t x)</td></tr>
<tr class="memdesc:aa498ec06db6575ec672e5ba847f086ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute floor of logarithm to base 2, 64 bit unsigned argument.  <a href="#aa498ec06db6575ec672e5ba847f086ab">More...</a><br/></td></tr>
<tr class="separator:aa498ec06db6575ec672e5ba847f086ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1cadcfe34ba004506db6e0e11f36c95"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ab1cadcfe34ba004506db6e0e11f36c95">log2I</a> (std::int32_t x)</td></tr>
<tr class="memdesc:ab1cadcfe34ba004506db6e0e11f36c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute floor of logarithm to base 2, 32 bit signed argument.  <a href="#ab1cadcfe34ba004506db6e0e11f36c95">More...</a><br/></td></tr>
<tr class="separator:ab1cadcfe34ba004506db6e0e11f36c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfba3f9dd776dc29c1d0a8311ed793f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#afbfba3f9dd776dc29c1d0a8311ed793f">log2I</a> (std::int64_t x)</td></tr>
<tr class="memdesc:afbfba3f9dd776dc29c1d0a8311ed793f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute floor of logarithm to base 2, 64 bit signed argument.  <a href="#afbfba3f9dd776dc29c1d0a8311ed793f">More...</a><br/></td></tr>
<tr class="separator:afbfba3f9dd776dc29c1d0a8311ed793f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a820e81baebe1c30a4190eb2aa2a64"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a87a820e81baebe1c30a4190eb2aa2a64">greatestCommonDivisor</a> (std::int64_t p, std::int64_t q)</td></tr>
<tr class="memdesc:a87a820e81baebe1c30a4190eb2aa2a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find greatest common divisor of two numbers.  <a href="#a87a820e81baebe1c30a4190eb2aa2a64">More...</a><br/></td></tr>
<tr class="separator:a87a820e81baebe1c30a4190eb2aa2a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dad03094a0ea5970a5f0977ce5fee84"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2dad03094a0ea5970a5f0977ce5fee84">erfinv</a> (double x)</td></tr>
<tr class="memdesc:a2dad03094a0ea5970a5f0977ce5fee84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse error function, double precision.  <a href="#a2dad03094a0ea5970a5f0977ce5fee84">More...</a><br/></td></tr>
<tr class="separator:a2dad03094a0ea5970a5f0977ce5fee84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85012c7d3609ac21e4052fc3114125a9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a85012c7d3609ac21e4052fc3114125a9">erfinv</a> (float x)</td></tr>
<tr class="memdesc:a85012c7d3609ac21e4052fc3114125a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse error function, single precision.  <a href="#a85012c7d3609ac21e4052fc3114125a9">More...</a><br/></td></tr>
<tr class="separator:a85012c7d3609ac21e4052fc3114125a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953226d61f6527af6485ea56a8384c85"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a953226d61f6527af6485ea56a8384c85">invsqrt</a> (float x)</td></tr>
<tr class="memdesc:a953226d61f6527af6485ea56a8384c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1.0/sqrt(x) in single precision.  <a href="#a953226d61f6527af6485ea56a8384c85">More...</a><br/></td></tr>
<tr class="separator:a953226d61f6527af6485ea56a8384c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26d0b65eb141c73979c5d2f1d0e13fa"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ae26d0b65eb141c73979c5d2f1d0e13fa">invsqrt</a> (double x)</td></tr>
<tr class="memdesc:ae26d0b65eb141c73979c5d2f1d0e13fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1.0/sqrt(x) in double precision, but single range.  <a href="#ae26d0b65eb141c73979c5d2f1d0e13fa">More...</a><br/></td></tr>
<tr class="separator:ae26d0b65eb141c73979c5d2f1d0e13fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91cb31b7abc3e020022ac8ce0b1b262"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa91cb31b7abc3e020022ac8ce0b1b262">invsqrt</a> (int x)</td></tr>
<tr class="memdesc:aa91cb31b7abc3e020022ac8ce0b1b262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1.0/sqrt(x) for integer x in double precision.  <a href="#aa91cb31b7abc3e020022ac8ce0b1b262">More...</a><br/></td></tr>
<tr class="separator:aa91cb31b7abc3e020022ac8ce0b1b262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabf4874cb58de0554f95f69c1768882"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#acabf4874cb58de0554f95f69c1768882">invcbrt</a> (float x)</td></tr>
<tr class="memdesc:acabf4874cb58de0554f95f69c1768882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate inverse cube root of x in single precision.  <a href="#acabf4874cb58de0554f95f69c1768882">More...</a><br/></td></tr>
<tr class="separator:acabf4874cb58de0554f95f69c1768882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d99226376a495b484eccd203d29c8d"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a08d99226376a495b484eccd203d29c8d">invcbrt</a> (double x)</td></tr>
<tr class="memdesc:a08d99226376a495b484eccd203d29c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate inverse sixth root of x in double precision.  <a href="#a08d99226376a495b484eccd203d29c8d">More...</a><br/></td></tr>
<tr class="separator:a08d99226376a495b484eccd203d29c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d304cf0e3cac1632695e394077fd2d7"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a1d304cf0e3cac1632695e394077fd2d7">invcbrt</a> (int x)</td></tr>
<tr class="memdesc:a1d304cf0e3cac1632695e394077fd2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate inverse sixth root of integer x in double precision.  <a href="#a1d304cf0e3cac1632695e394077fd2d7">More...</a><br/></td></tr>
<tr class="separator:a1d304cf0e3cac1632695e394077fd2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12dcc6af3bf2f769ea1e17ed12921e2c"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a12dcc6af3bf2f769ea1e17ed12921e2c">sixthroot</a> (float x)</td></tr>
<tr class="memdesc:a12dcc6af3bf2f769ea1e17ed12921e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate sixth root of x in single precision.  <a href="#a12dcc6af3bf2f769ea1e17ed12921e2c">More...</a><br/></td></tr>
<tr class="separator:a12dcc6af3bf2f769ea1e17ed12921e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf2628e4b20455d3396e0c2c234b951"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a4cf2628e4b20455d3396e0c2c234b951">sixthroot</a> (double x)</td></tr>
<tr class="memdesc:a4cf2628e4b20455d3396e0c2c234b951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate sixth root of x in double precision.  <a href="#a4cf2628e4b20455d3396e0c2c234b951">More...</a><br/></td></tr>
<tr class="separator:a4cf2628e4b20455d3396e0c2c234b951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02308efcb527a69ce399111550575880"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a02308efcb527a69ce399111550575880">sixthroot</a> (int x)</td></tr>
<tr class="memdesc:a02308efcb527a69ce399111550575880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate sixth root of integer x, return double.  <a href="#a02308efcb527a69ce399111550575880">More...</a><br/></td></tr>
<tr class="separator:a02308efcb527a69ce399111550575880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3aeb9a178f07d4bc64b934555d12842"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ad3aeb9a178f07d4bc64b934555d12842">invsixthroot</a> (float x)</td></tr>
<tr class="memdesc:ad3aeb9a178f07d4bc64b934555d12842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate inverse sixth root of x in single precision.  <a href="#ad3aeb9a178f07d4bc64b934555d12842">More...</a><br/></td></tr>
<tr class="separator:ad3aeb9a178f07d4bc64b934555d12842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8b9b01e7c291a443840d4f7af97c5c"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2f8b9b01e7c291a443840d4f7af97c5c">invsixthroot</a> (double x)</td></tr>
<tr class="memdesc:a2f8b9b01e7c291a443840d4f7af97c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate inverse sixth root of x in double precision.  <a href="#a2f8b9b01e7c291a443840d4f7af97c5c">More...</a><br/></td></tr>
<tr class="separator:a2f8b9b01e7c291a443840d4f7af97c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1604baa1a44d1de7bafa433c9443c395"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a1604baa1a44d1de7bafa433c9443c395">invsixthroot</a> (int x)</td></tr>
<tr class="memdesc:a1604baa1a44d1de7bafa433c9443c395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate inverse sixth root of integer x in double precision.  <a href="#a1604baa1a44d1de7bafa433c9443c395">More...</a><br/></td></tr>
<tr class="separator:a1604baa1a44d1de7bafa433c9443c395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cbcb5324f3eb428189024f020158ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a06cbcb5324f3eb428189024f020158ff"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a06cbcb5324f3eb428189024f020158ff">square</a> (T x)</td></tr>
<tr class="memdesc:a06cbcb5324f3eb428189024f020158ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate x^2  <a href="#a06cbcb5324f3eb428189024f020158ff">More...</a><br/></td></tr>
<tr class="separator:a06cbcb5324f3eb428189024f020158ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda6daf50f5129fb74816db29e411497"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abda6daf50f5129fb74816db29e411497"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#abda6daf50f5129fb74816db29e411497">power3</a> (T x)</td></tr>
<tr class="memdesc:abda6daf50f5129fb74816db29e411497"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate x^3  <a href="#abda6daf50f5129fb74816db29e411497">More...</a><br/></td></tr>
<tr class="separator:abda6daf50f5129fb74816db29e411497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304b15bae3a2a8277f686d4dfc9fa946"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a304b15bae3a2a8277f686d4dfc9fa946"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a304b15bae3a2a8277f686d4dfc9fa946">power4</a> (T x)</td></tr>
<tr class="memdesc:a304b15bae3a2a8277f686d4dfc9fa946"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate x^4  <a href="#a304b15bae3a2a8277f686d4dfc9fa946">More...</a><br/></td></tr>
<tr class="separator:a304b15bae3a2a8277f686d4dfc9fa946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb914d3b8bf083485bb26c88d2b9dda"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4bb914d3b8bf083485bb26c88d2b9dda"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a4bb914d3b8bf083485bb26c88d2b9dda">power5</a> (T x)</td></tr>
<tr class="memdesc:a4bb914d3b8bf083485bb26c88d2b9dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate x^5  <a href="#a4bb914d3b8bf083485bb26c88d2b9dda">More...</a><br/></td></tr>
<tr class="separator:a4bb914d3b8bf083485bb26c88d2b9dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab162c4ba231de5ffbfc62dc3803e8ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aab162c4ba231de5ffbfc62dc3803e8ff"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aab162c4ba231de5ffbfc62dc3803e8ff">power6</a> (T x)</td></tr>
<tr class="memdesc:aab162c4ba231de5ffbfc62dc3803e8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate x^6  <a href="#aab162c4ba231de5ffbfc62dc3803e8ff">More...</a><br/></td></tr>
<tr class="separator:aab162c4ba231de5ffbfc62dc3803e8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800ac84e9ee71a2dc0eedda74bea1513"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a800ac84e9ee71a2dc0eedda74bea1513"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a800ac84e9ee71a2dc0eedda74bea1513">power12</a> (T x)</td></tr>
<tr class="memdesc:a800ac84e9ee71a2dc0eedda74bea1513"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate x^12  <a href="#a800ac84e9ee71a2dc0eedda74bea1513">More...</a><br/></td></tr>
<tr class="separator:a800ac84e9ee71a2dc0eedda74bea1513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d3eb4aaecff5c613995ed4bce22a0a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a92d3eb4aaecff5c613995ed4bce22a0a">series_sinhx</a> (<a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> x)</td></tr>
<tr class="memdesc:a92d3eb4aaecff5c613995ed4bce22a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maclaurin series for sinh(x)/x.  <a href="#a92d3eb4aaecff5c613995ed4bce22a0a">More...</a><br/></td></tr>
<tr class="separator:a92d3eb4aaecff5c613995ed4bce22a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4548b5005dd861681ff13e55e5b6f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2c4548b5005dd861681ff13e55e5b6f9">invertBoxMatrix</a> (const matrix src, matrix dest)</td></tr>
<tr class="memdesc:a2c4548b5005dd861681ff13e55e5b6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert a simulation-box matrix in <code>src</code>, return in <code>dest</code>.  <a href="#a2c4548b5005dd861681ff13e55e5b6f9">More...</a><br/></td></tr>
<tr class="separator:a2c4548b5005dd861681ff13e55e5b6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2824e7adcb69e96942fefcb67809ec5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2824e7adcb69e96942fefcb67809ec5e">invertMatrix</a> (const matrix src, matrix dest)</td></tr>
<tr class="memdesc:a2824e7adcb69e96942fefcb67809ec5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert a general 3x3 matrix in <code>src</code>, return in <code>dest</code>.  <a href="#a2824e7adcb69e96942fefcb67809ec5e">More...</a><br/></td></tr>
<tr class="separator:a2824e7adcb69e96942fefcb67809ec5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0657ab84cdeab81eb449859ff086bcd6"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a0657ab84cdeab81eb449859ff086bcd6">paddedRVecVectorSize</a> (size_t numAtoms)</td></tr>
<tr class="memdesc:a0657ab84cdeab81eb449859ff086bcd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the padded size for PaddedRVecVector given the number of atoms.  <a href="#a0657ab84cdeab81eb449859ff086bcd6">More...</a><br/></td></tr>
<tr class="separator:a0657ab84cdeab81eb449859ff086bcd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28594b0fbe8151cffa0eb0f3db2a2ce9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a28594b0fbe8151cffa0eb0f3db2a2ce9"></a>
template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a28594b0fbe8151cffa0eb0f3db2a2ce9"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classgmx_1_1BasicVector.xhtml">BasicVector</a>&lt; ValueType &gt;<br class="typebreak"/>
::RawArray *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a28594b0fbe8151cffa0eb0f3db2a2ce9">as_vec_array</a> (<a class="el" href="classgmx_1_1BasicVector.xhtml">BasicVector</a>&lt; ValueType &gt; *x)</td></tr>
<tr class="memdesc:a28594b0fbe8151cffa0eb0f3db2a2ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a <a class="el" href="classgmx_1_1BasicVector.xhtml" title="C++ class for 3D vectors. ">gmx::BasicVector</a> array into an equivalent raw C array. <br/></td></tr>
<tr class="separator:a28594b0fbe8151cffa0eb0f3db2a2ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869efe6effe059ca2a9ebe609d2c30ee"><td class="memTemplParams" colspan="2"><a class="anchor" id="a869efe6effe059ca2a9ebe609d2c30ee"></a>
template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a869efe6effe059ca2a9ebe609d2c30ee"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classgmx_1_1BasicVector.xhtml">BasicVector</a><br class="typebreak"/>
&lt; ValueType &gt;::RawArray *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a869efe6effe059ca2a9ebe609d2c30ee">as_vec_array</a> (const <a class="el" href="classgmx_1_1BasicVector.xhtml">BasicVector</a>&lt; ValueType &gt; *x)</td></tr>
<tr class="memdesc:a869efe6effe059ca2a9ebe609d2c30ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a <a class="el" href="classgmx_1_1BasicVector.xhtml" title="C++ class for 3D vectors. ">gmx::BasicVector</a> array into an equivalent raw C array. <br/></td></tr>
<tr class="separator:a869efe6effe059ca2a9ebe609d2c30ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e7b50af65a3361901a37364ad0fa8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5e7b50af65a3361901a37364ad0fa8d"></a>
static rvec *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ac5e7b50af65a3361901a37364ad0fa8d">as_rvec_array</a> (<a class="el" href="namespacegmx.xhtml#a139c1919a9680de4ad1450f42e37d33b">RVec</a> *x)</td></tr>
<tr class="memdesc:ac5e7b50af65a3361901a37364ad0fa8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a <a class="el" href="namespacegmx.xhtml#a139c1919a9680de4ad1450f42e37d33b" title="Shorthand for C++ rvec-equivalent type. ">gmx::RVec</a> array into an <code>rvec</code> array. <br/></td></tr>
<tr class="separator:ac5e7b50af65a3361901a37364ad0fa8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa725d6666d8341042ae4fa3667bf83b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa725d6666d8341042ae4fa3667bf83b1"></a>
static const rvec *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa725d6666d8341042ae4fa3667bf83b1">as_rvec_array</a> (const <a class="el" href="namespacegmx.xhtml#a139c1919a9680de4ad1450f42e37d33b">RVec</a> *x)</td></tr>
<tr class="memdesc:aa725d6666d8341042ae4fa3667bf83b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a <a class="el" href="namespacegmx.xhtml#a139c1919a9680de4ad1450f42e37d33b" title="Shorthand for C++ rvec-equivalent type. ">gmx::RVec</a> array into an <code>rvec</code> array. <br/></td></tr>
<tr class="separator:aa725d6666d8341042ae4fa3667bf83b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce4feb63a64730e6c502fd902437e2a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; MDAtoms &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2ce4feb63a64730e6c502fd902437e2a">makeMDAtoms</a> (FILE *fp, const gmx_mtop_t &amp;mtop, const t_inputrec &amp;ir, bool useGpuForPme)</td></tr>
<tr class="memdesc:a2ce4feb63a64730e6c502fd902437e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builder function for MdAtomsWrapper.  <a href="#a2ce4feb63a64730e6c502fd902437e2a">More...</a><br/></td></tr>
<tr class="separator:a2ce4feb63a64730e6c502fd902437e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475269580d9d34d282e74f831403afda"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a475269580d9d34d282e74f831403afda">do_cg</a> (FILE *fplog, t_commrec *cr, const gmx::MDLogger &amp;mdlog, int nfile, const <a class="el" href="structt__filenm.xhtml">t_filenm</a> fnm[], const gmx_output_env_t *oenv, const MdrunOptions &amp;mdrunOptions, gmx_vsite_t *vsite, gmx_constr_t constr, gmx::IMDOutputProvider *outputProvider, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, <a class="el" href="classt__state.xhtml">t_state</a> *state_global, ObservablesHistory *observablesHistory, gmx::MDAtoms *mdAtoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, t_forcerec *fr, const ReplicaExchangeParameters &amp;replExParams, gmx_membed_t *membed, gmx_walltime_accounting_t walltime_accounting)</td></tr>
<tr class="memdesc:a475269580d9d34d282e74f831403afda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do conjugate gradients minimization.  <a href="#a475269580d9d34d282e74f831403afda">More...</a><br/></td></tr>
<tr class="separator:a475269580d9d34d282e74f831403afda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc884f7f1ed3c1d3404b78f07b0b3fea"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#adc884f7f1ed3c1d3404b78f07b0b3fea">do_lbfgs</a> (FILE *fplog, t_commrec *cr, const gmx::MDLogger &amp;mdlog, int nfile, const <a class="el" href="structt__filenm.xhtml">t_filenm</a> fnm[], const gmx_output_env_t *oenv, const MdrunOptions &amp;mdrunOptions, gmx_vsite_t *vsite, gmx_constr_t constr, gmx::IMDOutputProvider *outputProvider, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, <a class="el" href="classt__state.xhtml">t_state</a> *state_global, ObservablesHistory *observablesHistory, gmx::MDAtoms *mdAtoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, t_forcerec *fr, const ReplicaExchangeParameters &amp;replExParams, gmx_membed_t *membed, gmx_walltime_accounting_t walltime_accounting)</td></tr>
<tr class="memdesc:adc884f7f1ed3c1d3404b78f07b0b3fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do L-BFGS conjugate gradients minimization.  <a href="#adc884f7f1ed3c1d3404b78f07b0b3fea">More...</a><br/></td></tr>
<tr class="separator:adc884f7f1ed3c1d3404b78f07b0b3fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab958777e1c348318f87aaea003bd344"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aab958777e1c348318f87aaea003bd344">do_steep</a> (FILE *fplog, t_commrec *cr, const gmx::MDLogger &amp;mdlog, int nfile, const <a class="el" href="structt__filenm.xhtml">t_filenm</a> fnm[], const gmx_output_env_t *oenv, const MdrunOptions &amp;mdrunOptions, gmx_vsite_t *vsite, gmx_constr_t constr, gmx::IMDOutputProvider *outputProvider, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, <a class="el" href="classt__state.xhtml">t_state</a> *state_global, ObservablesHistory *observablesHistory, gmx::MDAtoms *mdAtoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, t_forcerec *fr, const ReplicaExchangeParameters &amp;replExParams, gmx_membed_t *membed, gmx_walltime_accounting_t walltime_accounting)</td></tr>
<tr class="memdesc:aab958777e1c348318f87aaea003bd344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do steepest descents minimization.  <a href="#aab958777e1c348318f87aaea003bd344">More...</a><br/></td></tr>
<tr class="separator:aab958777e1c348318f87aaea003bd344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6ac3ade79370a97682bc64ec4d763a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a0f6ac3ade79370a97682bc64ec4d763a">do_nm</a> (FILE *fplog, t_commrec *cr, const gmx::MDLogger &amp;mdlog, int nfile, const <a class="el" href="structt__filenm.xhtml">t_filenm</a> fnm[], const gmx_output_env_t *oenv, const MdrunOptions &amp;mdrunOptions, gmx_vsite_t *vsite, gmx_constr_t constr, gmx::IMDOutputProvider *outputProvider, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, <a class="el" href="classt__state.xhtml">t_state</a> *state_global, ObservablesHistory *observablesHistory, gmx::MDAtoms *mdAtoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, t_forcerec *fr, const ReplicaExchangeParameters &amp;replExParams, gmx_membed_t *membed, gmx_walltime_accounting_t walltime_accounting)</td></tr>
<tr class="memdesc:a0f6ac3ade79370a97682bc64ec4d763a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do normal modes analysis.  <a href="#a0f6ac3ade79370a97682bc64ec4d763a">More...</a><br/></td></tr>
<tr class="separator:a0f6ac3ade79370a97682bc64ec4d763a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fe0760b635bfaa85fa2152bb8ff067"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ab9fe0760b635bfaa85fa2152bb8ff067">do_tpi</a> (FILE *fplog, t_commrec *cr, const gmx::MDLogger &amp;mdlog, int nfile, const <a class="el" href="structt__filenm.xhtml">t_filenm</a> fnm[], const gmx_output_env_t *oenv, const MdrunOptions &amp;mdrunOptions, gmx_vsite_t *vsite, gmx_constr_t constr, gmx::IMDOutputProvider *outputProvider, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, <a class="el" href="classt__state.xhtml">t_state</a> *state_global, ObservablesHistory *observablesHistory, gmx::MDAtoms *mdAtoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, t_forcerec *fr, const ReplicaExchangeParameters &amp;replExParams, gmx_membed_t *membed, gmx_walltime_accounting_t walltime_accounting)</td></tr>
<tr class="memdesc:ab9fe0760b635bfaa85fa2152bb8ff067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do test particle insertion.  <a href="#ab9fe0760b635bfaa85fa2152bb8ff067">More...</a><br/></td></tr>
<tr class="separator:ab9fe0760b635bfaa85fa2152bb8ff067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822fc85669d18b6a3ff65438ea41c4fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a822fc85669d18b6a3ff65438ea41c4fd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a822fc85669d18b6a3ff65438ea41c4fd">boxesAreEqual</a> (const matrix box1, const matrix box2)</td></tr>
<tr class="memdesc:a822fc85669d18b6a3ff65438ea41c4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether two boxes are of equal size and shape (within reasonable tolerance). <br/></td></tr>
<tr class="separator:a822fc85669d18b6a3ff65438ea41c4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25af86f979aaadf3b1d5e02dd529a6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af25af86f979aaadf3b1d5e02dd529a6a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af25af86f979aaadf3b1d5e02dd529a6a">boxIsZero</a> (const matrix box)</td></tr>
<tr class="memdesc:af25af86f979aaadf3b1d5e02dd529a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a box is only initialised to zero or not. <br/></td></tr>
<tr class="separator:af25af86f979aaadf3b1d5e02dd529a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddacc94505a46b63d40a995556cef32"><td class="memItemLeft" align="right" valign="top">gmx_uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a8ddacc94505a46b63d40a995556cef32">makeRandomSeed</a> ()</td></tr>
<tr class="memdesc:a8ddacc94505a46b63d40a995556cef32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 64 random bits from the random device, suitable as seed.  <a href="#a8ddacc94505a46b63d40a995556cef32">More...</a><br/></td></tr>
<tr class="separator:a8ddacc94505a46b63d40a995556cef32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba622deb792fdc881824ce7a36d8440"><td class="memTemplParams" colspan="2">template&lt;class RealType  = real, unsigned int Bits, class Rng &gt; </td></tr>
<tr class="memitem:a7ba622deb792fdc881824ce7a36d8440"><td class="memTemplItemLeft" align="right" valign="top">RealType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a7ba622deb792fdc881824ce7a36d8440">generateCanonical</a> (Rng &amp;g)</td></tr>
<tr class="memdesc:a7ba622deb792fdc881824ce7a36d8440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a floating-point value with specified number of random bits.  <a href="#a7ba622deb792fdc881824ce7a36d8440">More...</a><br/></td></tr>
<tr class="separator:a7ba622deb792fdc881824ce7a36d8440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073963d19e7e6337168de8dc0005b7e4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a073963d19e7e6337168de8dc0005b7e4">simdPrefetch</a> (void *m)</td></tr>
<tr class="memdesc:a073963d19e7e6337168de8dc0005b7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefetch memory at address m.  <a href="#a073963d19e7e6337168de8dc0005b7e4">More...</a><br/></td></tr>
<tr class="separator:a073963d19e7e6337168de8dc0005b7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba56cff453ff9a1f21a11d72358592a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a5ba56cff453ff9a1f21a11d72358592a">store</a> (float *m, float a)</td></tr>
<tr class="memdesc:a5ba56cff453ff9a1f21a11d72358592a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store contents of float variable to aligned memory m.  <a href="#a5ba56cff453ff9a1f21a11d72358592a">More...</a><br/></td></tr>
<tr class="separator:a5ba56cff453ff9a1f21a11d72358592a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a3dcd7322b5b2555938fe1c05be15f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af3a3dcd7322b5b2555938fe1c05be15f">storeU</a> (float *m, float a)</td></tr>
<tr class="memdesc:af3a3dcd7322b5b2555938fe1c05be15f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store contents of float variable to unaligned memory m.  <a href="#af3a3dcd7322b5b2555938fe1c05be15f">More...</a><br/></td></tr>
<tr class="separator:af3a3dcd7322b5b2555938fe1c05be15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183d89182d418bb66a668104978af5bf"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a183d89182d418bb66a668104978af5bf">fma</a> (float a, float b, float c)</td></tr>
<tr class="memdesc:a183d89182d418bb66a668104978af5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float Fused-multiply-add. Result is a*b + c.  <a href="#a183d89182d418bb66a668104978af5bf">More...</a><br/></td></tr>
<tr class="separator:a183d89182d418bb66a668104978af5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad947f51589a3a9eef2f8364ab62c19"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#afad947f51589a3a9eef2f8364ab62c19">fms</a> (float a, float b, float c)</td></tr>
<tr class="memdesc:afad947f51589a3a9eef2f8364ab62c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float Fused-multiply-subtract. Result is a*b - c.  <a href="#afad947f51589a3a9eef2f8364ab62c19">More...</a><br/></td></tr>
<tr class="separator:afad947f51589a3a9eef2f8364ab62c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55183d689ab9328c18c3b3f819bd7266"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a55183d689ab9328c18c3b3f819bd7266">fnma</a> (float a, float b, float c)</td></tr>
<tr class="memdesc:a55183d689ab9328c18c3b3f819bd7266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float Fused-negated-multiply-add. Result is -a*b + c.  <a href="#a55183d689ab9328c18c3b3f819bd7266">More...</a><br/></td></tr>
<tr class="separator:a55183d689ab9328c18c3b3f819bd7266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e6950597f4833fa93b09a94e7b0e16"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa6e6950597f4833fa93b09a94e7b0e16">fnms</a> (float a, float b, float c)</td></tr>
<tr class="memdesc:aa6e6950597f4833fa93b09a94e7b0e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float Fused-negated-multiply-subtract. Result is -a*b - c.  <a href="#aa6e6950597f4833fa93b09a94e7b0e16">More...</a><br/></td></tr>
<tr class="separator:aa6e6950597f4833fa93b09a94e7b0e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0178a127dde331652ab015323ae622f2"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a0178a127dde331652ab015323ae622f2">maskAdd</a> (float a, float b, float m)</td></tr>
<tr class="memdesc:a0178a127dde331652ab015323ae622f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two float variables, masked version.  <a href="#a0178a127dde331652ab015323ae622f2">More...</a><br/></td></tr>
<tr class="separator:a0178a127dde331652ab015323ae622f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3c4084e25d298f95003df8e9aeffa1"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a1e3c4084e25d298f95003df8e9aeffa1">maskzMul</a> (float a, float b, float m)</td></tr>
<tr class="memdesc:a1e3c4084e25d298f95003df8e9aeffa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two float variables, masked version.  <a href="#a1e3c4084e25d298f95003df8e9aeffa1">More...</a><br/></td></tr>
<tr class="separator:a1e3c4084e25d298f95003df8e9aeffa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8151e61ef06e30e360c03bba6fb5e2ab"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a8151e61ef06e30e360c03bba6fb5e2ab">maskzFma</a> (float a, float b, float c, float m)</td></tr>
<tr class="memdesc:a8151e61ef06e30e360c03bba6fb5e2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float fused multiply-add, masked version.  <a href="#a8151e61ef06e30e360c03bba6fb5e2ab">More...</a><br/></td></tr>
<tr class="separator:a8151e61ef06e30e360c03bba6fb5e2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc46e83d110b8c81339683bf748fc81"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a5dc46e83d110b8c81339683bf748fc81">abs</a> (float a)</td></tr>
<tr class="memdesc:a5dc46e83d110b8c81339683bf748fc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float Floating-point <a class="el" href="namespacegmx.xhtml#a5dc46e83d110b8c81339683bf748fc81" title="Float Floating-point abs(). ">abs()</a>.  <a href="#a5dc46e83d110b8c81339683bf748fc81">More...</a><br/></td></tr>
<tr class="separator:a5dc46e83d110b8c81339683bf748fc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c7b010fbd32f5424afa0de0c70db6f"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a35c7b010fbd32f5424afa0de0c70db6f">max</a> (float a, float b)</td></tr>
<tr class="memdesc:a35c7b010fbd32f5424afa0de0c70db6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set each float element to the largest from two variables.  <a href="#a35c7b010fbd32f5424afa0de0c70db6f">More...</a><br/></td></tr>
<tr class="separator:a35c7b010fbd32f5424afa0de0c70db6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d21dccd9a94698363bdb1943f139bb"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa6d21dccd9a94698363bdb1943f139bb">min</a> (float a, float b)</td></tr>
<tr class="memdesc:aa6d21dccd9a94698363bdb1943f139bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set each float element to the smallest from two variables.  <a href="#aa6d21dccd9a94698363bdb1943f139bb">More...</a><br/></td></tr>
<tr class="separator:aa6d21dccd9a94698363bdb1943f139bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0a061335a242530d8d791459a8e2d0"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a1c0a061335a242530d8d791459a8e2d0">round</a> (float a)</td></tr>
<tr class="memdesc:a1c0a061335a242530d8d791459a8e2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float round to nearest integer value (in floating-point format).  <a href="#a1c0a061335a242530d8d791459a8e2d0">More...</a><br/></td></tr>
<tr class="separator:a1c0a061335a242530d8d791459a8e2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4323d38c16cd7ce6b1ae9df62e94ef2a"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a4323d38c16cd7ce6b1ae9df62e94ef2a">trunc</a> (float a)</td></tr>
<tr class="memdesc:a4323d38c16cd7ce6b1ae9df62e94ef2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate float, i.e. round towards zero - common hardware instruction.  <a href="#a4323d38c16cd7ce6b1ae9df62e94ef2a">More...</a><br/></td></tr>
<tr class="separator:a4323d38c16cd7ce6b1ae9df62e94ef2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a37558328ab029203170ad4c6c4d01"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa4a37558328ab029203170ad4c6c4d01">reduce</a> (float a)</td></tr>
<tr class="memdesc:aa4a37558328ab029203170ad4c6c4d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sum of all elements in float variable (i.e., the variable itself).  <a href="#aa4a37558328ab029203170ad4c6c4d01">More...</a><br/></td></tr>
<tr class="separator:aa4a37558328ab029203170ad4c6c4d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec39ef87dbec92292cd5954c922be6d"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aaec39ef87dbec92292cd5954c922be6d">andNot</a> (float a, float b)</td></tr>
<tr class="memdesc:aaec39ef87dbec92292cd5954c922be6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise andnot for two scalar float variables.  <a href="#aaec39ef87dbec92292cd5954c922be6d">More...</a><br/></td></tr>
<tr class="separator:aaec39ef87dbec92292cd5954c922be6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a3628d9b9ddc7900590f963be7bbf0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af6a3628d9b9ddc7900590f963be7bbf0">testBits</a> (float a)</td></tr>
<tr class="memdesc:af6a3628d9b9ddc7900590f963be7bbf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any bits are set in the float variable.  <a href="#af6a3628d9b9ddc7900590f963be7bbf0">More...</a><br/></td></tr>
<tr class="separator:af6a3628d9b9ddc7900590f963be7bbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90cd5d709899e47809553109383299e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af90cd5d709899e47809553109383299e">anyTrue</a> (bool a)</td></tr>
<tr class="memdesc:af90cd5d709899e47809553109383299e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the boolean is true.  <a href="#af90cd5d709899e47809553109383299e">More...</a><br/></td></tr>
<tr class="separator:af90cd5d709899e47809553109383299e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47eb155075f6f9aa99ecca11825b021"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af47eb155075f6f9aa99ecca11825b021">selectByMask</a> (float a, bool mask)</td></tr>
<tr class="memdesc:af47eb155075f6f9aa99ecca11825b021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from single precision variable where boolean is true.  <a href="#af47eb155075f6f9aa99ecca11825b021">More...</a><br/></td></tr>
<tr class="separator:af47eb155075f6f9aa99ecca11825b021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f8ccf8f582242260b4e785ebf48e3a"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a76f8ccf8f582242260b4e785ebf48e3a">selectByNotMask</a> (float a, bool mask)</td></tr>
<tr class="memdesc:a76f8ccf8f582242260b4e785ebf48e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from single precision variable where boolean is false.  <a href="#a76f8ccf8f582242260b4e785ebf48e3a">More...</a><br/></td></tr>
<tr class="separator:a76f8ccf8f582242260b4e785ebf48e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f9e21174d44695b53626648515c4b4"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a97f9e21174d44695b53626648515c4b4">blend</a> (float a, float b, bool sel)</td></tr>
<tr class="memdesc:a97f9e21174d44695b53626648515c4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blend float selection.  <a href="#a97f9e21174d44695b53626648515c4b4">More...</a><br/></td></tr>
<tr class="separator:a97f9e21174d44695b53626648515c4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2136f5684897fc7ea139039eba172629"><td class="memItemLeft" align="right" valign="top">static std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2136f5684897fc7ea139039eba172629">cvtR2I</a> (float a)</td></tr>
<tr class="memdesc:a2136f5684897fc7ea139039eba172629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round single precision floating point to integer.  <a href="#a2136f5684897fc7ea139039eba172629">More...</a><br/></td></tr>
<tr class="separator:a2136f5684897fc7ea139039eba172629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c74ba54abe2627167abfc0df7286f5d"><td class="memItemLeft" align="right" valign="top">static std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a7c74ba54abe2627167abfc0df7286f5d">cvttR2I</a> (float a)</td></tr>
<tr class="memdesc:a7c74ba54abe2627167abfc0df7286f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate single precision floating point to integer.  <a href="#a7c74ba54abe2627167abfc0df7286f5d">More...</a><br/></td></tr>
<tr class="separator:a7c74ba54abe2627167abfc0df7286f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69388fb35cb4b891c7517554e4500615"><td class="memItemLeft" align="right" valign="top">static std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a69388fb35cb4b891c7517554e4500615">cvtI2R</a> (std::int32_t a)</td></tr>
<tr class="memdesc:a69388fb35cb4b891c7517554e4500615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return integer.  <a href="#a69388fb35cb4b891c7517554e4500615">More...</a><br/></td></tr>
<tr class="separator:a69388fb35cb4b891c7517554e4500615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1d0d7a9f81e8e5cac19a3b66f0170e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aea1d0d7a9f81e8e5cac19a3b66f0170e">store</a> (double *m, double a)</td></tr>
<tr class="memdesc:aea1d0d7a9f81e8e5cac19a3b66f0170e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store contents of double variable to aligned memory m.  <a href="#aea1d0d7a9f81e8e5cac19a3b66f0170e">More...</a><br/></td></tr>
<tr class="separator:aea1d0d7a9f81e8e5cac19a3b66f0170e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9644fa777bc5e47ff9d3e2bdde34e0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aea9644fa777bc5e47ff9d3e2bdde34e0">storeU</a> (double *m, double a)</td></tr>
<tr class="memdesc:aea9644fa777bc5e47ff9d3e2bdde34e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store contents of double variable to unaligned memory m.  <a href="#aea9644fa777bc5e47ff9d3e2bdde34e0">More...</a><br/></td></tr>
<tr class="separator:aea9644fa777bc5e47ff9d3e2bdde34e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e2ba07938cafa28c0988ba52874f46"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a79e2ba07938cafa28c0988ba52874f46">fma</a> (double a, double b, double c)</td></tr>
<tr class="memdesc:a79e2ba07938cafa28c0988ba52874f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">double Fused-multiply-add. Result is a*b + c.  <a href="#a79e2ba07938cafa28c0988ba52874f46">More...</a><br/></td></tr>
<tr class="separator:a79e2ba07938cafa28c0988ba52874f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb2c8942d173c6a9964940f90c55b2a"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#abcb2c8942d173c6a9964940f90c55b2a">fms</a> (double a, double b, double c)</td></tr>
<tr class="memdesc:abcb2c8942d173c6a9964940f90c55b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">double Fused-multiply-subtract. Result is a*b - c.  <a href="#abcb2c8942d173c6a9964940f90c55b2a">More...</a><br/></td></tr>
<tr class="separator:abcb2c8942d173c6a9964940f90c55b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf7849c8ce1bbbe3e2fecffedfc05e8"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#adcf7849c8ce1bbbe3e2fecffedfc05e8">fnma</a> (double a, double b, double c)</td></tr>
<tr class="memdesc:adcf7849c8ce1bbbe3e2fecffedfc05e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">double Fused-negated-multiply-add. Result is - a*b + c.  <a href="#adcf7849c8ce1bbbe3e2fecffedfc05e8">More...</a><br/></td></tr>
<tr class="separator:adcf7849c8ce1bbbe3e2fecffedfc05e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bd8328d5cbdb7f6a054b877183f277"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ad9bd8328d5cbdb7f6a054b877183f277">fnms</a> (double a, double b, double c)</td></tr>
<tr class="memdesc:ad9bd8328d5cbdb7f6a054b877183f277"><td class="mdescLeft">&#160;</td><td class="mdescRight">double Fused-negated-multiply-subtract. Result is -a*b - c.  <a href="#ad9bd8328d5cbdb7f6a054b877183f277">More...</a><br/></td></tr>
<tr class="separator:ad9bd8328d5cbdb7f6a054b877183f277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b090d0e3ab5695c508453406ee43c8"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a68b090d0e3ab5695c508453406ee43c8">maskAdd</a> (double a, double b, double m)</td></tr>
<tr class="memdesc:a68b090d0e3ab5695c508453406ee43c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two double variables, masked version.  <a href="#a68b090d0e3ab5695c508453406ee43c8">More...</a><br/></td></tr>
<tr class="separator:a68b090d0e3ab5695c508453406ee43c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4ab8b1ab046ff242d32ab93366bfde"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a7e4ab8b1ab046ff242d32ab93366bfde">maskzMul</a> (double a, double b, double m)</td></tr>
<tr class="memdesc:a7e4ab8b1ab046ff242d32ab93366bfde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two double variables, masked version.  <a href="#a7e4ab8b1ab046ff242d32ab93366bfde">More...</a><br/></td></tr>
<tr class="separator:a7e4ab8b1ab046ff242d32ab93366bfde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cf4eaad108887d2462f5beecd4db62"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa3cf4eaad108887d2462f5beecd4db62">maskzFma</a> (double a, double b, double c, double m)</td></tr>
<tr class="memdesc:aa3cf4eaad108887d2462f5beecd4db62"><td class="mdescLeft">&#160;</td><td class="mdescRight">double fused multiply-add, masked version.  <a href="#aa3cf4eaad108887d2462f5beecd4db62">More...</a><br/></td></tr>
<tr class="separator:aa3cf4eaad108887d2462f5beecd4db62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85ea3af684916aee86e2674a6bd81e5"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ac85ea3af684916aee86e2674a6bd81e5">abs</a> (double a)</td></tr>
<tr class="memdesc:ac85ea3af684916aee86e2674a6bd81e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">double doubleing-point <a class="el" href="namespacegmx.xhtml#a5dc46e83d110b8c81339683bf748fc81" title="Float Floating-point abs(). ">abs()</a>.  <a href="#ac85ea3af684916aee86e2674a6bd81e5">More...</a><br/></td></tr>
<tr class="separator:ac85ea3af684916aee86e2674a6bd81e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f6bf4a20b14262f28168596d5bb8b9"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a16f6bf4a20b14262f28168596d5bb8b9">max</a> (double a, double b)</td></tr>
<tr class="memdesc:a16f6bf4a20b14262f28168596d5bb8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set each double element to the largest from two variables.  <a href="#a16f6bf4a20b14262f28168596d5bb8b9">More...</a><br/></td></tr>
<tr class="separator:a16f6bf4a20b14262f28168596d5bb8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65fb0c7aa84962905d3d78a913c787c3"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a65fb0c7aa84962905d3d78a913c787c3">min</a> (double a, double b)</td></tr>
<tr class="memdesc:a65fb0c7aa84962905d3d78a913c787c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set each double element to the smallest from two variables.  <a href="#a65fb0c7aa84962905d3d78a913c787c3">More...</a><br/></td></tr>
<tr class="separator:a65fb0c7aa84962905d3d78a913c787c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15179b513c1ec4ec0b9090e57b76bac4"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a15179b513c1ec4ec0b9090e57b76bac4">round</a> (double a)</td></tr>
<tr class="memdesc:a15179b513c1ec4ec0b9090e57b76bac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">double round to nearest integer value (in doubleing-point format).  <a href="#a15179b513c1ec4ec0b9090e57b76bac4">More...</a><br/></td></tr>
<tr class="separator:a15179b513c1ec4ec0b9090e57b76bac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d84f65dae98aeb02816975f5045eed"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a00d84f65dae98aeb02816975f5045eed">trunc</a> (double a)</td></tr>
<tr class="memdesc:a00d84f65dae98aeb02816975f5045eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate double, i.e. round towards zero - common hardware instruction.  <a href="#a00d84f65dae98aeb02816975f5045eed">More...</a><br/></td></tr>
<tr class="separator:a00d84f65dae98aeb02816975f5045eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157983d90620412d404e8a77d1ddbd0f"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a157983d90620412d404e8a77d1ddbd0f">reduce</a> (double a)</td></tr>
<tr class="memdesc:a157983d90620412d404e8a77d1ddbd0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sum of all elements in double variable (i.e., the variable itself).  <a href="#a157983d90620412d404e8a77d1ddbd0f">More...</a><br/></td></tr>
<tr class="separator:a157983d90620412d404e8a77d1ddbd0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb0315d31c3c818a738bdc153397365"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aebb0315d31c3c818a738bdc153397365">andNot</a> (double a, double b)</td></tr>
<tr class="memdesc:aebb0315d31c3c818a738bdc153397365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise andnot for two scalar double variables.  <a href="#aebb0315d31c3c818a738bdc153397365">More...</a><br/></td></tr>
<tr class="separator:aebb0315d31c3c818a738bdc153397365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58ba299df96ee6c45043e646a1d01dc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ae58ba299df96ee6c45043e646a1d01dc">testBits</a> (double a)</td></tr>
<tr class="memdesc:ae58ba299df96ee6c45043e646a1d01dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any bits are set in the double variable.  <a href="#ae58ba299df96ee6c45043e646a1d01dc">More...</a><br/></td></tr>
<tr class="separator:ae58ba299df96ee6c45043e646a1d01dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1449de9307a87e0c5946fd9cab43b35"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa1449de9307a87e0c5946fd9cab43b35">selectByMask</a> (double a, bool mask)</td></tr>
<tr class="memdesc:aa1449de9307a87e0c5946fd9cab43b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from double precision variable where boolean is true.  <a href="#aa1449de9307a87e0c5946fd9cab43b35">More...</a><br/></td></tr>
<tr class="separator:aa1449de9307a87e0c5946fd9cab43b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f03ad3380ef6213c5459051c3268ba7"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2f03ad3380ef6213c5459051c3268ba7">selectByNotMask</a> (double a, bool mask)</td></tr>
<tr class="memdesc:a2f03ad3380ef6213c5459051c3268ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from double precision variable where boolean is false.  <a href="#a2f03ad3380ef6213c5459051c3268ba7">More...</a><br/></td></tr>
<tr class="separator:a2f03ad3380ef6213c5459051c3268ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069393b3673bd0df6aefc16f8379cf96"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a069393b3673bd0df6aefc16f8379cf96">blend</a> (double a, double b, bool sel)</td></tr>
<tr class="memdesc:a069393b3673bd0df6aefc16f8379cf96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blend double selection.  <a href="#a069393b3673bd0df6aefc16f8379cf96">More...</a><br/></td></tr>
<tr class="separator:a069393b3673bd0df6aefc16f8379cf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9f420c1d0c099cc58ac3ae5fcb1ace"><td class="memItemLeft" align="right" valign="top">static std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#acc9f420c1d0c099cc58ac3ae5fcb1ace">cvtR2I</a> (double a)</td></tr>
<tr class="memdesc:acc9f420c1d0c099cc58ac3ae5fcb1ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round single precision doubleing point to integer.  <a href="#acc9f420c1d0c099cc58ac3ae5fcb1ace">More...</a><br/></td></tr>
<tr class="separator:acc9f420c1d0c099cc58ac3ae5fcb1ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0fb4318cc5c14075330d52382e6bdd4"><td class="memItemLeft" align="right" valign="top">static std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ac0fb4318cc5c14075330d52382e6bdd4">cvttR2I</a> (double a)</td></tr>
<tr class="memdesc:ac0fb4318cc5c14075330d52382e6bdd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate single precision doubleing point to integer.  <a href="#ac0fb4318cc5c14075330d52382e6bdd4">More...</a><br/></td></tr>
<tr class="separator:ac0fb4318cc5c14075330d52382e6bdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac575d3b81809b71e414755dc8acf3317"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ac575d3b81809b71e414755dc8acf3317">cvtF2D</a> (float a)</td></tr>
<tr class="memdesc:ac575d3b81809b71e414755dc8acf3317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert float to double (mimicks SIMD conversion)  <a href="#ac575d3b81809b71e414755dc8acf3317">More...</a><br/></td></tr>
<tr class="separator:ac575d3b81809b71e414755dc8acf3317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22401779c65549d3061b4fdd5290ef19"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a22401779c65549d3061b4fdd5290ef19">cvtD2F</a> (double a)</td></tr>
<tr class="memdesc:a22401779c65549d3061b4fdd5290ef19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert double to float (mimicks SIMD conversion)  <a href="#a22401779c65549d3061b4fdd5290ef19">More...</a><br/></td></tr>
<tr class="separator:a22401779c65549d3061b4fdd5290ef19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa169afcbfb3992ab9fde1ed5beee8b06"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa169afcbfb3992ab9fde1ed5beee8b06">store</a> (std::int32_t *m, std::int32_t a)</td></tr>
<tr class="memdesc:aa169afcbfb3992ab9fde1ed5beee8b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store contents of integer variable to aligned memory m.  <a href="#aa169afcbfb3992ab9fde1ed5beee8b06">More...</a><br/></td></tr>
<tr class="separator:aa169afcbfb3992ab9fde1ed5beee8b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43354d3d210193bcf5316234dc7d93ae"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a43354d3d210193bcf5316234dc7d93ae">storeU</a> (std::int32_t *m, std::int32_t a)</td></tr>
<tr class="memdesc:a43354d3d210193bcf5316234dc7d93ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store contents of integer variable to unaligned memory m.  <a href="#a43354d3d210193bcf5316234dc7d93ae">More...</a><br/></td></tr>
<tr class="separator:a43354d3d210193bcf5316234dc7d93ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880a42645963c52980a5790f09e3bd18"><td class="memItemLeft" align="right" valign="top">static std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a880a42645963c52980a5790f09e3bd18">andNot</a> (std::int32_t a, std::int32_t b)</td></tr>
<tr class="memdesc:a880a42645963c52980a5790f09e3bd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise andnot for two scalar integer variables.  <a href="#a880a42645963c52980a5790f09e3bd18">More...</a><br/></td></tr>
<tr class="separator:a880a42645963c52980a5790f09e3bd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a03b61db6a3ed3e8c2d5e1b3acc9a8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ae2a03b61db6a3ed3e8c2d5e1b3acc9a8">testBits</a> (std::int32_t a)</td></tr>
<tr class="memdesc:ae2a03b61db6a3ed3e8c2d5e1b3acc9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any bits are set in the integer variable.  <a href="#ae2a03b61db6a3ed3e8c2d5e1b3acc9a8">More...</a><br/></td></tr>
<tr class="separator:ae2a03b61db6a3ed3e8c2d5e1b3acc9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543420229312467871aaa26ea79f5a5d"><td class="memItemLeft" align="right" valign="top">static std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a543420229312467871aaa26ea79f5a5d">selectByMask</a> (std::int32_t a, bool mask)</td></tr>
<tr class="memdesc:a543420229312467871aaa26ea79f5a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from integer variable where boolean is true.  <a href="#a543420229312467871aaa26ea79f5a5d">More...</a><br/></td></tr>
<tr class="separator:a543420229312467871aaa26ea79f5a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c7d81b9ba8302dadcbdded4fcd4399"><td class="memItemLeft" align="right" valign="top">static std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa1c7d81b9ba8302dadcbdded4fcd4399">selectByNotMask</a> (std::int32_t a, bool mask)</td></tr>
<tr class="memdesc:aa1c7d81b9ba8302dadcbdded4fcd4399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from integer variable where boolean is false.  <a href="#aa1c7d81b9ba8302dadcbdded4fcd4399">More...</a><br/></td></tr>
<tr class="separator:aa1c7d81b9ba8302dadcbdded4fcd4399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174859a095e84b4a4ee3214547fe8f13"><td class="memItemLeft" align="right" valign="top">static std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a174859a095e84b4a4ee3214547fe8f13">blend</a> (std::int32_t a, std::int32_t b, bool sel)</td></tr>
<tr class="memdesc:a174859a095e84b4a4ee3214547fe8f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blend integer selection.  <a href="#a174859a095e84b4a4ee3214547fe8f13">More...</a><br/></td></tr>
<tr class="separator:a174859a095e84b4a4ee3214547fe8f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27254f29caa9fd12a6e774bf7a13502c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a27254f29caa9fd12a6e774bf7a13502c">cvtB2IB</a> (bool a)</td></tr>
<tr class="memdesc:a27254f29caa9fd12a6e774bf7a13502c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just return a boolean (mimicks SIMD real-to-int bool conversions)  <a href="#a27254f29caa9fd12a6e774bf7a13502c">More...</a><br/></td></tr>
<tr class="separator:a27254f29caa9fd12a6e774bf7a13502c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a600fa6a48b5df753c2fcc99c47f3f3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2a600fa6a48b5df753c2fcc99c47f3f3">cvtIB2B</a> (bool a)</td></tr>
<tr class="memdesc:a2a600fa6a48b5df753c2fcc99c47f3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just return a boolean (mimicks SIMD int-to-real bool conversions)  <a href="#a2a600fa6a48b5df753c2fcc99c47f3f3">More...</a><br/></td></tr>
<tr class="separator:a2a600fa6a48b5df753c2fcc99c47f3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef5f6af06e493a4ae2d47109ee0e723"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a8ef5f6af06e493a4ae2d47109ee0e723">copysign</a> (float x, float y)</td></tr>
<tr class="memdesc:a8ef5f6af06e493a4ae2d47109ee0e723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes single value with the magnitude of x and the sign of y.  <a href="#a8ef5f6af06e493a4ae2d47109ee0e723">More...</a><br/></td></tr>
<tr class="separator:a8ef5f6af06e493a4ae2d47109ee0e723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2ac92d9abba8296506e281dc66c47a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aba2ac92d9abba8296506e281dc66c47a">invsqrtPair</a> (float x0, float x1, float *out0, float *out1)</td></tr>
<tr class="memdesc:aba2ac92d9abba8296506e281dc66c47a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for two floats.  <a href="#aba2ac92d9abba8296506e281dc66c47a">More...</a><br/></td></tr>
<tr class="separator:aba2ac92d9abba8296506e281dc66c47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd74be08263227a2b2f4405dee6a359"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a6cd74be08263227a2b2f4405dee6a359">inv</a> (float x)</td></tr>
<tr class="memdesc:a6cd74be08263227a2b2f4405dee6a359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/x for float.  <a href="#a6cd74be08263227a2b2f4405dee6a359">More...</a><br/></td></tr>
<tr class="separator:a6cd74be08263227a2b2f4405dee6a359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa182f9ceead92b3055e6ae5903994651"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa182f9ceead92b3055e6ae5903994651">maskzInvsqrt</a> (float x, bool m)</td></tr>
<tr class="memdesc:aa182f9ceead92b3055e6ae5903994651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for masked entry of float.  <a href="#aa182f9ceead92b3055e6ae5903994651">More...</a><br/></td></tr>
<tr class="separator:aa182f9ceead92b3055e6ae5903994651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582d71ff8e7d51cbd2386e29935e89ef"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a582d71ff8e7d51cbd2386e29935e89ef">maskzInv</a> (float x, bool m)</td></tr>
<tr class="memdesc:a582d71ff8e7d51cbd2386e29935e89ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/x for masked entry of float.  <a href="#a582d71ff8e7d51cbd2386e29935e89ef">More...</a><br/></td></tr>
<tr class="separator:a582d71ff8e7d51cbd2386e29935e89ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaecef21922df570fac2ce44fd7d5566"><td class="memTemplParams" colspan="2">template&lt;MathOptimization opt = MathOptimization::Safe&gt; </td></tr>
<tr class="memitem:acaecef21922df570fac2ce44fd7d5566"><td class="memTemplItemLeft" align="right" valign="top">static float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#acaecef21922df570fac2ce44fd7d5566">sqrt</a> (float x)</td></tr>
<tr class="memdesc:acaecef21922df570fac2ce44fd7d5566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float sqrt(x). This is the square root.  <a href="#acaecef21922df570fac2ce44fd7d5566">More...</a><br/></td></tr>
<tr class="separator:acaecef21922df570fac2ce44fd7d5566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0a25f25b649f59d96b67f2d73c8ad8"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a7b0a25f25b649f59d96b67f2d73c8ad8">log</a> (float x)</td></tr>
<tr class="memdesc:a7b0a25f25b649f59d96b67f2d73c8ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float log(x). This is the natural logarithm.  <a href="#a7b0a25f25b649f59d96b67f2d73c8ad8">More...</a><br/></td></tr>
<tr class="separator:a7b0a25f25b649f59d96b67f2d73c8ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643a4be46c81b885274394cd9ac1a30a"><td class="memTemplParams" colspan="2">template&lt;MathOptimization opt = MathOptimization::Safe&gt; </td></tr>
<tr class="memitem:a643a4be46c81b885274394cd9ac1a30a"><td class="memTemplItemLeft" align="right" valign="top">static float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a643a4be46c81b885274394cd9ac1a30a">exp2</a> (float x)</td></tr>
<tr class="memdesc:a643a4be46c81b885274394cd9ac1a30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float 2^x.  <a href="#a643a4be46c81b885274394cd9ac1a30a">More...</a><br/></td></tr>
<tr class="separator:a643a4be46c81b885274394cd9ac1a30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22dfb3027cee75bbc9686094f928050"><td class="memTemplParams" colspan="2">template&lt;MathOptimization opt = MathOptimization::Safe&gt; </td></tr>
<tr class="memitem:aa22dfb3027cee75bbc9686094f928050"><td class="memTemplItemLeft" align="right" valign="top">static float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa22dfb3027cee75bbc9686094f928050">exp</a> (float x)</td></tr>
<tr class="memdesc:aa22dfb3027cee75bbc9686094f928050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float exp(x).  <a href="#aa22dfb3027cee75bbc9686094f928050">More...</a><br/></td></tr>
<tr class="separator:aa22dfb3027cee75bbc9686094f928050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a81ecdda73e384cd4e6896492144529"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a9a81ecdda73e384cd4e6896492144529">erf</a> (float x)</td></tr>
<tr class="memdesc:a9a81ecdda73e384cd4e6896492144529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float erf(x).  <a href="#a9a81ecdda73e384cd4e6896492144529">More...</a><br/></td></tr>
<tr class="separator:a9a81ecdda73e384cd4e6896492144529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad005ed4133f5a01702c63a9440feab7"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aad005ed4133f5a01702c63a9440feab7">erfc</a> (float x)</td></tr>
<tr class="memdesc:aad005ed4133f5a01702c63a9440feab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float erfc(x).  <a href="#aad005ed4133f5a01702c63a9440feab7">More...</a><br/></td></tr>
<tr class="separator:aad005ed4133f5a01702c63a9440feab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3191310c1a122aafe946f0caf2fdf364"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a3191310c1a122aafe946f0caf2fdf364">sincos</a> (float x, float *sinval, float *cosval)</td></tr>
<tr class="memdesc:a3191310c1a122aafe946f0caf2fdf364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float sin &amp; cos.  <a href="#a3191310c1a122aafe946f0caf2fdf364">More...</a><br/></td></tr>
<tr class="separator:a3191310c1a122aafe946f0caf2fdf364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85c54a566c85f916aaa2561d12fa851"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af85c54a566c85f916aaa2561d12fa851">sin</a> (float x)</td></tr>
<tr class="memdesc:af85c54a566c85f916aaa2561d12fa851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float sin.  <a href="#af85c54a566c85f916aaa2561d12fa851">More...</a><br/></td></tr>
<tr class="separator:af85c54a566c85f916aaa2561d12fa851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c6356a58f3d2c2fe6d2f50afc0c686"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a16c6356a58f3d2c2fe6d2f50afc0c686">cos</a> (float x)</td></tr>
<tr class="memdesc:a16c6356a58f3d2c2fe6d2f50afc0c686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float cos.  <a href="#a16c6356a58f3d2c2fe6d2f50afc0c686">More...</a><br/></td></tr>
<tr class="separator:a16c6356a58f3d2c2fe6d2f50afc0c686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7063173231453ec737688c8d91aa0749"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a7063173231453ec737688c8d91aa0749">tan</a> (float x)</td></tr>
<tr class="memdesc:a7063173231453ec737688c8d91aa0749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float tan.  <a href="#a7063173231453ec737688c8d91aa0749">More...</a><br/></td></tr>
<tr class="separator:a7063173231453ec737688c8d91aa0749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5120df9c0bf437e64c806a7cfdad02"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a3d5120df9c0bf437e64c806a7cfdad02">asin</a> (float x)</td></tr>
<tr class="memdesc:a3d5120df9c0bf437e64c806a7cfdad02"><td class="mdescLeft">&#160;</td><td class="mdescRight">float asin.  <a href="#a3d5120df9c0bf437e64c806a7cfdad02">More...</a><br/></td></tr>
<tr class="separator:a3d5120df9c0bf437e64c806a7cfdad02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab102173c68c06e7a340e4eebbf6c3492"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ab102173c68c06e7a340e4eebbf6c3492">acos</a> (float x)</td></tr>
<tr class="memdesc:ab102173c68c06e7a340e4eebbf6c3492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float acos.  <a href="#ab102173c68c06e7a340e4eebbf6c3492">More...</a><br/></td></tr>
<tr class="separator:ab102173c68c06e7a340e4eebbf6c3492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1afbc2ada56f899a8d3dc5c61530e28b"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a1afbc2ada56f899a8d3dc5c61530e28b">atan</a> (float x)</td></tr>
<tr class="memdesc:a1afbc2ada56f899a8d3dc5c61530e28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float atan.  <a href="#a1afbc2ada56f899a8d3dc5c61530e28b">More...</a><br/></td></tr>
<tr class="separator:a1afbc2ada56f899a8d3dc5c61530e28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8336a58abddcdb6afa7835138ecf46"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aed8336a58abddcdb6afa7835138ecf46">atan2</a> (float y, float x)</td></tr>
<tr class="memdesc:aed8336a58abddcdb6afa7835138ecf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float atan2(y,x).  <a href="#aed8336a58abddcdb6afa7835138ecf46">More...</a><br/></td></tr>
<tr class="separator:aed8336a58abddcdb6afa7835138ecf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5b1230d0301fa6760e34d7641ca7e4"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a1e5b1230d0301fa6760e34d7641ca7e4">pmeForceCorrection</a> (float z2)</td></tr>
<tr class="memdesc:a1e5b1230d0301fa6760e34d7641ca7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the force correction due to PME analytically in float.  <a href="#a1e5b1230d0301fa6760e34d7641ca7e4">More...</a><br/></td></tr>
<tr class="separator:a1e5b1230d0301fa6760e34d7641ca7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54e81f11cb53c7d68ff7dab05bd6afd"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ac54e81f11cb53c7d68ff7dab05bd6afd">pmePotentialCorrection</a> (float z2)</td></tr>
<tr class="memdesc:ac54e81f11cb53c7d68ff7dab05bd6afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the potential correction due to PME analytically in float.  <a href="#ac54e81f11cb53c7d68ff7dab05bd6afd">More...</a><br/></td></tr>
<tr class="separator:ac54e81f11cb53c7d68ff7dab05bd6afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cfb56189c360e005911247ebf5fd42"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af6cfb56189c360e005911247ebf5fd42">copysign</a> (double x, double y)</td></tr>
<tr class="memdesc:af6cfb56189c360e005911247ebf5fd42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes double value with the magnitude of x and the sign of y.  <a href="#af6cfb56189c360e005911247ebf5fd42">More...</a><br/></td></tr>
<tr class="separator:af6cfb56189c360e005911247ebf5fd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb50fcc000a2c2d4b8446fc17a5695e0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#abb50fcc000a2c2d4b8446fc17a5695e0">invsqrtPair</a> (double x0, double x1, double *out0, double *out1)</td></tr>
<tr class="memdesc:abb50fcc000a2c2d4b8446fc17a5695e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for two doubles.  <a href="#abb50fcc000a2c2d4b8446fc17a5695e0">More...</a><br/></td></tr>
<tr class="separator:abb50fcc000a2c2d4b8446fc17a5695e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed9172c60ed326ca31f64a490fabe17"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a8ed9172c60ed326ca31f64a490fabe17">inv</a> (double x)</td></tr>
<tr class="memdesc:a8ed9172c60ed326ca31f64a490fabe17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/x for double.  <a href="#a8ed9172c60ed326ca31f64a490fabe17">More...</a><br/></td></tr>
<tr class="separator:a8ed9172c60ed326ca31f64a490fabe17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b5a9766964a2b854f493fd783bb63d"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa5b5a9766964a2b854f493fd783bb63d">maskzInvsqrt</a> (double x, bool m)</td></tr>
<tr class="memdesc:aa5b5a9766964a2b854f493fd783bb63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for masked entry of double.  <a href="#aa5b5a9766964a2b854f493fd783bb63d">More...</a><br/></td></tr>
<tr class="separator:aa5b5a9766964a2b854f493fd783bb63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5cc89f64ab845f88816a9cbb16d467c"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af5cc89f64ab845f88816a9cbb16d467c">maskzInv</a> (double x, bool m)</td></tr>
<tr class="memdesc:af5cc89f64ab845f88816a9cbb16d467c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/x for masked entry of double.  <a href="#af5cc89f64ab845f88816a9cbb16d467c">More...</a><br/></td></tr>
<tr class="separator:af5cc89f64ab845f88816a9cbb16d467c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc4e2ff8f9541e36f13fa579be8c7c7"><td class="memTemplParams" colspan="2">template&lt;MathOptimization opt = MathOptimization::Safe&gt; </td></tr>
<tr class="memitem:aabc4e2ff8f9541e36f13fa579be8c7c7"><td class="memTemplItemLeft" align="right" valign="top">static double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aabc4e2ff8f9541e36f13fa579be8c7c7">sqrt</a> (double x)</td></tr>
<tr class="memdesc:aabc4e2ff8f9541e36f13fa579be8c7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double sqrt(x). This is the square root.  <a href="#aabc4e2ff8f9541e36f13fa579be8c7c7">More...</a><br/></td></tr>
<tr class="separator:aabc4e2ff8f9541e36f13fa579be8c7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398a52e25652367446f9180a50343885"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a398a52e25652367446f9180a50343885">log</a> (double x)</td></tr>
<tr class="memdesc:a398a52e25652367446f9180a50343885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double log(x). This is the natural logarithm.  <a href="#a398a52e25652367446f9180a50343885">More...</a><br/></td></tr>
<tr class="separator:a398a52e25652367446f9180a50343885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ee0155bc450db5b12eb105efce27df"><td class="memTemplParams" colspan="2">template&lt;MathOptimization opt = MathOptimization::Safe&gt; </td></tr>
<tr class="memitem:a32ee0155bc450db5b12eb105efce27df"><td class="memTemplItemLeft" align="right" valign="top">static double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a32ee0155bc450db5b12eb105efce27df">exp2</a> (double x)</td></tr>
<tr class="memdesc:a32ee0155bc450db5b12eb105efce27df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double 2^x.  <a href="#a32ee0155bc450db5b12eb105efce27df">More...</a><br/></td></tr>
<tr class="separator:a32ee0155bc450db5b12eb105efce27df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70905c614c3a1bb238913e8dbf6cdf85"><td class="memTemplParams" colspan="2">template&lt;MathOptimization opt = MathOptimization::Safe&gt; </td></tr>
<tr class="memitem:a70905c614c3a1bb238913e8dbf6cdf85"><td class="memTemplItemLeft" align="right" valign="top">static double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a70905c614c3a1bb238913e8dbf6cdf85">exp</a> (double x)</td></tr>
<tr class="memdesc:a70905c614c3a1bb238913e8dbf6cdf85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double exp(x).  <a href="#a70905c614c3a1bb238913e8dbf6cdf85">More...</a><br/></td></tr>
<tr class="separator:a70905c614c3a1bb238913e8dbf6cdf85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3fe934a0b6419312a82b6bb6b8b6ff"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a6a3fe934a0b6419312a82b6bb6b8b6ff">erf</a> (double x)</td></tr>
<tr class="memdesc:a6a3fe934a0b6419312a82b6bb6b8b6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double erf(x).  <a href="#a6a3fe934a0b6419312a82b6bb6b8b6ff">More...</a><br/></td></tr>
<tr class="separator:a6a3fe934a0b6419312a82b6bb6b8b6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c071a6a14720e2b94e4b034e110614"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a56c071a6a14720e2b94e4b034e110614">erfc</a> (double x)</td></tr>
<tr class="memdesc:a56c071a6a14720e2b94e4b034e110614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double erfc(x).  <a href="#a56c071a6a14720e2b94e4b034e110614">More...</a><br/></td></tr>
<tr class="separator:a56c071a6a14720e2b94e4b034e110614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5923534ff59a386ae0579eb4196b1e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a0a5923534ff59a386ae0579eb4196b1e">sincos</a> (double x, double *sinval, double *cosval)</td></tr>
<tr class="memdesc:a0a5923534ff59a386ae0579eb4196b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double sin &amp; cos.  <a href="#a0a5923534ff59a386ae0579eb4196b1e">More...</a><br/></td></tr>
<tr class="separator:a0a5923534ff59a386ae0579eb4196b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6579216abaac018cb0bc59e9183f99ba"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a6579216abaac018cb0bc59e9183f99ba">sin</a> (double x)</td></tr>
<tr class="memdesc:a6579216abaac018cb0bc59e9183f99ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double sin.  <a href="#a6579216abaac018cb0bc59e9183f99ba">More...</a><br/></td></tr>
<tr class="separator:a6579216abaac018cb0bc59e9183f99ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda573e9aa3efa5d223c9fe39f682cfd"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aeda573e9aa3efa5d223c9fe39f682cfd">cos</a> (double x)</td></tr>
<tr class="memdesc:aeda573e9aa3efa5d223c9fe39f682cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double cos.  <a href="#aeda573e9aa3efa5d223c9fe39f682cfd">More...</a><br/></td></tr>
<tr class="separator:aeda573e9aa3efa5d223c9fe39f682cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e727a4960ac7f8ba5149f9b251c520"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a45e727a4960ac7f8ba5149f9b251c520">tan</a> (double x)</td></tr>
<tr class="memdesc:a45e727a4960ac7f8ba5149f9b251c520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double tan.  <a href="#a45e727a4960ac7f8ba5149f9b251c520">More...</a><br/></td></tr>
<tr class="separator:a45e727a4960ac7f8ba5149f9b251c520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02c7d47595f11074fbfedff40145544"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ab02c7d47595f11074fbfedff40145544">asin</a> (double x)</td></tr>
<tr class="memdesc:ab02c7d47595f11074fbfedff40145544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double asin.  <a href="#ab02c7d47595f11074fbfedff40145544">More...</a><br/></td></tr>
<tr class="separator:ab02c7d47595f11074fbfedff40145544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b534003a0dba716c08d6053e0514311"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a5b534003a0dba716c08d6053e0514311">acos</a> (double x)</td></tr>
<tr class="memdesc:a5b534003a0dba716c08d6053e0514311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double acos.  <a href="#a5b534003a0dba716c08d6053e0514311">More...</a><br/></td></tr>
<tr class="separator:a5b534003a0dba716c08d6053e0514311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15e6f3962e035d69013bd91621fd9f8"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af15e6f3962e035d69013bd91621fd9f8">atan</a> (double x)</td></tr>
<tr class="memdesc:af15e6f3962e035d69013bd91621fd9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double atan.  <a href="#af15e6f3962e035d69013bd91621fd9f8">More...</a><br/></td></tr>
<tr class="separator:af15e6f3962e035d69013bd91621fd9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70a1aa5e9c161a2770d0f9b7eca1805"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa70a1aa5e9c161a2770d0f9b7eca1805">atan2</a> (double y, double x)</td></tr>
<tr class="memdesc:aa70a1aa5e9c161a2770d0f9b7eca1805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double atan2(y,x).  <a href="#aa70a1aa5e9c161a2770d0f9b7eca1805">More...</a><br/></td></tr>
<tr class="separator:aa70a1aa5e9c161a2770d0f9b7eca1805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5275f264f1c6da2502ec03e8fbf855a4"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a5275f264f1c6da2502ec03e8fbf855a4">pmeForceCorrection</a> (double z2)</td></tr>
<tr class="memdesc:a5275f264f1c6da2502ec03e8fbf855a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the force correction due to PME analytically in double.  <a href="#a5275f264f1c6da2502ec03e8fbf855a4">More...</a><br/></td></tr>
<tr class="separator:a5275f264f1c6da2502ec03e8fbf855a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba0166c05fec69dd4a2624ed8dcff95"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#acba0166c05fec69dd4a2624ed8dcff95">pmePotentialCorrection</a> (double z2)</td></tr>
<tr class="memdesc:acba0166c05fec69dd4a2624ed8dcff95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the potential correction due to PME analytically in double.  <a href="#acba0166c05fec69dd4a2624ed8dcff95">More...</a><br/></td></tr>
<tr class="separator:acba0166c05fec69dd4a2624ed8dcff95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44adc739c8fb319abe1b6769f39e9341"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a44adc739c8fb319abe1b6769f39e9341">invsqrtSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a44adc739c8fb319abe1b6769f39e9341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for double, but with single accuracy.  <a href="#a44adc739c8fb319abe1b6769f39e9341">More...</a><br/></td></tr>
<tr class="separator:a44adc739c8fb319abe1b6769f39e9341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f2d71567d1b88689c8498f3592b386"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a18f2d71567d1b88689c8498f3592b386">invsqrtPairSingleAccuracy</a> (double x0, double x1, double *out0, double *out1)</td></tr>
<tr class="memdesc:a18f2d71567d1b88689c8498f3592b386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for two doubles, but with single accuracy.  <a href="#a18f2d71567d1b88689c8498f3592b386">More...</a><br/></td></tr>
<tr class="separator:a18f2d71567d1b88689c8498f3592b386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac51c492a5589e075b7b8ebda5a8cbd"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a8ac51c492a5589e075b7b8ebda5a8cbd">invSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a8ac51c492a5589e075b7b8ebda5a8cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/x for double, but with single accuracy.  <a href="#a8ac51c492a5589e075b7b8ebda5a8cbd">More...</a><br/></td></tr>
<tr class="separator:a8ac51c492a5589e075b7b8ebda5a8cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdaf91102db0bfbc6fd440524b15199"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a1fdaf91102db0bfbc6fd440524b15199">maskzInvsqrtSingleAccuracy</a> (double x, bool m)</td></tr>
<tr class="memdesc:a1fdaf91102db0bfbc6fd440524b15199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for masked entry of double, but with single accuracy.  <a href="#a1fdaf91102db0bfbc6fd440524b15199">More...</a><br/></td></tr>
<tr class="separator:a1fdaf91102db0bfbc6fd440524b15199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2433c82892495a73bf41de15f5e8908f"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2433c82892495a73bf41de15f5e8908f">maskzInvSingleAccuracy</a> (double x, bool m)</td></tr>
<tr class="memdesc:a2433c82892495a73bf41de15f5e8908f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/x for masked entry of double, but with single accuracy.  <a href="#a2433c82892495a73bf41de15f5e8908f">More...</a><br/></td></tr>
<tr class="separator:a2433c82892495a73bf41de15f5e8908f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6d95fd83052d09775c976a961eee29"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2d6d95fd83052d09775c976a961eee29">sqrtSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a2d6d95fd83052d09775c976a961eee29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate sqrt(x) for double, but with single accuracy.  <a href="#a2d6d95fd83052d09775c976a961eee29">More...</a><br/></td></tr>
<tr class="separator:a2d6d95fd83052d09775c976a961eee29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c2c975d7e597b08a67d85920d4f562"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a54c2c975d7e597b08a67d85920d4f562">logSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a54c2c975d7e597b08a67d85920d4f562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double log(x), but with single accuracy. This is the natural logarithm.  <a href="#a54c2c975d7e597b08a67d85920d4f562">More...</a><br/></td></tr>
<tr class="separator:a54c2c975d7e597b08a67d85920d4f562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119f14f4a364f71eb9273b5dd8c927cd"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a119f14f4a364f71eb9273b5dd8c927cd">exp2SingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a119f14f4a364f71eb9273b5dd8c927cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double 2^x, but with single accuracy.  <a href="#a119f14f4a364f71eb9273b5dd8c927cd">More...</a><br/></td></tr>
<tr class="separator:a119f14f4a364f71eb9273b5dd8c927cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6d2866bd8be11dce227ad0e26511a4"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#afa6d2866bd8be11dce227ad0e26511a4">expSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:afa6d2866bd8be11dce227ad0e26511a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double exp(x), but with single accuracy.  <a href="#afa6d2866bd8be11dce227ad0e26511a4">More...</a><br/></td></tr>
<tr class="separator:afa6d2866bd8be11dce227ad0e26511a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2491a7f4b92881d4887491a532e8e5f7"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2491a7f4b92881d4887491a532e8e5f7">erfSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a2491a7f4b92881d4887491a532e8e5f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double erf(x), but with single accuracy.  <a href="#a2491a7f4b92881d4887491a532e8e5f7">More...</a><br/></td></tr>
<tr class="separator:a2491a7f4b92881d4887491a532e8e5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d277c19df61f3b0176da88ba40b53a"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a56d277c19df61f3b0176da88ba40b53a">erfcSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a56d277c19df61f3b0176da88ba40b53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double erfc(x), but with single accuracy.  <a href="#a56d277c19df61f3b0176da88ba40b53a">More...</a><br/></td></tr>
<tr class="separator:a56d277c19df61f3b0176da88ba40b53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200455e2d7401d66cac8e39b4c8142bf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a200455e2d7401d66cac8e39b4c8142bf">sincosSingleAccuracy</a> (double x, double *sinval, double *cosval)</td></tr>
<tr class="memdesc:a200455e2d7401d66cac8e39b4c8142bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double sin &amp; cos, but with single accuracy.  <a href="#a200455e2d7401d66cac8e39b4c8142bf">More...</a><br/></td></tr>
<tr class="separator:a200455e2d7401d66cac8e39b4c8142bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810c7b2f5d8f267f421f2c59a308c11d"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a810c7b2f5d8f267f421f2c59a308c11d">sinSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a810c7b2f5d8f267f421f2c59a308c11d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double sin, but with single accuracy.  <a href="#a810c7b2f5d8f267f421f2c59a308c11d">More...</a><br/></td></tr>
<tr class="separator:a810c7b2f5d8f267f421f2c59a308c11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e717707cf40d6bbacf8752cf28de422"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2e717707cf40d6bbacf8752cf28de422">cosSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a2e717707cf40d6bbacf8752cf28de422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double cos, but with single accuracy.  <a href="#a2e717707cf40d6bbacf8752cf28de422">More...</a><br/></td></tr>
<tr class="separator:a2e717707cf40d6bbacf8752cf28de422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f979f3defa4f725cfce2d7e93fc0d9e"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a0f979f3defa4f725cfce2d7e93fc0d9e">tanSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a0f979f3defa4f725cfce2d7e93fc0d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double tan, but with single accuracy.  <a href="#a0f979f3defa4f725cfce2d7e93fc0d9e">More...</a><br/></td></tr>
<tr class="separator:a0f979f3defa4f725cfce2d7e93fc0d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98465e562d7b1b24755bc693db04c8f5"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a98465e562d7b1b24755bc693db04c8f5">asinSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a98465e562d7b1b24755bc693db04c8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double asin, but with single accuracy.  <a href="#a98465e562d7b1b24755bc693db04c8f5">More...</a><br/></td></tr>
<tr class="separator:a98465e562d7b1b24755bc693db04c8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f487fc13f5bd1b83417f108a74f5a0"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a72f487fc13f5bd1b83417f108a74f5a0">acosSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a72f487fc13f5bd1b83417f108a74f5a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double acos, but with single accuracy.  <a href="#a72f487fc13f5bd1b83417f108a74f5a0">More...</a><br/></td></tr>
<tr class="separator:a72f487fc13f5bd1b83417f108a74f5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ca54cb014d2f33b98f3d523d90a2f5"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a44ca54cb014d2f33b98f3d523d90a2f5">atanSingleAccuracy</a> (double x)</td></tr>
<tr class="memdesc:a44ca54cb014d2f33b98f3d523d90a2f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double atan, but with single accuracy.  <a href="#a44ca54cb014d2f33b98f3d523d90a2f5">More...</a><br/></td></tr>
<tr class="separator:a44ca54cb014d2f33b98f3d523d90a2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2552094c1be29e087e1e85ae02fb0c7a"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2552094c1be29e087e1e85ae02fb0c7a">atan2SingleAccuracy</a> (double y, double x)</td></tr>
<tr class="memdesc:a2552094c1be29e087e1e85ae02fb0c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double atan2(y,x), but with single accuracy.  <a href="#a2552094c1be29e087e1e85ae02fb0c7a">More...</a><br/></td></tr>
<tr class="separator:a2552094c1be29e087e1e85ae02fb0c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd18f07b8fd19f03f12442211982db53"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#abd18f07b8fd19f03f12442211982db53">pmeForceCorrectionSingleAccuracy</a> (double z2)</td></tr>
<tr class="memdesc:abd18f07b8fd19f03f12442211982db53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force correction due to PME in double, but with single accuracy.  <a href="#abd18f07b8fd19f03f12442211982db53">More...</a><br/></td></tr>
<tr class="separator:abd18f07b8fd19f03f12442211982db53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8004b2507f7192ead653fcdcb6735fe"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ab8004b2507f7192ead653fcdcb6735fe">pmePotentialCorrectionSingleAccuracy</a> (double z2)</td></tr>
<tr class="memdesc:ab8004b2507f7192ead653fcdcb6735fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Potential correction due to PME in double, but with single accuracy.  <a href="#ab8004b2507f7192ead653fcdcb6735fe">More...</a><br/></td></tr>
<tr class="separator:ab8004b2507f7192ead653fcdcb6735fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7ff3639534a22d4b9c7a834d7584fd"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:aba7ff3639534a22d4b9c7a834d7584fd"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aba7ff3639534a22d4b9c7a834d7584fd">gatherLoadTranspose</a> (const float *base, const std::int32_t offset[], float *v0, float *v1, float *v2, float *v3)</td></tr>
<tr class="memdesc:aba7ff3639534a22d4b9c7a834d7584fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 4 consecutive floats from base/offset into four variables.  <a href="#aba7ff3639534a22d4b9c7a834d7584fd">More...</a><br/></td></tr>
<tr class="separator:aba7ff3639534a22d4b9c7a834d7584fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0cda66eba19ad12a50e48f848f268f"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a4c0cda66eba19ad12a50e48f848f268f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a4c0cda66eba19ad12a50e48f848f268f">gatherLoadTranspose</a> (const float *base, const std::int32_t offset[], float *v0, float *v1)</td></tr>
<tr class="memdesc:a4c0cda66eba19ad12a50e48f848f268f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 2 consecutive floats from base/offset into four variables.  <a href="#a4c0cda66eba19ad12a50e48f848f268f">More...</a><br/></td></tr>
<tr class="separator:a4c0cda66eba19ad12a50e48f848f268f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfefc291c66a8404f2aad767af91cb21"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:acfefc291c66a8404f2aad767af91cb21"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#acfefc291c66a8404f2aad767af91cb21">gatherLoadUTranspose</a> (const float *base, const std::int32_t offset[], float *v0, float *v1, float *v2)</td></tr>
<tr class="memdesc:acfefc291c66a8404f2aad767af91cb21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 3 consecutive floats from base/offsets, store into three vars.  <a href="#acfefc291c66a8404f2aad767af91cb21">More...</a><br/></td></tr>
<tr class="separator:acfefc291c66a8404f2aad767af91cb21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d8dd5e7a4ade4e3750b48e2a95b308"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a65d8dd5e7a4ade4e3750b48e2a95b308"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a65d8dd5e7a4ade4e3750b48e2a95b308">transposeScatterStoreU</a> (float *base, const std::int32_t offset[], float v0, float v1, float v2)</td></tr>
<tr class="memdesc:a65d8dd5e7a4ade4e3750b48e2a95b308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store 3 floats to 3 to base/offset.  <a href="#a65d8dd5e7a4ade4e3750b48e2a95b308">More...</a><br/></td></tr>
<tr class="separator:a65d8dd5e7a4ade4e3750b48e2a95b308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12069a0402115678c9c39b303585917d"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a12069a0402115678c9c39b303585917d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a12069a0402115678c9c39b303585917d">transposeScatterIncrU</a> (float *base, const std::int32_t offset[], float v0, float v1, float v2)</td></tr>
<tr class="memdesc:a12069a0402115678c9c39b303585917d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add 3 floats to base/offset.  <a href="#a12069a0402115678c9c39b303585917d">More...</a><br/></td></tr>
<tr class="separator:a12069a0402115678c9c39b303585917d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e302c7dcfb8d4937c4388d77057435"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:af7e302c7dcfb8d4937c4388d77057435"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af7e302c7dcfb8d4937c4388d77057435">transposeScatterDecrU</a> (float *base, const std::int32_t offset[], float v0, float v1, float v2)</td></tr>
<tr class="memdesc:af7e302c7dcfb8d4937c4388d77057435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract 3 floats from base/offset.  <a href="#af7e302c7dcfb8d4937c4388d77057435">More...</a><br/></td></tr>
<tr class="separator:af7e302c7dcfb8d4937c4388d77057435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b19d8b9f07e36c8152b30d4b3caaad6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a6b19d8b9f07e36c8152b30d4b3caaad6">expandScalarsToTriplets</a> (float scalar, float *triplets0, float *triplets1, float *triplets2)</td></tr>
<tr class="memdesc:a6b19d8b9f07e36c8152b30d4b3caaad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy single float to three variables.  <a href="#a6b19d8b9f07e36c8152b30d4b3caaad6">More...</a><br/></td></tr>
<tr class="separator:a6b19d8b9f07e36c8152b30d4b3caaad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179f05bc9899fe2b7e71d53a1a95b629"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a179f05bc9899fe2b7e71d53a1a95b629"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a179f05bc9899fe2b7e71d53a1a95b629">gatherLoadBySimdIntTranspose</a> (const float *base, std::int32_t offset, float *v0, float *v1, float *v2, float *v3)</td></tr>
<tr class="memdesc:a179f05bc9899fe2b7e71d53a1a95b629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 4 floats from base/offsets and store into variables.  <a href="#a179f05bc9899fe2b7e71d53a1a95b629">More...</a><br/></td></tr>
<tr class="separator:a179f05bc9899fe2b7e71d53a1a95b629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c67b43b26cfba5ec360bf020df4c8a"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a29c67b43b26cfba5ec360bf020df4c8a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a29c67b43b26cfba5ec360bf020df4c8a">gatherLoadUBySimdIntTranspose</a> (const float *base, std::int32_t offset, float *v0, float *v1)</td></tr>
<tr class="memdesc:a29c67b43b26cfba5ec360bf020df4c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 2 floats from base/offsets and store into variables (unaligned).  <a href="#a29c67b43b26cfba5ec360bf020df4c8a">More...</a><br/></td></tr>
<tr class="separator:a29c67b43b26cfba5ec360bf020df4c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0614e0463cccdf97cec36fffb2b24764"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a0614e0463cccdf97cec36fffb2b24764"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a0614e0463cccdf97cec36fffb2b24764">gatherLoadBySimdIntTranspose</a> (const float *base, std::int32_t offset, float *v0, float *v1)</td></tr>
<tr class="memdesc:a0614e0463cccdf97cec36fffb2b24764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 2 floats from base/offsets and store into variables (aligned).  <a href="#a0614e0463cccdf97cec36fffb2b24764">More...</a><br/></td></tr>
<tr class="separator:a0614e0463cccdf97cec36fffb2b24764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eac2eb3581affdefb5b3e79e000cf84"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a6eac2eb3581affdefb5b3e79e000cf84">reduceIncr4ReturnSum</a> (float *m, float v0, float v1, float v2, float v3)</td></tr>
<tr class="memdesc:a6eac2eb3581affdefb5b3e79e000cf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add each float to four consecutive memory locations, return sum.  <a href="#a6eac2eb3581affdefb5b3e79e000cf84">More...</a><br/></td></tr>
<tr class="separator:a6eac2eb3581affdefb5b3e79e000cf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e990607fd4d48ca160fbc380597f5a"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a94e990607fd4d48ca160fbc380597f5a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a94e990607fd4d48ca160fbc380597f5a">gatherLoadTranspose</a> (const double *base, const std::int32_t offset[], double *v0, double *v1, double *v2, double *v3)</td></tr>
<tr class="memdesc:a94e990607fd4d48ca160fbc380597f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 4 consecutive doubles from base/offset into four variables.  <a href="#a94e990607fd4d48ca160fbc380597f5a">More...</a><br/></td></tr>
<tr class="separator:a94e990607fd4d48ca160fbc380597f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c464ebd492587005bb4baefb4293072"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a0c464ebd492587005bb4baefb4293072"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a0c464ebd492587005bb4baefb4293072">gatherLoadTranspose</a> (const double *base, const std::int32_t offset[], double *v0, double *v1)</td></tr>
<tr class="memdesc:a0c464ebd492587005bb4baefb4293072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 2 consecutive doubles from base/offset into four variables.  <a href="#a0c464ebd492587005bb4baefb4293072">More...</a><br/></td></tr>
<tr class="separator:a0c464ebd492587005bb4baefb4293072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0502844193d9fcf13648a4165a67a1a3"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a0502844193d9fcf13648a4165a67a1a3"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a0502844193d9fcf13648a4165a67a1a3">gatherLoadUTranspose</a> (const double *base, const std::int32_t offset[], double *v0, double *v1, double *v2)</td></tr>
<tr class="memdesc:a0502844193d9fcf13648a4165a67a1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 3 consecutive doubles from base/offsets, store into three vars.  <a href="#a0502844193d9fcf13648a4165a67a1a3">More...</a><br/></td></tr>
<tr class="separator:a0502844193d9fcf13648a4165a67a1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d74c633ff138def6fa648441c5decf"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:ab5d74c633ff138def6fa648441c5decf"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ab5d74c633ff138def6fa648441c5decf">transposeScatterStoreU</a> (double *base, const std::int32_t offset[], double v0, double v1, double v2)</td></tr>
<tr class="memdesc:ab5d74c633ff138def6fa648441c5decf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store 3 doubles to 3 to base/offset.  <a href="#ab5d74c633ff138def6fa648441c5decf">More...</a><br/></td></tr>
<tr class="separator:ab5d74c633ff138def6fa648441c5decf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e3f241eaafa47cfa9258ec9efec8d0"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a83e3f241eaafa47cfa9258ec9efec8d0"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a83e3f241eaafa47cfa9258ec9efec8d0">transposeScatterIncrU</a> (double *base, const std::int32_t offset[], double v0, double v1, double v2)</td></tr>
<tr class="memdesc:a83e3f241eaafa47cfa9258ec9efec8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add 3 doubles to base/offset.  <a href="#a83e3f241eaafa47cfa9258ec9efec8d0">More...</a><br/></td></tr>
<tr class="separator:a83e3f241eaafa47cfa9258ec9efec8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812731a42d1358e6a06f81848a67eeb7"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a812731a42d1358e6a06f81848a67eeb7"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a812731a42d1358e6a06f81848a67eeb7">transposeScatterDecrU</a> (double *base, const std::int32_t offset[], double v0, double v1, double v2)</td></tr>
<tr class="memdesc:a812731a42d1358e6a06f81848a67eeb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract 3 doubles from base/offset.  <a href="#a812731a42d1358e6a06f81848a67eeb7">More...</a><br/></td></tr>
<tr class="separator:a812731a42d1358e6a06f81848a67eeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a2ae7f742d7612f2808bfd39b0f975"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af8a2ae7f742d7612f2808bfd39b0f975">expandScalarsToTriplets</a> (double scalar, double *triplets0, double *triplets1, double *triplets2)</td></tr>
<tr class="memdesc:af8a2ae7f742d7612f2808bfd39b0f975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy single double to three variables.  <a href="#af8a2ae7f742d7612f2808bfd39b0f975">More...</a><br/></td></tr>
<tr class="separator:af8a2ae7f742d7612f2808bfd39b0f975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c67d959864d2549a679f0f2245bacb"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a92c67d959864d2549a679f0f2245bacb"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a92c67d959864d2549a679f0f2245bacb">gatherLoadBySimdIntTranspose</a> (const double *base, std::int32_t offset, double *v0, double *v1, double *v2, double *v3)</td></tr>
<tr class="memdesc:a92c67d959864d2549a679f0f2245bacb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 4 doubles from base/offsets and store into variables.  <a href="#a92c67d959864d2549a679f0f2245bacb">More...</a><br/></td></tr>
<tr class="separator:a92c67d959864d2549a679f0f2245bacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74c58ce1915c6a25061153cd3b4bde8"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:af74c58ce1915c6a25061153cd3b4bde8"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#af74c58ce1915c6a25061153cd3b4bde8">gatherLoadUBySimdIntTranspose</a> (const double *base, std::int32_t offset, double *v0, double *v1)</td></tr>
<tr class="memdesc:af74c58ce1915c6a25061153cd3b4bde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 2 doubles from base/offsets and store into variables (unaligned).  <a href="#af74c58ce1915c6a25061153cd3b4bde8">More...</a><br/></td></tr>
<tr class="separator:af74c58ce1915c6a25061153cd3b4bde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb92443ba8da5d878c1dd85b2bcde8d"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:a6bb92443ba8da5d878c1dd85b2bcde8d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a6bb92443ba8da5d878c1dd85b2bcde8d">gatherLoadBySimdIntTranspose</a> (const double *base, std::int32_t offset, double *v0, double *v1)</td></tr>
<tr class="memdesc:a6bb92443ba8da5d878c1dd85b2bcde8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 2 doubles from base/offsets and store into variables (aligned).  <a href="#a6bb92443ba8da5d878c1dd85b2bcde8d">More...</a><br/></td></tr>
<tr class="separator:a6bb92443ba8da5d878c1dd85b2bcde8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd8c33571b1296598b509d30d254bac"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#afdd8c33571b1296598b509d30d254bac">reduceIncr4ReturnSum</a> (double *m, double v0, double v1, double v2, double v3)</td></tr>
<tr class="memdesc:afdd8c33571b1296598b509d30d254bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add each double to four consecutive memory locations, return sum.  <a href="#afdd8c33571b1296598b509d30d254bac">More...</a><br/></td></tr>
<tr class="separator:afdd8c33571b1296598b509d30d254bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08a29cc96a87845ddae4cafd8a4da89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ab08a29cc96a87845ddae4cafd8a4da89">decideWhetherToUseGpusForNonbondedWithThreadMpi</a> (const <a class="el" href="namespacegmx.xhtml#aacf83788a301a602c40e8a49fce9c5e8">TaskTarget</a> nonbondedTarget, const std::vector&lt; int &gt; &amp;gpuIdsToUse, const std::vector&lt; int &gt; &amp;userGpuTaskAssignment, const EmulateGpuNonbonded emulateGpuNonbonded, const bool usingVerletScheme, const bool nonbondedOnGpuIsUseful, const int numRanksPerSimulation)</td></tr>
<tr class="memdesc:ab08a29cc96a87845ddae4cafd8a4da89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide whether this thread-MPI simulation will run nonbonded tasks on GPUs.  <a href="#ab08a29cc96a87845ddae4cafd8a4da89">More...</a><br/></td></tr>
<tr class="separator:ab08a29cc96a87845ddae4cafd8a4da89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae895fab6248bb320ada21c2a65d0e6ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ae895fab6248bb320ada21c2a65d0e6ac">decideWhetherToUseGpusForPmeWithThreadMpi</a> (const bool useGpuForNonbonded, const <a class="el" href="namespacegmx.xhtml#aacf83788a301a602c40e8a49fce9c5e8">TaskTarget</a> pmeTarget, const std::vector&lt; int &gt; &amp;gpuIdsToUse, const std::vector&lt; int &gt; &amp;userGpuTaskAssignment, const bool canUseGpuForPme, const int numRanksPerSimulation, const int numPmeRanksPerSimulation)</td></tr>
<tr class="memdesc:ae895fab6248bb320ada21c2a65d0e6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide whether this thread-MPI simulation will run PME tasks on GPUs.  <a href="#ae895fab6248bb320ada21c2a65d0e6ac">More...</a><br/></td></tr>
<tr class="separator:ae895fab6248bb320ada21c2a65d0e6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138aa78ae5a68e19fe9ef231061dce44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a138aa78ae5a68e19fe9ef231061dce44">decideWhetherToUseGpusForNonbonded</a> (const <a class="el" href="namespacegmx.xhtml#aacf83788a301a602c40e8a49fce9c5e8">TaskTarget</a> nonbondedTarget, const std::vector&lt; int &gt; &amp;userGpuTaskAssignment, const EmulateGpuNonbonded emulateGpuNonbonded, const bool usingVerletScheme, const bool nonbondedOnGpuIsUseful, const bool gpusWereDetected)</td></tr>
<tr class="memdesc:a138aa78ae5a68e19fe9ef231061dce44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide whether the simulation will try to run nonbonded tasks on GPUs.  <a href="#a138aa78ae5a68e19fe9ef231061dce44">More...</a><br/></td></tr>
<tr class="separator:a138aa78ae5a68e19fe9ef231061dce44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d32a9f9c61cc84646acee0cec26e6d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a6d32a9f9c61cc84646acee0cec26e6d6">decideWhetherToUseGpusForPme</a> (const bool useGpuForNonbonded, const <a class="el" href="namespacegmx.xhtml#aacf83788a301a602c40e8a49fce9c5e8">TaskTarget</a> pmeTarget, const std::vector&lt; int &gt; &amp;userGpuTaskAssignment, const bool canUseGpuForPme, const int numRanksPerSimulation, const int numPmeRanksPerSimulation, const bool gpusWereDetected)</td></tr>
<tr class="memdesc:a6d32a9f9c61cc84646acee0cec26e6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide whether the simulation will try to run tasks of different types on GPUs.  <a href="#a6d32a9f9c61cc84646acee0cec26e6d6">More...</a><br/></td></tr>
<tr class="separator:a6d32a9f9c61cc84646acee0cec26e6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d9eaa14aa830a5c06ee01f5789a152"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegmx.xhtml#a01b141a05049b61c32b587e8d19e8947">GpuTasksOnRanks</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ad0d9eaa14aa830a5c06ee01f5789a152">findAllGpuTasksOnThisNode</a> (<a class="el" href="classgmx_1_1ArrayRef.xhtml">ArrayRef</a>&lt; const <a class="el" href="namespacegmx.xhtml#a6efc2e8f104eb3699bc82c2b8984cedb">GpuTask</a> &gt; gpuTasksOnThisRank, int numRanksOnThisNode, MPI_Comm communicator)</td></tr>
<tr class="memdesc:ad0d9eaa14aa830a5c06ee01f5789a152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns container of all tasks on all ranks of this node that are eligible for GPU execution.  <a href="#ad0d9eaa14aa830a5c06ee01f5789a152">More...</a><br/></td></tr>
<tr class="separator:ad0d9eaa14aa830a5c06ee01f5789a152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7149c73e79faf42117ef7006229094"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a9e7149c73e79faf42117ef7006229094">reportGpuUsage</a> (const MDLogger &amp;mdlog, bool userSetGpuIds, const <a class="el" href="namespacegmx.xhtml#a40a41b5592e3e9de8d1c1cba2901a7ef">GpuTaskAssignments</a> &amp;gpuTaskAssignmentOnRanksOfThisNode, size_t numGpuTasksOnThisNode, size_t numPpRanks, bool bPrintHostName)</td></tr>
<tr class="memdesc:a9e7149c73e79faf42117ef7006229094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log a report on how GPUs are being used on the ranks of the physical node of rank 0 of the simulation.  <a href="#a9e7149c73e79faf42117ef7006229094">More...</a><br/></td></tr>
<tr class="separator:a9e7149c73e79faf42117ef7006229094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218bc5f1c3fae33c282582464914ca59"><td class="memItemLeft" align="right" valign="top">GpuTaskAssignments::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a218bc5f1c3fae33c282582464914ca59">runTaskAssignment</a> (const std::vector&lt; int &gt; &amp;gpuIdsToUse, const std::vector&lt; int &gt; &amp;userGpuTaskAssignment, const gmx_hw_info_t &amp;hardwareInfo, const MDLogger &amp;mdlog, const t_commrec *cr, const std::vector&lt; <a class="el" href="namespacegmx.xhtml#a6efc2e8f104eb3699bc82c2b8984cedb">GpuTask</a> &gt; &amp;gpuTasksOnThisRank)</td></tr>
<tr class="memdesc:a218bc5f1c3fae33c282582464914ca59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coordinate the final stages of task assignment and reporting, and return the assignment for this rank.  <a href="#a218bc5f1c3fae33c282582464914ca59">More...</a><br/></td></tr>
<tr class="separator:a218bc5f1c3fae33c282582464914ca59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec51273be789bb73e2e926ccf7e37a2"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeec51273be789bb73e2e926ccf7e37a2"></a>
template&lt;GpuTask TaskType&gt; </td></tr>
<tr class="memitem:aeec51273be789bb73e2e926ccf7e37a2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aeec51273be789bb73e2e926ccf7e37a2">hasTaskType</a> (const GpuTaskMapping &amp;mapping)</td></tr>
<tr class="memdesc:aeec51273be789bb73e2e926ccf7e37a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for whether the task of <code>mapping</code> has value <code>TaskType</code>. <br/></td></tr>
<tr class="separator:aeec51273be789bb73e2e926ccf7e37a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0488b32fffa77eb0a4b7644546037b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aeb0488b32fffa77eb0a4b7644546037b">parseUserGpuIds</a> (const std::string &amp;gpuIdString)</td></tr>
<tr class="memdesc:aeb0488b32fffa77eb0a4b7644546037b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a GPU ID string into a container describing the task types and associated device IDs.  <a href="#aeb0488b32fffa77eb0a4b7644546037b">More...</a><br/></td></tr>
<tr class="separator:aeb0488b32fffa77eb0a4b7644546037b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693d74a839c577c612b44493481a34d2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a693d74a839c577c612b44493481a34d2">makeGpuIds</a> (<a class="el" href="classgmx_1_1ArrayRef.xhtml">ArrayRef</a>&lt; const int &gt; compatibleGpus, size_t numGpuTasks)</td></tr>
<tr class="memdesc:a693d74a839c577c612b44493481a34d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a vector containing <code>numGpuTasks</code> IDs of the IDs found in <code>compatibleGpus</code>.  <a href="#a693d74a839c577c612b44493481a34d2">More...</a><br/></td></tr>
<tr class="separator:a693d74a839c577c612b44493481a34d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28940788cd491e2248aa6345eb2ad94c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a28940788cd491e2248aa6345eb2ad94c">makeGpuIdString</a> (const std::vector&lt; int &gt; &amp;gpuIds, int totalNumberOfTasks)</td></tr>
<tr class="memdesc:a28940788cd491e2248aa6345eb2ad94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a container of GPU deviced IDs to a string that can be used by gmx tune_pme as input to mdrun -gputasks.  <a href="#a28940788cd491e2248aa6345eb2ad94c">More...</a><br/></td></tr>
<tr class="separator:a28940788cd491e2248aa6345eb2ad94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a614356b557457126513747fbb559f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a36a614356b557457126513747fbb559f">checkUserGpuIds</a> (const gmx_gpu_info_t &amp;gpu_info, const std::vector&lt; int &gt; &amp;compatibleGpus, const std::vector&lt; int &gt; &amp;gpuIds)</td></tr>
<tr class="memdesc:a36a614356b557457126513747fbb559f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that all user-selected GPUs are compatible.  <a href="#a36a614356b557457126513747fbb559f">More...</a><br/></td></tr>
<tr class="separator:a36a614356b557457126513747fbb559f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ac652392d2a98ce5a3b3a3ca809206"><td class="memItemLeft" align="right" valign="top">static std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a14ac652392d2a98ce5a3b3a3ca809206">getPageSize</a> ()</td></tr>
<tr class="memdesc:a14ac652392d2a98ce5a3b3a3ca809206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a page size, from a sysconf/WinAPI query if available, or a default guess (4096 bytes).  <a href="#a14ac652392d2a98ce5a3b3a3ca809206">More...</a><br/></td></tr>
<tr class="separator:a14ac652392d2a98ce5a3b3a3ca809206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f63c30185ee31c10a30e46b7d53f9d"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a41f63c30185ee31c10a30e46b7d53f9d">pageSize</a> ()</td></tr>
<tr class="memdesc:a41f63c30185ee31c10a30e46b7d53f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the memory page size on this system.  <a href="#a41f63c30185ee31c10a30e46b7d53f9d">More...</a><br/></td></tr>
<tr class="separator:a41f63c30185ee31c10a30e46b7d53f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2126967a7118ceb84d92fe263368f71"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab2126967a7118ceb84d92fe263368f71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgmx_1_1ArrayRef.xhtml">ArrayRef</a>&lt; typename <br class="typebreak"/>
std::conditional<br class="typebreak"/>
&lt; std::is_const&lt; T &gt;::value, <br class="typebreak"/>
const typename T::value_type, <br class="typebreak"/>
typename T::value_type &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ab2126967a7118ceb84d92fe263368f71">makeArrayRef</a> (T &amp;c)</td></tr>
<tr class="memdesc:ab2126967a7118ceb84d92fe263368f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classgmx_1_1ArrayRef.xhtml" title="STL-like container for an interface to a C array of T (or part of a std::vector&lt;T, A&gt; or std::array&lt;T&gt;). ">ArrayRef</a> from container with type deduction.  <a href="#ab2126967a7118ceb84d92fe263368f71">More...</a><br/></td></tr>
<tr class="separator:ab2126967a7118ceb84d92fe263368f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713215f4358a42b3b59689419203cfcf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a713215f4358a42b3b59689419203cfcf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgmx_1_1ArrayRef.xhtml">ArrayRef</a>&lt; const typename <br class="typebreak"/>
T::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a713215f4358a42b3b59689419203cfcf">makeConstArrayRef</a> (const T &amp;c)</td></tr>
<tr class="memdesc:a713215f4358a42b3b59689419203cfcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classgmx_1_1ArrayRef.xhtml" title="STL-like container for an interface to a C array of T (or part of a std::vector&lt;T, A&gt; or std::array&lt;T&gt;). ">ArrayRef</a> to const T from container with type deduction.  <a href="#a713215f4358a42b3b59689419203cfcf">More...</a><br/></td></tr>
<tr class="separator:a713215f4358a42b3b59689419203cfcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f21654b9945d04d277523f6c8ab1d11"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6f21654b9945d04d277523f6c8ab1d11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga6f21654b9945d04d277523f6c8ab1d11">swap</a> (<a class="el" href="classgmx_1_1ArrayRef.xhtml">ArrayRef</a>&lt; T &gt; &amp;a, <a class="el" href="classgmx_1_1ArrayRef.xhtml">ArrayRef</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:ga6f21654b9945d04d277523f6c8ab1d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple swap method for <a class="el" href="classgmx_1_1ArrayRef.xhtml" title="STL-like container for an interface to a C array of T (or part of a std::vector&lt;T, A&gt; or std::array&lt;T&gt;). ">ArrayRef</a> objects.  <a href="group__module__utility.xhtml#ga6f21654b9945d04d277523f6c8ab1d11">More...</a><br/></td></tr>
<tr class="separator:ga6f21654b9945d04d277523f6c8ab1d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff67fcd64bdaa64a3823cc1a322a6783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aff67fcd64bdaa64a3823cc1a322a6783">printBinaryInformation</a> (FILE *fp, const <a class="el" href="classgmx_1_1IProgramContext.xhtml">IProgramContext</a> &amp;programContext)</td></tr>
<tr class="memdesc:aff67fcd64bdaa64a3823cc1a322a6783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print basic information about the executable.  <a href="#aff67fcd64bdaa64a3823cc1a322a6783">More...</a><br/></td></tr>
<tr class="separator:aff67fcd64bdaa64a3823cc1a322a6783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c6bc3dc4ee812f31a6076c7d4f42a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ad0c6bc3dc4ee812f31a6076c7d4f42a9">printBinaryInformation</a> (FILE *fp, const <a class="el" href="classgmx_1_1IProgramContext.xhtml">IProgramContext</a> &amp;programContext, const BinaryInformationSettings &amp;settings)</td></tr>
<tr class="memdesc:ad0c6bc3dc4ee812f31a6076c7d4f42a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print basic information about the executable with custom settings.  <a href="#ad0c6bc3dc4ee812f31a6076c7d4f42a9">More...</a><br/></td></tr>
<tr class="separator:ad0c6bc3dc4ee812f31a6076c7d4f42a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea11527285a0547aafa0ee27c4f4817"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a0ea11527285a0547aafa0ee27c4f4817">printBinaryInformation</a> (TextWriter *writer, const <a class="el" href="classgmx_1_1IProgramContext.xhtml">IProgramContext</a> &amp;programContext, const BinaryInformationSettings &amp;settings)</td></tr>
<tr class="memdesc:a0ea11527285a0547aafa0ee27c4f4817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print basic information about the executable with custom settings.  <a href="#a0ea11527285a0547aafa0ee27c4f4817">More...</a><br/></td></tr>
<tr class="separator:a0ea11527285a0547aafa0ee27c4f4817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0211f291fe376a0bcf8f12e382620495"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0211f291fe376a0bcf8f12e382620495"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a0211f291fe376a0bcf8f12e382620495">bromacs</a> ()</td></tr>
<tr class="memdesc:a0211f291fe376a0bcf8f12e382620495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a cool definition for the acronym GROMACS. <br/></td></tr>
<tr class="separator:a0211f291fe376a0bcf8f12e382620495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a579db3d112ccecde57a054f288216c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a579db3d112ccecde57a054f288216c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a7a579db3d112ccecde57a054f288216c">getCoolQuote</a> ()</td></tr>
<tr class="memdesc:a7a579db3d112ccecde57a054f288216c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string with a cool quote. <br/></td></tr>
<tr class="separator:a7a579db3d112ccecde57a054f288216c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7641cbe8fc0aee6b7253d1e1a543aae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7641cbe8fc0aee6b7253d1e1a543aae"></a>
std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa7641cbe8fc0aee6b7253d1e1a543aae">getCudaDriverVersion</a> ()</td></tr>
<tr class="memdesc:aa7641cbe8fc0aee6b7253d1e1a543aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a (major, minor) tuple of the CUDA driver version. <br/></td></tr>
<tr class="separator:aa7641cbe8fc0aee6b7253d1e1a543aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2d657a3d4d0726a96c6226043c567d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a2d657a3d4d0726a96c6226043c567d"></a>
std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a9a2d657a3d4d0726a96c6226043c567d">getCudaRuntimeVersion</a> ()</td></tr>
<tr class="memdesc:a9a2d657a3d4d0726a96c6226043c567d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a (major, minor) tuple of the CUDA runtime version. <br/></td></tr>
<tr class="separator:a9a2d657a3d4d0726a96c6226043c567d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac30db5a87fa0f55776bc8a3dcef0d67"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gaac30db5a87fa0f55776bc8a3dcef0d67">getErrorCodeString</a> (int errorcode)</td></tr>
<tr class="memdesc:gaac30db5a87fa0f55776bc8a3dcef0d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short string description of an error code.  <a href="group__module__utility.xhtml#gaac30db5a87fa0f55776bc8a3dcef0d67">More...</a><br/></td></tr>
<tr class="separator:gaac30db5a87fa0f55776bc8a3dcef0d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6287dc8a550a2d54429e44994e00e58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gac6287dc8a550a2d54429e44994e00e58">printFatalErrorMessage</a> (FILE *fp, const std::exception &amp;ex)</td></tr>
<tr class="memdesc:gac6287dc8a550a2d54429e44994e00e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a standard fatal error message for reporting an exception.  <a href="group__module__utility.xhtml#gac6287dc8a550a2d54429e44994e00e58">More...</a><br/></td></tr>
<tr class="separator:gac6287dc8a550a2d54429e44994e00e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7703ad35b606758d2d12edc0a3d5217"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gac7703ad35b606758d2d12edc0a3d5217">formatExceptionMessageToString</a> (const std::exception &amp;ex)</td></tr>
<tr class="memdesc:gac7703ad35b606758d2d12edc0a3d5217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats an error message for reporting an exception.  <a href="group__module__utility.xhtml#gac7703ad35b606758d2d12edc0a3d5217">More...</a><br/></td></tr>
<tr class="separator:gac7703ad35b606758d2d12edc0a3d5217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5e6f6ec944fb2484d6f273c9a0ff495"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gac5e6f6ec944fb2484d6f273c9a0ff495">formatExceptionMessageToFile</a> (FILE *fp, const std::exception &amp;ex)</td></tr>
<tr class="memdesc:gac5e6f6ec944fb2484d6f273c9a0ff495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats an error message for reporting an exception.  <a href="group__module__utility.xhtml#gac5e6f6ec944fb2484d6f273c9a0ff495">More...</a><br/></td></tr>
<tr class="separator:gac5e6f6ec944fb2484d6f273c9a0ff495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacf6bfb81220e44ed1bf73f0a44d9926"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gaacf6bfb81220e44ed1bf73f0a44d9926">formatExceptionMessageToWriter</a> (TextWriter *writer, const std::exception &amp;ex)</td></tr>
<tr class="memdesc:gaacf6bfb81220e44ed1bf73f0a44d9926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats an error message for reporting an exception.  <a href="group__module__utility.xhtml#gaacf6bfb81220e44ed1bf73f0a44d9926">More...</a><br/></td></tr>
<tr class="separator:gaacf6bfb81220e44ed1bf73f0a44d9926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a45f49e157fa8e1059d24243283e248"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga5a45f49e157fa8e1059d24243283e248">processExceptionAtExit</a> (const std::exception &amp;ex)</td></tr>
<tr class="memdesc:ga5a45f49e157fa8e1059d24243283e248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles an exception that is causing the program to terminate.  <a href="group__module__utility.xhtml#ga5a45f49e157fa8e1059d24243283e248">More...</a><br/></td></tr>
<tr class="separator:ga5a45f49e157fa8e1059d24243283e248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13076c5bb17dd3bf90f683af835b8b62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga13076c5bb17dd3bf90f683af835b8b62">processExceptionAsFatalError</a> (const std::exception &amp;ex)</td></tr>
<tr class="memdesc:ga13076c5bb17dd3bf90f683af835b8b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for terminating the program on an exception.  <a href="group__module__utility.xhtml#ga13076c5bb17dd3bf90f683af835b8b62">More...</a><br/></td></tr>
<tr class="separator:ga13076c5bb17dd3bf90f683af835b8b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b9a1e3988a89d1b90944c6ff6c3e794"><td class="memTemplParams" colspan="2">template&lt;class Exception , class Tag , class T &gt; </td></tr>
<tr class="memitem:ga1b9a1e3988a89d1b90944c6ff6c3e794"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; std::is_base_of<br class="typebreak"/>
&lt; <a class="el" href="classgmx_1_1GromacsException.xhtml">GromacsException</a>, Exception &gt;<br class="typebreak"/>
::value, const Exception &amp; &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga1b9a1e3988a89d1b90944c6ff6c3e794">operator&lt;&lt;</a> (const Exception &amp;ex, const <a class="el" href="classgmx_1_1ExceptionInfo.xhtml">ExceptionInfo</a>&lt; Tag, T &gt; &amp;item)</td></tr>
<tr class="memdesc:ga1b9a1e3988a89d1b90944c6ff6c3e794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates extra information with an exception.  <a href="group__module__utility.xhtml#ga1b9a1e3988a89d1b90944c6ff6c3e794">More...</a><br/></td></tr>
<tr class="separator:ga1b9a1e3988a89d1b90944c6ff6c3e794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga312499e4abb409ad85844d83e52d795b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classgmx_1_1DataFileFinder.xhtml">DataFileFinder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga312499e4abb409ad85844d83e52d795b">getLibraryFileFinder</a> ()</td></tr>
<tr class="memdesc:ga312499e4abb409ad85844d83e52d795b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a finder for locating data files from share/top/.  <a href="group__module__utility.xhtml#ga312499e4abb409ad85844d83e52d795b">More...</a><br/></td></tr>
<tr class="separator:ga312499e4abb409ad85844d83e52d795b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106cb113fd73e054dbb8dfa2118d7153"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a106cb113fd73e054dbb8dfa2118d7153">setLibraryFileFinder</a> (const <a class="el" href="classgmx_1_1DataFileFinder.xhtml">DataFileFinder</a> *finder)</td></tr>
<tr class="memdesc:a106cb113fd73e054dbb8dfa2118d7153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a finder for location data files from share/top/.  <a href="#a106cb113fd73e054dbb8dfa2118d7153">More...</a><br/></td></tr>
<tr class="separator:a106cb113fd73e054dbb8dfa2118d7153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae00d174a8ddd5325460d74dc663711c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gae00d174a8ddd5325460d74dc663711c0">init</a> (int *argc, char ***argv)</td></tr>
<tr class="memdesc:gae00d174a8ddd5325460d74dc663711c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the GROMACS library.  <a href="group__module__utility.xhtml#gae00d174a8ddd5325460d74dc663711c0">More...</a><br/></td></tr>
<tr class="separator:gae00d174a8ddd5325460d74dc663711c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0a90b2770cb4b69e16229daa271a1af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gaa0a90b2770cb4b69e16229daa271a1af">finalize</a> ()</td></tr>
<tr class="memdesc:gaa0a90b2770cb4b69e16229daa271a1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitializes the GROMACS library.  <a href="group__module__utility.xhtml#gaa0a90b2770cb4b69e16229daa271a1af">More...</a><br/></td></tr>
<tr class="separator:gaa0a90b2770cb4b69e16229daa271a1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ffeb99198d2e37e902971b17a673a47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a7ffeb99198d2e37e902971b17a673a47">niceHeader</a> (TextWriter *writer, const char *fn, char commentChar)</td></tr>
<tr class="memdesc:a7ffeb99198d2e37e902971b17a673a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints creation time stamp and user information into a string as comments, and returns it.  <a href="#a7ffeb99198d2e37e902971b17a673a47">More...</a><br/></td></tr>
<tr class="separator:a7ffeb99198d2e37e902971b17a673a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ac09bdfd662fa49b0426432744f57be"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classgmx_1_1IProgramContext.xhtml">IProgramContext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga5ac09bdfd662fa49b0426432744f57be">getProgramContext</a> ()</td></tr>
<tr class="memdesc:ga5ac09bdfd662fa49b0426432744f57be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the global <a class="el" href="classgmx_1_1IProgramContext.xhtml" title="Provides context information about the program that is calling the library. ">IProgramContext</a> instance.  <a href="group__module__utility.xhtml#ga5ac09bdfd662fa49b0426432744f57be">More...</a><br/></td></tr>
<tr class="separator:ga5ac09bdfd662fa49b0426432744f57be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cf34635c815cc712b6291c2c8da2555"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga2cf34635c815cc712b6291c2c8da2555">setProgramContext</a> (const <a class="el" href="classgmx_1_1IProgramContext.xhtml">IProgramContext</a> *context)</td></tr>
<tr class="memdesc:ga2cf34635c815cc712b6291c2c8da2555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the global <a class="el" href="classgmx_1_1IProgramContext.xhtml" title="Provides context information about the program that is calling the library. ">IProgramContext</a> instance.  <a href="group__module__utility.xhtml#ga2cf34635c815cc712b6291c2c8da2555">More...</a><br/></td></tr>
<tr class="separator:ga2cf34635c815cc712b6291c2c8da2555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea61e0b5bfc1f24f51a9eb5272b51603"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gaea61e0b5bfc1f24f51a9eb5272b51603">countWords</a> (const char *s)</td></tr>
<tr class="memdesc:gaea61e0b5bfc1f24f51a9eb5272b51603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of space-separated words in zero-terminated char ptr.  <a href="group__module__utility.xhtml#gaea61e0b5bfc1f24f51a9eb5272b51603">More...</a><br/></td></tr>
<tr class="separator:gaea61e0b5bfc1f24f51a9eb5272b51603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae837a92609acdf559a6b8587e9233008"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gae837a92609acdf559a6b8587e9233008">countWords</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gae837a92609acdf559a6b8587e9233008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of space-separated words in a string object.  <a href="group__module__utility.xhtml#gae837a92609acdf559a6b8587e9233008">More...</a><br/></td></tr>
<tr class="separator:gae837a92609acdf559a6b8587e9233008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b22d1fd014cc09c9cf7c4c1615c0a1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga8b22d1fd014cc09c9cf7c4c1615c0a1b">endsWith</a> (const char *str, const char *suffix)</td></tr>
<tr class="memdesc:ga8b22d1fd014cc09c9cf7c4c1615c0a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a string ends with another string.  <a href="group__module__utility.xhtml#ga8b22d1fd014cc09c9cf7c4c1615c0a1b">More...</a><br/></td></tr>
<tr class="separator:ga8b22d1fd014cc09c9cf7c4c1615c0a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea84ff4850c382e09a3e158939b34b3e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gaea84ff4850c382e09a3e158939b34b3e">stripSuffixIfPresent</a> (const std::string &amp;str, const char *suffix)</td></tr>
<tr class="memdesc:gaea84ff4850c382e09a3e158939b34b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a suffix from a string.  <a href="group__module__utility.xhtml#gaea84ff4850c382e09a3e158939b34b3e">More...</a><br/></td></tr>
<tr class="separator:gaea84ff4850c382e09a3e158939b34b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f31464a19604fde038dba36307ac066"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga5f31464a19604fde038dba36307ac066">stripString</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga5f31464a19604fde038dba36307ac066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes leading and trailing whitespace from a string.  <a href="group__module__utility.xhtml#ga5f31464a19604fde038dba36307ac066">More...</a><br/></td></tr>
<tr class="separator:ga5f31464a19604fde038dba36307ac066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed06df18ca6f9fc3f42bad9ea4d7e025"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gaed06df18ca6f9fc3f42bad9ea4d7e025">formatString</a> (const char *fmt,...)</td></tr>
<tr class="memdesc:gaed06df18ca6f9fc3f42bad9ea4d7e025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a string (snprintf() wrapper).  <a href="group__module__utility.xhtml#gaed06df18ca6f9fc3f42bad9ea4d7e025">More...</a><br/></td></tr>
<tr class="separator:gaed06df18ca6f9fc3f42bad9ea4d7e025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1034db9546754cdf0a21ef6c131c0747"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga1034db9546754cdf0a21ef6c131c0747">formatStringV</a> (const char *fmt, va_list ap)</td></tr>
<tr class="memdesc:ga1034db9546754cdf0a21ef6c131c0747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a string (vsnprintf() wrapper).  <a href="group__module__utility.xhtml#ga1034db9546754cdf0a21ef6c131c0747">More...</a><br/></td></tr>
<tr class="separator:ga1034db9546754cdf0a21ef6c131c0747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga720e46b4a7625c675507adbea1df3f96"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga720e46b4a7625c675507adbea1df3f96">splitString</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga720e46b4a7625c675507adbea1df3f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a string to whitespace separated tokens.  <a href="group__module__utility.xhtml#ga720e46b4a7625c675507adbea1df3f96">More...</a><br/></td></tr>
<tr class="separator:ga720e46b4a7625c675507adbea1df3f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cb3d438ea0c5c205ce8aa5430e89d4b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga5cb3d438ea0c5c205ce8aa5430e89d4b">splitDelimitedString</a> (const std::string &amp;str, char delim)</td></tr>
<tr class="memdesc:ga5cb3d438ea0c5c205ce8aa5430e89d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a string to tokens separated by a given delimiter.  <a href="group__module__utility.xhtml#ga5cb3d438ea0c5c205ce8aa5430e89d4b">More...</a><br/></td></tr>
<tr class="separator:ga5cb3d438ea0c5c205ce8aa5430e89d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff5615f507445a241a90970d4ad3705c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gaff5615f507445a241a90970d4ad3705c">splitAndTrimDelimitedString</a> (const std::string &amp;str, char delim)</td></tr>
<tr class="memdesc:gaff5615f507445a241a90970d4ad3705c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits <code>str</code> to tokens separated by delimiter <code>delim</code>. Removes leading and trailing whitespace from those strings with std::isspace.  <a href="group__module__utility.xhtml#gaff5615f507445a241a90970d4ad3705c">More...</a><br/></td></tr>
<tr class="separator:gaff5615f507445a241a90970d4ad3705c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e4d61dba5d6fb924b8888e5597d2d0f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga1e4d61dba5d6fb924b8888e5597d2d0f">replaceAll</a> (const std::string &amp;input, const char *from, const char *to)</td></tr>
<tr class="memdesc:ga1e4d61dba5d6fb924b8888e5597d2d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of a string with another string.  <a href="group__module__utility.xhtml#ga1e4d61dba5d6fb924b8888e5597d2d0f">More...</a><br/></td></tr>
<tr class="separator:ga1e4d61dba5d6fb924b8888e5597d2d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba6fb72c71891e47fc68c36167bee72e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gaba6fb72c71891e47fc68c36167bee72e">replaceAll</a> (const std::string &amp;input, const std::string &amp;from, const std::string &amp;to)</td></tr>
<tr class="memdesc:gaba6fb72c71891e47fc68c36167bee72e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of a string with another string.  <a href="group__module__utility.xhtml#gaba6fb72c71891e47fc68c36167bee72e">More...</a><br/></td></tr>
<tr class="separator:gaba6fb72c71891e47fc68c36167bee72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacdb65ab5673b946ea9764f708a4afcc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gaacdb65ab5673b946ea9764f708a4afcc">replaceAllWords</a> (const std::string &amp;input, const char *from, const char *to)</td></tr>
<tr class="memdesc:gaacdb65ab5673b946ea9764f708a4afcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace whole words with others.  <a href="group__module__utility.xhtml#gaacdb65ab5673b946ea9764f708a4afcc">More...</a><br/></td></tr>
<tr class="separator:gaacdb65ab5673b946ea9764f708a4afcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2df338df2e0b32b8c1fd032452409d57"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga2df338df2e0b32b8c1fd032452409d57">replaceAllWords</a> (const std::string &amp;input, const std::string &amp;from, const std::string &amp;to)</td></tr>
<tr class="memdesc:ga2df338df2e0b32b8c1fd032452409d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace whole words with others.  <a href="group__module__utility.xhtml#ga2df338df2e0b32b8c1fd032452409d57">More...</a><br/></td></tr>
<tr class="separator:ga2df338df2e0b32b8c1fd032452409d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f35bd1d4a654edabc2a3aaf6f6bccea"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga2f35bd1d4a654edabc2a3aaf6f6bccea">isNullOrEmpty</a> (const char *str)</td></tr>
<tr class="memdesc:ga2f35bd1d4a654edabc2a3aaf6f6bccea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a string is null or empty.  <a href="group__module__utility.xhtml#ga2f35bd1d4a654edabc2a3aaf6f6bccea">More...</a><br/></td></tr>
<tr class="separator:ga2f35bd1d4a654edabc2a3aaf6f6bccea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8adb72aeb7775a649d7378c8e51321e6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga8adb72aeb7775a649d7378c8e51321e6">startsWith</a> (const std::string &amp;str, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:ga8adb72aeb7775a649d7378c8e51321e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a string starts with another string.  <a href="group__module__utility.xhtml#ga8adb72aeb7775a649d7378c8e51321e6">More...</a><br/></td></tr>
<tr class="separator:ga8adb72aeb7775a649d7378c8e51321e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87824e9b26adc46671ccffa89f3985d0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga87824e9b26adc46671ccffa89f3985d0">startsWith</a> (const char *str, const char *prefix)</td></tr>
<tr class="memdesc:ga87824e9b26adc46671ccffa89f3985d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a string starts with another string.  <a href="group__module__utility.xhtml#ga87824e9b26adc46671ccffa89f3985d0">More...</a><br/></td></tr>
<tr class="separator:ga87824e9b26adc46671ccffa89f3985d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1e33d963e2538664428c8db95ca564e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gaa1e33d963e2538664428c8db95ca564e">endsWith</a> (const std::string &amp;str, const char *suffix)</td></tr>
<tr class="memdesc:gaa1e33d963e2538664428c8db95ca564e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a string ends with another string.  <a href="group__module__utility.xhtml#gaa1e33d963e2538664428c8db95ca564e">More...</a><br/></td></tr>
<tr class="separator:gaa1e33d963e2538664428c8db95ca564e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d6c1daa93bf46a2c397d179e007e3e8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga5d6c1daa93bf46a2c397d179e007e3e8">contains</a> (const std::string &amp;str, const char *substr)</td></tr>
<tr class="memdesc:ga5d6c1daa93bf46a2c397d179e007e3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a string contains another as a substring.  <a href="group__module__utility.xhtml#ga5d6c1daa93bf46a2c397d179e007e3e8">More...</a><br/></td></tr>
<tr class="separator:ga5d6c1daa93bf46a2c397d179e007e3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0bef974d105fbfcc7e5362111eafed5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gac0bef974d105fbfcc7e5362111eafed5">contains</a> (const std::string &amp;str, const std::string &amp;substr)</td></tr>
<tr class="memdesc:gac0bef974d105fbfcc7e5362111eafed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a string contains another as a substring.  <a href="group__module__utility.xhtml#gac0bef974d105fbfcc7e5362111eafed5">More...</a><br/></td></tr>
<tr class="separator:gac0bef974d105fbfcc7e5362111eafed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga555d78d19565dec63c740318187b4d0d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga555d78d19565dec63c740318187b4d0d">endsWith</a> (const std::string &amp;str, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:ga555d78d19565dec63c740318187b4d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a string ends with another string.  <a href="group__module__utility.xhtml#ga555d78d19565dec63c740318187b4d0d">More...</a><br/></td></tr>
<tr class="separator:ga555d78d19565dec63c740318187b4d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa21c247b747e12412da58cb9f6d500ef"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename FormatterType &gt; </td></tr>
<tr class="memitem:gaa21c247b747e12412da58cb9f6d500ef"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gaa21c247b747e12412da58cb9f6d500ef">formatAndJoin</a> (InputIterator begin, InputIterator end, const char *separator, const FormatterType &amp;formatter)</td></tr>
<tr class="memdesc:gaa21c247b747e12412da58cb9f6d500ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats all the range as strings, and then joins them with a separator in between.  <a href="group__module__utility.xhtml#gaa21c247b747e12412da58cb9f6d500ef">More...</a><br/></td></tr>
<tr class="separator:gaa21c247b747e12412da58cb9f6d500ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e151e320e4072b2cc254b653077bb68"><td class="memTemplParams" colspan="2">template&lt;typename ContainerType , typename FormatterType &gt; </td></tr>
<tr class="memitem:ga8e151e320e4072b2cc254b653077bb68"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga8e151e320e4072b2cc254b653077bb68">formatAndJoin</a> (const ContainerType &amp;container, const char *separator, const FormatterType &amp;formatter)</td></tr>
<tr class="memdesc:ga8e151e320e4072b2cc254b653077bb68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats all elements of the container as strings, and then joins them with a separator in between.  <a href="group__module__utility.xhtml#ga8e151e320e4072b2cc254b653077bb68">More...</a><br/></td></tr>
<tr class="separator:ga8e151e320e4072b2cc254b653077bb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0ae45171d0f46a06095bf86855a8b28"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:gae0ae45171d0f46a06095bf86855a8b28"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#gae0ae45171d0f46a06095bf86855a8b28">joinStrings</a> (InputIterator begin, InputIterator end, const char *separator)</td></tr>
<tr class="memdesc:gae0ae45171d0f46a06095bf86855a8b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins strings from a range with a separator in between.  <a href="group__module__utility.xhtml#gae0ae45171d0f46a06095bf86855a8b28">More...</a><br/></td></tr>
<tr class="separator:gae0ae45171d0f46a06095bf86855a8b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dec76a57e8089a89f9298fb2fbaf2ed"><td class="memTemplParams" colspan="2">template&lt;typename ContainerType &gt; </td></tr>
<tr class="memitem:ga7dec76a57e8089a89f9298fb2fbaf2ed"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga7dec76a57e8089a89f9298fb2fbaf2ed">joinStrings</a> (const ContainerType &amp;container, const char *separator)</td></tr>
<tr class="memdesc:ga7dec76a57e8089a89f9298fb2fbaf2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins strings from a container with a separator in between.  <a href="group__module__utility.xhtml#ga7dec76a57e8089a89f9298fb2fbaf2ed">More...</a><br/></td></tr>
<tr class="separator:ga7dec76a57e8089a89f9298fb2fbaf2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31335553bd6174a68ad8d30c48de3df5"><td class="memTemplParams" colspan="2">template&lt;size_t count&gt; </td></tr>
<tr class="memitem:ga31335553bd6174a68ad8d30c48de3df5"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__utility.xhtml#ga31335553bd6174a68ad8d30c48de3df5">joinStrings</a> (const char *const (&amp;array)[count], const char *separator)</td></tr>
<tr class="memdesc:ga31335553bd6174a68ad8d30c48de3df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins strings from an array with a separator in between.  <a href="group__module__utility.xhtml#ga31335553bd6174a68ad8d30c48de3df5">More...</a><br/></td></tr>
<tr class="separator:ga31335553bd6174a68ad8d30c48de3df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3650e68b5247515adc7f919894173c34"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3650e68b5247515adc7f919894173c34"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3650e68b5247515adc7f919894173c34"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a3650e68b5247515adc7f919894173c34">free_wrapper</a> (T *p)</td></tr>
<tr class="memdesc:a3650e68b5247515adc7f919894173c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper of standard library free(), to be used as unique_cptr deleter for memory allocated by malloc, e.g. by an external library such as TNG. <br/></td></tr>
<tr class="separator:a3650e68b5247515adc7f919894173c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa097a11e79b9b187cadef998470f4e54"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa097a11e79b9b187cadef998470f4e54"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa097a11e79b9b187cadef998470f4e54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa097a11e79b9b187cadef998470f4e54">sfree_wrapper</a> (T *p)</td></tr>
<tr class="memdesc:aa097a11e79b9b187cadef998470f4e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">sfree wrapper to be used as unique_cptr deleter <br/></td></tr>
<tr class="separator:aa097a11e79b9b187cadef998470f4e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86fd9b984e1b8e95e08abd6cbe1a6ac"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab86fd9b984e1b8e95e08abd6cbe1a6ac"></a>
template&lt;typename T , typename D &gt; </td></tr>
<tr class="memitem:ab86fd9b984e1b8e95e08abd6cbe1a6ac"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ab86fd9b984e1b8e95e08abd6cbe1a6ac">create_unique_with_deleter</a> (T *t, D d)</td></tr>
<tr class="memdesc:ab86fd9b984e1b8e95e08abd6cbe1a6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create unique_ptr with any deleter function or lambda. <br/></td></tr>
<tr class="separator:ab86fd9b984e1b8e95e08abd6cbe1a6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae43945530feb98492481e64f0bc5256"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aae43945530feb98492481e64f0bc5256">mdrunner_start_fn</a> (void *arg)</td></tr>
<tr class="memdesc:aae43945530feb98492481e64f0bc5256"><td class="mdescLeft">&#160;</td><td class="mdescRight">The callback used for running on spawned threads.  <a href="#aae43945530feb98492481e64f0bc5256">More...</a><br/></td></tr>
<tr class="separator:aae43945530feb98492481e64f0bc5256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33884289d98877477b9fd970da3101b8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a33884289d98877477b9fd970da3101b8">gpuAccelerationOfNonbondedIsUseful</a> (const MDLogger &amp;mdlog, const t_inputrec *ir, bool issueWarning)</td></tr>
<tr class="memdesc:a33884289d98877477b9fd970da3101b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether GPU acceleration of nonbondeds is supported with the given settings.  <a href="#a33884289d98877477b9fd970da3101b8">More...</a><br/></td></tr>
<tr class="separator:a33884289d98877477b9fd970da3101b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ab84fc76c89c13dcc7bd753a720d90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79ab84fc76c89c13dcc7bd753a720d90"></a>
static <a class="el" href="namespacegmx.xhtml#a24c220170a68ad4867d5cb6b89bdec4b">integrator_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a79ab84fc76c89c13dcc7bd753a720d90">my_integrator</a> (unsigned int ei)</td></tr>
<tr class="memdesc:a79ab84fc76c89c13dcc7bd753a720d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correct integrator function. <br/></td></tr>
<tr class="separator:a79ab84fc76c89c13dcc7bd753a720d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a229da675e966d5b2f67e5ef3a490ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a229da675e966d5b2f67e5ef3a490ad"></a>
static gmx::LoggerOwner&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a2a229da675e966d5b2f67e5ef3a490ad">buildLogger</a> (FILE *fplog, const t_commrec *cr)</td></tr>
<tr class="memdesc:a2a229da675e966d5b2f67e5ef3a490ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the logger for mdrun. <br/></td></tr>
<tr class="separator:a2a229da675e966d5b2f67e5ef3a490ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20deb1b7598a29356dc21eaee062425"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac20deb1b7598a29356dc21eaee062425"></a>
static <a class="el" href="namespacegmx.xhtml#aacf83788a301a602c40e8a49fce9c5e8">TaskTarget</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ac20deb1b7598a29356dc21eaee062425">findTaskTarget</a> (const char *optionString)</td></tr>
<tr class="memdesc:ac20deb1b7598a29356dc21eaee062425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a TaskTarget from an mdrun argument string. <br/></td></tr>
<tr class="separator:ac20deb1b7598a29356dc21eaee062425"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a073ea9e3fe0996089d9b8b04707b79de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a073ea9e3fe0996089d9b8b04707b79de"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a073ea9e3fe0996089d9b8b04707b79de">c_linewidth</a> = 80 - 2</td></tr>
<tr class="memdesc:a073ea9e3fe0996089d9b8b04707b79de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linewidth used for warning output. <br/></td></tr>
<tr class="separator:a073ea9e3fe0996089d9b8b04707b79de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d18af799eb390727664e70817a5f90c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d18af799eb390727664e70817a5f90c"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a3d18af799eb390727664e70817a5f90c">c_indent</a> = 0</td></tr>
<tr class="memdesc:a3d18af799eb390727664e70817a5f90c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indent used for warning output. <br/></td></tr>
<tr class="separator:a3d18af799eb390727664e70817a5f90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b52689d9c5c9740cdc1074d344377e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b52689d9c5c9740cdc1074d344377e2"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a4b52689d9c5c9740cdc1074d344377e2">c_biasMaxNumDim</a> = 4</td></tr>
<tr class="memdesc:a4b52689d9c5c9740cdc1074d344377e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum dimensionality of the AWH coordinate. <br/></td></tr>
<tr class="separator:a4b52689d9c5c9740cdc1074d344377e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fea4f8ebc2475a5b1b1db2b159684ad"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a6fea4f8ebc2475a5b1b1db2b159684ad">eawhtarget_names</a> [eawhtargetNR+1]</td></tr>
<tr class="memdesc:a6fea4f8ebc2475a5b1b1db2b159684ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">String for target distribution.  <a href="#a6fea4f8ebc2475a5b1b1db2b159684ad">More...</a><br/></td></tr>
<tr class="separator:a6fea4f8ebc2475a5b1b1db2b159684ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46308cc74309940ea36f42140d21eae3"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a46308cc74309940ea36f42140d21eae3">eawhgrowth_names</a> [eawhgrowthNR+1]</td></tr>
<tr class="memdesc:a46308cc74309940ea36f42140d21eae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">String for weight histogram growth.  <a href="#a46308cc74309940ea36f42140d21eae3">More...</a><br/></td></tr>
<tr class="separator:a46308cc74309940ea36f42140d21eae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10c2458446d6f4f644435e5c67b8259"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ae10c2458446d6f4f644435e5c67b8259">eawhpotential_names</a> [eawhpotentialNR+1]</td></tr>
<tr class="memdesc:ae10c2458446d6f4f644435e5c67b8259"><td class="mdescLeft">&#160;</td><td class="mdescRight">String for AWH potential type.  <a href="#ae10c2458446d6f4f644435e5c67b8259">More...</a><br/></td></tr>
<tr class="separator:ae10c2458446d6f4f644435e5c67b8259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958b60db1366d19c6b0e19eafcc1d546"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a958b60db1366d19c6b0e19eafcc1d546">eawhcoordprovider_names</a> [eawhcoordproviderNR+1]</td></tr>
<tr class="memdesc:a958b60db1366d19c6b0e19eafcc1d546"><td class="mdescLeft">&#160;</td><td class="mdescRight">String for AWH bias reaction coordinate provider.  <a href="#a958b60db1366d19c6b0e19eafcc1d546">More...</a><br/></td></tr>
<tr class="separator:a958b60db1366d19c6b0e19eafcc1d546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14235f12ea8bc98dd7d02c0206fbc97"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespacegmx.xhtml#a20e189e3f31f5f1e8581a5cc84063453">Architecture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ac14235f12ea8bc98dd7d02c0206fbc97">c_architecture</a></td></tr>
<tr class="memdesc:ac14235f12ea8bc98dd7d02c0206fbc97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant that tells what the architecture is.  <a href="#ac14235f12ea8bc98dd7d02c0206fbc97">More...</a><br/></td></tr>
<tr class="separator:ac14235f12ea8bc98dd7d02c0206fbc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1058af577b77199877092472287f8ede"><td class="memItemLeft" align="right" valign="top">static const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a1058af577b77199877092472287f8ede">bGPUBinary</a> = GMX_GPU != GMX_GPU_NONE</td></tr>
<tr class="memdesc:a1058af577b77199877092472287f8ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro to help us avoid ifdefs each time we use sysconf.  <a href="#a1058af577b77199877092472287f8ede">More...</a><br/></td></tr>
<tr class="separator:a1058af577b77199877092472287f8ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112b366b91e4bbca373f7491b272e0db"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr<br class="typebreak"/>
&lt; gmx_hw_info_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a112b366b91e4bbca373f7491b272e0db">hwinfo_g</a></td></tr>
<tr class="memdesc:a112b366b91e4bbca373f7491b272e0db"><td class="mdescLeft">&#160;</td><td class="mdescRight">The hwinfo structure (common to all threads in this process).  <a href="#a112b366b91e4bbca373f7491b272e0db">More...</a><br/></td></tr>
<tr class="separator:a112b366b91e4bbca373f7491b272e0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538fa98a649fc05f6af187e1b5c312c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a538fa98a649fc05f6af187e1b5c312c9"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a538fa98a649fc05f6af187e1b5c312c9">n_hwinfo</a> = 0</td></tr>
<tr class="memdesc:a538fa98a649fc05f6af187e1b5c312c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference counter for the hwinfo structure. <br/></td></tr>
<tr class="separator:a538fa98a649fc05f6af187e1b5c312c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762e2a4d397e666f133c1576ec75a1ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a762e2a4d397e666f133c1576ec75a1ee"></a>
static tMPI_Thread_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a762e2a4d397e666f133c1576ec75a1ee">hw_info_lock</a> = TMPI_THREAD_MUTEX_INITIALIZER</td></tr>
<tr class="memdesc:a762e2a4d397e666f133c1576ec75a1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lock to protect the hwinfo structure. <br/></td></tr>
<tr class="separator:a762e2a4d397e666f133c1576ec75a1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d101abde50194b033bd47aca343efb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69d101abde50194b033bd47aca343efb"></a>
<a class="el" href="namespacegmx.xhtml#a24c220170a68ad4867d5cb6b89bdec4b">integrator_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a69d101abde50194b033bd47aca343efb">do_steep</a></td></tr>
<tr class="memdesc:a69d101abde50194b033bd47aca343efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Steepest descents energy minimization. <br/></td></tr>
<tr class="separator:a69d101abde50194b033bd47aca343efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7e06ca1a66d04665db497fe64b8c2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b7e06ca1a66d04665db497fe64b8c2c"></a>
<a class="el" href="namespacegmx.xhtml#a24c220170a68ad4867d5cb6b89bdec4b">integrator_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a6b7e06ca1a66d04665db497fe64b8c2c">do_cg</a></td></tr>
<tr class="memdesc:a6b7e06ca1a66d04665db497fe64b8c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conjugate gradient energy minimization. <br/></td></tr>
<tr class="separator:a6b7e06ca1a66d04665db497fe64b8c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a1b057a39053d0c4a28c49285f900e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6a1b057a39053d0c4a28c49285f900e"></a>
<a class="el" href="namespacegmx.xhtml#a24c220170a68ad4867d5cb6b89bdec4b">integrator_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#ac6a1b057a39053d0c4a28c49285f900e">do_lbfgs</a></td></tr>
<tr class="memdesc:ac6a1b057a39053d0c4a28c49285f900e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conjugate gradient energy minimization using the L-BFGS algorithm. <br/></td></tr>
<tr class="separator:ac6a1b057a39053d0c4a28c49285f900e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6872c2f4b813d88a0beccdacfe730c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6872c2f4b813d88a0beccdacfe730c9"></a>
<a class="el" href="namespacegmx.xhtml#a24c220170a68ad4867d5cb6b89bdec4b">integrator_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#aa6872c2f4b813d88a0beccdacfe730c9">do_nm</a></td></tr>
<tr class="memdesc:aa6872c2f4b813d88a0beccdacfe730c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal mode analysis. <br/></td></tr>
<tr class="separator:aa6872c2f4b813d88a0beccdacfe730c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efd8b13fa02f4aebf73a8d8555e81f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1efd8b13fa02f4aebf73a8d8555e81f9"></a>
<a class="el" href="namespacegmx.xhtml#a24c220170a68ad4867d5cb6b89bdec4b">integrator_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a1efd8b13fa02f4aebf73a8d8555e81f9">do_tpi</a></td></tr>
<tr class="memdesc:a1efd8b13fa02f4aebf73a8d8555e81f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test particle insertion. <br/></td></tr>
<tr class="separator:a1efd8b13fa02f4aebf73a8d8555e81f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f6a93a5bf9ce1e585bebf205d6f6ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19f6a93a5bf9ce1e585bebf205d6f6ea"></a>
<a class="el" href="namespacegmx.xhtml#a24c220170a68ad4867d5cb6b89bdec4b">integrator_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml#a19f6a93a5bf9ce1e585bebf205d6f6ea">do_md</a></td></tr>
<tr class="memdesc:a19f6a93a5bf9ce1e585bebf205d6f6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">MD simulations. <br/></td></tr>
<tr class="separator:a19f6a93a5bf9ce1e585bebf205d6f6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ac3ca6adcfda5170180c2140c7b2f9d47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegmx.xhtml#ac3ca6adcfda5170180c2140c7b2f9d47">gmx::AlignedAllocator</a> = typedef Allocator&lt;T, AlignedAllocationPolicy&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligned memory allocator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of objects to allocate</td></tr>
  </table>
  </dd>
</dl>
<p>This convenience partial specialization can be used for the optional allocator template parameter in standard library containers, which is necessary e.g. to use SIMD aligned load and store operations on data in those containers. The memory will always be aligned according to the behavior of AlignedAllocationPolicy. </p>

</div>
</div>
<a class="anchor" id="a7ea21974bdd8acdfa1c344b0945cff1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classgmx_1_1ThreeFry2x64Fast.xhtml">ThreeFry2x64Fast</a> <a class="el" href="namespacegmx.xhtml#a7ea21974bdd8acdfa1c344b0945cff1b">gmx::DefaultRandomEngine</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default fast and accurate random engine in Gromacs. </p>
<p>This engine will return 2*2^64 random results using the default <a class="el" href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0a6311ae17c1ee52b36e68aaf4ad066387" title="Generic - stream uniqueness is not important. ">gmx::RandomDomain::Other</a> stream, and can be initialized with a single seed argument without having to remember empty template angle brackets. </p>

</div>
</div>
<a class="anchor" id="aae347fd6abaab2e4d8278bf17973b664"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegmx.xhtml#aae347fd6abaab2e4d8278bf17973b664">gmx::HostAllocator</a> = typedef Allocator&lt;T, HostAllocationPolicy&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memory allocator that uses HostAllocationPolicy. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of objects to allocate</td></tr>
  </table>
  </dd>
</dl>
<p>This convenience partial specialization can be used for the optional allocator template parameter in standard library containers whose memory may be used for e.g. GPU transfers. The memory will always be allocated according to the behavior of HostAllocationPolicy. </p>

</div>
</div>
<a class="anchor" id="a24c220170a68ad4867d5cb6b89bdec4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double gmx::integrator_t(FILE *fplog, t_commrec *cr, const gmx::MDLogger &amp;mdlog, int nfile, const <a class="el" href="structt__filenm.xhtml">t_filenm</a> fnm[], const gmx_output_env_t *oenv, const MdrunOptions &amp;mdrunOptions, gmx_vsite_t *vsite, gmx_constr_t constr, gmx::IMDOutputProvider *outputProvider, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, <a class="el" href="classt__state.xhtml">t_state</a> *state_global, ObservablesHistory *observablesHistory, MDAtoms *mdatoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, t_forcerec *fr, const ReplicaExchangeParameters &amp;replExParams, gmx_membed_t *membed, gmx_walltime_accounting_t walltime_accounting)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrator algorithm implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fplog</td><td>Log file for output </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cr</td><td>Communication record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mdlog</td><td>Log writer for important output </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nfile</td><td>Number of files </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fnm</td><td>Filename structure array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oenv</td><td>Output information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mdrunOptions</td><td><a class="el" href="classgmx_1_1Options.xhtml" title="Collection of options. ">Options</a> for mdrun </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vsite</td><td>Virtual site information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constr</td><td>Constraint information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputProvider</td><td>Additional output provider </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputrec</td><td>Input record with mdp options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top_global</td><td>Molecular topology for the whole system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fcd</td><td>Force and constraint data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state_global</td><td>The state (x, v, f, box etc.) of the whole system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">observablesHistory</td><td>The observables statistics history </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mdAtoms</td><td>Atom information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrnb</td><td>Accounting for floating point operations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wcycle</td><td>Wall cycle timing information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fr</td><td>Force record with cut-off information and more </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replExParams</td><td>Parameters for the replica exchange algorithm </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">membed</td><td>Membrane embedding data structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">walltime_accounting</td><td>More timing information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ed9d94613445e3a616e7116786ed534"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegmx.xhtml#a7ed9d94613445e3a616e7116786ed534">gmx::PaddedArrayRef</a> = typedef <a class="el" href="classgmx_1_1ArrayRef.xhtml">ArrayRef</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Temporary definition of a type usable for SIMD-style loads of RVec quantities from a view. </p>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000028">Todo:</a></b></dt><dd>Find a more permanent solution that permits the update code to safely use a padded, aligned array-ref type. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5162006582f166d58667a890f462eba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegmx.xhtml#ab5162006582f166d58667a890f462eba">gmx::PaddedRVecVector</a> = typedef std::vector &lt; <a class="el" href="namespacegmx.xhtml#a139c1919a9680de4ad1450f42e37d33b">RVec</a>, Allocator &lt; <a class="el" href="namespacegmx.xhtml#a139c1919a9680de4ad1450f42e37d33b">RVec</a>, AlignedAllocationPolicy &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Temporary definition of a type usable for SIMD-style loads of RVec quantities. </p>
<dl class="section note"><dt>Note</dt><dd>When resizing paddedRVecVector, the size should be chosen with <a class="el" href="namespacegmx.xhtml#a0657ab84cdeab81eb449859ff086bcd6" title="Returns the padded size for PaddedRVecVector given the number of atoms. ">paddedRVecVectorSize()</a> to ensure correct padding. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000027">Todo:</a></b></dt><dd><p class="startdd">Consider replacing the padding applied in resizePaddedRVecVector() by automated padding on resize() of the vector. </p>
<p class="enddd">Undo the move of <a class="el" href="allocator_8h.xhtml" title="Declares gmx::Allocator template whose allocation functionality is configured both by type of object ...">allocator.h</a> and <a class="el" href="alignedallocator_8h.xhtml" title="Declares allocation policy classes and allocators that are used to make library containers compatible...">alignedallocator.h</a> from the internal to be public API applied in Change-Id: Ifb8dacf, needed to use AlignedAllocationPolicy here, when replacing std::vector here. </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="af01c69345463ebb433d1fedfd356b74a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegmx.xhtml#af01c69345463ebb433d1fedfd356b74a">gmx::PageAlignedAllocator</a> = typedef Allocator&lt;T, PageAlignedAllocationPolicy&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PageAligned memory allocator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of objects to allocate</td></tr>
  </table>
  </dd>
</dl>
<p>This convenience partial specialization can be used for the optional allocator template parameter in standard library containers, which is necessary for locking memory pages for asynchronous transfer between a GPU device and the host. The memory will always be aligned according to the behavior of PageAlignedAllocationPolicy. </p>

</div>
</div>
<a class="anchor" id="aac44e2bbcc40f48812b6b756a503ea51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::random_device <a class="el" href="namespacegmx.xhtml#aac44e2bbcc40f48812b6b756a503ea51">gmx::RandomDevice</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Random device. </p>
<p>For now this is identical to the standard library, but since we use the GROMACS random module for all other random engines and distributions it is convenient to have this too in the same module. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a20e189e3f31f5f1e8581a5cc84063453"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacegmx.xhtml#a20e189e3f31f5f1e8581a5cc84063453">gmx::Architecture</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum for GROMACS CPU hardware detection support. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a20e189e3f31f5f1e8581a5cc84063453afd1a4608b5b463bc7a41d86a1662d3b7"></a>X86</em>&nbsp;</td><td class="fielddoc">
<p>Not one of the cases below. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a20e189e3f31f5f1e8581a5cc84063453a551c5c03a1a91f2cf90e0d9a9b6dd378"></a>Arm</em>&nbsp;</td><td class="fielddoc">
<p>X86. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a20e189e3f31f5f1e8581a5cc84063453a1c020c7b78f5c449ffbe479f3b1aaa82"></a>PowerPC</em>&nbsp;</td><td class="fielddoc">
<p>ARM. </p>
<p>IBM PowerPC </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="aed0429233bc357e419dafee7b8bd1344"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacegmx.xhtml#aed0429233bc357e419dafee7b8bd1344">gmx::AwhOutputEntryType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum with the AWH variables to write. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="aed0429233bc357e419dafee7b8bd1344a02104739967781f89c6b0e63dd2147ca"></a>MetaData</em>&nbsp;</td><td class="fielddoc">
<p>Meta data. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aed0429233bc357e419dafee7b8bd1344a720c5bc3c2ea29a296e3461990c4899b"></a>CoordValue</em>&nbsp;</td><td class="fielddoc">
<p>Coordinate value. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aed0429233bc357e419dafee7b8bd1344a84c75a906e1e7548f6df1e4e3aa3af52"></a>Pmf</em>&nbsp;</td><td class="fielddoc">
<p>The pmf. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aed0429233bc357e419dafee7b8bd1344a4ad6b9e6418fd2d739906bd47e887ae3"></a>Bias</em>&nbsp;</td><td class="fielddoc">
<p>The bias. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aed0429233bc357e419dafee7b8bd1344ad7e637a6e9ff116de2fa89551240a94d"></a>Visits</em>&nbsp;</td><td class="fielddoc">
<p>The number of visits. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aed0429233bc357e419dafee7b8bd1344a8831731b52fdc6cb7f162f9767d66e4d"></a>Weights</em>&nbsp;</td><td class="fielddoc">
<p>The weights. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aed0429233bc357e419dafee7b8bd1344ac41a31890959544c6523af684561abe5"></a>Target</em>&nbsp;</td><td class="fielddoc">
<p>The target distribition. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aed0429233bc357e419dafee7b8bd1344a9e3dc756a9b59b3b98e12633705af8a2"></a>ForceCorrelationVolume</em>&nbsp;</td><td class="fielddoc">
<p>The volume of the force correlation tensor. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aed0429233bc357e419dafee7b8bd1344a8a0a3ea3dad6182f51bbbdaf5a244d9a"></a>FrictionTensor</em>&nbsp;</td><td class="fielddoc">
<p>The full friction tensor. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="aa78c6481d10a93316c155ffdf021e581"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacegmx.xhtml#aa78c6481d10a93316c155ffdf021e581">gmx::AwhOutputMetaData</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum with the types of metadata to write. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="aa78c6481d10a93316c155ffdf021e581a03c23956aa8e12507d6d59be8a983a13"></a>NumBlock</em>&nbsp;</td><td class="fielddoc">
<p>The number of blocks. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa78c6481d10a93316c155ffdf021e581a461586ff73a95486e167031a14a63505"></a>TargetError</em>&nbsp;</td><td class="fielddoc">
<p>The target error. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa78c6481d10a93316c155ffdf021e581a7cffc85b2f1c2177a818913479ea4f18"></a>ScaledSampleWeight</em>&nbsp;</td><td class="fielddoc">
<p>The logarithm of the sample weight relative to a sample weight of 1 at the initial time. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa78c6481d10a93316c155ffdf021e581ae93f994f01c537c4e2f7d8528c3eb5e9"></a>Count</em>&nbsp;</td><td class="fielddoc">
<p>The number of enum values, not including Count. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a6efc2e8f104eb3699bc82c2b8984cedb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacegmx.xhtml#a6efc2e8f104eb3699bc82c2b8984cedb">gmx::GpuTask</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Types of compute tasks that can be run on a GPU. </p>
<p>These names refer to existing practice in GROMACS, which is not strictly accurate. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a6efc2e8f104eb3699bc82c2b8984cedba661e23745453f323614a6316657bcbde"></a>Nonbonded</em>&nbsp;</td><td class="fielddoc">
<p>Short-ranged interactions. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a6efc2e8f104eb3699bc82c2b8984cedba4792b2e853b980eb284e82db5ad5f4d5"></a>Pme</em>&nbsp;</td><td class="fielddoc">
<p>Long-ranged interactions. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a35a656f58d79c7258c8b6e0141bd440b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacegmx.xhtml#a35a656f58d79c7258c8b6e0141bd440b">gmx::Normalization</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum with different ways of normalizing the output. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a35a656f58d79c7258c8b6e0141bd440ba6adf97f83acf6453d4a6a4b1070f3754"></a>None</em>&nbsp;</td><td class="fielddoc">
<p>No normalization. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a35a656f58d79c7258c8b6e0141bd440bac7c60dd55c0cd4692587f5e9dc114ae9"></a>Coordinate</em>&nbsp;</td><td class="fielddoc">
<p>Scale using the internal/user input coordinate scaling factor. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a35a656f58d79c7258c8b6e0141bd440baf17c26adf091ff1700432cd9fb5e6906"></a>FreeEnergy</em>&nbsp;</td><td class="fielddoc">
<p>Normalize free energy values by subtracting the minimum value. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a35a656f58d79c7258c8b6e0141bd440baf0bac093bb884df2891d32385d053788"></a>Distribution</em>&nbsp;</td><td class="fielddoc">
<p>Normalize the distribution to 1. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="abe4caed0469c0de84e0c1c1a81972b38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacegmx.xhtml#abe4caed0469c0de84e0c1c1a81972b38">gmx::PinningPolicy</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper enum for pinning policy of the allocation of HostAllocationPolicy. </p>
<p>For an efficient non-blocking transfer (e.g. to a GPU), the memory pages for a buffer need to be pinned to a physical page. Aligning such buffers to a physical page should miminize the number of pages that need to be pinned. However, some buffers that may be used for such transfers may also be used in either GROMACS builds or run paths that cannot use such a device, so the policy can be configured so that the resource consumption is no higher than required for correct, efficient operation in all cases. </p>

</div>
</div>
<a class="anchor" id="a73202d646d57bcc963d8afd5a16015f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacegmx.xhtml#a73202d646d57bcc963d8afd5a16015f0">gmx::RandomDomain</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerated values for fixed part of random seed (domain) </p>
<p>Random numbers are used in many places in GROMACS, and to avoid identical streams the random seeds should be different. Instead of keeping track of several different user-provided seeds, it is better to use the fact that generators like ThreeFry take two 64-bit keys, and combine a general user-provided 64-bit random seed with a second constant value from this list to make each stream guaranteed unique.</p>
<dl class="section note"><dt>Note</dt><dd>There is no reason to go overboard with adding options; we only need to guarantee different streams for cases that might be present simultaneously in a single simulation. As an example, two different integrators (or thermostats) can reuse the same domain. </dd>
<dd>
When you do add options, leave some space between the values so you can group new options with old ones without changing old values. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a73202d646d57bcc963d8afd5a16015f0a6311ae17c1ee52b36e68aaf4ad066387"></a>Other</em>&nbsp;</td><td class="fielddoc">
<p>Generic - stream uniqueness is not important. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a73202d646d57bcc963d8afd5a16015f0accb9e34a240647891f931e772cad80ef"></a>MaxwellVelocities</em>&nbsp;</td><td class="fielddoc">
<p>Veolcity assignment from Maxwell distribution. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a73202d646d57bcc963d8afd5a16015f0aa42c5450c670a7ecbea5532bde9c0c65"></a>TestParticleInsertion</em>&nbsp;</td><td class="fielddoc">
<p>Test particle insertion. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a73202d646d57bcc963d8afd5a16015f0a23714d9a49cc46ca81ad32670bde8b5e"></a>UpdateCoordinates</em>&nbsp;</td><td class="fielddoc">
<p>Particle integrators. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a73202d646d57bcc963d8afd5a16015f0ab0634f71dbc527342668f2a63f1b3510"></a>UpdateConstraints</em>&nbsp;</td><td class="fielddoc">
<p>Second integrator step for constraints. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a73202d646d57bcc963d8afd5a16015f0a91e0b95db0c752d879aebd0ac65a7fb9"></a>Thermostat</em>&nbsp;</td><td class="fielddoc">
<p>Stochastic temperature coupling. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a73202d646d57bcc963d8afd5a16015f0a79248e4db93ba16182fd3bf1c8e2fda7"></a>Barostat</em>&nbsp;</td><td class="fielddoc">
<p>Stochastic pressure coupling. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a73202d646d57bcc963d8afd5a16015f0ada8008568302912872628be09e68fb84"></a>ReplicaExchange</em>&nbsp;</td><td class="fielddoc">
<p>Replica exchange metropolis moves. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a73202d646d57bcc963d8afd5a16015f0a19bd460326d41817323764fa9e4287ff"></a>ExpandedEnsemble</em>&nbsp;</td><td class="fielddoc">
<p>Expanded ensemble lambda moves. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a73202d646d57bcc963d8afd5a16015f0a447fab9cec8aab189be326d1cc099a3c"></a>AwhBiasing</em>&nbsp;</td><td class="fielddoc">
<p>AWH biasing reference value moves. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a5dc46e83d110b8c81339683bf748fc81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::abs </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float Floating-point <a class="el" href="namespacegmx.xhtml#a5dc46e83d110b8c81339683bf748fc81" title="Float Floating-point abs(). ">abs()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>any floating point values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>abs(a) for each element.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ac85ea3af684916aee86e2674a6bd81e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::abs </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>double doubleing-point <a class="el" href="namespacegmx.xhtml#a5dc46e83d110b8c81339683bf748fc81" title="Float Floating-point abs(). ">abs()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>any doubleing point values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>abs(a) for each element.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ab102173c68c06e7a340e4eebbf6c3492"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::acos </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float acos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate acos for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Acos(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b534003a0dba716c08d6053e0514311"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::acos </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double acos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate acos for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Acos(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a72f487fc13f5bd1b83417f108a74f5a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::acosSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double acos, but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate acos for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Acos(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a94faad595233e4c3ca46c42dc1c1b5e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gmx::advancePointInSubgrid </td>
          <td>(</td>
          <td class="paramtype">const Grid &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const awh_ivec&#160;</td>
          <td class="paramname"><em>subgridOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const awh_ivec&#160;</td>
          <td class="paramname"><em>subgridNpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>gridPointIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the next grid point in the sub-part of the grid given a starting point. </p>
<p>The given grid point index is updated to the next valid grid point index by traversing the sub-part of the grid, here termed the subgrid. Since the subgrid range might extend beyond the actual size of the grid, the subgrid is traversed until a point both in the subgrid and grid is found. If no point is found, the function returns false and the index is not modified. The starting point needs to be inside of the subgrid. However, if this index is not given, meaning &lt; 0, then the search is initialized at the subgrid origin, i.e. in this case the "next" grid point index is defined to be the first common grid/subgrid point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grid</td><td>The grid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subgridOrigin</td><td>Vector locating the subgrid origin relative to the grid origin. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subgridNpoints</td><td>Number of points along each subgrid dimension. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">gridPointIndex</td><td>Pointer to the starting/next grid point index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the grid point was updated. </dd></dl>

</div>
</div>
<a class="anchor" id="aaec39ef87dbec92292cd5954c922be6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::andNot </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise andnot for two scalar float variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>data1 </td></tr>
    <tr><td class="paramname">b</td><td>data2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(~data1) &amp; data2</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aebb0315d31c3c818a738bdc153397365"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::andNot </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise andnot for two scalar double variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>data1 </td></tr>
    <tr><td class="paramname">b</td><td>data2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(~data1) &amp; data2</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a880a42645963c52980a5790f09e3bd18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::int32_t gmx::andNot </td>
          <td>(</td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise andnot for two scalar integer variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>data1 </td></tr>
    <tr><td class="paramname">b</td><td>data2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(~data1) &amp; data2</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="af90cd5d709899e47809553109383299e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool gmx::anyTrue </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the boolean is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Logical variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a is true, otherwise false.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a3d5120df9c0bf437e64c806a7cfdad02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::asin </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>float asin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate asin for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Asin(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ab02c7d47595f11074fbfedff40145544"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::asin </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double asin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate asin for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Asin(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a98465e562d7b1b24755bc693db04c8f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::asinSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double asin, but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate asin for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Asin(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a1afbc2ada56f899a8d3dc5c61530e28b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::atan </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float atan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate atan for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Atan(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="af15e6f3962e035d69013bd91621fd9f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::atan </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double atan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate atan for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Atan(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aed8336a58abddcdb6afa7835138ecf46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::atan2 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float atan2(y,x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Y component of vector, any quartile </td></tr>
    <tr><td class="paramname">x</td><td>X component of vector, any quartile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Atan(y,x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aa70a1aa5e9c161a2770d0f9b7eca1805"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::atan2 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double atan2(y,x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Y component of vector, any quartile </td></tr>
    <tr><td class="paramname">x</td><td>X component of vector, any quartile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Atan(y,x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a2552094c1be29e087e1e85ae02fb0c7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::atan2SingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double atan2(y,x), but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Y component of vector, any quartile </td></tr>
    <tr><td class="paramname">x</td><td>X component of vector, any quartile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Atan(y,x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a44ca54cb014d2f33b98f3d523d90a2f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::atanSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double atan, but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate atan for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Atan(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a7fa9d80fa7714a4342b4e28cff1e636d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::biasesAreCompatibleForSharingBetweenSimulations </td>
          <td>(</td>
          <td class="paramtype">const AwhParams &amp;&#160;</td>
          <td class="paramname"><em>awhParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gmx_multisim_t *&#160;</td>
          <td class="paramname"><em>multiSimComm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if biases are compatible for sharing between simulations, throws if not. </p>
<p>Should be called simultaneously on the master rank of every simulation. Note that this only checks for technical compatibility. It is up to the user to check that the sharing physically makes sense. Throws an exception when shared biases are not compatible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">awhParams</td><td>The AWH parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointSize</td><td>Vector of grid-point sizes for each bias. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">multiSimComm</td><td>Struct for multi-simulation communication. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a97f9e21174d44695b53626648515c4b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::blend </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blend float selection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First source </td></tr>
    <tr><td class="paramname">b</td><td>Second source </td></tr>
    <tr><td class="paramname">sel</td><td>Boolean selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Select b if sel is true, a otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a069393b3673bd0df6aefc16f8379cf96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::blend </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blend double selection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First source </td></tr>
    <tr><td class="paramname">b</td><td>Second source </td></tr>
    <tr><td class="paramname">sel</td><td>Boolean selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Select b if sel is true, a otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a174859a095e84b4a4ee3214547fe8f13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::int32_t gmx::blend </td>
          <td>(</td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blend integer selection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First source </td></tr>
    <tr><td class="paramname">b</td><td>Second source </td></tr>
    <tr><td class="paramname">sel</td><td>Boolean selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Select b if sel is true, a otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a242c17b1eeb8720c0e6324d098810ac8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gmx::changePinningPolicy </td>
          <td>(</td>
          <td class="paramtype">HostVector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PinningPolicy&#160;</td>
          <td class="paramname"><em>pinningPolicy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function for changing the pinning policy of a HostVector. </p>
<p>Declare as a friend function the only supported way to change the pinning policy.</p>
<p>If the vector has contents, then a full reallocation and buffer copy are needed if the policy change requires tighter restrictions, and desirable even if the policy change requires looser restrictions. That cost is OK, because GROMACS will do this operation very rarely (e.g. when auto-tuning and deciding to switch whether a task will run on a GPU, or not). </p>

</div>
</div>
<a class="anchor" id="a8ff52fcc642134b6d46c014f4dbb2969"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::checkInputConsistencyAwh </td>
          <td>(</td>
          <td class="paramtype">const AwhParams &amp;&#160;</td>
          <td class="paramname"><em>awhParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">warninp_t&#160;</td>
          <td class="paramname"><em>wi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check consistency of input at the AWH level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">awhParams</td><td>AWH parameters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">wi</td><td>Struct for bookkeeping warnings. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85717d4bd89406922cfa1fd7c92c9485"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::checkInputConsistencyAwhBias </td>
          <td>(</td>
          <td class="paramtype">const AwhBiasParams &amp;&#160;</td>
          <td class="paramname"><em>awhBiasParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">warninp_t&#160;</td>
          <td class="paramname"><em>wi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check consistency of input at the AWH bias level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">awhBiasParams</td><td>AWH bias parameters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">wi</td><td>Struct for bookkeeping warnings. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a49931df65c6a671dc8b4f2ea519b7b3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::checkInputConsistencyInterval </td>
          <td>(</td>
          <td class="paramtype">const AwhParams *&#160;</td>
          <td class="paramname"><em>awhParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">warninp_t&#160;</td>
          <td class="paramname"><em>wi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the starting configuration is consistent with the given interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">awhParams</td><td>AWH parameters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">wi</td><td>Struct for bookeeping warnings. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a36a614356b557457126513747fbb559f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::checkUserGpuIds </td>
          <td>(</td>
          <td class="paramtype">const gmx_gpu_info_t &amp;&#160;</td>
          <td class="paramname"><em>gpu_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>compatibleGpus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpuIds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that all user-selected GPUs are compatible. </p>
<p>Given the <code>gpuIds</code> and <code>hardwareInfo</code>, throw if any selected GPUs is not compatible.</p>
<p>The error is given with a suitable descriptive message, which will have context if this check is done after the hardware detection results have been reported to the user. However, note that only the GPUs detected on the master rank are reported, because of the existing limitations of that reporting.</p>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000053">Todo:</a></b></dt><dd>Note that the selected GPUs can be different on each rank, and the IDs of compatible GPUs can be different on each node, so this routine ought to do communication to determine whether all ranks are able to proceed. Currently this relies on the MPI runtime to kill the other processes because GROMACS lacks the appropriate infrastructure to do a good job of coordinating error messages and behaviour across MPMD ranks and multiple simulations.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gpu_info</td><td>Information detected about GPUs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compatibleGpus</td><td>Vector of GPUs that are compatible </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gpuIds</td><td>The GPU IDs selected by the user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If out of memory <a class="el" href="classgmx_1_1InconsistentInputError.xhtml" title="Exception class for situations where user input is inconsistent. ">InconsistentInputError</a> If the assigned GPUs are not valid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8ef5f6af06e493a4ae2d47109ee0e723"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::copysign </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes single value with the magnitude of x and the sign of y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Value to set sign for </td></tr>
    <tr><td class="paramname">y</td><td>Value used to set sign </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Magnitude of x, sign of y</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="af6cfb56189c360e005911247ebf5fd42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::copysign </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes double value with the magnitude of x and the sign of y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Value to set sign for </td></tr>
    <tr><td class="paramname">y</td><td>Value used to set sign </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Magnitude of x, sign of y</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a16c6356a58f3d2c2fe6d2f50afc0c686"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::cos </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float cos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate cos for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cos(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aeda573e9aa3efa5d223c9fe39f682cfd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::cos </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double cos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate cos for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cos(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e717707cf40d6bbacf8752cf28de422"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::cosSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double cos, but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate cos for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cos(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ed28e758d06a65093782945f720a305"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static gmx_int64_t gmx::countSamples </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; PointState &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the total number of samples / sample weight over all grid points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pointState</td><td>The state of the points in a bias. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total sample count. </dd></dl>

</div>
</div>
<a class="anchor" id="abb3a624cce03f1a33bca6a9d70e8c3a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int gmx::countTrailingZeroRows </td>
          <td>(</td>
          <td class="paramtype">const double *const *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numColumns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count trailing data rows containing only zeros. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>2D data array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>Number of rows in array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numColumns</td><td>Number of cols in array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of trailing zero rows. </dd></dl>

</div>
</div>
<a class="anchor" id="af536d7a23a442f3c0876b05ac20d7d40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gmx::cpuIsX86Nehalem </td>
          <td>(</td>
          <td class="paramtype">const CpuInfo &amp;&#160;</td>
          <td class="paramname"><em>cpuInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the CPU is an Intel x86 Nehalem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpuInfo</td><td>Object with cpu information</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if running on Nehalem CPU </dd></dl>

</div>
</div>
<a class="anchor" id="a71df1e05c861d1f59d7185d9577e7944"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; IMDModule &gt; gmx::createElectricFieldModule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a module for an external electric field. </p>
<p>The returned class describes the time dependent electric field that can be applied to all charges in a simulation. The field is described by the following: E(t) = A cos(omega*(t-t0))*exp(-sqr(t-t0)/(2.0*sqr(sigma))); If sigma = 0 there is no pulse and we have instead E(t) = A cos(omega*t)</p>
<p>force is kJ mol^-1 nm^-1 = e * kJ mol^-1 nm^-1 / e</p>
<p>WARNING: There can be problems with the virial. Since the field is not self-consistent this is unavoidable. For neutral molecules the virial is correct within this approximation. For neutral systems with many charged molecules the error is small. But for systems with a net charge or a few charged molecules the error can be significant when the field is high. Solution: implement a self-consistent electric field into PME. </p>

</div>
</div>
<a class="anchor" id="a27254f29caa9fd12a6e774bf7a13502c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool gmx::cvtB2IB </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just return a boolean (mimicks SIMD real-to-int bool conversions) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>boolean </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>same boolean</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a22401779c65549d3061b4fdd5290ef19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::cvtD2F </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert double to float (mimicks SIMD conversion) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>double </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a, as float</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ac575d3b81809b71e414755dc8acf3317"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::cvtF2D </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert float to double (mimicks SIMD conversion) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>float </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a, as double double</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a69388fb35cb4b891c7517554e4500615"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::int32_t gmx::cvtI2R </td>
          <td>(</td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return integer. </p>
<p>This function mimicks the SIMD integer-to-real conversion routines. By simply returning an integer, we let the compiler sort out whether the conversion should be to float or double rather than using proxy objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>same value (a)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a600fa6a48b5df753c2fcc99c47f3f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool gmx::cvtIB2B </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just return a boolean (mimicks SIMD int-to-real bool conversions) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>boolean </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>same boolean</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a2136f5684897fc7ea139039eba172629"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::int32_t gmx::cvtR2I </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round single precision floating point to integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>float </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer format, a rounded to nearest integer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="acc9f420c1d0c099cc58ac3ae5fcb1ace"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::int32_t gmx::cvtR2I </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round single precision doubleing point to integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>double </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer format, a rounded to nearest integer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c74ba54abe2627167abfc0df7286f5d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::int32_t gmx::cvttR2I </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncate single precision floating point to integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>float </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer format, a truncated to integer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0fb4318cc5c14075330d52382e6bdd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::int32_t gmx::cvttR2I </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncate single precision doubleing point to integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>double </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer format, a truncated to integer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a138aa78ae5a68e19fe9ef231061dce44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gmx::decideWhetherToUseGpusForNonbonded </td>
          <td>(</td>
          <td class="paramtype">const TaskTarget&#160;</td>
          <td class="paramname"><em>nonbondedTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>userGpuTaskAssignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EmulateGpuNonbonded&#160;</td>
          <td class="paramname"><em>emulateGpuNonbonded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>usingVerletScheme</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>nonbondedOnGpuIsUseful</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>gpusWereDetected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decide whether the simulation will try to run nonbonded tasks on GPUs. </p>
<p>The final decision cannot be made until after the duty of the rank is known. But we need to know if nonbonded will run on GPUs for setting up DD (particularly rlist) and determining duty. If the user requires GPUs for the tasks of that duty, then it will be an error when none are found.</p>
<p>With thread-MPI, calls have been made to <a class="el" href="namespacegmx.xhtml#ab08a29cc96a87845ddae4cafd8a4da89" title="Decide whether this thread-MPI simulation will run nonbonded tasks on GPUs. ">decideWhetherToUseGpusForNonbondedWithThreadMpi()</a> and <a class="el" href="namespacegmx.xhtml#ae895fab6248bb320ada21c2a65d0e6ac" title="Decide whether this thread-MPI simulation will run PME tasks on GPUs. ">decideWhetherToUseGpusForPmeWithThreadMpi()</a> to help determine the number of ranks and run some checks, but the final decision is made in this routine, along with many more consistency checks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nonbondedTarget</td><td>The user's choice for mdrun -nb for where to assign short-ranged nonbonded interaction tasks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userGpuTaskAssignment</td><td>The user-specified assignment of GPU tasks to device IDs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">emulateGpuNonbonded</td><td>Whether we will emulate GPU calculation of nonbonded interactions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usingVerletScheme</td><td>Whether the nonbondeds are using the Verlet scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nonbondedOnGpuIsUseful</td><td>Whether computing nonbonded interactions on a GPU is useful for this calculation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gpusWereDetected</td><td>Whether compatible GPUs were detected on any node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the simulation will run nonbonded and PME tasks, respectively, on GPUs.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If out of memory <a class="el" href="classgmx_1_1InconsistentInputError.xhtml" title="Exception class for situations where user input is inconsistent. ">InconsistentInputError</a> If the user requirements are inconsistent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab08a29cc96a87845ddae4cafd8a4da89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gmx::decideWhetherToUseGpusForNonbondedWithThreadMpi </td>
          <td>(</td>
          <td class="paramtype">const TaskTarget&#160;</td>
          <td class="paramname"><em>nonbondedTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpuIdsToUse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>userGpuTaskAssignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EmulateGpuNonbonded&#160;</td>
          <td class="paramname"><em>emulateGpuNonbonded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>usingVerletScheme</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>nonbondedOnGpuIsUseful</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>numRanksPerSimulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decide whether this thread-MPI simulation will run nonbonded tasks on GPUs. </p>
<p>The number of GPU tasks and devices influences both the choice of the number of ranks, and checks upon any such choice made by the user. So we need to consider this before any automated choice of the number of thread-MPI ranks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nonbondedTarget</td><td>The user's choice for mdrun -nb for where to assign short-ranged nonbonded interaction tasks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gpuIdsToUse</td><td>The compatible GPUs that the user permitted us to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userGpuTaskAssignment</td><td>The user-specified assignment of GPU tasks to device IDs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">emulateGpuNonbonded</td><td>Whether we will emulate GPU calculation of nonbonded interactions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usingVerletScheme</td><td>Whether the nonbondeds are using the Verlet scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nonbondedOnGpuIsUseful</td><td>Whether computing nonbonded interactions on a GPU is useful for this calculation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRanksPerSimulation</td><td>The number of ranks in each simulation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the simulation will run nonbonded tasks on GPUs.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If out of memory <a class="el" href="classgmx_1_1InconsistentInputError.xhtml" title="Exception class for situations where user input is inconsistent. ">InconsistentInputError</a> If the user requirements are inconsistent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6d32a9f9c61cc84646acee0cec26e6d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gmx::decideWhetherToUseGpusForPme </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>useGpuForNonbonded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TaskTarget&#160;</td>
          <td class="paramname"><em>pmeTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>userGpuTaskAssignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>canUseGpuForPme</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>numRanksPerSimulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>numPmeRanksPerSimulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>gpusWereDetected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decide whether the simulation will try to run tasks of different types on GPUs. </p>
<p>The final decision cannot be made until after the duty of the rank is known. But we need to know if nonbonded will run on GPUs for setting up DD (particularly rlist) and determining duty. If the user requires GPUs for the tasks of that duty, then it will be an error when none are found.</p>
<p>With thread-MPI, calls have been made to <a class="el" href="namespacegmx.xhtml#ab08a29cc96a87845ddae4cafd8a4da89" title="Decide whether this thread-MPI simulation will run nonbonded tasks on GPUs. ">decideWhetherToUseGpusForNonbondedWithThreadMpi()</a> and <a class="el" href="namespacegmx.xhtml#ae895fab6248bb320ada21c2a65d0e6ac" title="Decide whether this thread-MPI simulation will run PME tasks on GPUs. ">decideWhetherToUseGpusForPmeWithThreadMpi()</a> to help determine the number of ranks and run some checks, but the final decision is made in this routine, along with many more consistency checks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">useGpuForNonbonded</td><td>Whether GPUs will be used for nonbonded interactions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pmeTarget</td><td>The user's choice for mdrun -pme for where to assign long-ranged PME nonbonded interaction tasks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userGpuTaskAssignment</td><td>The user-specified assignment of GPU tasks to device IDs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">canUseGpuForPme</td><td>Whether the form of PME chosen can run on a GPU </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRanksPerSimulation</td><td>The number of ranks in each simulation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numPmeRanksPerSimulation</td><td>The number of PME ranks in each simulation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gpusWereDetected</td><td>Whether compatible GPUs were detected on any node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the simulation will run nonbonded and PME tasks, respectively, on GPUs.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If out of memory <a class="el" href="classgmx_1_1InconsistentInputError.xhtml" title="Exception class for situations where user input is inconsistent. ">InconsistentInputError</a> If the user requirements are inconsistent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae895fab6248bb320ada21c2a65d0e6ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gmx::decideWhetherToUseGpusForPmeWithThreadMpi </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>useGpuForNonbonded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TaskTarget&#160;</td>
          <td class="paramname"><em>pmeTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpuIdsToUse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>userGpuTaskAssignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>canUseGpuForPme</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>numRanksPerSimulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>numPmeRanksPerSimulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decide whether this thread-MPI simulation will run PME tasks on GPUs. </p>
<p>The number of GPU tasks and devices influences both the choice of the number of ranks, and checks upon any such choice made by the user. So we need to consider this before any automated choice of the number of thread-MPI ranks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">useGpuForNonbonded</td><td>Whether GPUs will be used for nonbonded interactions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pmeTarget</td><td>The user's choice for mdrun -pme for where to assign long-ranged PME nonbonded interaction tasks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gpuIdsToUse</td><td>The compatible GPUs that the user permitted us to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userGpuTaskAssignment</td><td>The user-specified assignment of GPU tasks to device IDs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">canUseGpuForPme</td><td>Whether the form of PME chosen can run on a GPU </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRanksPerSimulation</td><td>The number of ranks in each simulation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numPmeRanksPerSimulation</td><td>The number of PME ranks in each simulation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the simulation will run PME tasks on GPUs.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If out of memory <a class="el" href="classgmx_1_1InconsistentInputError.xhtml" title="Exception class for situations where user input is inconsistent. ">InconsistentInputError</a> If the user requirements are inconsistent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a475269580d9d34d282e74f831403afda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double gmx::do_cg </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fplog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_commrec *&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gmx::MDLogger &amp;&#160;</td>
          <td class="paramname"><em>mdlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structt__filenm.xhtml">t_filenm</a>&#160;</td>
          <td class="paramname"><em>fnm</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gmx_output_env_t *&#160;</td>
          <td class="paramname"><em>oenv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MdrunOptions &amp;&#160;</td>
          <td class="paramname"><em>mdrunOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_vsite_t *&#160;</td>
          <td class="paramname"><em>vsite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_constr_t&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx::IMDOutputProvider *&#160;</td>
          <td class="paramname"><em>outputProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_inputrec *&#160;</td>
          <td class="paramname"><em>inputrec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_mtop_t *&#160;</td>
          <td class="paramname"><em>top_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_fcdata *&#160;</td>
          <td class="paramname"><em>fcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classt__state.xhtml">t_state</a> *&#160;</td>
          <td class="paramname"><em>state_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ObservablesHistory *&#160;</td>
          <td class="paramname"><em>observablesHistory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx::MDAtoms *&#160;</td>
          <td class="paramname"><em>mdAtoms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_nrnb *&#160;</td>
          <td class="paramname"><em>nrnb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_wallcycle_t&#160;</td>
          <td class="paramname"><em>wcycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_forcerec *&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ReplicaExchangeParameters &amp;&#160;</td>
          <td class="paramname"><em>replExParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_membed_t *&#160;</td>
          <td class="paramname"><em>membed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_walltime_accounting_t&#160;</td>
          <td class="paramname"><em>walltime_accounting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do conjugate gradients minimization. </p>

</div>
</div>
<a class="anchor" id="adc884f7f1ed3c1d3404b78f07b0b3fea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double gmx::do_lbfgs </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fplog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_commrec *&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gmx::MDLogger &amp;&#160;</td>
          <td class="paramname"><em>mdlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structt__filenm.xhtml">t_filenm</a>&#160;</td>
          <td class="paramname"><em>fnm</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gmx_output_env_t *&#160;</td>
          <td class="paramname"><em>oenv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MdrunOptions &amp;&#160;</td>
          <td class="paramname"><em>mdrunOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_vsite_t *&#160;</td>
          <td class="paramname"><em>vsite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_constr_t&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx::IMDOutputProvider *&#160;</td>
          <td class="paramname"><em>outputProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_inputrec *&#160;</td>
          <td class="paramname"><em>inputrec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_mtop_t *&#160;</td>
          <td class="paramname"><em>top_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_fcdata *&#160;</td>
          <td class="paramname"><em>fcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classt__state.xhtml">t_state</a> *&#160;</td>
          <td class="paramname"><em>state_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ObservablesHistory *&#160;</td>
          <td class="paramname"><em>observablesHistory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx::MDAtoms *&#160;</td>
          <td class="paramname"><em>mdAtoms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_nrnb *&#160;</td>
          <td class="paramname"><em>nrnb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_wallcycle_t&#160;</td>
          <td class="paramname"><em>wcycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_forcerec *&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ReplicaExchangeParameters &amp;&#160;</td>
          <td class="paramname"><em>replExParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_membed_t *&#160;</td>
          <td class="paramname"><em>membed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_walltime_accounting_t&#160;</td>
          <td class="paramname"><em>walltime_accounting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do L-BFGS conjugate gradients minimization. </p>

</div>
</div>
<a class="anchor" id="a0f6ac3ade79370a97682bc64ec4d763a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double gmx::do_nm </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fplog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_commrec *&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gmx::MDLogger &amp;&#160;</td>
          <td class="paramname"><em>mdlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structt__filenm.xhtml">t_filenm</a>&#160;</td>
          <td class="paramname"><em>fnm</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gmx_output_env_t *&#160;</td>
          <td class="paramname"><em>oenv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MdrunOptions &amp;&#160;</td>
          <td class="paramname"><em>mdrunOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_vsite_t *&#160;</td>
          <td class="paramname"><em>vsite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_constr_t&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx::IMDOutputProvider *&#160;</td>
          <td class="paramname"><em>outputProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_inputrec *&#160;</td>
          <td class="paramname"><em>inputrec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_mtop_t *&#160;</td>
          <td class="paramname"><em>top_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_fcdata *&#160;</td>
          <td class="paramname"><em>fcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classt__state.xhtml">t_state</a> *&#160;</td>
          <td class="paramname"><em>state_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ObservablesHistory *&#160;</td>
          <td class="paramname"><em>observablesHistory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx::MDAtoms *&#160;</td>
          <td class="paramname"><em>mdAtoms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_nrnb *&#160;</td>
          <td class="paramname"><em>nrnb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_wallcycle_t&#160;</td>
          <td class="paramname"><em>wcycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_forcerec *&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ReplicaExchangeParameters &amp;&#160;</td>
          <td class="paramname"><em>replExParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_membed_t *&#160;</td>
          <td class="paramname"><em>membed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_walltime_accounting_t&#160;</td>
          <td class="paramname"><em>walltime_accounting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do normal modes analysis. </p>

</div>
</div>
<a class="anchor" id="aab958777e1c348318f87aaea003bd344"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double gmx::do_steep </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fplog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_commrec *&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gmx::MDLogger &amp;&#160;</td>
          <td class="paramname"><em>mdlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structt__filenm.xhtml">t_filenm</a>&#160;</td>
          <td class="paramname"><em>fnm</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gmx_output_env_t *&#160;</td>
          <td class="paramname"><em>oenv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MdrunOptions &amp;&#160;</td>
          <td class="paramname"><em>mdrunOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_vsite_t *&#160;</td>
          <td class="paramname"><em>vsite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_constr_t&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx::IMDOutputProvider *&#160;</td>
          <td class="paramname"><em>outputProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_inputrec *&#160;</td>
          <td class="paramname"><em>inputrec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_mtop_t *&#160;</td>
          <td class="paramname"><em>top_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_fcdata *&#160;</td>
          <td class="paramname"><em>fcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classt__state.xhtml">t_state</a> *&#160;</td>
          <td class="paramname"><em>state_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ObservablesHistory *&#160;</td>
          <td class="paramname"><em>observablesHistory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx::MDAtoms *&#160;</td>
          <td class="paramname"><em>mdAtoms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_nrnb *&#160;</td>
          <td class="paramname"><em>nrnb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_wallcycle_t&#160;</td>
          <td class="paramname"><em>wcycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_forcerec *&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ReplicaExchangeParameters &amp;&#160;</td>
          <td class="paramname"><em>replExParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_membed_t *&#160;</td>
          <td class="paramname"><em>membed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_walltime_accounting_t&#160;</td>
          <td class="paramname"><em>walltime_accounting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do steepest descents minimization. </p>

</div>
</div>
<a class="anchor" id="ab9fe0760b635bfaa85fa2152bb8ff067"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double gmx::do_tpi </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fplog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_commrec *&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gmx::MDLogger &amp;&#160;</td>
          <td class="paramname"><em>mdlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structt__filenm.xhtml">t_filenm</a>&#160;</td>
          <td class="paramname"><em>fnm</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gmx_output_env_t *&#160;</td>
          <td class="paramname"><em>oenv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MdrunOptions &amp;&#160;</td>
          <td class="paramname"><em>mdrunOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_vsite_t *&#160;</td>
          <td class="paramname"><em>vsite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_constr_t&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx::IMDOutputProvider *&#160;</td>
          <td class="paramname"><em>outputProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_inputrec *&#160;</td>
          <td class="paramname"><em>inputrec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_mtop_t *&#160;</td>
          <td class="paramname"><em>top_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_fcdata *&#160;</td>
          <td class="paramname"><em>fcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classt__state.xhtml">t_state</a> *&#160;</td>
          <td class="paramname"><em>state_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ObservablesHistory *&#160;</td>
          <td class="paramname"><em>observablesHistory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx::MDAtoms *&#160;</td>
          <td class="paramname"><em>mdAtoms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_nrnb *&#160;</td>
          <td class="paramname"><em>nrnb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_wallcycle_t&#160;</td>
          <td class="paramname"><em>wcycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_forcerec *&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ReplicaExchangeParameters &amp;&#160;</td>
          <td class="paramname"><em>replExParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_membed_t *&#160;</td>
          <td class="paramname"><em>membed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_walltime_accounting_t&#160;</td>
          <td class="paramname"><em>walltime_accounting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do test particle insertion. </p>
<p>Integrator algorithm implementation. (FILE *fplog, t_commrec *cr, const gmx::MDLogger &amp;mdlog, </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fplog</td><td>Log file for output </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cr</td><td>Communication record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mdlog</td><td>Log writer for important output </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nfile</td><td>Number of files </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fnm</td><td>Filename structure array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oenv</td><td>Output information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mdrunOptions</td><td><a class="el" href="classgmx_1_1Options.xhtml" title="Collection of options. ">Options</a> for mdrun </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vsite</td><td>Virtual site information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constr</td><td>Constraint information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputProvider</td><td>Additional output provider </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputrec</td><td>Input record with mdp options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top_global</td><td>Molecular topology for the whole system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fcd</td><td>Force and constraint data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state_global</td><td>The state (x, v, f, box etc.) of the whole system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">observablesHistory</td><td>The observables statistics history </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mdAtoms</td><td>Atom information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrnb</td><td>Accounting for floating point operations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wcycle</td><td>Wall cycle timing information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fr</td><td>Force record with cut-off information and more </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replExParams</td><td>Parameters for the replica exchange algorithm </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">membed</td><td>Membrane embedding data structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">walltime_accounting</td><td>More timing information (FILE *fplog, t_commrec *cr, const gmx::MDLogger &amp;mdlog, int nfile, const <a class="el" href="structt__filenm.xhtml" title="File name option definition for C code. ">t_filenm</a> fnm[], const gmx_output_env_t *oenv, const MdrunOptions &amp;mdrunOptions, gmx_vsite_t *vsite, gmx_constr_t constr, gmx::IMDOutputProvider *outputProvider, t_inputrec *inputrec, gmx_mtop_t *top_global, t_fcdata *fcd, <a class="el" href="classt__state.xhtml" title="The microstate of the system. ">t_state</a> *state_global, gmx::MDAtoms *mdAtoms, t_nrnb *nrnb, gmx_wallcycle_t wcycle, gmx_edsam_t ed, t_forcerec *fr, const ReplicaExchangeParameters &amp;replExParams, gmx_membed_t gmx_unused *membed, gmx_walltime_accounting_t walltime_accounting) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70063f05c46b838ac5aab645dff410c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::doDeviceTransfers </td>
          <td>(</td>
          <td class="paramtype">const gmx_gpu_info_t &amp;&#160;</td>
          <td class="paramname"><em>gpuInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayRef&lt; const char &gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayRef&lt; char &gt;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function for GPU test code to be platform agnostic. </p>
<p>Transfers <code>input</code> to device 0, if present, and transfers it back into <code>output</code>. Both sizes must match. If no devices are present, do a simple host-side buffer copy instead.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classgmx_1_1InternalError.xhtml" title="Exception class for internal errors. ">InternalError</a></td><td>Upon any GPU API error condition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aabf06e7cadddc4762cf22625a990a97e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::ensureStateAndRunConsistency </td>
          <td>(</td>
          <td class="paramtype">const BiasParams &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BiasState &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the state (loaded from checkpoint) and the run are consistent. </p>
<p>When the state and the run setup are inconsistent, an exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>The parameters of the bias. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>The state of the bias. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a81ecdda73e384cd4e6896492144529"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::erf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float erf(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>erf(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a3fe934a0b6419312a82b6bb6b8b6ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::erf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double erf(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>erf(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aad005ed4133f5a01702c63a9440feab7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::erfc </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float erfc(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>erfc(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a56c071a6a14720e2b94e4b034e110614"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::erfc </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double erfc(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>erfc(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a56d277c19df61f3b0176da88ba40b53a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::erfcSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double erfc(x), but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>erfc(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a2dad03094a0ea5970a5f0977ce5fee84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double gmx::erfinv </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverse error function, double precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, should be in the range -1.0 &lt; x &lt; 1.0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse of the error function if the argument is inside the range, +/- infinity if it is exactly 1.0 or -1.0, and NaN otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a85012c7d3609ac21e4052fc3114125a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gmx::erfinv </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverse error function, single precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, should be in the range -1.0 &lt; x &lt; 1.0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse of the error function if the argument is inside the range, +/- infinity if it is exactly 1.0 or -1.0, and NaN otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2491a7f4b92881d4887491a532e8e5f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::erfSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double erf(x), but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>erf(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aa22dfb3027cee75bbc9686094f928050"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MathOptimization opt = MathOptimization::Safe&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::exp </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float exp(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>exp(x). Undefined if input argument caused overflow.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a70905c614c3a1bb238913e8dbf6cdf85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MathOptimization opt = MathOptimization::Safe&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::exp </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double exp(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>exp(x). Undefined if input argument caused overflow.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a643a4be46c81b885274394cd9ac1a30a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MathOptimization opt = MathOptimization::Safe&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::exp2 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float 2^x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2^x. Undefined if input argument caused overflow.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a32ee0155bc450db5b12eb105efce27df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MathOptimization opt = MathOptimization::Safe&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::exp2 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double 2^x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2^x. Undefined if input argument caused overflow.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a119f14f4a364f71eb9273b5dd8c927cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::exp2SingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double 2^x, but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2^x. Undefined if input argument caused overflow.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b19d8b9f07e36c8152b30d4b3caaad6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::expandScalarsToTriplets </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>triplets0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>triplets1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>triplets2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy single float to three variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">scalar</td><td>Floating-point input. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">triplets0</td><td>Copy 1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">triplets1</td><td>Copy 2. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">triplets2</td><td>Copy 3.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="af8a2ae7f742d7612f2808bfd39b0f975"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::expandScalarsToTriplets </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>triplets0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>triplets1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>triplets2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy single double to three variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">scalar</td><td>Floating-point input. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">triplets0</td><td>Copy 1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">triplets1</td><td>Copy 2. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">triplets2</td><td>Copy 3.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="afa6d2866bd8be11dce227ad0e26511a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::expSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double exp(x), but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>exp(x). Undefined if input argument caused overflow.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ad0d9eaa14aa830a5c06ee01f5789a152"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegmx.xhtml#a01b141a05049b61c32b587e8d19e8947">GpuTasksOnRanks</a> gmx::findAllGpuTasksOnThisNode </td>
          <td>(</td>
          <td class="paramtype">ArrayRef&lt; const GpuTask &gt;&#160;</td>
          <td class="paramname"><em>gpuTasksOnThisRank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numRanksOnThisNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns container of all tasks on all ranks of this node that are eligible for GPU execution. </p>
<p>Perform all necessary communication for preparing for task assignment. Separating this aspect makes it possible to unit test the logic of task assignment. </p>

</div>
</div>
<a class="anchor" id="a183d89182d418bb66a668104978af5bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::fma </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float Fused-multiply-add. Result is a*b + c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a*b + c</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a79e2ba07938cafa28c0988ba52874f46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::fma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>double Fused-multiply-add. Result is a*b + c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a*b + c</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="afad947f51589a3a9eef2f8364ab62c19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::fms </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float Fused-multiply-subtract. Result is a*b - c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a*b - c</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="abcb2c8942d173c6a9964940f90c55b2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::fms </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>double Fused-multiply-subtract. Result is a*b - c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a*b - c</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a55183d689ab9328c18c3b3f819bd7266"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::fnma </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float Fused-negated-multiply-add. Result is -a*b + c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-a*b + c</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="adcf7849c8ce1bbbe3e2fecffedfc05e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::fnma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>double Fused-negated-multiply-add. Result is - a*b + c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-a*b + c</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aa6e6950597f4833fa93b09a94e7b0e16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::fnms </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float Fused-negated-multiply-subtract. Result is -a*b - c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-a*b - c</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9bd8328d5cbdb7f6a054b877183f277"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::fnms </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>double Fused-negated-multiply-subtract. Result is -a*b - c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-a*b - c</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a179f05bc9899fe2b7e71d53a1a95b629"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::gatherLoadBySimdIntTranspose </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 4 floats from base/offsets and store into variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Aligned pointer to the start of the memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Integer type with offset to the start of each triplet. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>First float, base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>Second float, base[align*offset[0] + 1]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v2</td><td>Third float, base[align*offset[0] + 2]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v3</td><td>Fourth float, base[align*offset[0] + 3].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a0614e0463cccdf97cec36fffb2b24764"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::gatherLoadBySimdIntTranspose </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 2 floats from base/offsets and store into variables (aligned). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Aligned pointer to the start of the memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Integer type with offset to the start of each triplet. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>First float, base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>Second float, base[align*offset[0] + 1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a92c67d959864d2549a679f0f2245bacb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::gatherLoadBySimdIntTranspose </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 4 doubles from base/offsets and store into variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Aligned pointer to the start of the memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Integer type with offset to the start of each triplet. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>First double, base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>Second double, base[align*offset[0] + 1]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v2</td><td>Third double, base[align*offset[0] + 2]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v3</td><td>Fourth double, base[align*offset[0] + 3].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a6bb92443ba8da5d878c1dd85b2bcde8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::gatherLoadBySimdIntTranspose </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 2 doubles from base/offsets and store into variables (aligned). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Aligned pointer to the start of the memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Integer type with offset to the start of each triplet. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>First double, base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>Second double, base[align*offset[0] + 1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aba7ff3639534a22d4b9c7a834d7584fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::gatherLoadTranspose </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 4 consecutive floats from base/offset into four variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Index to data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>1st float, base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>2nd float, base[align*offset[0] + 1]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v2</td><td>3rd float, base[align*offset[0] + 2]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v3</td><td>4th float, base[align*offset[0] + 3].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c0cda66eba19ad12a50e48f848f268f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::gatherLoadTranspose </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 2 consecutive floats from base/offset into four variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Index to data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>1st float, base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>2nd float, base[align*offset[0] + 1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a94e990607fd4d48ca160fbc380597f5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::gatherLoadTranspose </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 4 consecutive doubles from base/offset into four variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Index to data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>1st double, base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>2nd double, base[align*offset[0] + 1]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v2</td><td>3rd double, base[align*offset[0] + 2]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v3</td><td>4th double, base[align*offset[0] + 3].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c464ebd492587005bb4baefb4293072"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::gatherLoadTranspose </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 2 consecutive doubles from base/offset into four variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Index to data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>1st double, base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>2nd double, base[align*offset[0] + 1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a29c67b43b26cfba5ec360bf020df4c8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::gatherLoadUBySimdIntTranspose </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 2 floats from base/offsets and store into variables (unaligned). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Aligned pointer to the start of the memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Integer type with offset to the start of each triplet. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>First float, base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>Second float, base[align*offset[0] + 1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="af74c58ce1915c6a25061153cd3b4bde8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::gatherLoadUBySimdIntTranspose </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 2 doubles from base/offsets and store into variables (unaligned). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Aligned pointer to the start of the memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Integer type with offset to the start of each triplet. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>First double, base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>Second double, base[align*offset[0] + 1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="acfefc291c66a8404f2aad767af91cb21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::gatherLoadUTranspose </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 3 consecutive floats from base/offsets, store into three vars. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Offset to the start of data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>1st value, base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>2nd value, base[align*offset[0] + 1]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v2</td><td>3rd value, base[align*offset[0] + 2].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a0502844193d9fcf13648a4165a67a1a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::gatherLoadUTranspose </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 3 consecutive doubles from base/offsets, store into three vars. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Offset to the start of data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>1st double, base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>2nd double, base[align*offset[0] + 1]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v2</td><td>3rd double, base[align*offset[0] + 2].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ba622deb792fdc881824ce7a36d8440"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RealType  = real, unsigned int Bits, class Rng &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RealType gmx::generateCanonical </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a floating-point value with specified number of random bits. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RealType</td><td>Floating-point type to generate </td></tr>
    <tr><td class="paramname">Bits</td><td>Number of random bits to generate </td></tr>
    <tr><td class="paramname">Rng</td><td>Random number generator class</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Random number generator to use</td></tr>
  </table>
  </dd>
</dl>
<p>This implementation avoids the bug in libc++ and stdlibc++ (which is due to the C++ standard being unclear) where 1.0 can be returned occasionally. </p>

</div>
</div>
<a class="anchor" id="a4208e61154b60990cfabb18cb8a48a84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::get_pull_coord_period </td>
          <td>(</td>
          <td class="paramtype">const pull_params_t *&#160;</td>
          <td class="paramname"><em>pull_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>coord_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the period of a pull coordinate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pull_params</td><td>Pull parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coord_ind</td><td>Pull coordinate index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>Box vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the period (or 0 if not periodic). </dd></dl>

</div>
</div>
<a class="anchor" id="a4309ee8c0866fc1d57d89a3b0a4fdfb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double gmx::getDeviationFromPointAlongGridAxis </td>
          <td>(</td>
          <td class="paramtype">const Grid &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pointIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the deviation along one dimension from the given value to a point in the grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grid</td><td>The grid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dimIndex</td><td>Dimensional index in [0, ndim -1]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointIndex</td><td>Grid point index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value along the given dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the deviation of the given value to the given point. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b1a7538a2bc458730d961649ae007d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int gmx::getNearestIndexInGrid </td>
          <td>(</td>
          <td class="paramtype">const awh_dvec&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; GridAxis &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map a value to the nearest point in the grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axis</td><td>The grid axes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the point index nearest to the value. </dd></dl>

</div>
</div>
<a class="anchor" id="a14ac652392d2a98ce5a3b3a3ca809206"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::size_t gmx::getPageSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a page size, from a sysconf/WinAPI query if available, or a default guess (4096 bytes). </p>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000056">Todo:</a></b></dt><dd>Move this function into sysinfo.cpp where other OS-specific code/includes live </dd></dl>

</div>
</div>
<a class="anchor" id="ac1528c07c49b94c33fc51f681f8ba170"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gmx_hw_info_t * gmx::gmx_detect_hardware </td>
          <td>(</td>
          <td class="paramtype">const gmx::MDLogger &amp;&#160;</td>
          <td class="paramname"><em>mdlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const t_commrec *&#160;</td>
          <td class="paramname"><em>cr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run detection, consistency checks, and make available on all ranks. </p>
<p>This routine constructs the global hwinfo structure and returns a pointer to it. It will run a preamble before executing cpu and hardware checks, and then run consistency checks afterwards. The results will also be made available on all nodes. Caller is responsible for calling <a class="el" href="namespacegmx.xhtml#af34312071a6a3659084534504aeef089" title="Free the hwinfo structure. ">gmx_hardware_info_free()</a> when finished. </p>

</div>
</div>
<a class="anchor" id="a33884289d98877477b9fd970da3101b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool gmx::gpuAccelerationOfNonbondedIsUseful </td>
          <td>(</td>
          <td class="paramtype">const MDLogger &amp;&#160;</td>
          <td class="paramname"><em>mdlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const t_inputrec *&#160;</td>
          <td class="paramname"><em>ir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>issueWarning</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether GPU acceleration of nonbondeds is supported with the given settings. </p>
<p>If not, and if a warning may be issued, logs a warning about falling back to CPU code. With thread-MPI, only the first call to this function should have <code>issueWarning</code> true. </p>

</div>
</div>
<a class="anchor" id="a87a820e81baebe1c30a4190eb2aa2a64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t gmx::greatestCommonDivisor </td>
          <td>(</td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find greatest common divisor of two numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>First number, positive </td></tr>
    <tr><td class="paramname">q</td><td>Second number, positive</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Greatest common divisor of p and q </dd></dl>

</div>
</div>
<a class="anchor" id="a0fe4ce4fbd2881cc0c7a1aebfb93cf50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::hardwareTopologyDoubleCheckDetection </td>
          <td>(</td>
          <td class="paramtype">const gmx::MDLogger &amp;&#160;</td>
          <td class="paramname"><em>mdlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gmx::HardwareTopology &amp;&#160;</td>
          <td class="paramname"><em>hardwareTopology</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sanity check hardware topology and print some notes to log. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mdlog</td><td>Logger. </td></tr>
    <tr><td class="paramname">hardwareTopology</td><td>Reference to hardwareTopology object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a94df5cf90664201e85bedaa913dff674"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::hardwareTopologyPrepareDetection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare the system before hardware topology detection. </p>
<p>This routine should perform any actions we want to put the system in a state where we want it to be before detecting the hardware topology. For most processors there is nothing to do, but some architectures (in particular ARM) have support for taking configured cores offline, which will make them disappear from the online processor count.</p>
<p>This routine checks if there is a mismatch between the number of cores configured and online, and in that case we issue a small workload that attempts to wake sleeping cores before doing the actual detection.</p>
<p>This type of mismatch can also occur for x86 or PowerPC on Linux, if SMT has only been disabled in the kernel (rather than bios). Since those cores will never come online automatically, we currently skip this test for x86 &amp; PowerPC to avoid wasting 2 seconds. We also skip the test if there is no thread support.</p>
<dl class="section note"><dt>Note</dt><dd>Cores will sleep relatively quickly again, so it's important to issue the real detection code directly after this routine. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e36f9644573f5a5a187ada06cc52e46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gmx::haveBiasSharingWithinSimulation </td>
          <td>(</td>
          <td class="paramtype">const AwhParams &amp;&#160;</td>
          <td class="paramname"><em>awhParams</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if any bias is sharing within a simulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">awhParams</td><td>The AWH parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6edee513f8fdeaffb9094124f58ba270"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmx::identifyAvx512FmaUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether machine has dual AVX512 FMA units. </p>
<dl class="section return"><dt>Returns</dt><dd>1 or 2 for the number of AVX512 FMA units if AVX512 support is present, 0 if we know the hardware does not have AVX512 support, or -1 if the test cannot run because the compiler lacked AVX512 support. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf6f64a0b469be5da3207e0855763183"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::initCorrelationGridHistory </td>
          <td>(</td>
          <td class="paramtype">CorrelationGridHistory *&#160;</td>
          <td class="paramname"><em>correlationGridHistory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numCorrelationTensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tensorSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockDataListSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize correlation grid history, sets all sizes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">correlationGridHistory</td><td>Correlation grid history for master rank. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numCorrelationTensors</td><td>Number of correlation tensors in the grid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensorSize</td><td>Number of correlation elements in each tensor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockDataListSize</td><td>The number of blocks in the list of each tensor element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa01b9aad76f60c5c887139e4644fd079"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CorrelationGridHistory gmx::initCorrelationGridHistoryFromState </td>
          <td>(</td>
          <td class="paramtype">const CorrelationGrid &amp;&#160;</td>
          <td class="paramname"><em>corrGrid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a correlation grid history with the same structure as the given correlation grid. </p>
<p>This function would be called at the start of a new simulation. Note that only sizes and memory are initialized here. History data is set by <a class="el" href="namespacegmx.xhtml#a25892b094f85a4d534ed625143b489e2">updateCorrelationGridHistory</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">corrGrid</td><td>Correlation grid state to initialize with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correlation grid history struct. </dd></dl>

</div>
</div>
<a class="anchor" id="adc67674eebce1fa4cc561927ba73ccda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool gmx::intervalIsInPeriodicInterval </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given interval is defined in the correct periodic interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">origin</td><td>Start value of interval. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>End value of interval. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>Period (or 0 if not periodic). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the end point values are in the correct periodic interval. </dd></dl>

</div>
</div>
<a class="anchor" id="a6cd74be08263227a2b2f4405dee6a359"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::inv </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/x for float. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be nonzero. This routine does not check arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/x. Result is undefined if your argument was invalid.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ed9172c60ed326ca31f64a490fabe17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::inv </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/x for double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be nonzero. This routine does not check arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/x. Result is undefined if your argument was invalid.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="acabf4874cb58de0554f95f69c1768882"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::invcbrt </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate inverse cube root of x in single precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^(-1/3)</dd></dl>
<p>This routine is typically faster than using std::pow(). </p>

</div>
</div>
<a class="anchor" id="a08d99226376a495b484eccd203d29c8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::invcbrt </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate inverse sixth root of x in double precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^(-1/3)</dd></dl>
<p>This routine is typically faster than using std::pow(). </p>

</div>
</div>
<a class="anchor" id="a1d304cf0e3cac1632695e394077fd2d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::invcbrt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate inverse sixth root of integer x in double precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^(-1/3)</dd></dl>
<p>This routine is typically faster than using std::pow(). </p>

</div>
</div>
<a class="anchor" id="a2c4548b5005dd861681ff13e55e5b6f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::invertBoxMatrix </td>
          <td>(</td>
          <td class="paramtype">const matrix&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert a simulation-box matrix in <code>src</code>, return in <code>dest</code>. </p>
<p>This routine assumes that src is a simulation-box matrix, i.e. has zeroes in the upper-right triangle. A fatal error occurs if the product of the leading diagonal is too small. The inversion can be done "in place", i.e <code>src</code> and <code>dest</code> can be the same matrix. </p>

</div>
</div>
<a class="anchor" id="a2824e7adcb69e96942fefcb67809ec5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::invertMatrix </td>
          <td>(</td>
          <td class="paramtype">const matrix&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert a general 3x3 matrix in <code>src</code>, return in <code>dest</code>. </p>
<p>A fatal error occurs if the determinant is too small. <code>src</code> and <code>dest</code> cannot be the same matrix. </p>

</div>
</div>
<a class="anchor" id="a8ac51c492a5589e075b7b8ebda5a8cbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::invSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/x for double, but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be nonzero. This routine does not check arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/x. Result is undefined if your argument was invalid.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3aeb9a178f07d4bc64b934555d12842"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::invsixthroot </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate inverse sixth root of x in single precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, must be greater than zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^(-1/6)</dd></dl>
<p>This routine is typically faster than using std::pow(). </p>

</div>
</div>
<a class="anchor" id="a2f8b9b01e7c291a443840d4f7af97c5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::invsixthroot </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate inverse sixth root of x in double precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, must be greater than zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^(-1/6)</dd></dl>
<p>This routine is typically faster than using std::pow(). </p>

</div>
</div>
<a class="anchor" id="a1604baa1a44d1de7bafa433c9443c395"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::invsixthroot </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate inverse sixth root of integer x in double precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, must be greater than zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^(-1/6)</dd></dl>
<p>This routine is typically faster than using std::pow(). </p>

</div>
</div>
<a class="anchor" id="a953226d61f6527af6485ea56a8384c85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::invsqrt </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1.0/sqrt(x) in single precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Positive value to calculate inverse square root for</td></tr>
  </table>
  </dd>
</dl>
<p>For now this is implemented with std::sqrt(x) since gcc seems to do a decent job optimizing it. However, we might decide to use instrinsics or compiler-specific functions in the future.</p>
<dl class="section return"><dt>Returns</dt><dd>1.0/sqrt(x) </dd></dl>

</div>
</div>
<a class="anchor" id="ae26d0b65eb141c73979c5d2f1d0e13fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::invsqrt </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1.0/sqrt(x) in double precision, but single range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Positive value to calculate inverse square root for, must be in the input domain valid for single precision.</td></tr>
  </table>
  </dd>
</dl>
<p>For now this is implemented with std::sqrt(x). However, we might decide to use instrinsics or compiler-specific functions in the future, and then we want to have the freedom to do the first step in single precision.</p>
<dl class="section return"><dt>Returns</dt><dd>1.0/sqrt(x) </dd></dl>

</div>
</div>
<a class="anchor" id="aa91cb31b7abc3e020022ac8ce0b1b262"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::invsqrt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1.0/sqrt(x) for integer x in double precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Positive value to calculate inverse square root for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1.0/sqrt(x) </dd></dl>

</div>
</div>
<a class="anchor" id="aba2ac92d9abba8296506e281dc66c47a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::invsqrtPair </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>out1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for two floats. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">x0</td><td>First argument, x0 must be positive - no argument checking. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">x1</td><td>Second argument, x1 must be positive - no argument checking. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out0</td><td>Result 1/sqrt(x0) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out1</td><td>Result 1/sqrt(x1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="abb50fcc000a2c2d4b8446fc17a5695e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::invsqrtPair </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for two doubles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">x0</td><td>First argument, x0 must be positive - no argument checking. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">x1</td><td>Second argument, x1 must be positive - no argument checking. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out0</td><td>Result 1/sqrt(x0) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out1</td><td>Result 1/sqrt(x1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a18f2d71567d1b88689c8498f3592b386"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::invsqrtPairSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for two doubles, but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">x0</td><td>First argument, x0 must be positive - no argument checking. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">x1</td><td>Second argument, x1 must be positive - no argument checking. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out0</td><td>Result 1/sqrt(x0) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out1</td><td>Result 1/sqrt(x1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a44adc739c8fb319abe1b6769f39e9341"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::invsqrtSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for double, but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be &gt;0. This routine does not check arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/sqrt(x). Result is undefined if your argument was invalid.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a1bde42dccd13214cf4944199d9046a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::linearArrayIndexToMultiDim </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indexLinear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const awh_ivec&#160;</td>
          <td class="paramname"><em>numPointsDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">awh_ivec&#160;</td>
          <td class="paramname"><em>indexMulti</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a linear array index to a multidimensional one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indexLinear</td><td>Linear array index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ndim</td><td>Number of dimensions of the array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numPointsDim</td><td>Number of points for each dimension. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indexMulti</td><td>The multidimensional index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4ebe3ce6ae05dc90ba9d59d5e09cb39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::linearGridindexToMultiDim </td>
          <td>(</td>
          <td class="paramtype">const Grid &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indexLinear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">awh_ivec&#160;</td>
          <td class="paramname"><em>indexMulti</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a linear grid point index to a multidimensional one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grid</td><td>The grid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indexLinear</td><td>Linear grid point index to convert to a multidimensional one. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indexMulti</td><td>The multidimensional index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b0a25f25b649f59d96b67f2d73c8ad8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::log </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float log(x). This is the natural logarithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, should be &gt;0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural logarithm of x. Undefined if argument is invalid.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a398a52e25652367446f9180a50343885"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::log </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double log(x). This is the natural logarithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, should be &gt;0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural logarithm of x. Undefined if argument is invalid.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b47d79ef735987258c2f601cf2822be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int gmx::log2I </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute floor of logarithm to base 2, 32 bit unsigned argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>32-bit unsigned argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log2(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This version of the overloaded function uses unsigned arguments to be able to handle arguments using all 32 bits. </dd></dl>

</div>
</div>
<a class="anchor" id="aa498ec06db6575ec672e5ba847f086ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int gmx::log2I </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute floor of logarithm to base 2, 64 bit unsigned argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>64-bit unsigned argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log2(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This version of the overloaded function uses unsigned arguments to be able to handle arguments using all 64 bits. </dd></dl>

</div>
</div>
<a class="anchor" id="ab1cadcfe34ba004506db6e0e11f36c95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int gmx::log2I </td>
          <td>(</td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute floor of logarithm to base 2, 32 bit signed argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>32-bit signed argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log2(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This version of the overloaded function will assert that x is not negative. </dd></dl>

</div>
</div>
<a class="anchor" id="afbfba3f9dd776dc29c1d0a8311ed793f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int gmx::log2I </td>
          <td>(</td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute floor of logarithm to base 2, 64 bit signed argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>64-bit signed argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log2(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This version of the overloaded function will assert that x is not negative. </dd></dl>

</div>
</div>
<a class="anchor" id="a54c2c975d7e597b08a67d85920d4f562"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::logSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double log(x), but with single accuracy. This is the natural logarithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, should be &gt;0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural logarithm of x. Undefined if argument is invalid.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2126967a7118ceb84d92fe263368f71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgmx_1_1ArrayRef.xhtml">ArrayRef</a>&lt;typename std::conditional&lt;std::is_const&lt;T&gt;::value, const typename T::value_type, typename T::value_type&gt;::type&gt; gmx::makeArrayRef </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="classgmx_1_1ArrayRef.xhtml" title="STL-like container for an interface to a C array of T (or part of a std::vector&lt;T, A&gt; or std::array&lt;T&gt;). ">ArrayRef</a> from container with type deduction. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classgmx_1_1ArrayRef.xhtml" title="STL-like container for an interface to a C array of T (or part of a std::vector&lt;T, A&gt; or std::array&lt;T&gt;). ">ArrayRef</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a713215f4358a42b3b59689419203cfcf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgmx_1_1ArrayRef.xhtml">ArrayRef</a>&lt;const typename T::value_type&gt; gmx::makeConstArrayRef </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="classgmx_1_1ArrayRef.xhtml" title="STL-like container for an interface to a C array of T (or part of a std::vector&lt;T, A&gt; or std::array&lt;T&gt;). ">ArrayRef</a> to const T from container with type deduction. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classgmx_1_1ArrayRef.xhtml" title="STL-like container for an interface to a C array of T (or part of a std::vector&lt;T, A&gt; or std::array&lt;T&gt;). ">ArrayRef</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a693d74a839c577c612b44493481a34d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; gmx::makeGpuIds </td>
          <td>(</td>
          <td class="paramtype">ArrayRef&lt; const int &gt;&#160;</td>
          <td class="paramname"><em>compatibleGpus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numGpuTasks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a vector containing <code>numGpuTasks</code> IDs of the IDs found in <code>compatibleGpus</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If out of memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sorted vector of IDs of compatible vectors, whose length matches that of the number of GPU tasks required. </dd></dl>

</div>
</div>
<a class="anchor" id="a28940788cd491e2248aa6345eb2ad94c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string gmx::makeGpuIdString </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpuIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>totalNumberOfTasks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a container of GPU deviced IDs to a string that can be used by gmx tune_pme as input to mdrun -gputasks. </p>
<p>Produce a valid input for mdrun -gputasks that refers to the device IDs in <code>gpuIds</code> but produces a mapping for <code>totalNumberOfTasks</code> tasks. Note that gmx tune_pme does not currently support filling mdrun -gputasks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gpuIds</td><td>Container of device IDs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">totalNumberOfTasks</td><td>Total number of tasks for the output mapping produced by the returned string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string that is suitable to pass to mdrun -gputasks.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If out of memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ce4feb63a64730e6c502fd902437e2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; MDAtoms &gt; gmx::makeMDAtoms </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gmx_mtop_t &amp;&#160;</td>
          <td class="paramname"><em>mtop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const t_inputrec &amp;&#160;</td>
          <td class="paramname"><em>ir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGpuForPme</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builder function for MdAtomsWrapper. </p>
<p>Builder function. </p>

</div>
</div>
<a class="anchor" id="a8ddacc94505a46b63d40a995556cef32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gmx_uint64_t gmx::makeRandomSeed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return 64 random bits from the random device, suitable as seed. </p>
<p>If the internal random device output is smaller than 64 bits, this routine will use multiple calls internally until we have 64 bits of random data.</p>
<dl class="section return"><dt>Returns</dt><dd>64-bit unsigned integer with random bits. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a5f6c6b181970bbba2ecf4d61f49b4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::mapGridToDataGrid </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>gridpointToDatapoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numDataPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dataFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Grid &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>correctFormatMessage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps each point in the grid to a point in the data grid. </p>
<p>This functions maps an AWH bias grid to a user provided input data grid. The value of data grid point i along dimension d is given by data[d][i]. The number of dimensions of the data should equal that of the grid. A fatal error is thrown if extracting the data fails or the data does not cover the whole grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">gridpointToDatapoint</td><td>Array mapping each grid point to a data point index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>2D array in format ndim x ndatapoints with data grid point values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numDataPoints</td><td>Number of data points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataFilename</td><td>The data filename. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grid</td><td>The grid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">correctFormatMessage</td><td>String to include in error message if extracting the data fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0178a127dde331652ab015323ae622f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::maskAdd </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add two float variables, masked version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>term1 </td></tr>
    <tr><td class="paramname">b</td><td>term2 </td></tr>
    <tr><td class="paramname">m</td><td>mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a+b where mask is true, a otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a68b090d0e3ab5695c508453406ee43c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::maskAdd </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add two double variables, masked version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>term1 </td></tr>
    <tr><td class="paramname">b</td><td>term2 </td></tr>
    <tr><td class="paramname">m</td><td>mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a+b where mask is true, a otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a8151e61ef06e30e360c03bba6fb5e2ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::maskzFma </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float fused multiply-add, masked version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
    <tr><td class="paramname">m</td><td>mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a*b+c where mask is true, 0.0 otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aa3cf4eaad108887d2462f5beecd4db62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::maskzFma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>double fused multiply-add, masked version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
    <tr><td class="paramname">m</td><td>mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a*b+c where mask is true, 0.0 otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a582d71ff8e7d51cbd2386e29935e89ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::maskzInv </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/x for masked entry of float. </p>
<p>This routine only evaluates 1/x if mask is true. Illegal values for a masked-out float will not lead to floating-point exceptions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be nonzero if masked-in. </td></tr>
    <tr><td class="paramname">m</td><td>Mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/x. Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="af5cc89f64ab845f88816a9cbb16d467c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::maskzInv </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/x for masked entry of double. </p>
<p>This routine only evaluates 1/x if mask is true. Illegal values for a masked-out double will not lead to floating-point exceptions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be nonzero if masked-in. </td></tr>
    <tr><td class="paramname">m</td><td>Mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/x. Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a2433c82892495a73bf41de15f5e8908f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::maskzInvSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/x for masked entry of double, but with single accuracy. </p>
<p>This routine only evaluates 1/x if mask is true. Illegal values for a masked-out double will not lead to floating-point exceptions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be nonzero if masked-in. </td></tr>
    <tr><td class="paramname">m</td><td>Mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/x. Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aa182f9ceead92b3055e6ae5903994651"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::maskzInvsqrt </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for masked entry of float. </p>
<p>This routine only evaluates 1/sqrt(x) if mask is true. Illegal values for a masked-out float will not lead to floating-point exceptions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be &gt;0 if masked-in. </td></tr>
    <tr><td class="paramname">m</td><td>Mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/sqrt(x). Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5b5a9766964a2b854f493fd783bb63d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::maskzInvsqrt </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for masked entry of double. </p>
<p>This routine only evaluates 1/sqrt(x) if mask is true. Illegal values for a masked-out double will not lead to floating-point exceptions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be &gt;0 if masked-in. </td></tr>
    <tr><td class="paramname">m</td><td>Mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/sqrt(x). Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a1fdaf91102db0bfbc6fd440524b15199"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::maskzInvsqrtSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for masked entry of double, but with single accuracy. </p>
<p>This routine only evaluates 1/sqrt(x) if mask is true. Illegal values for a masked-out double will not lead to floating-point exceptions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be &gt;0 if masked-in. </td></tr>
    <tr><td class="paramname">m</td><td>Mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/sqrt(x). Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e3c4084e25d298f95003df8e9aeffa1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::maskzMul </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two float variables, masked version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">m</td><td>mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a*b where mask is true, 0.0 otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e4ab8b1ab046ff242d32ab93366bfde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::maskzMul </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two double variables, masked version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">m</td><td>mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a*b where mask is true, 0.0 otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a35c7b010fbd32f5424afa0de0c70db6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::max </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set each float element to the largest from two variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Any floating-point value </td></tr>
    <tr><td class="paramname">b</td><td>Any floating-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>max(a,b) for each element.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a16f6bf4a20b14262f28168596d5bb8b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::max </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set each double element to the largest from two variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Any doubleing-point value </td></tr>
    <tr><td class="paramname">b</td><td>Any doubleing-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>max(a,b) for each element.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aae43945530feb98492481e64f0bc5256"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::mdrunner_start_fn </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The callback used for running on spawned threads. </p>
<p>Obtains the pointer to the master mdrunner object from the one argument permitted to the thread-launch API call, copies it to make a new runner for this thread, reinitializes necessary data, and proceeds to the simulation. </p>

</div>
</div>
<a class="anchor" id="aa6d21dccd9a94698363bdb1943f139bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::min </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set each float element to the smallest from two variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Any floating-point value </td></tr>
    <tr><td class="paramname">b</td><td>Any floating-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>min(a,b) for each element.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a65fb0c7aa84962905d3d78a913c787c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::min </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set each double element to the smallest from two variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Any doubleing-point value </td></tr>
    <tr><td class="paramname">b</td><td>Any doubleing-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>min(a,b) for each element.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d3c14f0aeb1baca8c9c7e874f83a9ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmx::multiDimArrayIndexToLinear </td>
          <td>(</td>
          <td class="paramtype">const awh_ivec&#160;</td>
          <td class="paramname"><em>indexMulti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const awh_ivec&#160;</td>
          <td class="paramname"><em>numPointsDim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert multidimensional array index to a linear one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indexMulti</td><td>Multidimensional index to convert to a linear one. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numDim</td><td>Number of dimensions of the array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numPointsDim</td><td>Number of points of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the linear index. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function can be used without having an initialized grid. </dd></dl>

</div>
</div>
<a class="anchor" id="adf57aec6fb404cfd80fef4fb95610f49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmx::multiDimGridIndexToLinear </td>
          <td>(</td>
          <td class="paramtype">const Grid &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const awh_ivec&#160;</td>
          <td class="paramname"><em>indexMulti</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a multidimensional grid point index to a linear one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grid</td><td>The grid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indexMulti</td><td>Multidimensional grid point index to convert to a linear one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the linear index. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ffeb99198d2e37e902971b17a673a47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::niceHeader </td>
          <td>(</td>
          <td class="paramtype">TextWriter *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>commentChar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints creation time stamp and user information into a string as comments, and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">writer</td><td>Where to print the information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>Name of the file being written; if nullptr, described as "unknown". </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commentChar</td><td>Character to use as the starting delimiter for comments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if out of memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70bac9d01a06d35dc45d86a6bdba4f06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::normalizeBlock </td>
          <td>(</td>
          <td class="paramtype">AwhEnergyBlock *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Bias &amp;&#160;</td>
          <td class="paramname"><em>bias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalizes block data for output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block</td><td>The block to normalize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bias</td><td>The AWH bias. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac1a9213632dd1a11d0ad5eb64eb211cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::normalizeFreeEnergyAndPmfSum </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; PointState &gt; *&#160;</td>
          <td class="paramname"><em>pointState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalizes the free energy and PMF sum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pointState</td><td>The state of the points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0657ab84cdeab81eb449859ff086bcd6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t gmx::paddedRVecVectorSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numAtoms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the padded size for PaddedRVecVector given the number of atoms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numAtoms</td><td>The number of atoms for which data will be stored in a PaddedRVecVector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a41f63c30185ee31c10a30e46b7d53f9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t gmx::pageSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the memory page size on this system. </p>
<p>Implements the "construct on first use" idiom to avoid the static initialization order fiasco where a possible static page-aligned container would be initialized before the alignment variable was.</p>
<p>Note that thread-safety is guaranteed by the C++11 language standard. </p>

</div>
</div>
<a class="anchor" id="aeb0488b32fffa77eb0a4b7644546037b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; gmx::parseUserGpuIds </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>gpuIdString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a GPU ID string into a container describing the task types and associated device IDs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gpuIdString</td><td>String like "013" or "0,1,3" typically supplied by the user to mdrun -gpu_id or -gputasks. Must contain only decimal digits, or only decimal digits separated by comma delimiters. A terminal comma is accceptable (and required to specify a single ID that is larger than 9).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of GPU ID task mappings, like { 0, 1, 3 }</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If out of memory. <a class="el" href="classgmx_1_1InvalidInputError.xhtml" title="Exception class for situations where user input cannot be parsed/understood. ">InvalidInputError</a> If an invalid character is found (ie not a digit or ','). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7baa17fdd5339a2faa2e0427bde6dea9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::pinBuffer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pin the allocation to physical memory. </p>
<p>Requires that <code>pointer</code> is not nullptr.</p>
<p>Does not throw. </p>

</div>
</div>
<a class="anchor" id="a1e5b1230d0301fa6760e34d7641ca7e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::pmeForceCorrection </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the force correction due to PME analytically in float. </p>
<p>See the SIMD version of this function for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z2</td><td>input parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Correction to use on force</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a5275f264f1c6da2502ec03e8fbf855a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::pmeForceCorrection </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the force correction due to PME analytically in double. </p>
<p>See the SIMD version of this function for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z2</td><td>input parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Correction to use on force</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="abd18f07b8fd19f03f12442211982db53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::pmeForceCorrectionSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force correction due to PME in double, but with single accuracy. </p>
<p>See the SIMD version of this function for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z2</td><td>input parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Correction to use on force</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ac54e81f11cb53c7d68ff7dab05bd6afd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::pmePotentialCorrection </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the potential correction due to PME analytically in float. </p>
<p>See the SIMD version of this function for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z2</td><td>input parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Correction to use on potential.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="acba0166c05fec69dd4a2624ed8dcff95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::pmePotentialCorrection </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the potential correction due to PME analytically in double. </p>
<p>See the SIMD version of this function for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z2</td><td>input parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Correction to use on potential.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8004b2507f7192ead653fcdcb6735fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::pmePotentialCorrectionSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Potential correction due to PME in double, but with single accuracy. </p>
<p>See the SIMD version of this function for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z2</td><td>input parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Correction to use on potential.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a9980e0f1eac7ff209652d8cecb1eca36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int gmx::pointDistanceAlongAxis </td>
          <td>(</td>
          <td class="paramtype">const GridAxis &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the point distance between from value x to value x0 along the given axis. </p>
<p>Note that the returned distance may be negative or larger than the number of points in the axis. For a periodic axis, the distance is chosen to be in [0, period), i.e. always positive but not the shortest one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">axis</td><td>Grid axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>From value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x0</td><td>To value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(x - x0) in number of points. </dd></dl>

</div>
</div>
<a class="anchor" id="a800ac84e9ee71a2dc0eedda74bea1513"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T gmx::power12 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate x^12 </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of argument and return value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^12 </dd></dl>

</div>
</div>
<a class="anchor" id="abda6daf50f5129fb74816db29e411497"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T gmx::power3 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate x^3 </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of argument and return value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^3 </dd></dl>

</div>
</div>
<a class="anchor" id="a304b15bae3a2a8277f686d4dfc9fa946"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T gmx::power4 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate x^4 </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of argument and return value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^4 </dd></dl>

</div>
</div>
<a class="anchor" id="a4bb914d3b8bf083485bb26c88d2b9dda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T gmx::power5 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate x^5 </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of argument and return value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^5 </dd></dl>

</div>
</div>
<a class="anchor" id="aab162c4ba231de5ffbfc62dc3803e8ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T gmx::power6 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate x^6 </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of argument and return value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^6 </dd></dl>

</div>
</div>
<a class="anchor" id="aff67fcd64bdaa64a3823cc1a322a6783"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::printBinaryInformation </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IProgramContext &amp;&#160;</td>
          <td class="paramname"><em>programContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print basic information about the executable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">fp</td><td>Where to print the information to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">programContext</td><td>Program information object to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0c6bc3dc4ee812f31a6076c7d4f42a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::printBinaryInformation </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IProgramContext &amp;&#160;</td>
          <td class="paramname"><em>programContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BinaryInformationSettings &amp;&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print basic information about the executable with custom settings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">fp</td><td>Where to print the information to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">programContext</td><td>Program information object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">settings</td><td>Specifies what to print.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>BinaryInformationSettings </dd></dl>

</div>
</div>
<a class="anchor" id="a0ea11527285a0547aafa0ee27c4f4817"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::printBinaryInformation </td>
          <td>(</td>
          <td class="paramtype">TextWriter *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IProgramContext &amp;&#160;</td>
          <td class="paramname"><em>programContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BinaryInformationSettings &amp;&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print basic information about the executable with custom settings. </p>
<p>Needed to read the members without otherwise unnecessary accessors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">writer</td><td>Where to print the information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">programContext</td><td>Program information object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">settings</td><td>Specifies what to print. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if out of memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>BinaryInformationSettings </dd></dl>

</div>
</div>
<a class="anchor" id="ad8fe34835a6e197f2731e7d604f28992"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmx::processExceptionAtExitForCommandLine </td>
          <td>(</td>
          <td class="paramtype">const std::exception &amp;&#160;</td>
          <td class="paramname"><em>ex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles an exception and deinitializes after initForCommandLine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ex</td><td>Exception that is the cause for terminating the program. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return code to return from <a class="el" href="template_8cpp.xhtml#a0ddf1224851353fc92bfbff6f499fa97" title="The main function for the analysis template. ">main()</a>.</dd></dl>
<p>This method should be called as the last thing before terminating the program because of an exception. See <a class="el" href="group__module__utility.xhtml#ga5a45f49e157fa8e1059d24243283e248" title="Handles an exception that is causing the program to terminate. ">processExceptionAtExit()</a> for details. Additionally this method undoes the work done by initForCommandLine.</p>
<p>Does not throw. </p>

</div>
</div>
<a class="anchor" id="af9efd8200514249693d8d5e78b365d02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::read_bias_params </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ninp_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_inpfile **&#160;</td>
          <td class="paramname"><em>inp_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AwhBiasParams *&#160;</td>
          <td class="paramname"><em>awhBiasParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const t_inputrec *&#160;</td>
          <td class="paramname"><em>ir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">warninp_t&#160;</td>
          <td class="paramname"><em>wi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bComment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read parameters of an AWH bias. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ninp_p</td><td>Number of read input file entries. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">inp_p</td><td>Input file entries. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">awhBiasParams</td><td>AWH dimensional parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>Prefix for bias parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ir</td><td>Input parameter struct. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">wi</td><td>Struct for bookeeping warnings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bComment</td><td>True if comments should be printed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0b1ab815522d5c19977d39108b4d5e8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AwhParams * gmx::readAndCheckAwhParams </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ninp_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_inpfile **&#160;</td>
          <td class="paramname"><em>inp_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const t_inputrec *&#160;</td>
          <td class="paramname"><em>inputrec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">warninp_t&#160;</td>
          <td class="paramname"><em>wi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate, initialize and check the AWH parameters with values from the input file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ninp_p</td><td>Number of read input file entries. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">inp_p</td><td>Input file entries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputrec</td><td>Input parameter struct. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">wi</td><td>Struct for bookeeping warnings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AWH parameters. </dd></dl>

</div>
</div>
<a class="anchor" id="a106f95fbad0f5e464f5af96026421175"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::readDimParams </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ninp_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_inpfile **&#160;</td>
          <td class="paramname"><em>inp_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AwhDimParams *&#160;</td>
          <td class="paramname"><em>dimParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pull_params_t *&#160;</td>
          <td class="paramname"><em>pull_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">warninp_t&#160;</td>
          <td class="paramname"><em>wi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bComment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read parameters of an AWH bias dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ninp_p</td><td>Number of read input file entries. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">inp_p</td><td>Input file entries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>Prefix for dimension parameters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dimParams</td><td>AWH dimensional parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pull_params</td><td>Pull parameters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">wi</td><td>Struct for bookeeping warnings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bComment</td><td>True if comments should be printed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac89c1ec80da5f3b1d759be2ce01993fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::readUserPmfAndTargetDistribution </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; DimParams &gt; &amp;&#160;</td>
          <td class="paramname"><em>dimParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Grid &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numBias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>biasIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PointState &gt; *&#160;</td>
          <td class="paramname"><em>pointState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the PMF and target with data read from an input table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dimParams</td><td>The dimension parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grid</td><td>The grid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The filename to read PMF and target from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numBias</td><td>Number of biases. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">biasIndex</td><td>The index of the bias. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pointState</td><td>The state of the points in this bias. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4a37558328ab029203170ad4c6c4d01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::reduce </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return sum of all elements in float variable (i.e., the variable itself). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>variable to reduce/sum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The argument variable itself.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a157983d90620412d404e8a77d1ddbd0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::reduce </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return sum of all elements in double variable (i.e., the variable itself). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>variable to reduce/sum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The argument variable itself.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a6eac2eb3581affdefb5b3e79e000cf84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::reduceIncr4ReturnSum </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add each float to four consecutive memory locations, return sum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Pointer to memory where four floats should be incremented </td></tr>
    <tr><td class="paramname">v0</td><td>float to be added to m[0] </td></tr>
    <tr><td class="paramname">v1</td><td>float to be added to m[1] </td></tr>
    <tr><td class="paramname">v2</td><td>float to be added to m[2] </td></tr>
    <tr><td class="paramname">v3</td><td>float to be added to m[3]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>v0+v1+v2+v3.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="afdd8c33571b1296598b509d30d254bac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::reduceIncr4ReturnSum </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add each double to four consecutive memory locations, return sum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Pointer to memory where four floats should be incremented </td></tr>
    <tr><td class="paramname">v0</td><td>double to be added to m[0] </td></tr>
    <tr><td class="paramname">v1</td><td>double to be added to m[1] </td></tr>
    <tr><td class="paramname">v2</td><td>double to be added to m[2] </td></tr>
    <tr><td class="paramname">v3</td><td>double to be added to m[3]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>v0+v1+v2+v3.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e7149c73e79faf42117ef7006229094"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::reportGpuUsage </td>
          <td>(</td>
          <td class="paramtype">const MDLogger &amp;&#160;</td>
          <td class="paramname"><em>mdlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>userSetGpuIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GpuTaskAssignments &amp;&#160;</td>
          <td class="paramname"><em>gpuTaskAssignmentOnRanksOfThisNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numGpuTasksOnThisNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numPpRanks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPrintHostName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Log a report on how GPUs are being used on the ranks of the physical node of rank 0 of the simulation. </p>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000052">Todo:</a></b></dt><dd>It could be useful to report also whether any nodes differed, and in what way.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mdlog</td><td>Logging object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userSetGpuIds</td><td>Whether the user selected the GPU ids </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gpuTaskAssignmentOnRanksOfThisNode</td><td>The selected GPU IDs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numGpuTasksOnThisNode</td><td>The number of GPU tasks on this node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numPpRanks</td><td>Number of PP ranks on this node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bPrintHostName</td><td>Print the hostname in the usage information</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if out of memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf507d7b44182c8c37cbcd937c1c7599"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::restoreCorrelationGridStateFromHistory </td>
          <td>(</td>
          <td class="paramtype">const CorrelationGridHistory &amp;&#160;</td>
          <td class="paramname"><em>corrGridHist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CorrelationGrid *&#160;</td>
          <td class="paramname"><em>corrGrid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restores the correlation grid state from the correlation grid history. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">corrGridHist</td><td>Correlation grid history to read. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">corrGrid</td><td>Correlation grid state to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c0a061335a242530d8d791459a8e2d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::round </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float round to nearest integer value (in floating-point format). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Any floating-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The nearest integer, represented in floating-point format.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a15179b513c1ec4ec0b9090e57b76bac4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::round </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>double round to nearest integer value (in doubleing-point format). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Any doubleing-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The nearest integer, represented in doubleing-point format.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a3bc0e66dda7e48091ad129bede7eff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmx::runCommandLineModule </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICommandLineModule *&#160;</td>
          <td class="paramname"><em>module</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements a <a class="el" href="template_8cpp.xhtml#a0ddf1224851353fc92bfbff6f499fa97" title="The main function for the analysis template. ">main()</a> method that runs a single module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td><code>argc</code> passed to <a class="el" href="template_8cpp.xhtml#a0ddf1224851353fc92bfbff6f499fa97" title="The main function for the analysis template. ">main()</a>. </td></tr>
    <tr><td class="paramname">argv</td><td><code>argv</code> passed to <a class="el" href="template_8cpp.xhtml#a0ddf1224851353fc92bfbff6f499fa97" title="The main function for the analysis template. ">main()</a>. </td></tr>
    <tr><td class="paramname">module</td><td>Module to run.</td></tr>
  </table>
  </dd>
</dl>
<p>This method allows for uniform behavior for binaries that only contain a single module without duplicating any of the implementation from CommandLineModuleManager (startup headers, common options etc.).</p>
<p>The signature assumes that <code>module</code> construction does not throw (because otherwise the caller would need to duplicate all the exception handling code). It is possible to move the construction inside the try/catch in this method using an indirection similar to <a class="el" href="classgmx_1_1TrajectoryAnalysisCommandLineRunner.xhtml#a12cd1b40ed04cda667f315e2adee3337" title="Implements a main() method that runs a given module. ">TrajectoryAnalysisCommandLineRunner::runAsMain()</a>, but until that is necessary, the current approach leads to simpler code.</p>
<p>Usage: </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="template_8cpp.xhtml#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">    CustomCommandLineModule module;</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespacegmx.xhtml#a5a3bc0e66dda7e48091ad129bede7eff">gmx::runCommandLineModule</a>(argc, argv, &amp;module);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Does not throw. All exceptions are caught and handled internally. </p>

</div>
</div>
<a class="anchor" id="a8a7a039b6fae746686d472d1fcae6fee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmx::runCommandLineModule </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; std::unique_ptr&lt; ICommandLineOptionsModule &gt;()&gt;&#160;</td>
          <td class="paramname"><em>factory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements a <a class="el" href="template_8cpp.xhtml#a0ddf1224851353fc92bfbff6f499fa97" title="The main function for the analysis template. ">main()</a> method that runs a single module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">argc</td><td><code>argc</code> passed to <a class="el" href="template_8cpp.xhtml#a0ddf1224851353fc92bfbff6f499fa97" title="The main function for the analysis template. ">main()</a>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">argv</td><td><code>argv</code> passed to <a class="el" href="template_8cpp.xhtml#a0ddf1224851353fc92bfbff6f499fa97" title="The main function for the analysis template. ">main()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name for the module. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">description</td><td>Short description for the module. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">factory</td><td>Factory method that creates the module to run.</td></tr>
  </table>
  </dd>
</dl>
<p>This method allows for uniform behavior for binaries that only contain a single module without duplicating any of the implementation from CommandLineModuleManager (startup headers, common options etc.).</p>
<p>Usage: </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>CustomCommandLineOptionsModule : <span class="keyword">public</span> ICommandLineOptionsModule</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// &lt;...&gt;</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> ICommandLineOptionsModule *create()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> CustomCommandLineOptionsModule();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="template_8cpp.xhtml#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespacegmx.xhtml#a5a3bc0e66dda7e48091ad129bede7eff">gmx::runCommandLineModule</a>(</div>
<div class="line">            argc, argv, <span class="stringliteral">&quot;mymodule&quot;</span>, <span class="stringliteral">&quot;short description&quot;</span>, &amp;create);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Does not throw. All exceptions are caught and handled internally. </p>

</div>
</div>
<a class="anchor" id="a218bc5f1c3fae33c282582464914ca59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GpuTaskAssignments::value_type gmx::runTaskAssignment </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpuIdsToUse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>userGpuTaskAssignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gmx_hw_info_t &amp;&#160;</td>
          <td class="paramname"><em>hardwareInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MDLogger &amp;&#160;</td>
          <td class="paramname"><em>mdlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const t_commrec *&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; GpuTask &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpuTasksOnThisRank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coordinate the final stages of task assignment and reporting, and return the assignment for this rank. </p>
<p>Communicates between ranks on a node to coordinate task assignment between them onto available hardware, e.g. accelerators.</p>
<p>Releases the taskAssigner once its work is complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gpuIdsToUse</td><td>The compatible GPUs that the user permitted us to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userGpuTaskAssignment</td><td>The user-specified assignment of GPU tasks to device IDs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hardwareInfo</td><td>The detected hardware </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mdlog</td><td>Logging object to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cr</td><td>Communication object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gpuTasksOnThisRank</td><td>Information about what GPU tasks exist on this rank.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GPU task assignment for this rank.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If out of memory. <a class="el" href="classgmx_1_1InconsistentInputError.xhtml" title="Exception class for situations where user input is inconsistent. ">InconsistentInputError</a> If user and/or detected inputs are inconsistent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af47eb155075f6f9aa99ecca11825b021"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::selectByMask </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select from single precision variable where boolean is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Floating-point variable to select from </td></tr>
    <tr><td class="paramname">mask</td><td>Boolean selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a is selected for true, 0 for false.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1449de9307a87e0c5946fd9cab43b35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::selectByMask </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select from double precision variable where boolean is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>double variable to select from </td></tr>
    <tr><td class="paramname">mask</td><td>Boolean selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a is selected for true, 0 for false.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a543420229312467871aaa26ea79f5a5d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::int32_t gmx::selectByMask </td>
          <td>(</td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select from integer variable where boolean is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Integer variable to select from </td></tr>
    <tr><td class="paramname">mask</td><td>Boolean selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a is selected for true, 0 for false.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a76f8ccf8f582242260b4e785ebf48e3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::selectByNotMask </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select from single precision variable where boolean is false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Floating-point variable to select from </td></tr>
    <tr><td class="paramname">mask</td><td>Boolean selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a is selected for false, 0 for true.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f03ad3380ef6213c5459051c3268ba7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::selectByNotMask </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select from double precision variable where boolean is false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>double variable to select from </td></tr>
    <tr><td class="paramname">mask</td><td>Boolean selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a is selected for false, 0 for true.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1c7d81b9ba8302dadcbdded4fcd4399"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::int32_t gmx::selectByNotMask </td>
          <td>(</td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select from integer variable where boolean is false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Integer variable to select from </td></tr>
    <tr><td class="paramname">mask</td><td>Boolean selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a is selected for false, 0 for true.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a92d3eb4aaecff5c613995ed4bce22a0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> gmx::series_sinhx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maclaurin series for sinh(x)/x. </p>
<p>Used for NH chains and MTTK pressure control. Here, we compute it to 10th order, which might be an overkill. 8th is probably enough, but it's not very much more expensive. </p>

</div>
</div>
<a class="anchor" id="a106cb113fd73e054dbb8dfa2118d7153"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::setLibraryFileFinder </td>
          <td>(</td>
          <td class="paramtype">const DataFileFinder *&#160;</td>
          <td class="paramname"><em>finder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a finder for location data files from share/top/. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">finder</td><td>finder to set (can be NULL to restore the default finder).</td></tr>
  </table>
  </dd>
</dl>
<p>The library does not take ownership of <code>finder</code>. The provided object must remain valid until the global instance is changed by another call to <a class="el" href="namespacegmx.xhtml#a106cb113fd73e054dbb8dfa2118d7153" title="Sets a finder for location data files from share/top/. ">setLibraryFileFinder()</a>.</p>
<p>The global instance is used by <a class="el" href="futil_8h.xhtml#a07349956250b160526d32b00d15a544c" title="Finds full path for a library file. ">gmxlibfn()</a> and <a class="el" href="futil_8h.xhtml#a5be6c498c4e4820ead110d48b4587210" title="Opens a library file for reading. ">libopen()</a>.</p>
<p>This method is not thread-safe. See <a class="el" href="group__module__utility.xhtml#ga2cf34635c815cc712b6291c2c8da2555" title="Sets the global IProgramContext instance. ">setProgramContext()</a>; the same constraints apply here as well.</p>
<p>Does not throw. </p>

</div>
</div>
<a class="anchor" id="aff25434ee8b48eac9e2d95c5ebbbaf87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::setStateDependentAwhParams </td>
          <td>(</td>
          <td class="paramtype">AwhParams *&#160;</td>
          <td class="paramname"><em>awhParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pull_params_t *&#160;</td>
          <td class="paramname"><em>pull_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pull_t *&#160;</td>
          <td class="paramname"><em>pull_work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ePBC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const t_grpopts *&#160;</td>
          <td class="paramname"><em>inputrecGroupOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">warninp_t&#160;</td>
          <td class="paramname"><em>wi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets AWH parameters that need state parameters such as the box vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">awhParams</td><td>AWH parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pull_params</td><td>Pull parameters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pull_work</td><td>Pull working struct to register AWH bias in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>Box vectors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ePBC</td><td>Periodic boundary conditions enum. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputrecGroupOptions</td><td>Parameters for atom groups. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">wi</td><td>Struct for bookeeping warnings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function currently relies on the function set_pull_init to have been called. </dd></dl>

</div>
</div>
<a class="anchor" id="a073963d19e7e6337168de8dc0005b7e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::simdPrefetch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prefetch memory at address m. </p>
<p>This typically prefetches one cache line of memory from address m, usually 64bytes or more, but the exact amount will depend on the implementation. On many platforms this is simply a no-op. Technically it might not be part of the SIMD instruction set, but since it is a hardware-specific function that is normally only used in tight loops where we also apply SIMD, it fits well here.</p>
<p>There are no guarantees about the level of cache or temporality, but usually we expect stuff to end up in level 2, and be used in a few hundred clock cycles, after which it stays in cache until evicted (normal caching).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Pointer to location prefetch. There are no alignment requirements, but if the pointer is not aligned the prefetch might start at the lower cache line boundary (meaning fewer bytes are prefetched). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af85c54a566c85f916aaa2561d12fa851"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::sin </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float sin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate sin for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sin(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a6579216abaac018cb0bc59e9183f99ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::sin </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double sin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate sin for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sin(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a3191310c1a122aafe946f0caf2fdf364"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::sincos </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>sinval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>cosval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float sin &amp; cos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">x</td><td>The argument to evaluate sin/cos for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sinval</td><td>Sin(x) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cosval</td><td>Cos(x)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a5923534ff59a386ae0579eb4196b1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::sincos </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>sinval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>cosval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double sin &amp; cos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">x</td><td>The argument to evaluate sin/cos for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sinval</td><td>Sin(x) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cosval</td><td>Cos(x)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a200455e2d7401d66cac8e39b4c8142bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::sincosSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>sinval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>cosval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double sin &amp; cos, but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">x</td><td>The argument to evaluate sin/cos for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sinval</td><td>Sin(x) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cosval</td><td>Cos(x)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a810c7b2f5d8f267f421f2c59a308c11d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::sinSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double sin, but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate sin for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sin(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a12dcc6af3bf2f769ea1e17ed12921e2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::sixthroot </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate sixth root of x in single precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, must be greater than or equal to zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^(1/6)</dd></dl>
<p>This routine is typically faster than using std::pow(). </p>

</div>
</div>
<a class="anchor" id="a4cf2628e4b20455d3396e0c2c234b951"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::sixthroot </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate sixth root of x in double precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, must be greater than or equal to zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^(1/6)</dd></dl>
<p>This routine is typically faster than using std::pow(). </p>

</div>
</div>
<a class="anchor" id="a02308efcb527a69ce399111550575880"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::sixthroot </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate sixth root of integer x, return double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, must be greater than or equal to zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^(1/6)</dd></dl>
<p>This routine is typically faster than using std::pow(). </p>

</div>
</div>
<a class="anchor" id="a5dd311127349695578cbf6fd8d1e0c0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::spinUpCore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility that does dummy computing for max 2 seconds to spin up cores. </p>
<p>This routine will check the number of cores configured and online (using sysconf), and the spins doing dummy compute operations for up to 2 seconds, or until all cores have come online. This can be used prior to hardware detection for platforms that take unused processors offline.</p>
<p>This routine will not throw exceptions. </p>

</div>
</div>
<a class="anchor" id="acaecef21922df570fac2ce44fd7d5566"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MathOptimization opt = MathOptimization::Safe&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::sqrt </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float sqrt(x). This is the square root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, should be &gt;= 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square root of x. Undefined if argument is invalid.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aabc4e2ff8f9541e36f13fa579be8c7c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MathOptimization opt = MathOptimization::Safe&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::sqrt </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double sqrt(x). This is the square root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, should be &gt;= 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square root of x. Undefined if argument is invalid.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d6d95fd83052d09775c976a961eee29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::sqrtSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate sqrt(x) for double, but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be &gt;=0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sqrt(x).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a06cbcb5324f3eb428189024f020158ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T gmx::square </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate x^2 </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of argument and return value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x^2 </dd></dl>

</div>
</div>
<a class="anchor" id="a5ba56cff453ff9a1f21a11d72358592a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::store </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store contents of float variable to aligned memory m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>Pointer to memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>float variable to store</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aea1d0d7a9f81e8e5cac19a3b66f0170e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::store </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store contents of double variable to aligned memory m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>Pointer to memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>double variable to store</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aa169afcbfb3992ab9fde1ed5beee8b06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::store </td>
          <td>(</td>
          <td class="paramtype">std::int32_t *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store contents of integer variable to aligned memory m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>Pointer to memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>integer variable to store</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="af3a3dcd7322b5b2555938fe1c05be15f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::storeU </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store contents of float variable to unaligned memory m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>Pointer to memory, no alignment requirement. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>float variable to store.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="aea9644fa777bc5e47ff9d3e2bdde34e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::storeU </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store contents of double variable to unaligned memory m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>Pointer to memory, no alignment requirement. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>double variable to store.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a43354d3d210193bcf5316234dc7d93ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::storeU </td>
          <td>(</td>
          <td class="paramtype">std::int32_t *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store contents of integer variable to unaligned memory m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>Pointer to memory, no alignment requirement. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>integer variable to store.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a7063173231453ec737688c8d91aa0749"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::tan </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float tan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate tan for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tan(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a45e727a4960ac7f8ba5149f9b251c520"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::tan </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double tan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate tan for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tan(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f979f3defa4f725cfce2d7e93fc0d9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::tanSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double tan, but with single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate tan for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tan(x)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="af6a3628d9b9ddc7900590f963be7bbf0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool gmx::testBits </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any bits are set in the float variable. </p>
<p>This function is used to handle bitmasks, mainly for exclusions in the inner kernels. Note that it will return true even for -0.0f (sign bit set), so it is not identical to not-equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any bit in a is nonzero.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ae58ba299df96ee6c45043e646a1d01dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool gmx::testBits </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any bits are set in the double variable. </p>
<p>This function is used to handle bitmasks, mainly for exclusions in the inner kernels. Note that it will return true even for -0.0 (sign bit set), so it is not identical to not-equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any bit in a is nonzero.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2a03b61db6a3ed3e8c2d5e1b3acc9a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool gmx::testBits </td>
          <td>(</td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any bits are set in the integer variable. </p>
<p>This function is used to handle bitmasks, mainly for exclusions in the inner kernels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any bit in a is nonzero.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="af7e302c7dcfb8d4937c4388d77057435"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::transposeScatterDecrU </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract 3 floats from base/offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Offset to the start of triplet. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v0</td><td>1st value, subtracted from base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v1</td><td>2nd value, subtracted from base[align*offset[0] + 1]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v2</td><td>3rd value, subtracted from base[align*offset[0] + 2].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a812731a42d1358e6a06f81848a67eeb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::transposeScatterDecrU </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract 3 doubles from base/offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Offset to the start of triplet. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v0</td><td>1st value, subtracted from base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v1</td><td>2nd value, subtracted from base[align*offset[0] + 1]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v2</td><td>3rd value, subtracted from base[align*offset[0] + 2].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a12069a0402115678c9c39b303585917d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::transposeScatterIncrU </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add 3 floats to base/offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Offset to the start of triplet. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v0</td><td>1st value, added to base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v1</td><td>2nd value, added to base[align*offset[0] + 1]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v2</td><td>3rd value, added to base[align*offset[0] + 2].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a83e3f241eaafa47cfa9258ec9efec8d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::transposeScatterIncrU </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add 3 doubles to base/offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Offset to the start of triplet. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v0</td><td>1st value, added to base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v1</td><td>2nd value, added to base[align*offset[0] + 1]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v2</td><td>3rd value, added to base[align*offset[0] + 2].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a65d8dd5e7a4ade4e3750b48e2a95b308"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::transposeScatterStoreU </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store 3 floats to 3 to base/offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Offset to the start of triplet. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v0</td><td>1st value, written to base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v1</td><td>2nd value, written to base[align*offset[0] + 1]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v2</td><td>3rd value, written to base[align*offset[0] + 2].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5d74c633ff138def6fa648441c5decf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx::transposeScatterStoreU </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store 3 doubles to 3 to base/offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Offset to the start of triplet. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v0</td><td>1st value, written to base[align*offset[0]]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v1</td><td>2nd value, written to base[align*offset[0] + 1]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v2</td><td>3rd value, written to base[align*offset[0] + 2].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a4323d38c16cd7ce6b1ae9df62e94ef2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx::trunc </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncate float, i.e. round towards zero - common hardware instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Any floating-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer rounded towards zero, represented in floating-point format.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a00d84f65dae98aeb02816975f5045eed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx::trunc </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncate double, i.e. round towards zero - common hardware instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Any doubleing-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer rounded towards zero, represented in doubleing-point format.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be superficially meaningless, but it helps us to write templated SIMD/non-SIMD code. For clarity it should not be used outside such code. </dd></dl>

</div>
</div>
<a class="anchor" id="a89a29f07fcc6fe2c674e57357ca36327"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::unpinBuffer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpin the allocation. </p>
<p>Requries that <code>pointer</code> is not nullptr and was previously pinned with <a class="el" href="namespacegmx.xhtml#a7baa17fdd5339a2faa2e0427bde6dea9" title="Pin the allocation to physical memory. ">pinBuffer()</a>.</p>
<p>Does not throw. </p>

</div>
</div>
<a class="anchor" id="a25892b094f85a4d534ed625143b489e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::updateCorrelationGridHistory </td>
          <td>(</td>
          <td class="paramtype">CorrelationGridHistory *&#160;</td>
          <td class="paramname"><em>corrGridHist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CorrelationGrid &amp;&#160;</td>
          <td class="paramname"><em>corrGrid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the correlation grid history for checkpointing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">corrGridHist</td><td>Correlation grid history to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">corrGrid</td><td>Correlation grid state to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae3c9ffd9ce10581a97bb93f064c6c98c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool gmx::valueIsInGrid </td>
          <td>(</td>
          <td class="paramtype">const awh_dvec&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; GridAxis &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query if a value is in range of the grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axis</td><td>The grid axes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value is in the grid. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ee766424804cf631da09f2368073fe9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool gmx::valueIsInInterval </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a value is within an interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">origin</td><td>Start value of interval. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>End value of interval. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>Period (or 0 if not periodic). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value is within the interval. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ced30f5b4f4e3a6b3d2192040a135dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::writeKeyValueTreeAsMdp </td>
          <td>(</td>
          <td class="paramtype">TextWriter *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyValueTreeObject &amp;&#160;</td>
          <td class="paramname"><em>tree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a flat key-value <code>tree</code> to <code>writer</code> in mdp style. </p>
<p>Sub-objects will output nothing, so they can be used to contain a special key-value pair to create a comment, as well as the normal key and value. The comment pair will have a key of "comment", and the value will be used as a comment (if non-empty). </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a1058af577b77199877092472287f8ede"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool gmx::bGPUBinary = GMX_GPU != GMX_GPU_NONE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience macro to help us avoid ifdefs each time we use sysconf. </p>
<p>Convenience macro to help us avoid ifdefs each time we use sysconf Constant used to help minimize preprocessed code </p>

</div>
</div>
<a class="anchor" id="ac14235f12ea8bc98dd7d02c0206fbc97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacegmx.xhtml#a20e189e3f31f5f1e8581a5cc84063453">Architecture</a> gmx::c_architecture</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    Architecture::Unknown</div>
</div><!-- fragment -->
<p>Constant that tells what the architecture is. </p>

</div>
</div>
<a class="anchor" id="a958b60db1366d19c6b0e19eafcc1d546"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * gmx::eawhcoordprovider_names</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    <span class="stringliteral">&quot;pull&quot;</span>, <span class="keyword">nullptr</span></div>
<div class="line">}</div>
</div><!-- fragment -->
<p>String for AWH bias reaction coordinate provider. </p>

</div>
</div>
<a class="anchor" id="a46308cc74309940ea36f42140d21eae3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * gmx::eawhgrowth_names</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    <span class="stringliteral">&quot;exp-linear&quot;</span>, <span class="stringliteral">&quot;linear&quot;</span>, <span class="keyword">nullptr</span></div>
<div class="line">}</div>
</div><!-- fragment -->
<p>String for weight histogram growth. </p>

</div>
</div>
<a class="anchor" id="ae10c2458446d6f4f644435e5c67b8259"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * gmx::eawhpotential_names</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    <span class="stringliteral">&quot;convolved&quot;</span>, <span class="stringliteral">&quot;umbrella&quot;</span>, <span class="keyword">nullptr</span></div>
<div class="line">}</div>
</div><!-- fragment -->
<p>String for AWH potential type. </p>

</div>
</div>
<a class="anchor" id="a6fea4f8ebc2475a5b1b1db2b159684ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * gmx::eawhtarget_names</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    <span class="stringliteral">&quot;constant&quot;</span>, <span class="stringliteral">&quot;cutoff&quot;</span>, <span class="stringliteral">&quot;boltzmann&quot;</span>, <span class="stringliteral">&quot;local-boltzmann&quot;</span>, <span class="keyword">nullptr</span></div>
<div class="line">}</div>
</div><!-- fragment -->
<p>String for target distribution. </p>

</div>
</div>
<a class="anchor" id="a112b366b91e4bbca373f7491b272e0db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;gmx_hw_info_t&gt; gmx::hwinfo_g</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The hwinfo structure (common to all threads in this process). </p>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000024">Todo:</a></b></dt><dd>This should become a shared_ptr owned by e.g. Mdrunner::runner() that is shared across any threads as needed (e.g. for thread-MPI). That offers about the same run time performance as we get here, and avoids a lot of custom code. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 23 2018 14:54:35 for Gromacs by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
