<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.5">
  <compounddef id="group______module__nb__verlet" kind="group">
    <compoundname>__module_nb_verlet</compoundname>
    <title>Short-range non-bonded interaction module</title>
    <innerfile refid="nb__verlet_8h">nb_verlet.h</innerfile>
    <innerfile refid="nbnxn__tuning_8cpp">nbnxn_tuning.cpp</innerfile>
    <innerfile refid="nbnxn__tuning_8h">nbnxn_tuning.h</innerfile>
    <briefdescription>
<para>Computes forces and energies for short-range pair-interactions based on the Verlet algorithm. The algorithm uses pair-lists generated at fixed intervals as well as various flavors of pair interaction kernels implemented for a wide range of CPU and GPU architectures. </para>    </briefdescription>
    <detaileddescription>
<para> <libinternal /> </para><para>The module includes support for flavors of Coulomb and Lennard-Jones interaction treatment implemented for a large range of SIMD instruction sets for CPU architectures as well as in CUDA and OpenCL for GPU architectures. Additionally there is a reference CPU non-SIMD and a reference CPU for GPU pair-list setup interaction kernel.</para><para>The implementation of the kernels is based on the cluster non-bonded algorithm which in the code is referred to as the NxN algorithms (&quot;nbnxn_&quot; prefix); for details of the algorithm see DOI:10.1016/j.cpc.2013.06.003.</para><para>Algorithmically, the non-bonded computation has two different modes: A &quot;classical&quot; mode: generate a list every nstlist steps containing at least all atom pairs up to a distance of rlistOuter and compute pair interactions for all pairs that are within the interaction cut-off. A &quot;dynamic pruning&quot; mode: generate an &quot;outer-list&quot; up to cut-off rlistOuter every nstlist steps and prune the outer-list using a cut-off of rlistInner every nstlistPrune steps to obtain a, smaller, &quot;inner-list&quot;. This results in fewer interaction computations and allows for a larger nstlist. On a GPU, this dynamic pruning is performed in a rolling fashion, pruning only a sub-part of the list each (second) step. This way it can often overlap with integration and constraints on the CPU. Currently a simple heuristic determines which mode will be used.</para><para>TODO: add a summary list and brief descriptions of the different submodules: search, CPU kernels, GPU glue code + kernels.</para><para><simplesect kind="author"><para>Berk Hess <ulink url="mailto:hess@kth.se">hess@kth.se</ulink> </para><simplesectsep/><para>Szilárd Páll <ulink url="mailto:pall.szilard@gmail.com">pall.szilard@gmail.com</ulink> </para><simplesectsep/><para>Mark Abraham <ulink url="mailto:mark.j.abraham@gmail.com">mark.j.abraham@gmail.com</ulink> </para><simplesectsep/><para>Anca Hamuraru <ulink url="mailto:anca@streamcomputing.eu">anca@streamcomputing.eu</ulink> </para><simplesectsep/><para>Teemu Virolainen <ulink url="mailto:teemu@streamcomputing.eu">teemu@streamcomputing.eu</ulink> </para><simplesectsep/><para>Dimitrios Karkoulis <ulink url="mailto:dimitris.karkoulis@gmail.com">dimitris.karkoulis@gmail.com</ulink></para></simplesect>
TODO: add more authors! </para>    </detaileddescription>
  </compounddef>
</doxygen>
