<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.5">
  <compounddef id="page_analysisdata" kind="page">
    <compoundname>page_analysisdata</compoundname>
    <title>Analysis output data handling</title>
    <detaileddescription>
<para>The <ref refid="group__module__analysisdata" kindref="compound">Parallelizable Handling of Output Data (analysisdata)</ref> module provides support for common data analysis tasks within the <ref refid="page_analysisframework" kindref="compound">Framework for trajectory analysis</ref>. The basic approach used in the module is visualized below:</para><para><dot> 
  digraph analysisdata_overview {
    rankdir = BT
    dataobject [label=&quot;data object\n(subclass of gmx::AbstractAnalysisData)&quot;]
    datamodule1 [label=&quot;data module\n(implements gmx::IAnalysisDataModule)&quot;]
    datamodule2 [label=&quot;data module\nthat also provides data&quot;]
    datamodule3 [label=&quot;data module&quot;]
    datamodule1 -&gt; dataobject
    datamodule2 -&gt; dataobject
    datamodule3 -&gt; datamodule2
  }
</dot></para><para>Typically, an analysis tool provides its raw data output through one or more <ref refid="classgmx_1_1AnalysisData" kindref="compound">gmx::AnalysisData</ref> objects (the root <emphasis>data object</emphasis> in the diagram above). This object provides only storage for the data.</para><para>To perform operations on the data, one or more <emphasis>data modules</emphasis> can be attached to the data object. Examples of such operations are averaging, histogramming, and plotting the data into a file. Some data modules are provided by the <ref refid="group__module__analysisdata" kindref="compound">Parallelizable Handling of Output Data (analysisdata)</ref> module. To implement new ones, it is necessary to create a class that implements <ref refid="classgmx_1_1IAnalysisDataModule" kindref="compound">gmx::IAnalysisDataModule</ref>.</para><para>In many cases, such data modules also provide data that can be processed further, acting as data objects themselves. This makes it possible to attach further data modules to form a processing chain. In simple cases, such a chain ends in a module that writes the data into a file, but it is also possible to access the data in a data object (whether a plain data object or a data module) programmatically to do further computation or post-processing outside the framework. To do this, the data object typically needs to be told in advance such that it knows to store the data permanently even if attached modules do not require it.</para><para>The modules can do their processing online, i.e., as the data is produced. If all the attached modules support this, it is not necessary to store all the raw data in memory. The module design also supports processing frames in parallel: in such cases, the data may become available out of order. In particular for writing the per-frame data into a file, but also for other types of post-processing, it is necessary to reorder the data sequentially. This is implemented once in the framework, and analysis tools do not need to worry, other than using the provided API.</para><para><heading level="1">Structure of data </heading>
</para><para>At the highest level, data can be structured into separate <ref refid="classgmx_1_1AbstractAnalysisData" kindref="compound">gmx::AbstractAnalysisData</ref> objects that operate independently. Each such object has an independent set of post-processing modules.</para><para>Within a <ref refid="classgmx_1_1AbstractAnalysisData" kindref="compound">gmx::AbstractAnalysisData</ref> object, data is structured along three &quot;dimensions&quot;:</para><para><itemizedlist>
<listitem><para><emphasis>frames</emphasis>: There is one or more frames in each data object. For raw data produced by an analysis tool, these typically correspond to input trajectory frames. For other data set, it can be viewed as an X axis of a graph.</para></listitem><listitem><para><emphasis>data sets</emphasis>: There is one or more data sets in each data object. For most purposes, data sets work independently (i.e., the post-processing modules operate on each data set separately), but some modules reduce the data sets into single columns in the output. The main purpose for using multiple data sets is to share the same post-processing chain for multiple sets of data (e.g., multiple RDFs computed by the same tool in one pass), in particular for cases where the number of data sets is not known at compile time. Note that each data set contains the same number of frames.</para></listitem><listitem><para><emphasis>columns</emphasis>: There is one or more columns in each data set. Different data sets can contain a different number of columns. Each column in a frame can contain a single value (see below for supported values).</para></listitem></itemizedlist>
</para><para>Programmatically the data within each frame is organized into <emphasis>point sets</emphasis>. Each point set consists of a continuous range of columns from a single data set. There are two types of data:</para><para><itemizedlist>
<listitem><para><emphasis>simple</emphasis>: For each frame, there is exactly one point set for each data set, and that point set spans all columns in that data set.</para></listitem><listitem><para><emphasis>multipoint</emphasis>: For each frame, there can be any number of point sets, and they may span arbitrary columns. It is allowed that point sets overlap, i.e., that multiple point sets specify a value for the same column.</para></listitem></itemizedlist>
</para><para>The main purpose of multipoint data is to support cases where it is not known in advance how many values there will be for each frame, or where that number is impractically large. The need to do this is mainly a matter of performance/implementation complexity tradeoff: with a more complex internal implementation, it would be possible to support larger data sets without a performance/memory impact they currently impose. The current implementation places the burden of deciding on the appropriate usage pattern on the user code, allowing for much simpler internal implementation.</para><para>An individual value (identified by frame, data set, and column) consists of a single value of type <computeroutput>real</computeroutput>, an optional error value, and some flags. The flags identify what parts of the value are really available. The following states are possible:<itemizedlist>
<listitem><para><emphasis>present</emphasis>: The value is set.</para></listitem><listitem><para><emphasis>missing</emphasis>: The value is marked as missing by the data source. In this state, the value can still be accessed, and the returned <computeroutput>real</computeroutput> value has some meaning. Different data modules handle these cases differently.</para></listitem><listitem><para><emphasis>unset</emphasis>: The value is not set. It is not allowed to access the value for other than querying the state. Data modules that ignore missing values (by skipping all values not <emphasis>present</emphasis>) can also handle unset values. Other data modules typically do not allow unset values.</para></listitem></itemizedlist>
</para><para><heading level="1">Data provider classes </heading>
</para><para>The base class for all data objects (including data modules that provide data) is <ref refid="classgmx_1_1AbstractAnalysisData" kindref="compound">gmx::AbstractAnalysisData</ref>. This class provides facilities for attaching data modules to the data, and to query the data. It does not provide any methods to alter the data; all logic for managing the actual data is in derived classes.</para><para>The main root (non-module) data object class for use in analysis tools is <ref refid="classgmx_1_1AnalysisData" kindref="compound">gmx::AnalysisData</ref>. This class provides methods to set properties of the data, and to add frames to it. The interface is frame-based: you construct one frame at a time, and after it is finished, you move to the next frame. The frames are not constructed directly using <ref refid="classgmx_1_1AnalysisData" kindref="compound">gmx::AnalysisData</ref>, but instead separate <emphasis>data handles</emphasis> are used. This is explained in more detail below under <ref refid="page_analysisdata_1section_analysisdata_parallelization" kindref="member">Parallelization </ref>.</para><para>For simple needs and small amounts of data, <ref refid="classgmx_1_1AnalysisArrayData" kindref="compound">gmx::AnalysisArrayData</ref> is also provided. This class allows for all the data to be prepared in memory as a single big array, and allows random access to the data while setting the values. When all the values are set to their final values, it then notifies the attached data modules by looping over the array.</para><sect1 id="page_analysisdata_1section_analysisdata_parallelization">
<title>Parallelization </title>
<para>One major driver for the design of the analysis data module has been to provide support for transparently processing multiple frames in parallel. In such cases, output data for multiple frames may be constructed simultaneously, and must be ordered correctly for some data modules, such as writing it into a file. This ordering is taken care of by the framework, allowing the analysis tool writer to concentrate on the actual analysis task.</para><para>From a user&apos;s point of view, the main player in this respect is the <ref refid="classgmx_1_1AnalysisData" kindref="compound">gmx::AnalysisData</ref> object. If there are two threads doing the processing in parallel, it allows creating a separate <ref refid="classgmx_1_1AnalysisDataHandle" kindref="compound">gmx::AnalysisDataHandle</ref> for each object. Each of these handles can be used independently to construct frames into the output data, and the <ref refid="classgmx_1_1AnalysisData" kindref="compound">gmx::AnalysisData</ref> object internally takes care of notifying the modules correctly. If necessary, it stores finished frames into a temporary buffer until all preceding frames have also been finished.</para><para>For increased efficiency, some data modules are also parallelization-aware: they have the ability to process the data in any order, allowing <ref refid="classgmx_1_1AnalysisData" kindref="compound">gmx::AnalysisData</ref> to notify them as soon as a frame becomes available. If there are only parallel data modules attached, no frame reordering or temporary buffers are needed. If a non-parallel data module is attached to a parallel data module, then that parallel data module takes the responsibility of ordering its output frames. Ideally, such data modules produce significantly less data than what they take in, making it cheaper to do the ordering only at this point.</para><para>Currently, no parallel runner has been implemented, but it is likely that applicable tools written to use the framework require minimal or no changes to take advantage of frame-level parallelism once such a runner materializes.</para><para><heading level="1">Provided data processing modules </heading>
</para><para>Data modules provided by the <ref refid="group__module__analysisdata" kindref="compound">Parallelizable Handling of Output Data (analysisdata)</ref> module are listed below with a short description. See the documentation of the individual classes for more details. Note that this list is manually maintained, so it may not always be up-to-date. A comprehensive list can be found by looking at the inheritance graph of <ref refid="classgmx_1_1IAnalysisDataModule" kindref="compound">gmx::IAnalysisDataModule</ref>, but the list here is more user-friendly.</para><para><variablelist>
<varlistentry><term><ref refid="classgmx_1_1AnalysisDataAverageModule" kindref="compound">gmx::AnalysisDataAverageModule</ref> </term></varlistentry>
<listitem><para>Computes averages and standard deviations for columns in input data. One output value for each input column.  </para></listitem>
<varlistentry><term><ref refid="classgmx_1_1AnalysisDataFrameAverageModule" kindref="compound">gmx::AnalysisDataFrameAverageModule</ref> </term></varlistentry>
<listitem><para>Computes averages for each frame in input data. One output value for each input data set for each frame.  </para></listitem>
<varlistentry><term><ref refid="classgmx_1_1AnalysisDataBinAverageModule" kindref="compound">gmx::AnalysisDataBinAverageModule</ref> </term></varlistentry>
<listitem><para>Computes averages within bins. Input is pairs of values, where the first value defines the bin, and the second value sets the value to accumulate into the average within the bin. One output histogram for each input data set.  </para></listitem>
<varlistentry><term><ref refid="classgmx_1_1AnalysisDataSimpleHistogramModule" kindref="compound">gmx::AnalysisDataSimpleHistogramModule</ref> </term></varlistentry>
<listitem><para>Computes histograms. All values within a data set are added into a histogram. One output histogram for each input data set. Provides the histogram for each input frame separately, and also the full histogram over frames (through an internal submodule).  </para></listitem>
<varlistentry><term><ref refid="classgmx_1_1AnalysisDataWeightedHistogramModule" kindref="compound">gmx::AnalysisDataWeightedHistogramModule</ref> </term></varlistentry>
<listitem><para>Computes histograms. Input is pairs of values, where the first value defines the bin, and the second value sets the value to add into that bin. Output like with <ref refid="classgmx_1_1AnalysisDataSimpleHistogramModule" kindref="compound">gmx::AnalysisDataSimpleHistogramModule</ref>.  </para></listitem>
<varlistentry><term><ref refid="classgmx_1_1AnalysisDataLifetimeModule" kindref="compound">gmx::AnalysisDataLifetimeModule</ref> </term></varlistentry>
<listitem><para>Computes lifetime histograms. For each input column, determines the time intervals during which a value is continuously present/non-zero, and creates a histogram from the lengths of these intervals. One output histogram for each input data set.  </para></listitem>
<varlistentry><term><ref refid="classgmx_1_1AnalysisDataPlotModule" kindref="compound">gmx::AnalysisDataPlotModule</ref> </term></varlistentry>
<listitem></listitem>
<varlistentry><term><ref refid="classgmx_1_1AnalysisDataVectorPlotModule" kindref="compound">gmx::AnalysisDataVectorPlotModule</ref> </term></varlistentry>
<listitem><para>Writes data into a file.  </para></listitem>
</variablelist>
</para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
