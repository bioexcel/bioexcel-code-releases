<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.5">
  <compounddef id="page_analysistemplate" kind="page">
    <compoundname>page_analysistemplate</compoundname>
    <title>Example code for writing trajectory analysis tools</title>
    <detaileddescription>
<para>GROMACS installation includes a template for writing trajectory analysis tools using <ref refid="page_analysisframework" kindref="compound">Framework for trajectory analysis</ref>. It can be found from <computeroutput>share/gromacs/template/</computeroutput> under the installation directory, and from <computeroutput>share/template/</computeroutput> in the source distribution.</para><para>The full source code for the file is also included in this documentation: <ref refid="template_8cpp-example" kindref="compound">template.cpp</ref> The rest of this page walks through the code to explain the different parts.</para><para></para><para><heading level="1">Global definitions </heading>
</para><para>We start by including some generic C++ headers: <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;string&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight></codeline>
</programlisting> and continue by including the header for the analysis library: <programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;<ref refid="trajectoryanalysis_8h" kindref="compound">gromacs/trajectoryanalysis.h</ref>&gt;</highlight></codeline>
</programlisting> This header includes other headers that together define all the basic data types needed for writing trajectory analysis tools. For convenience, we also import all names from the <ref refid="namespacegmx" kindref="compound">gmx</ref> namespace into the global scope to avoid repeating the name everywhere: <programlisting><codeline><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal">gmx;</highlight></codeline>
</programlisting></para><para><heading level="1">Tool module class declaration </heading>
</para><para>We then define a class that implements our analysis tool: <programlisting><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal"><ref refid="classAnalysisTemplate" kindref="compound">AnalysisTemplate</ref><sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="classgmx_1_1TrajectoryAnalysisModule_1a2023063f2d3978b4d89c90f03fb2a805" kindref="member">TrajectoryAnalysisModule</ref></highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classAnalysisTemplate" kindref="compound">AnalysisTemplate</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="classAnalysisTemplate_1ac1e17717634942620122ef3a42438765" kindref="member">initOptions</ref>(IOptionsContainer<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*options,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TrajectoryAnalysisSettings<sp/>*settings);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="classAnalysisTemplate_1a9e02b7a948032879e4d172533fca27f4" kindref="member">initAnalysis</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>TrajectoryAnalysisSettings<sp/>&amp;settings,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>TopologyInformation<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;top);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="classAnalysisTemplate_1a113ec08275e9efd12c97e2387cf72115" kindref="member">analyzeFrame</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>frnr,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structt__trxframe" kindref="compound">t_trxframe</ref><sp/>&amp;fr,<sp/><ref refid="structt__pbc" kindref="compound">t_pbc</ref><sp/>*pbc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classgmx_1_1TrajectoryAnalysisModule_1aab5ed763e4b63da4601f9b9004b595a9" kindref="member">TrajectoryAnalysisModuleData</ref><sp/>*pdata);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="classAnalysisTemplate_1ae041eaddc628f03387dab1c217442606" kindref="member">finishAnalysis</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nframes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="classAnalysisTemplate_1a517aacaffbe2754d8700e05d96639edf" kindref="member">writeOutput</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">ModuleData;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::string<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fnDist_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cutoff_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Selection<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>refsel_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespacegmx_1ac852a0801cf49723903e23bc77a32163" kindref="member">SelectionList</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sel_;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AnalysisNeighborhood<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nb_;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AnalysisData<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespacegmx_1a87e4f5152c736da50dd59275f423a7a3" kindref="member">AnalysisDataAverageModulePointer</ref><sp/>avem_;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting> The analysis tool class inherits from <ref refid="classgmx_1_1TrajectoryAnalysisModule" kindref="compound">gmx::TrajectoryAnalysisModule</ref>, which is an interface with a few convenience functions for easier interfacing with other code. Below, we walk through the different methods as implemented in the template (note that the template does not implement some of the virtual methods because they are less often needed), discussing some issues that can arise in more complex cases. See documentation of <ref refid="classgmx_1_1TrajectoryAnalysisModule" kindref="compound">gmx::TrajectoryAnalysisModule</ref> for a full description of the available virtual methods and convenience functions. The first block of member variables are used to contain values provided to the different options. They will vary depending on the needs of the analysis tool. The AnalysisNeighborhood object provides neighborhood searching that is used in the analysis. The final block of variables are used to process output data. See initAnalysis() for details on how they are used.</para><para>For the template, we do not need any custom frame-local data. If you think you need some for more complex analysis needs, see documentation of <ref refid="classgmx_1_1TrajectoryAnalysisModuleData" kindref="compound">gmx::TrajectoryAnalysisModuleData</ref> for more details. If you do not care about parallelization, you do not need to consider this part. You can simply declare all variables in the module class itself, initialize them in <ref refid="classgmx_1_1TrajectoryAnalysisModule_1ae5ae73770caad4ff1808c2ca655dad0e" kindref="member">gmx::TrajectoryAnalysisModule::initAnalysis()</ref>, and do any postprocessing in <ref refid="classgmx_1_1TrajectoryAnalysisModule_1a3b9d902a262ba124be565eca5b714e4b" kindref="member">gmx::TrajectoryAnalysisModule::finishAnalysis()</ref>).</para><para><heading level="1">Construction </heading>
</para><para>The constructor (and possible destructor) of the analysis module should be simple: the constructor should just initialize default values, and the destructor should free any memory managed by the module. For the template, we have no attributes in our class that need to be explicitly freed, so we declare only a constructor: <programlisting><codeline><highlight class="normal">AnalysisTemplate::AnalysisTemplate()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>cutoff_(0.0)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>registerAnalysisDataset(&amp;data_,<sp/></highlight><highlight class="stringliteral">&quot;avedist&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><heading level="1">Input options </heading>
</para><para>Initialization of the module is split into a few methods, two of which are used in the template. <ref refid="classgmx_1_1TrajectoryAnalysisModule_1aba5990675e980bf746ecd224f814d549" kindref="member">gmx::TrajectoryAnalysisModule::initOptions()</ref> is used to set up options understood by the module, as well as for setting up different options through <ref refid="classgmx_1_1TrajectoryAnalysisSettings" kindref="compound">gmx::TrajectoryAnalysisSettings</ref> (see the documentation of that class for more details): <programlisting><codeline><highlight class="keywordtype">void</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classAnalysisTemplate_1ac1e17717634942620122ef3a42438765" kindref="member">AnalysisTemplate::initOptions</ref>(IOptionsContainer<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*options,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TrajectoryAnalysisSettings<sp/>*settings)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>desc[]<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;This<sp/>is<sp/>a<sp/>template<sp/>for<sp/>writing<sp/>your<sp/>own<sp/>analysis<sp/>tools<sp/>for&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;GROMACS.<sp/>The<sp/>advantage<sp/>of<sp/>using<sp/>GROMACS<sp/>for<sp/>this<sp/>is<sp/>that<sp/>you&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;have<sp/>access<sp/>to<sp/>all<sp/>information<sp/>in<sp/>the<sp/>topology,<sp/>and<sp/>your&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;program<sp/>will<sp/>be<sp/>able<sp/>to<sp/>handle<sp/>all<sp/>types<sp/>of<sp/>coordinates<sp/>and&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;trajectory<sp/>files<sp/>supported<sp/>by<sp/>GROMACS.<sp/>In<sp/>addition,&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;you<sp/>get<sp/>a<sp/>lot<sp/>of<sp/>functionality<sp/>for<sp/>free<sp/>from<sp/>the<sp/>trajectory&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;analysis<sp/>library,<sp/>including<sp/>support<sp/>for<sp/>flexible<sp/>dynamic&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;selections.<sp/>Go<sp/>ahead<sp/>an<sp/>try<sp/>it![PAR]&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;To<sp/>get<sp/>started<sp/>with<sp/>implementing<sp/>your<sp/>own<sp/>analysis<sp/>program,&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;follow<sp/>the<sp/>instructions<sp/>in<sp/>the<sp/>README<sp/>file<sp/>provided.&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;This<sp/>template<sp/>implements<sp/>a<sp/>simple<sp/>analysis<sp/>programs<sp/>that<sp/>calculates&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;average<sp/>distances<sp/>from<sp/>a<sp/>reference<sp/>group<sp/>to<sp/>one<sp/>or<sp/>more&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;analysis<sp/>groups.&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>settings-&gt;setHelpText(desc);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>options-&gt;addOption(FileNameOption(</highlight><highlight class="stringliteral">&quot;o&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.filetype(eftPlot).outputFile()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="namespacegmx_1a9c1227e97a6084a280a611c2934c8ee1" kindref="member">store</ref>(&amp;fnDist_).defaultBasename(</highlight><highlight class="stringliteral">&quot;avedist&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.description(</highlight><highlight class="stringliteral">&quot;Average<sp/>distances<sp/>from<sp/>reference<sp/>group&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>options-&gt;addOption(SelectionOption(</highlight><highlight class="stringliteral">&quot;reference&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="namespacegmx_1a9c1227e97a6084a280a611c2934c8ee1" kindref="member">store</ref>(&amp;refsel_).required()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.description(</highlight><highlight class="stringliteral">&quot;Reference<sp/>group<sp/>to<sp/>calculate<sp/>distances<sp/>from&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>options-&gt;addOption(SelectionOption(</highlight><highlight class="stringliteral">&quot;select&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.storeVector(&amp;sel_).required().multiValue()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.description(</highlight><highlight class="stringliteral">&quot;Groups<sp/>to<sp/>calculate<sp/>distances<sp/>to&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>options-&gt;addOption(DoubleOption(</highlight><highlight class="stringliteral">&quot;cutoff&quot;</highlight><highlight class="normal">).<ref refid="namespacegmx_1a9c1227e97a6084a280a611c2934c8ee1" kindref="member">store</ref>(&amp;cutoff_)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.description(</highlight><highlight class="stringliteral">&quot;Cutoff<sp/>for<sp/>distance<sp/>calculation<sp/>(0<sp/>=<sp/>no<sp/>cutoff)&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>settings-&gt;setFlag(TrajectoryAnalysisSettings::efRequireTop);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> For the template, we first set a description text for the tool (used for help text). Then we declare an option to specify the output file name, followed by options that are used to set selections, and finally an option to set a cutoff value. For the cutoff, the default value will be the one that was set in the constructor, but it would also be possible to explicitly set it here. The values provided by the user for the options will be stored in member variables. Finally, we indicate that the tool always requires topology information. This is done for demonstration purposes only; the code in the template works even without a topology.</para><para>For additional documentation on how to define different kinds of options, see <ref refid="classgmx_1_1IOptionsContainer" kindref="compound">gmx::IOptionsContainer</ref>, <ref refid="basicoptions_8h" kindref="compound">basicoptions.h</ref>, and <ref refid="classgmx_1_1SelectionOption" kindref="compound">gmx::SelectionOption</ref>. You only need to define options that are specific to the analysis; common options, e.g., for specifying input topology and trajectories are added by the framework.</para><para>To adjust settings or selection options (e.g., the number of accepted selections) based on option values, you need to override <ref refid="classgmx_1_1TrajectoryAnalysisModule_1afa3457cc922f1d16c4c19cec740e0442" kindref="member">gmx::TrajectoryAnalysisModule::optionsFinished()</ref>. For simplicity, this is not done in the template.</para><para><heading level="1">Analysis initialization </heading>
</para><para>The actual analysis is initialized in <ref refid="classgmx_1_1TrajectoryAnalysisModule_1ae5ae73770caad4ff1808c2ca655dad0e" kindref="member">gmx::TrajectoryAnalysisModule::initAnalysis()</ref>: <programlisting><codeline><highlight class="keywordtype">void</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classAnalysisTemplate_1a9e02b7a948032879e4d172533fca27f4" kindref="member">AnalysisTemplate::initAnalysis</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>TrajectoryAnalysisSettings<sp/>&amp;settings,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>TopologyInformation<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;<sp/></highlight><highlight class="comment">/*top*/</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>nb_.setCutoff(cutoff_);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>data_.setColumnCount(0,<sp/>sel_.size());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>avem_.reset(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>AnalysisDataAverageModule());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>data_.addModule(avem_);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!fnDist_.empty())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespacegmx_1a38eb9496e0b6e783869001733014b6d0" kindref="member">AnalysisDataPlotModulePointer</ref><sp/>plotm(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>AnalysisDataPlotModule(settings.plotSettings()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>plotm-&gt;setFileName(fnDist_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>plotm-&gt;setTitle(</highlight><highlight class="stringliteral">&quot;Average<sp/>distance&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>plotm-&gt;setXAxisIsTime();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>plotm-&gt;setYLabel(</highlight><highlight class="stringliteral">&quot;Distance<sp/>(nm)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_.addModule(plotm);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> Information about the topology is passed as a parameter. The settings object can also be used to access information about user input.</para><para>One of the main tasks of this method is to set up appropriate <ref refid="classgmx_1_1AnalysisData" kindref="compound">gmx::AnalysisData</ref> objects and modules for them (see <ref refid="classgmx_1_1TrajectoryAnalysisModule" kindref="compound">gmx::TrajectoryAnalysisModule</ref> for the general approach). These objects will be used to process output from the tool. Their main purpose is to support parallelization, but even if you don&apos;t care about parallelism, they still provide convenient building blocks, e.g., for histogramming and file output.</para><para>For the template, we first set the cutoff for the neighborhood search.</para><para>Then, we create and register one <ref refid="classgmx_1_1AnalysisData" kindref="compound">gmx::AnalysisData</ref> object that will contain, for each frame, one column for each input selection. This will contain the main output from the tool: minimum distance between the reference selection and that particular selection. We then create and setup a module that will compute the average distance for each selection (see writeOutput() for how it is used). Finally, if an output file has been provided, we create and setup a module that will plot the per-frame distances to a file.</para><para>If the analysis module needs some temporary storage during processing of a frame (i.e., it uses a custom class derived from <ref refid="classgmx_1_1TrajectoryAnalysisModuleData" kindref="compound">gmx::TrajectoryAnalysisModuleData</ref>), this should be allocated in <ref refid="classgmx_1_1TrajectoryAnalysisModule_1a6082fcf69bdc3b0a1945ece31437f195" kindref="member">gmx::TrajectoryAnalysisModule::startFrames()</ref> (see below) if parallelization is to be supported.</para><para>If you need to do initialization based on data from the first frame (most commonly, based on the box size), you need to override <ref refid="classgmx_1_1TrajectoryAnalysisModule_1a419a3d7f950f0731a20d6a7fafaa6d05" kindref="member">gmx::TrajectoryAnalysisModule::initAfterFirstFrame()</ref>, but this is not used in the template.</para><para><heading level="1">Analyzing the frames </heading>
</para><para>There is one more initialization method that needs to be overridden to support automatic parallelization: <ref refid="classgmx_1_1TrajectoryAnalysisModule_1a6082fcf69bdc3b0a1945ece31437f195" kindref="member">gmx::TrajectoryAnalysisModule::startFrames()</ref>. If you do not need custom frame-local data (or parallelization at all), you can skip this method and ignore the last parameter to <ref refid="classgmx_1_1TrajectoryAnalysisModule_1adc7344d1b635c15320af636657383212" kindref="member">gmx::TrajectoryAnalysisModule::analyzeFrame()</ref> to make things simpler. In the template, this method is not necessary.</para><para>The main part of the analysis is (in most analysis codes) done in the <ref refid="classgmx_1_1TrajectoryAnalysisModule_1adc7344d1b635c15320af636657383212" kindref="member">gmx::TrajectoryAnalysisModule::analyzeFrame()</ref> method, which is called once for each frame: <programlisting><codeline><highlight class="keywordtype">void</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classAnalysisTemplate_1a113ec08275e9efd12c97e2387cf72115" kindref="member">AnalysisTemplate::analyzeFrame</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>frnr,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structt__trxframe" kindref="compound">t_trxframe</ref><sp/>&amp;fr,<sp/><ref refid="structt__pbc" kindref="compound">t_pbc</ref><sp/>*pbc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TrajectoryAnalysisModuleData<sp/>*pdata)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
</programlisting> The <computeroutput>frnr</computeroutput> parameter gives a zero-based index of the current frame (mostly for use with <ref refid="classgmx_1_1AnalysisData" kindref="compound">gmx::AnalysisData</ref>), <computeroutput>pbc</computeroutput> contains the PBC information for the current frame for distance calculations with, e.g., <ref refid="pbc_8cpp_1a9d6a489816eadddbdbd19509b0ff5e46" kindref="member">pbc_dx()</ref>, and <computeroutput>pdata</computeroutput> points to a data structure created in startFrames(). Although usually not necessary (except for the time field), raw frame data can be accessed through <computeroutput>fr</computeroutput>. In most cases, the analysis should be written such that it gets all position data through selections, and does not assume a constant size for them. This is all that is required to support the full flexibility of the selection engine.</para><para>For the template, we first get data from our custom data structure for shorthand access (if you use a custom data object, you need a <computeroutput>static_cast</computeroutput> here): <programlisting><codeline><highlight class="normal"><sp/><sp/><sp/><sp/>AnalysisDataHandle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dh<sp/><sp/><sp/><sp/><sp/>=<sp/>pdata-&gt;dataHandle(data_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Selection<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;refsel<sp/>=<sp/>pdata-&gt;parallelSelection(refsel_);</highlight></codeline>
</programlisting></para><para>We then do a simple calculation and use the AnalysisDataHandle class to set the per-frame output for the tool: <programlisting><codeline><highlight class="normal"><sp/><sp/><sp/><sp/>AnalysisNeighborhoodSearch<sp/>nbsearch<sp/>=<sp/>nb_.initSearch(pbc,<sp/>refsel);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dh.startFrame(frnr,<sp/>fr.time);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>g<sp/>=<sp/>0;<sp/>g<sp/>&lt;<sp/>sel_.size();<sp/>++g)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Selection<sp/>&amp;sel<sp/><sp/><sp/>=<sp/>pdata-&gt;parallelSelection(sel_[g]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="domdec_8h_1afbaeb09824aab3269073f92000ab0df5a0ab3e5d0801aea3f3758bcbd812e8f10" kindref="member">nr</ref><sp/><sp/><sp/><sp/>=<sp/>sel.posCount();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="real_8h_1a58a0c7cf2501f4492da833421be92547" kindref="member">real</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>frave<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/><ref refid="domdec_8h_1afbaeb09824aab3269073f92000ab0df5a0ab3e5d0801aea3f3758bcbd812e8f10" kindref="member">nr</ref>;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SelectionPosition<sp/>p<sp/>=<sp/>sel.position(i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>frave<sp/>+=<sp/>nbsearch.minimumDistance(p.x());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>frave<sp/>/=<sp/><ref refid="domdec_8h_1afbaeb09824aab3269073f92000ab0df5a0ab3e5d0801aea3f3758bcbd812e8f10" kindref="member">nr</ref>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dh.setPoint(g,<sp/>frave);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dh.finishFrame();</highlight></codeline>
</programlisting></para><para>After all the frames have been processed, <ref refid="classgmx_1_1TrajectoryAnalysisModule_1a3b9d902a262ba124be565eca5b714e4b" kindref="member">gmx::TrajectoryAnalysisModule::finishAnalysis()</ref> is called once. This is the place to do any custom postprocessing of the data. For the template, we do nothing, because all necessary processing is done in the data modules: <programlisting><codeline><highlight class="keywordtype">void</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classAnalysisTemplate_1ae041eaddc628f03387dab1c217442606" kindref="member">AnalysisTemplate::finishAnalysis</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">/*nframes*/</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>If the data structure created in <ref refid="classgmx_1_1TrajectoryAnalysisModule_1a6082fcf69bdc3b0a1945ece31437f195" kindref="member">gmx::TrajectoryAnalysisModule::startFrames()</ref> is used to aggregate data across frames, you need to override <ref refid="classgmx_1_1TrajectoryAnalysisModule_1a9d14bf1683086d3fafdb11e23e003de4" kindref="member">gmx::TrajectoryAnalysisModule::finishFrames()</ref> to combine the data from the data structures (see documentation of the method for details). This is not necessary for the template, because the ModuleData structure only contains data used during the analysis of a single frame.</para><para><heading level="1">Output </heading>
</para><para>Finally, most programs need to write out some values after the analysis is complete. In some cases, this can be achieved with proper chaining of data modules, but often it is necessary to do some custom processing. All such activities should be done in <ref refid="classgmx_1_1TrajectoryAnalysisModule_1a80869a7764274db8e314bf0a1c5858f6" kindref="member">gmx::TrajectoryAnalysisModule::writeOutput()</ref>. This makes it easier to reuse analysis modules in, e.g., scripting languages, where output into files might not be desired. The template simply prints out the average distances for each analysis group: <programlisting><codeline><highlight class="keywordtype">void</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classAnalysisTemplate_1a517aacaffbe2754d8700e05d96639edf" kindref="member">AnalysisTemplate::writeOutput</ref>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>print<sp/>out<sp/>the<sp/>average<sp/>of<sp/>the<sp/>mean<sp/>distances<sp/>for<sp/>each<sp/>group.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>g<sp/>=<sp/>0;<sp/>g<sp/>&lt;<sp/>sel_.size();<sp/>++g)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/></highlight><highlight class="stringliteral">&quot;Average<sp/>mean<sp/>distance<sp/>for<sp/>&apos;%s&apos;:<sp/>%.3f<sp/>nm\n&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sel_[g].name(),<sp/>avem_-&gt;average(0,<sp/>g));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> Here, we use the <computeroutput>avem_</computeroutput> module, which we initialized in initAnalysis() to aggregate the averages of the computed distances.</para><para><heading level="1">Definition of <ref refid="test__selection_8cpp_1a0ddf1224851353fc92bfbff6f499fa97" kindref="member">main()</ref> </heading>
</para><para>Now, the only thing remaining is to define the <ref refid="test__selection_8cpp_1a0ddf1224851353fc92bfbff6f499fa97" kindref="member">main()</ref> function. To implement a command-line tool, it should create a module and run it using <ref refid="classgmx_1_1TrajectoryAnalysisCommandLineRunner" kindref="compound">gmx::TrajectoryAnalysisCommandLineRunner</ref> using the boilerplate code below: <programlisting><codeline><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="test__selection_8cpp_1a0ddf1224851353fc92bfbff6f499fa97" kindref="member">main</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>gmx::TrajectoryAnalysisCommandLineRunner::runAsMain&lt;AnalysisTemplate&gt;(argc,<sp/>argv);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><heading level="1">Tools within GROMACS </heading>
</para><para>Analysis tools implemented using the template can also be easily included into the GROMACS library. To do this, follow these steps:</para><para><orderedlist>
<listitem><para>Put your tool source code into <computeroutput>src/gromacs/trajectoryanalysis/modules/</computeroutput>.</para></listitem><listitem><para>Remove <computeroutput>using namespace gmx;</computeroutput> and enclose all the code into <computeroutput>gmx::analysismodules</computeroutput> namespace, and the tool class into an unnamed namespace within this.</para></listitem><listitem><para>Create a header file corresponding to your tool and add the following class into it withing <computeroutput>gmx::analysismodules</computeroutput> namespace (replace <computeroutput>Template</computeroutput> with the name of your tool): <programlisting><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">TemplateInfo</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>name[];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>shortDescription[];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="namespacegmx_1a832da3c093109c13cc2369de05e02f3b" kindref="member">TrajectoryAnalysisModulePointer</ref><sp/>create();</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para></listitem><listitem><para>Add definition for these items in the source file, outside the unnamed namespace (replace <computeroutput>Template</computeroutput>, <computeroutput><ref refid="classAnalysisTemplate" kindref="compound">AnalysisTemplate</ref></computeroutput> and the strings with correct values): <programlisting><codeline><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>TemplateInfo::name[]<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/></highlight><highlight class="stringliteral">&quot;template&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>TemplateInfo::shortDescription[]<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;Compute<sp/>something&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespacegmx_1a832da3c093109c13cc2369de05e02f3b" kindref="member">TrajectoryAnalysisModulePointer</ref><sp/>TemplateInfo::create()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="namespacegmx_1a832da3c093109c13cc2369de05e02f3b" kindref="member">TrajectoryAnalysisModulePointer</ref>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/><ref refid="classAnalysisTemplate" kindref="compound">AnalysisTemplate</ref>);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></listitem><listitem><para>Register your module in <computeroutput><ref refid="modules_8cpp" kindref="compound">src/gromacs/trajectoryanalysis/modules.cpp</ref></computeroutput>.</para></listitem><listitem><para>Done. Your tool can now be invoked as <computeroutput>gmx template</computeroutput>, using the string you specified as the name.</para></listitem></orderedlist>
</para><para>See existing tools within the <computeroutput>src/gromacs/trajectoryanalysis/modules/</computeroutput> for concrete examples and preferred layout of the files. Please document yourself as the author of the files, using Doxygen comments like in the existing files. </para>    </detaileddescription>
  </compounddef>
</doxygen>
