<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.5">
  <compounddef id="page_module_selection_compiler" kind="page">
    <compoundname>page_module_selection_compiler</compoundname>
    <title>Selection compilation</title>
    <detaileddescription>
<internal><para>The compiler takes the selection element tree from the selection parser (see <ref refid="page_module_selection_parser" kindref="compound">Selection parsing</ref>) as input. The selection parser is quite independent of selection evaluation details, and the compiler processes the tree to conform to what the evaluation functions expect. For better control and optimization possibilities, the compilation is done on all selections simultaneously. Hence, all the selections should be parsed before the compiler can be called.</para><para>The compiler initializes all fields in <ref refid="classgmx_1_1SelectionTreeElement" kindref="compound">gmx::SelectionTreeElement</ref> not initialized by the parser: <ref refid="classgmx_1_1SelectionTreeElement_1a2085e80677c9c9f9e0427332fa08bc19" kindref="member">gmx::SelectionTreeElement::v</ref> (some fields have already been initialized by the parser), <ref refid="classgmx_1_1SelectionTreeElement_1aa2729334e9625ab9446f87dee5e2acf4" kindref="member">gmx::SelectionTreeElement::evaluate</ref>, and <ref refid="classgmx_1_1SelectionTreeElement_1a1306ac006263a789f1ac63ed62c541c1" kindref="member">gmx::SelectionTreeElement::u</ref> (again, some elements have been initialized in the parser). The <ref refid="classgmx_1_1SelectionTreeElement_1af30728cbc6cd5a0c0ad8e6efa91f4632" kindref="member">gmx::SelectionTreeElement::cdata</ref> field is used during the compilation to store internal data, but the data is freed when the compiler returns.</para><para>In addition to initializing the elements, the compiler reorganizes the tree to simplify and optimize evaluation. The compiler also evaluates the static parts of the selection: in the end of the compilation, static parts have been replaced by the result of the evaluation.</para><para>The compiler is invoked using <ref refid="classgmx_1_1SelectionCompiler" kindref="compound">gmx::SelectionCompiler</ref>. The <ref refid="classgmx_1_1SelectionCompiler_1aa72856cafe98fec9583722ce42816c9a" kindref="member">gmx::SelectionCompiler::compile()</ref> method does the compilation in several passes over the <ref refid="classgmx_1_1SelectionTreeElement" kindref="compound">gmx::SelectionTreeElement</ref> tree.<orderedlist>
<listitem><para>Defaults are set for the position type and flags of position calculation methods that were not explicitly specified in the user input.</para></listitem><listitem><para>Subexpressions are extracted: a separate root is created for each subexpression, and placed before the expression is first used. Currently, only variables and expressions used to evaluate parameter values are extracted, but common subexpression could also be detected here.</para></listitem><listitem><para>A second pass (in fact, multiple passes because of interdependencies) with simple reordering and initialization is done:<orderedlist>
<listitem><para>Boolean expressions are combined such that one element can evaluate, e.g., &quot;A and B and C&quot;. The subexpressions in boolean expression are reordered such that static expressions come first without otherwise altering the relative order of the expressions.</para></listitem><listitem><para>The compiler data structure is allocated for each element, and the fields are initialized, with the exception of the contents of <computeroutput>gmax</computeroutput> and <computeroutput>gmin</computeroutput> fields. This is the part that needs multiple passes, because some flags are set recursively based on which elements refer to an element, and these flags need to be set to initialize other fields.</para></listitem><listitem><para>The <ref refid="classgmx_1_1SelectionTreeElement_1aa2729334e9625ab9446f87dee5e2acf4" kindref="member">gmx::SelectionTreeElement::evaluate</ref> field is set to the correct evaluation function from <ref refid="evaluate_8h" kindref="compound">evaluate.h</ref>.</para></listitem></orderedlist>
</para></listitem><listitem><para>The evaluation function of all elements is replaced with the <ref refid="compiler_8cpp_1ac606faa067c02b2dc1bedfe5009ea455" kindref="member">analyze_static()</ref> function to be able to initialize the element before the actual evaluation function is called. The evaluation machinery is then called to initialize the whole tree, while simultaneously evaluating the static expressions. During the evaluation, track is kept of the smallest and largest possible selections, and these are stored in the internal compiler data structure for each element. To be able to do this for all possible values of dynamical expressions, special care needs to be taken with boolean expressions because they are short-circuiting. This is done through the <computeroutput>SEL_CDATA_EVALMAX</computeroutput> flag, which makes dynamic child expressions of <computeroutput>BOOL_OR</computeroutput> expressions evaluate to empty groups, while subexpressions of <computeroutput>BOOL_AND</computeroutput> are evaluated to largest possible groups. Memory is also allocated to store the results of the evaluation. For each element, <ref refid="compiler_8cpp_1ac606faa067c02b2dc1bedfe5009ea455" kindref="member">analyze_static()</ref> calls the actual evaluation function after the element has been properly initialized.</para></listitem><listitem><para>Another evaluation pass is done over subexpressions with more than one reference to them. These cannot be completely processed during the first pass, because it is not known whether later references require additional evaluation of static expressions.</para></listitem><listitem><para>Unused subexpressions are removed. For efficiency reasons (and to avoid some checks), this is actually done several times already earlier in the compilation process.</para></listitem><listitem><para>Most of the processing is now done, and the next pass simply sets the evaluation group of root elements to the largest selection as determined in pass 4. For root elements of subexpressions that should not be evaluated before they are referred to, the evaluation group/function is cleared. At the same time, position calculation data is initialized for for selection method elements that require it. Compiler data is also freed as it is no longer needed.</para></listitem><listitem><para>A final pass initializes the total masses and charges in the <computeroutput>gmx_ana_selection_t</computeroutput> data structures.</para></listitem></orderedlist>
</para><para>The actual evaluation of the selection is described in the documentation of the functions in <ref refid="evaluate_8h" kindref="compound">evaluate.h</ref>.</para><para><xrefsect id="todo_1_todo000070"><xreftitle>Todo</xreftitle><xrefdescription><para>Some combinations of method parameter flags are not yet properly treated by the compiler or the evaluation functions in <ref refid="evaluate_8cpp" kindref="compound">evaluate.cpp</ref>. All the ones used by currently implemented methods should work, but new combinations might not.</para></xrefdescription></xrefsect></para><sect1 id="page_module_selection_compiler_1selcompiler_tree">
<title>Element tree after compilation</title>
<para>After the compilation, the selection element tree is suitable for gmx_ana_selcollection_evaluate(). Enough memory has been allocated for <ref refid="classgmx_1_1SelectionTreeElement_1a2085e80677c9c9f9e0427332fa08bc19" kindref="member">gmx::SelectionTreeElement::v</ref> (and <ref refid="classgmx_1_1SelectionTreeElement_1af90dd41be850fc4afbafa49fb3ce67e8" kindref="member">gmx::SelectionTreeElement::cgrp</ref> for <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a4b01539a457afb7dbdf486c2a2e6dafb" kindref="member">SEL_SUBEXPR</ref> elements) to allow the selection to be evaluated without allocating any memory.</para><sect2 id="page_module_selection_compiler_1selcompiler_tree_root">
<title>Root elements</title>
<para>The top level of the tree consists of a chain of <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a4374c0be00e03bae94a94c4f2d88569d" kindref="member">SEL_ROOT</ref> elements. These are used for two purposes:<orderedlist>
<listitem><para>A selection that should be evaluated. These elements appear in the same order as the selections in the input. For these elements, <ref refid="classgmx_1_1SelectionTreeElement_1a2085e80677c9c9f9e0427332fa08bc19" kindref="member">gmx::SelectionTreeElement::v</ref> has been set to the maximum possible group that the selection can evaluate to (only for dynamic selections), and <ref refid="classgmx_1_1SelectionTreeElement_1af90dd41be850fc4afbafa49fb3ce67e8" kindref="member">gmx::SelectionTreeElement::cgrp</ref> has been set to use a NULL group for evaluation.</para></listitem><listitem><para>A subexpression that appears in one or more selections. Each selection that gives a value for a method parameter is a potential subexpression, as is any variable value. Only subexpressions that require evaluation for each frame are left after the selection is compiled. Each subexpression appears in the chain before any references to it. For these elements, <ref refid="classgmx_1_1SelectionTreeElement_1af90dd41be850fc4afbafa49fb3ce67e8" kindref="member">gmx::SelectionTreeElement::cgrp</ref> has been set to the group that should be used to evaluate the subexpression. If <ref refid="classgmx_1_1SelectionTreeElement_1af90dd41be850fc4afbafa49fb3ce67e8" kindref="member">gmx::SelectionTreeElement::cgrp</ref> is empty, the total evaluation group is not known in advance or it is more efficient to evaluate the subexpression only when it is referenced. If this is the case, <ref refid="classgmx_1_1SelectionTreeElement_1aa2729334e9625ab9446f87dee5e2acf4" kindref="member">gmx::SelectionTreeElement::evaluate</ref> is also NULL.</para></listitem></orderedlist>
</para><para>The children of the <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a4374c0be00e03bae94a94c4f2d88569d" kindref="member">SEL_ROOT</ref> elements can be used to distinguish the two types of root elements from each other; the rules are the same as for the parsed tree (see <ref refid="page_module_selection_parser_1selparser_tree_root" kindref="member">Root elements</ref>). Subexpressions are treated as if they had been provided through variables.</para><para>Selection names are stored as after parsing (see <ref refid="page_module_selection_parser_1selparser_tree_root" kindref="member">Root elements</ref>).</para></sect2>
<sect2 id="page_module_selection_compiler_1selcompiler_tree_const">
<title>Constant elements</title>
<para>All (sub)selections that do not require particle positions have been replaced with <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46afae2ba2c065f70efcda76e4b7a7d17d0" kindref="member">SEL_CONST</ref> elements. Constant elements from the parser are also retained if present in dynamic parts of the selections. Several constant elements with a NULL <ref refid="classgmx_1_1SelectionTreeElement_1aa2729334e9625ab9446f87dee5e2acf4" kindref="member">gmx::SelectionTreeElement::evaluate</ref> are left for debugging purposes; of these, only the ones for <ref refid="selelem_8h_1ad24657d98854e03c3d6c46c37022a446a8c0bc1b3b7b2d3182a79286aaec0d13e" kindref="member">BOOL_OR</ref> expressions are used during evaluation.</para><para>The value is stored in <ref refid="classgmx_1_1SelectionTreeElement_1a2085e80677c9c9f9e0427332fa08bc19" kindref="member">gmx::SelectionTreeElement::v</ref>, and for group values with an evaluation function set, also in <ref refid="classgmx_1_1SelectionTreeElement_1af90dd41be850fc4afbafa49fb3ce67e8" kindref="member">gmx::SelectionTreeElement::cgrp</ref>. For <ref refid="selvalue_8h_1a70b42b87d434580bf1493591857b8beca70a2af6eafa48adfab506ceee60471f6" kindref="member">GROUP_VALUE</ref> elements, unnecessary atoms (i.e., atoms that could never be selected) have been removed from the value.</para><para><ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46afae2ba2c065f70efcda76e4b7a7d17d0" kindref="member">SEL_CONST</ref> elements have no children.</para></sect2>
<sect2 id="page_module_selection_compiler_1selcompiler_tree_method">
<title>Method evaluation elements</title>
<para>All selection methods that need to be evaluated dynamically are described by a <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a3d3bb644ace8fdc5beac6feed4911a1f" kindref="member">SEL_EXPRESSION</ref> element. The <ref refid="classgmx_1_1SelectionTreeElement_1a54e0a2e6530911e98b0b49ecb877fe76" kindref="member">gmx::SelectionTreeElement::method</ref> and <ref refid="classgmx_1_1SelectionTreeElement_1a1173ae4061374013d0fead828f1fa4d4" kindref="member">gmx::SelectionTreeElement::mdata</ref> fields have already been initialized by the parser, and the compiler only calls the initialization functions in the method data structure to do some additional initialization of these fields at appropriate points. If the <ref refid="classgmx_1_1SelectionTreeElement_1a16711f8089fd04a0822a56a977adfdb3" kindref="member">gmx::SelectionTreeElement::pc</ref> data field has been created by the parser, the compiler initializes the data structure properly once the required positions are known. If the <ref refid="classgmx_1_1SelectionTreeElement_1a16711f8089fd04a0822a56a977adfdb3" kindref="member">gmx::SelectionTreeElement::pc</ref> field is NULL after the parser, but the method provides only <ref refid="selmethod_8h_1a3242fa2db3798ede59bc98633c07dc87" kindref="member">sel_updatefunc_pos()</ref>, an appropriate position calculation data structure is created. If <ref refid="classgmx_1_1SelectionTreeElement_1a16711f8089fd04a0822a56a977adfdb3" kindref="member">gmx::SelectionTreeElement::pc</ref> is not NULL, <ref refid="classgmx_1_1SelectionTreeElement_1ac78b536909e9843043af491cc3df4775" kindref="member">gmx::SelectionTreeElement::pos</ref> is also initialized to hold the positions calculated.</para><para>Children of these elements are of type <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46af3e44c019a776df8511a73457f9b32b4" kindref="member">SEL_SUBEXPRREF</ref>, and describe parameter values that need to be evaluated for each frame. See the next section for more details. <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46afae2ba2c065f70efcda76e4b7a7d17d0" kindref="member">SEL_CONST</ref> children can also appear, and stand for parameters that get their value from a static expression. These elements are present only for debugging purposes: they always have a NULL evaluation function.</para></sect2>
<sect2 id="page_module_selection_compiler_1selcompiler_tree_subexpr">
<title>Subexpression elements</title>
<para>As described in <ref refid="page_module_selection_compiler_1selcompiler_tree_root" kindref="member">Root elements</ref>, subexpressions are created for each variable and each expression that gives a value to a selection method parameter. As the only child of the <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a4374c0be00e03bae94a94c4f2d88569d" kindref="member">SEL_ROOT</ref> element, these elements have a <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a4b01539a457afb7dbdf486c2a2e6dafb" kindref="member">SEL_SUBEXPR</ref> element. The <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a4b01539a457afb7dbdf486c2a2e6dafb" kindref="member">SEL_SUBEXPR</ref> element has a single child, which evaluates the actual expression. After compilation, only subexpressions that require particle positions for evaluation are left. For non-variable subexpression, automatic names have been generated to help in debugging.</para><para>For <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a4b01539a457afb7dbdf486c2a2e6dafb" kindref="member">SEL_SUBEXPR</ref> elements, memory has been allocated for <ref refid="classgmx_1_1SelectionTreeElement_1af90dd41be850fc4afbafa49fb3ce67e8" kindref="member">gmx::SelectionTreeElement::cgrp</ref> to store the group for which the expression has been evaluated during the current frame. This is only done if full subexpression evaluation by <ref refid="evaluate_8cpp_1a83156ae734e0a975b7498826dee5bee4" kindref="member">_gmx_sel_evaluate_subexpr()</ref> is needed; the other evaluation functions do not require this memory.</para><para><ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46af3e44c019a776df8511a73457f9b32b4" kindref="member">SEL_SUBEXPRREF</ref> elements are used to describe references to subexpressions. They have always a single child, which is the <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a4b01539a457afb7dbdf486c2a2e6dafb" kindref="member">SEL_SUBEXPR</ref> element being referenced.</para><para>If a subexpression is used only once, the evaluation has been optimized by setting the child of the <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a4b01539a457afb7dbdf486c2a2e6dafb" kindref="member">SEL_SUBEXPR</ref> element to evaluate the value of <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46af3e44c019a776df8511a73457f9b32b4" kindref="member">SEL_SUBEXPRREF</ref> directly (in the case of memory pooling, this is managed by the evaluation functions). In such cases, the evaluation routines for the <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46af3e44c019a776df8511a73457f9b32b4" kindref="member">SEL_SUBEXPRREF</ref> and <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a4b01539a457afb7dbdf486c2a2e6dafb" kindref="member">SEL_SUBEXPR</ref> elements only propagate some status information, but do not unnecessarily copy the values.</para></sect2>
<sect2 id="page_module_selection_compiler_1selcompiler_tree_bool">
<title>Boolean elements</title>
<para><ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46ae886c4e170c3abd5527de0af74ba4a45" kindref="member">SEL_BOOLEAN</ref> elements have been merged such that one element may carry out evaluation of more than one operation of the same type. The static parts of the expressions have been evaluated, and are placed in the first child. These are followed by the dynamic expressions, in the order provided by the user.</para></sect2>
<sect2 id="page_module_selection_compiler_1selcompiler_tree_arith">
<title>Arithmetic elements</title>
<para>Constant and static expressions in <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a8b75dccbec633c2002ea8c8fd3639b0e" kindref="member">SEL_ARITHMETIC</ref> elements have been calculated. Currently, no other processing is done. </para></sect2>
</sect1>
</internal>
    </detaileddescription>
  </compounddef>
</doxygen>
