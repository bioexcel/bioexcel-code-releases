<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.5">
  <compounddef id="page_module_selection_parser" kind="page">
    <compoundname>page_module_selection_parser</compoundname>
    <title>Selection parsing</title>
    <detaileddescription>
<internal><para>The selection parser is implemented in the following files:<itemizedlist>
<listitem><para>scanner.l: Tokenizer implemented using Flex, splits the input into tokens (scanner.c and scanner_flex.h are generated from this file).</para></listitem><listitem><para><ref refid="scanner_8h" kindref="compound">scanner.h</ref>, <ref refid="scanner__internal_8h" kindref="compound">scanner_internal.h</ref>, <ref refid="scanner__internal_8cpp" kindref="compound">scanner_internal.cpp</ref>: Helper functions for scanner.l and for interfacing between scanner.l and parser.y. Functions in <ref refid="scanner__internal_8h" kindref="compound">scanner_internal.h</ref> are only used from scanner.l, while <ref refid="scanner_8h" kindref="compound">scanner.h</ref> is used from the parser.</para></listitem><listitem><para><ref refid="symrec_8h" kindref="compound">symrec.h</ref>, <ref refid="symrec_8cpp" kindref="compound">symrec.cpp</ref>: Functions used by the tokenizer to handle the symbol table, i.e., the recognized keywords. Some basic keywords are hardcoded into scanner.l, but all method and variable references go through the symbol table, as do position evaluation keywords.</para></listitem><listitem><para>parser.y: Semantic rules for parsing the grammar (parser.cpp and parser.h are generated from this file by Bison).</para></listitem><listitem><para><ref refid="parsetree_8h" kindref="compound">parsetree.h</ref>, <ref refid="parsetree_8cpp" kindref="compound">parsetree.cpp</ref>: Functions called from actions in parser.y to construct the evaluation elements corresponding to different grammar elements.</para></listitem><listitem><para>params.c: Defines a function that processes the parameters of selection methods and initializes the children of the method element.</para></listitem><listitem><para><ref refid="selectioncollection_8h" kindref="compound">selectioncollection.h</ref>, selectioncollection.cpp: These files define the high-level public interface to the parser through SelectionCollection::parseInteractive(), SelectionCollection::parseFromStdin(), SelectionCollection::parseFromFile(), and SelectionCollection::parseFromString().</para></listitem></itemizedlist>
</para><para>The basic control flow in the parser is as follows: when a parser function in SelectionCollection gets called, it performs some initialization, and then calls the _gmx_sel_yyparse() function generated by Bison. This function then calls _gmx_sel_yylex() to repeatedly read tokens from the input (more complex tasks related to token recognition and bookkeeping are done by functions in <ref refid="scanner__internal_8cpp" kindref="compound">scanner_internal.cpp</ref>) and uses the grammar rules to decide what to do with them. Whenever a grammar rule matches, a corresponding function in <ref refid="parsetree_8cpp" kindref="compound">parsetree.cpp</ref> is called to construct either a temporary representation for the object or a <ref refid="classgmx_1_1SelectionTreeElement" kindref="compound">gmx::SelectionTreeElement</ref> object (some simple rules are handled internally in parser.y). When a complete selection has been parsed, the functions in <ref refid="parsetree_8cpp" kindref="compound">parsetree.cpp</ref> also take care of updating the <ref refid="structgmx__ana__selcollection__t" kindref="compound">gmx_ana_selcollection_t</ref> structure appropriately.</para><para>The rest of this page describes the resulting <ref refid="classgmx_1_1SelectionTreeElement" kindref="compound">gmx::SelectionTreeElement</ref> object tree. Before the selections can be evaluated, this tree needs to be passed to the selection compiler, which is described on a separate page: <ref refid="page_module_selection_compiler" kindref="compound">Selection compilation</ref></para><sect1 id="page_module_selection_parser_1selparser_tree">
<title>Element tree constructed by the parser</title>
<para>The parser initializes the following fields in all selection elements: <ref refid="classgmx_1_1SelectionTreeElement_1a69e4a72bbcb657ba8b782f51d78b761c" kindref="member">gmx::SelectionTreeElement::name</ref>, <ref refid="classgmx_1_1SelectionTreeElement_1a736adc8c9144c93b431a77687c4f7ba2" kindref="member">gmx::SelectionTreeElement::type</ref>, <ref refid="classgmx_1_1SelectionTreeElement_1a2085e80677c9c9f9e0427332fa08bc19" kindref="member">gmx::SelectionTreeElement::v</ref><computeroutput></computeroutput>.type, <ref refid="classgmx_1_1SelectionTreeElement_1ae1d4776443f7193597655f14415aabab" kindref="member">gmx::SelectionTreeElement::flags</ref>, <ref refid="classgmx_1_1SelectionTreeElement_1a87e8bb0ca4b76068e2f18328b162f3b0" kindref="member">gmx::SelectionTreeElement::child</ref>, and <ref refid="classgmx_1_1SelectionTreeElement_1a9fdde6f3d324aebbb90c4e12e9645485" kindref="member">gmx::SelectionTreeElement::next</ref>. Some other fields are also initialized for particular element types as discussed below. Fields that are not initialized are set to zero, NULL, or other similar value.</para><sect2 id="page_module_selection_parser_1selparser_tree_root">
<title>Root elements</title>
<para>The parser creates a <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a4374c0be00e03bae94a94c4f2d88569d" kindref="member">SEL_ROOT</ref> selection element for each variable assignment and each selection. However, there are two exceptions that do not result in a <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a4374c0be00e03bae94a94c4f2d88569d" kindref="member">SEL_ROOT</ref> element (in these cases, only the symbol table is modified):<itemizedlist>
<listitem><para>Variable assignments that assign a variable to another variable.</para></listitem><listitem><para>Variable assignments that assign a non-group constant.</para></listitem></itemizedlist>
The <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a4374c0be00e03bae94a94c4f2d88569d" kindref="member">SEL_ROOT</ref> elements are linked together in a chain in the same order as in the input.</para><para>The children of the <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a4374c0be00e03bae94a94c4f2d88569d" kindref="member">SEL_ROOT</ref> elements can be used to distinguish the two types of root elements from each other:<itemizedlist>
<listitem><para>For variable assignments, the first and only child is always a <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a4b01539a457afb7dbdf486c2a2e6dafb" kindref="member">SEL_SUBEXPR</ref> element.</para></listitem><listitem><para>For selections, the first child is a <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a3d3bb644ace8fdc5beac6feed4911a1f" kindref="member">SEL_EXPRESSION</ref> or a <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a6be1ee895a50c28639608b8b47843422" kindref="member">SEL_MODIFIER</ref> element that evaluates the final positions (if the selection defines a constant position, the child is a <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46afae2ba2c065f70efcda76e4b7a7d17d0" kindref="member">SEL_CONST</ref>). The rest of the children are <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a6be1ee895a50c28639608b8b47843422" kindref="member">SEL_MODIFIER</ref> elements with <ref refid="selvalue_8h_1a70b42b87d434580bf1493591857b8beca4d694119ce83b62d74ff06b5e017dca8" kindref="member">NO_VALUE</ref>, in the order given by the user.</para></listitem></itemizedlist>
The name of the selection/variable is stored in <ref refid="classgmx_1_1SelectionTreeElement_1af90dd41be850fc4afbafa49fb3ce67e8" kindref="member">gmx::SelectionTreeElement::cgrp</ref><computeroutput></computeroutput>.name. It is set to either the name provided by the user or the selection string for selections not explicitly named by the user. <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a4374c0be00e03bae94a94c4f2d88569d" kindref="member">SEL_ROOT</ref> or <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a4b01539a457afb7dbdf486c2a2e6dafb" kindref="member">SEL_SUBEXPR</ref> elements do not appear anywhere else.</para></sect2>
<sect2 id="page_module_selection_parser_1selparser_tree_const">
<title>Constant elements</title>
<para><ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46afae2ba2c065f70efcda76e4b7a7d17d0" kindref="member">SEL_CONST</ref> elements are created for every constant that is required for later evaluation. Currently, <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46afae2ba2c065f70efcda76e4b7a7d17d0" kindref="member">SEL_CONST</ref> elements can be present for<itemizedlist>
<listitem><para>selections that consist of a constant position,</para></listitem><listitem><para><ref refid="selvalue_8h_1a70b42b87d434580bf1493591857b8beca70a2af6eafa48adfab506ceee60471f6" kindref="member">GROUP_VALUE</ref> method parameters if provided using external index groups,</para></listitem></itemizedlist>
For group-valued elements, the value is stored in <ref refid="classgmx_1_1SelectionTreeElement_1af90dd41be850fc4afbafa49fb3ce67e8" kindref="member">gmx::SelectionTreeElement::cgrp</ref>; other types of values are stored in <ref refid="classgmx_1_1SelectionTreeElement_1a2085e80677c9c9f9e0427332fa08bc19" kindref="member">gmx::SelectionTreeElement::v</ref>. Constants that appear as parameters for selection methods are not present in the selection tree unless they have <ref refid="selvalue_8h_1a70b42b87d434580bf1493591857b8beca70a2af6eafa48adfab506ceee60471f6" kindref="member">GROUP_VALUE</ref>. <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46afae2ba2c065f70efcda76e4b7a7d17d0" kindref="member">SEL_CONST</ref> elements have no children.</para></sect2>
<sect2 id="page_module_selection_parser_1selparser_tree_method">
<title>Method evaluation elements</title>
<para><ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a3d3bb644ace8fdc5beac6feed4911a1f" kindref="member">SEL_EXPRESSION</ref> and <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a6be1ee895a50c28639608b8b47843422" kindref="member">SEL_MODIFIER</ref> elements are treated very similarly. The <computeroutput><ref refid="structgmx__ana__selmethod__t" kindref="compound">gmx_ana_selmethod_t</ref></computeroutput> structure corresponding to the evaluation method is in <ref refid="classgmx_1_1SelectionTreeElement_1a54e0a2e6530911e98b0b49ecb877fe76" kindref="member">gmx::SelectionTreeElement::method</ref>, and the method data in <ref refid="classgmx_1_1SelectionTreeElement_1a1173ae4061374013d0fead828f1fa4d4" kindref="member">gmx::SelectionTreeElement::mdata</ref> has been allocated using <ref refid="selmethod_8h_1a5acbf2d7bead71c4d96f9e69b267df56" kindref="member">sel_datafunc()</ref>. If a non-standard reference position type was set, <ref refid="classgmx_1_1SelectionTreeElement_1a16711f8089fd04a0822a56a977adfdb3" kindref="member">gmx::SelectionTreeElement::pc</ref> has also been created, but only the type has been set. All children of these elements are of the type <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46af3e44c019a776df8511a73457f9b32b4" kindref="member">SEL_SUBEXPRREF</ref>, and each describes a selection that needs to be evaluated to obtain a value for one parameter of the method. No children are present for parameters that were given a constant non-<ref refid="selvalue_8h_1a70b42b87d434580bf1493591857b8beca70a2af6eafa48adfab506ceee60471f6" kindref="member">GROUP_VALUE</ref> value. The children are sorted in the order in which the parameters appear in the <ref refid="structgmx__ana__selmethod__t" kindref="compound">gmx_ana_selmethod_t</ref> structure.</para><para>In addition to actual selection keywords, <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a3d3bb644ace8fdc5beac6feed4911a1f" kindref="member">SEL_EXPRESSION</ref> elements are used internally to implement numerical comparisons (e.g., &quot;x &lt; 5&quot;) and keyword matching (e.g., &quot;resnr 1 to 3&quot; or &quot;name CA&quot;).</para></sect2>
<sect2 id="page_module_selection_parser_1selparser_tree_subexpr">
<title>Subexpression elements</title>
<para><ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a4b01539a457afb7dbdf486c2a2e6dafb" kindref="member">SEL_SUBEXPR</ref> elements only appear for variables, as described above. <ref refid="classgmx_1_1SelectionTreeElement_1a69e4a72bbcb657ba8b782f51d78b761c" kindref="member">gmx::SelectionTreeElement::name</ref> points to the name of the variable (from the <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a4374c0be00e03bae94a94c4f2d88569d" kindref="member">SEL_ROOT</ref> element). The element always has exactly one child, which represents the value of the variable.</para><para><ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46af3e44c019a776df8511a73457f9b32b4" kindref="member">SEL_SUBEXPRREF</ref> elements are used for two purposes:<itemizedlist>
<listitem><para>Variable references that need to be evaluated (i.e., there is a <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a4b01539a457afb7dbdf486c2a2e6dafb" kindref="member">SEL_SUBEXPR</ref> element for the variable) are represented using <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46af3e44c019a776df8511a73457f9b32b4" kindref="member">SEL_SUBEXPRREF</ref> elements. In this case, <ref refid="classgmx_1_1SelectionTreeElement_1a0b4956164b6ed61094a550099fa90d3b" kindref="member">gmx::SelectionTreeElement::param</ref> is NULL, and the first and only child of the element is the <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a4b01539a457afb7dbdf486c2a2e6dafb" kindref="member">SEL_SUBEXPR</ref> element of the variable. Such references can appear anywhere where the variable value (the child of the <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a4b01539a457afb7dbdf486c2a2e6dafb" kindref="member">SEL_SUBEXPR</ref> element) would be valid.</para></listitem><listitem><para>Children of <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a3d3bb644ace8fdc5beac6feed4911a1f" kindref="member">SEL_EXPRESSION</ref> and <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a6be1ee895a50c28639608b8b47843422" kindref="member">SEL_MODIFIER</ref> elements are always of this type. For these elements, <ref refid="classgmx_1_1SelectionTreeElement_1a0b4956164b6ed61094a550099fa90d3b" kindref="member">gmx::SelectionTreeElement::param</ref> is initialized to point to the parameter that receives the value from the expression. Each such element has exactly one child, which can be of any type; the <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a4b01539a457afb7dbdf486c2a2e6dafb" kindref="member">SEL_SUBEXPR</ref> element of a variable is used if the value comes from a variable, otherwise the child type is not <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a4b01539a457afb7dbdf486c2a2e6dafb" kindref="member">SEL_SUBEXPR</ref>.</para></listitem></itemizedlist>
</para></sect2>
<sect2 id="page_module_selection_parser_1selparser_tree_bool">
<title>Boolean elements</title>
<para>One <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46ae886c4e170c3abd5527de0af74ba4a45" kindref="member">SEL_BOOLEAN</ref> element is created for each boolean keyword in the input, and the tree structure represents the evaluation order. The <ref refid="classgmx_1_1SelectionTreeElement_1a5681faa349b7dd17efe8c2bcdaac9804" kindref="member">gmx::SelectionTreeElement::boolt</ref> type gives the type of the operation. Each element has exactly two children (one for <ref refid="selelem_8h_1ad24657d98854e03c3d6c46c37022a446a1a54e3beb472c1dc0a37a631f979f8ce" kindref="member">BOOL_NOT</ref> elements), which are in the order given in the input. The children always have <ref refid="selvalue_8h_1a70b42b87d434580bf1493591857b8beca70a2af6eafa48adfab506ceee60471f6" kindref="member">GROUP_VALUE</ref>, but different element types are possible.</para></sect2>
<sect2 id="page_module_selection_parser_1selparser_tree_arith">
<title>Arithmetic elements</title>
<para>One <ref refid="selelem_8h_1a1f104d5c71b1198ef51acc4ef016ae46a8b75dccbec633c2002ea8c8fd3639b0e" kindref="member">SEL_ARITHMETIC</ref> element is created for each arithmetic operation in the input, and the tree structure represents the evaluation order. The gmx::SelectionTreeElement::optype type gives the name of the operation. Each element has exactly two children (one for unary negation elements), which are in the order given in the input. </para></sect2>
</sect1>
</internal>
    </detaileddescription>
  </compounddef>
</doxygen>
