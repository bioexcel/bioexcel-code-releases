<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.5">
  <compounddef id="group__module__analysisdata" kind="group">
    <compoundname>module_analysisdata</compoundname>
    <title>Parallelizable Handling of Output Data (analysisdata)</title>
    <innerfile refid="abstractdata_8cpp">abstractdata.cpp</innerfile>
    <innerfile refid="abstractdata_8h">abstractdata.h</innerfile>
    <innerfile refid="analysisdata_8cpp">analysisdata.cpp</innerfile>
    <innerfile refid="analysisdata_2analysisdata_8h">analysisdata.h</innerfile>
    <innerfile refid="arraydata_8cpp">arraydata.cpp</innerfile>
    <innerfile refid="arraydata_8h">arraydata.h</innerfile>
    <innerfile refid="dataframe_8cpp">dataframe.cpp</innerfile>
    <innerfile refid="dataframe_8h">dataframe.h</innerfile>
    <innerfile refid="datamodule_8cpp">datamodule.cpp</innerfile>
    <innerfile refid="datamodule_8h">datamodule.h</innerfile>
    <innerfile refid="datamodulemanager_8cpp">datamodulemanager.cpp</innerfile>
    <innerfile refid="datamodulemanager_8h">datamodulemanager.h</innerfile>
    <innerfile refid="dataproxy_8cpp">dataproxy.cpp</innerfile>
    <innerfile refid="dataproxy_8h">dataproxy.h</innerfile>
    <innerfile refid="datastorage_8cpp">datastorage.cpp</innerfile>
    <innerfile refid="datastorage_8h">datastorage.h</innerfile>
    <innerfile refid="framelocaldata_8h">framelocaldata.h</innerfile>
    <innerfile refid="modules_2average_8cpp">average.cpp</innerfile>
    <innerfile refid="average_8h">average.h</innerfile>
    <innerfile refid="displacement_8cpp">displacement.cpp</innerfile>
    <innerfile refid="displacement_8h">displacement.h</innerfile>
    <innerfile refid="frameaverager_8cpp">frameaverager.cpp</innerfile>
    <innerfile refid="frameaverager_8h">frameaverager.h</innerfile>
    <innerfile refid="modules_2histogram_8cpp">histogram.cpp</innerfile>
    <innerfile refid="histogram_8h">histogram.h</innerfile>
    <innerfile refid="modules_2lifetime_8cpp">lifetime.cpp</innerfile>
    <innerfile refid="lifetime_8h">lifetime.h</innerfile>
    <innerfile refid="plot_8cpp">plot.cpp</innerfile>
    <innerfile refid="plot_8h">plot.h</innerfile>
    <innerfile refid="paralleloptions_8h">paralleloptions.h</innerfile>
    <innerfile refid="tests_2analysisdata_8cpp">analysisdata.cpp</innerfile>
    <innerfile refid="tests_2arraydata_8cpp">arraydata.cpp</innerfile>
    <innerfile refid="tests_2average_8cpp">average.cpp</innerfile>
    <innerfile refid="datatest_8cpp">datatest.cpp</innerfile>
    <innerfile refid="datatest_8h">datatest.h</innerfile>
    <innerfile refid="tests_2histogram_8cpp">histogram.cpp</innerfile>
    <innerfile refid="tests_2lifetime_8cpp">lifetime.cpp</innerfile>
    <innerfile refid="mock__datamodule_8cpp">mock_datamodule.cpp</innerfile>
    <innerfile refid="mock__datamodule_8h">mock_datamodule.h</innerfile>
    <innerfile refid="analysisdata_8h">analysisdata.h</innerfile>
    <innerclass refid="classgmx_1_1AbstractAnalysisData_1_1Impl" prot="public">gmx::AbstractAnalysisData::Impl</innerclass>
    <innerclass refid="classgmx_1_1AbstractAnalysisData" prot="public">gmx::AbstractAnalysisData</innerclass>
    <innerclass refid="classgmx_1_1internal_1_1AnalysisDataHandleImpl" prot="public">gmx::internal::AnalysisDataHandleImpl</innerclass>
    <innerclass refid="classgmx_1_1AnalysisData" prot="public">gmx::AnalysisData</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataHandle" prot="public">gmx::AnalysisDataHandle</innerclass>
    <innerclass refid="classgmx_1_1AbstractAnalysisArrayData" prot="public">gmx::AbstractAnalysisArrayData</innerclass>
    <innerclass refid="classgmx_1_1AnalysisArrayData" prot="public">gmx::AnalysisArrayData</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataValue" prot="public">gmx::AnalysisDataValue</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataFrameHeader" prot="public">gmx::AnalysisDataFrameHeader</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataPointSetRef" prot="public">gmx::AnalysisDataPointSetRef</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataFrameRef" prot="public">gmx::AnalysisDataFrameRef</innerclass>
    <innerclass refid="classgmx_1_1IAnalysisDataModule" prot="public">gmx::IAnalysisDataModule</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataModuleSerial" prot="public">gmx::AnalysisDataModuleSerial</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataModuleParallel" prot="public">gmx::AnalysisDataModuleParallel</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataModuleManager" prot="public">gmx::AnalysisDataModuleManager</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataProxy" prot="public">gmx::AnalysisDataProxy</innerclass>
    <innerclass refid="classgmx_1_1internal_1_1AnalysisDataStorageImpl" prot="public">gmx::internal::AnalysisDataStorageImpl</innerclass>
    <innerclass refid="classgmx_1_1internal_1_1AnalysisDataStorageFrameData" prot="public">gmx::internal::AnalysisDataStorageFrameData</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataStorageFrame" prot="public">gmx::AnalysisDataStorageFrame</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataStorage" prot="public">gmx::AnalysisDataStorage</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataFrameLocalDataSetHandle" prot="public">gmx::AnalysisDataFrameLocalDataSetHandle</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataFrameLocalDataHandle" prot="public">gmx::AnalysisDataFrameLocalDataHandle</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataFrameLocalData" prot="public">gmx::AnalysisDataFrameLocalData</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataAverageModule" prot="public">gmx::AnalysisDataAverageModule</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataFrameAverageModule" prot="public">gmx::AnalysisDataFrameAverageModule</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataDisplacementModule" prot="public">gmx::AnalysisDataDisplacementModule</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataFrameAverager" prot="public">gmx::AnalysisDataFrameAverager</innerclass>
    <innerclass refid="classgmx_1_1anonymous__namespace_02histogram_8cpp_03_1_1StaticAverageHistogram" prot="public">gmx::anonymous_namespace{histogram.cpp}::StaticAverageHistogram</innerclass>
    <innerclass refid="classgmx_1_1internal_1_1BasicAverageHistogramModule" prot="public">gmx::internal::BasicAverageHistogramModule</innerclass>
    <innerclass refid="classgmx_1_1internal_1_1BasicHistogramImpl" prot="public">gmx::internal::BasicHistogramImpl</innerclass>
    <innerclass refid="classgmx_1_1AnalysisHistogramSettingsInitializer" prot="public">gmx::AnalysisHistogramSettingsInitializer</innerclass>
    <innerclass refid="classgmx_1_1AnalysisHistogramSettings" prot="public">gmx::AnalysisHistogramSettings</innerclass>
    <innerclass refid="classgmx_1_1AbstractAverageHistogram" prot="public">gmx::AbstractAverageHistogram</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataSimpleHistogramModule" prot="public">gmx::AnalysisDataSimpleHistogramModule</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataWeightedHistogramModule" prot="public">gmx::AnalysisDataWeightedHistogramModule</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataBinAverageModule" prot="public">gmx::AnalysisDataBinAverageModule</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataLifetimeModule" prot="public">gmx::AnalysisDataLifetimeModule</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataPlotSettings" prot="public">gmx::AnalysisDataPlotSettings</innerclass>
    <innerclass refid="classgmx_1_1AbstractPlotModule" prot="public">gmx::AbstractPlotModule</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataPlotModule" prot="public">gmx::AnalysisDataPlotModule</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataVectorPlotModule" prot="public">gmx::AnalysisDataVectorPlotModule</innerclass>
    <innerclass refid="classgmx_1_1AnalysisDataParallelOptions" prot="public">gmx::AnalysisDataParallelOptions</innerclass>
    <innerclass refid="classgmx_1_1test_1_1AnalysisDataTestInputPointSet" prot="public">gmx::test::AnalysisDataTestInputPointSet</innerclass>
    <innerclass refid="classgmx_1_1test_1_1AnalysisDataTestInputFrame" prot="public">gmx::test::AnalysisDataTestInputFrame</innerclass>
    <innerclass refid="classgmx_1_1test_1_1AnalysisDataTestInput" prot="public">gmx::test::AnalysisDataTestInput</innerclass>
    <innerclass refid="classgmx_1_1test_1_1AnalysisDataTestFixture" prot="public">gmx::test::AnalysisDataTestFixture</innerclass>
    <innerclass refid="classanonymous__namespace_02histogram_8cpp_03_1_1MockAverageHistogram" prot="public">anonymous_namespace{histogram.cpp}::MockAverageHistogram</innerclass>
    <innerclass refid="classgmx_1_1analysismodules_1_1anonymous__namespace_02select_8cpp_03_1_1IndexFileWriterModule" prot="public">gmx::analysismodules::anonymous_namespace{select.cpp}::IndexFileWriterModule</innerclass>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__module__analysisdata_1gac450133dc0602bd18aaf78fe3ee4f534" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void gmx::test::anonymous_namespace{mock_datamodule.cpp}::checkReferenceDataPoint</definition>
        <argsstring>(TestReferenceChecker *checker, const AnalysisDataValue &amp;value)</argsstring>
        <name>checkReferenceDataPoint</name>
        <param>
          <type>TestReferenceChecker *</type>
          <declname>checker</declname>
        </param>
        <param>
          <type>const AnalysisDataValue &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Checks a single <ref refid="classgmx_1_1AnalysisDataValue" kindref="compound">AnalysisDataValue</ref>. </para>        </briefdescription>
        <detaileddescription>
<internal></internal>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins/workspace/Release_workflow_master/gromacs-2018.3/src/gromacs/analysisdata/tests/mock_datamodule.cpp" line="143" column="1" bodyfile="/home/jenkins/workspace/Release_workflow_master/gromacs-2018.3/src/gromacs/analysisdata/tests/mock_datamodule.cpp" bodystart="143" bodyend="156"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Provides functionality for handling and processing output data from analysis. </para>    </briefdescription>
    <detaileddescription>
<para><heading level="3">Overview</heading>
</para><para>This module provides functionality to do common processing for tabular data in analysis tools. In addition to providing this common functionality, one major driver for this module is to make it simple to write analysis tools that process frames in parallel: the functionality in this module takes care of necessary synchronization and communication such that output from the frames is collected and output in the correct order. See <ref refid="page_analysisdata" kindref="compound">Analysis output data handling</ref> for an overview of the high-level functionality and the terminology used.</para><para>This module consists of two main parts. The first is formed by the <ref refid="classgmx_1_1AbstractAnalysisData" kindref="compound">gmx::AbstractAnalysisData</ref> class and classes that derive from it: <ref refid="classgmx_1_1AnalysisData" kindref="compound">gmx::AnalysisData</ref> and <ref refid="classgmx_1_1AnalysisArrayData" kindref="compound">gmx::AnalysisArrayData</ref>. These classes are used to process and store raw data as produced by the analysis tool. They also provide an interface to attach data modules that implement <ref refid="classgmx_1_1IAnalysisDataModule" kindref="compound">gmx::IAnalysisDataModule</ref>.</para><para>Modules that implement <ref refid="classgmx_1_1IAnalysisDataModule" kindref="compound">gmx::IAnalysisDataModule</ref> form the second part of the module, and they provide functionality to do processing on the data. These modules can also derive from <ref refid="classgmx_1_1AbstractAnalysisData" kindref="compound">gmx::AbstractAnalysisData</ref>, allowing other modules to be attached to them to form a processing chain that best suits the analysis tool. Typically, such a processing chain ends in a plotting module that writes the data into a file, but the final module can also provide direct access to the processed data, allowing the analysis tool to do custom postprocessing outside the module framework.</para><para><heading level="3">Using Data Objects and Modules</heading>
</para><para>To use the functionality in this module, you typically declare one or more <ref refid="classgmx_1_1AnalysisData" kindref="compound">AnalysisData</ref> objects and set its properties. You then create some module objects and set their properties (see the list of classes that implement <ref refid="classgmx_1_1IAnalysisDataModule" kindref="compound">gmx::IAnalysisDataModule</ref>) and attach them to the data objects or to one another using <ref refid="classgmx_1_1AbstractAnalysisData_1ada778191d76b2826b57e7b30ecd7a296" kindref="member">gmx::AbstractAnalysisData::addModule()</ref>. Then you add the actual data values to the <ref refid="classgmx_1_1AnalysisData" kindref="compound">gmx::AnalysisData</ref> object, which automatically passes it on to the modules. After all data is added, you may optionally access some results directly from the module objects or from the <ref refid="classgmx_1_1AnalysisData" kindref="compound">gmx::AnalysisData</ref> object itself. However, in many cases it is sufficient to initially add a plotting module to the processing chain, which will then automatically write the results into a file.</para><para>For simple processing needs with a small amount of data, an <ref refid="classgmx_1_1AnalysisArrayData" kindref="compound">gmx::AnalysisArrayData</ref> class is also provided, which keeps all the data in an in-memory array and allows you to manipulate the data as you wish before you pass the data to the attached modules.</para><para><heading level="3">Data Modules</heading>
</para><para>Modules that derive from <ref refid="classgmx_1_1IAnalysisDataModule" kindref="compound">gmx::IAnalysisDataModule</ref> can operate in two modes:<itemizedlist>
<listitem><para>In <emphasis>serial</emphasis> mode, the frames are presented to the module always in the order of increasing indices, even if they become ready in a different order in the attached data.</para></listitem><listitem><para>In <emphasis>parallel</emphasis> mode, the frames are presented in the order that they become available in the input data, which may not be sequential. This mode allows the input data to optimize its behavior if it does not need to store and sort the frames.</para></listitem></itemizedlist>
</para><para>The figure below shows the sequence of callbacks that the module receives. Arrows show a dependency between callbacks: the event at the start of the arrow always occurs before the event at the end. The events in the box are repeated for each frame. Dashed lines within this box show dependencies between these frames:<itemizedlist>
<listitem><para>In serial mode, all the events are called in a deterministic order, with each frame completely processed before the next starts.</para></listitem><listitem><para>In parallel mode, multiple frames can be in progress simultaneously, and the events for different frames can occur even concurrently on different threads. However, frameFinishSerial() events will always occur in deterministic, sequential order for the frames. Also, the number of concurrent frames is limited by the parallelization factor passed to parallelDataStarted(): only M frames after the last frame for which frameFinishSerial() has been called can be in progress</para></listitem></itemizedlist>
</para><para><dot> 
    digraph datamodule_events {
        rankdir = LR
        node [ shape=box ]

        start  [ label=&quot;dataStarted()&quot;,
                 URL=&quot;\ref gmx::IAnalysisDataModule::dataStarted()&quot; ]
        pstart [ label=&quot;parallelDataStarted()&quot;,
                 URL=&quot;\ref gmx::IAnalysisDataModule::parallelDataStarted()&quot; ]
        subgraph cluster_frame {
            label = &quot;for each frame&quot;
            framestart   [ label=&quot;frameStarted()&quot;,
                           URL=&quot;\ref gmx::IAnalysisDataModule::frameStarted()&quot; ]
            pointsadd    [ label=&quot;pointsAdded()&quot;,
                           URL=&quot;\ref gmx::IAnalysisDataModule::pointsAdded()&quot; ]
            framefinish  [ label=&quot;frameFinished()&quot;,
                           URL=&quot;\ref gmx::IAnalysisDataModule::frameFinished()&quot; ]
            serialfinish [ label=&quot;frameFinishedSerial()&quot;,
                           URL=&quot;\ref gmx::IAnalysisDataModule::frameFinishedSerial()&quot; ]
        }
        finish [ label=&quot;dataFinished()&quot;,
                 URL=&quot;\ref gmx::IAnalysisDataModule::dataFinished()&quot; ]

        start -&gt; framestart
        pstart -&gt; framestart
        framestart -&gt; pointsadd
        pointsadd -&gt; pointsadd [ label=&quot;0..*&quot;, dir=back ]
        pointsadd -&gt; framefinish
        framefinish -&gt; serialfinish
        serialfinish -&gt; finish

        framestart:se -&gt; serialfinish:sw [ dir=back, style=dashed, weight=0,
                                           label=&quot;serial: frame n+1\nparallel: frame n+M&quot; ]
        serialfinish -&gt; serialfinish [ dir=back, style=dashed,
                                       label=&quot;frame n+1&quot; ]
    }
</dot></para><para>If the input data supports parallel mode, it calls parallelDataStarted(). If the module returns <computeroutput>true</computeroutput> from this method, then it will process the frames in the parallel mode. If the module returns <computeroutput>false</computeroutput>, it will get the frames in serial order. If the input data does not support parallel mode, it calls dataStarted(), and the module will always get the frames in order.</para><para>The sequence of when the module methods are called with respect to when data is added to the data object depends on the type of the module and the type of the data. However, generally the modules do not need to know the details of how this happens, as long as they work with the above state diagram.</para><para>For parallel processing, the <ref refid="classgmx_1_1AnalysisData" kindref="compound">gmx::AnalysisData</ref> object itself only provides the infrastructure to support all of the above, including the reordering of the frames for serial processing. However, the caller is still responsible of the actual thread synchronization, and must call <ref refid="classgmx_1_1AnalysisData_1a54e98fd211473c7cfe750e2b49517d96" kindref="member">gmx::AnalysisData::finishFrameSerial()</ref> for each frame from a suitable context where the serial processing for that frame can be done. When using the data objects as part of the trajectory analysis framework (<ref refid="page_analysisframework" kindref="compound">Framework for trajectory analysis</ref>), these calls are handled by the framework.</para><para><heading level="3">Writing New Data and Module Objects</heading>
</para><para>New data modules can be implemented to perform custom operations that are not supported by the modules provided in this module. This is done by creating a new class that implements <ref refid="classgmx_1_1IAnalysisDataModule" kindref="compound">gmx::IAnalysisDataModule</ref>. If the new module computes values that can be used as input for other modules, the new class should also derive from <ref refid="classgmx_1_1AbstractAnalysisData" kindref="compound">gmx::AbstractAnalysisData</ref>, and preferably use <ref refid="classgmx_1_1AnalysisDataStorage" kindref="compound">gmx::AnalysisDataStorage</ref> internally to implement storage of values. See the documentation of the mentioned classes for more details on how to implement custom modules. When implementing a new module, it should be considered whether it can be of more general use, and if so, it should be added to this module.</para><para>It is also possible to implement new data source objects by deriving a class from <ref refid="classgmx_1_1AbstractAnalysisData" kindref="compound">gmx::AbstractAnalysisData</ref>. This should not normally be necessary, since this module provides general data source objects for most typical uses. If the classes in this module are not suitable for some specific use, it should be considered whether a new generic class could be added (or an existing extended) instead of implementing a local custom solution.</para><para><simplesect kind="author"><para>Teemu Murtola <ulink url="mailto:teemu.murtola@gmail.com">teemu.murtola@gmail.com</ulink> </para></simplesect>
</para>    </detaileddescription>
  </compounddef>
</doxygen>
