<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Gromacs: gmx::Allocator&lt; T, AllocationPolicy &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Gromacs
   &#160;<span id="projectnumber">2018.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.xhtml"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.xhtml"><span>Modules</span></a></li>
      <li><a href="pages.xhtml"><span>Other&#160;Docs</span></a></li>
      <li><a href="namespaces.xhtml"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.xhtml"><span>Classes</span></a></li>
      <li><a href="files.xhtml"><span>Files</span></a></li>
      <li><a href="examples.xhtml"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.xhtml"><span>Class&#160;List</span></a></li>
      <li><a href="classes.xhtml"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.xhtml"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.xhtml"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegmx.xhtml">gmx</a></li><li class="navelem"><a class="el" href="classgmx_1_1Allocator.xhtml">Allocator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classgmx_1_1Allocator-members.xhtml">List of all members</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">gmx::Allocator&lt; T, AllocationPolicy &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__group__libraryapi.xhtml">Library API</a> &#124; <a class="el" href="group__module__utility.xhtml">Low-Level Utilities (utility)</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;gromacs/utility/allocator.h&gt;</code></p>

<p>Inherits AllocationPolicy.</p>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><h3>template&lt;class T, typename AllocationPolicy&gt;<br/>
class gmx::Allocator&lt; T, AllocationPolicy &gt;</h3>

<p>Policy-based memory allocator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of objects to allocate </td></tr>
    <tr><td class="paramname">AllocationPolicy</td><td>Policy of (matching) allocation and deallocation functions.</td></tr>
  </table>
  </dd>
</dl>
<p>This class can be used for the optional allocator template parameter in standard library containers. It must be configured with both the type of object to allocate, and an AllocationPolicy which effectively wraps a matching pair of malloc and free functions. This permits implementing a family of related allocators e.g. with SIMD alignment, GPU host-side page locking, or perhaps both, in a way that preserves a common programming interface and duplicates minimal code.</p>
<p>AllocationPolicy is used as a base class, so that if AllocationPolicy is stateless, then the empty base optimization will ensure that Allocation is also stateless, and objects made with the <a class="el" href="classgmx_1_1Allocator.xhtml" title="Policy-based memory allocator. ">Allocator</a> will incur no size penalty. (Embedding an AllocationPolicy object incurs a size penalty always, even if the object is empty.) Normally a stateless allocator will be used.</p>
<p>However, an AllocationPolicy with state might be desirable for simplifying writing code that needs to allocate suitably for a transfer to a GPU. That code needs to specify an <a class="el" href="classgmx_1_1Allocator.xhtml" title="Policy-based memory allocator. ">Allocator</a> that can do the right job, which can be stateless. However, if we have code that will not know until run time whether a GPU transfer will occur, then the allocator needs to be aware of the state. That will increase the size of a container that uses the stateful allocator.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Instead of a GROMACS exception object, we throw the standard one on allocation failures to make it as compatible as possible with the errors expected by code using the standard library containers. </td></tr>
  </table>
  </dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgmx_1_1Allocator_1_1rebind.xhtml">rebind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard-required typedef to use allocator with different class.  <a href="structgmx_1_1Allocator_1_1rebind.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a52ff4b2b565b8fd044b60435dde36cb1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52ff4b2b565b8fd044b60435dde36cb1"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Allocator.xhtml#a52ff4b2b565b8fd044b60435dde36cb1">value_type</a></td></tr>
<tr class="memdesc:a52ff4b2b565b8fd044b60435dde36cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of allocated elements. <br/></td></tr>
<tr class="separator:a52ff4b2b565b8fd044b60435dde36cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36defaf0a6325bb34eea401fe8b63240"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36defaf0a6325bb34eea401fe8b63240"></a>
typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Allocator.xhtml#a36defaf0a6325bb34eea401fe8b63240">reference</a></td></tr>
<tr class="memdesc:a36defaf0a6325bb34eea401fe8b63240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to allocated elements. <br/></td></tr>
<tr class="separator:a36defaf0a6325bb34eea401fe8b63240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253b7a6112bbac509fea1828cd47854e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a253b7a6112bbac509fea1828cd47854e"></a>
typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Allocator.xhtml#a253b7a6112bbac509fea1828cd47854e">const_reference</a></td></tr>
<tr class="memdesc:a253b7a6112bbac509fea1828cd47854e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant reference to allocated elements. <br/></td></tr>
<tr class="separator:a253b7a6112bbac509fea1828cd47854e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87f6d52282a6833058ce45ac7f92920"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af87f6d52282a6833058ce45ac7f92920"></a>
typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Allocator.xhtml#af87f6d52282a6833058ce45ac7f92920">pointer</a></td></tr>
<tr class="memdesc:af87f6d52282a6833058ce45ac7f92920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to allocated elements. <br/></td></tr>
<tr class="separator:af87f6d52282a6833058ce45ac7f92920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb62396cdb47cf800966ae6a56d7fb7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bb62396cdb47cf800966ae6a56d7fb7"></a>
typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Allocator.xhtml#a9bb62396cdb47cf800966ae6a56d7fb7">const_pointer</a></td></tr>
<tr class="memdesc:a9bb62396cdb47cf800966ae6a56d7fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant pointer to allocated elements. <br/></td></tr>
<tr class="separator:a9bb62396cdb47cf800966ae6a56d7fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12379a4355abb23868e0542abf1d8725"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12379a4355abb23868e0542abf1d8725"></a>
typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Allocator.xhtml#a12379a4355abb23868e0542abf1d8725">size_type</a></td></tr>
<tr class="memdesc:a12379a4355abb23868e0542abf1d8725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer type to use for size of objects. <br/></td></tr>
<tr class="separator:a12379a4355abb23868e0542abf1d8725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2091e39bcae03a85d824b41d655451fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2091e39bcae03a85d824b41d655451fc"></a>
typedef std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Allocator.xhtml#a2091e39bcae03a85d824b41d655451fc">difference_type</a></td></tr>
<tr class="memdesc:a2091e39bcae03a85d824b41d655451fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type to hold differences between pointers. <br/></td></tr>
<tr class="separator:a2091e39bcae03a85d824b41d655451fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38e018883067a0cacebbbc4df532de1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad38e018883067a0cacebbbc4df532de1"></a>
typedef AllocationPolicy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Allocator.xhtml#ad38e018883067a0cacebbbc4df532de1">allocation_policy</a></td></tr>
<tr class="memdesc:ad38e018883067a0cacebbbc4df532de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the AllocationPolicy. <br/></td></tr>
<tr class="separator:ad38e018883067a0cacebbbc4df532de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aff6e796fd68d6f9e7b9af6ffd9c8e2d6"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:aff6e796fd68d6f9e7b9af6ffd9c8e2d6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgmx_1_1Allocator.xhtml#aff6e796fd68d6f9e7b9af6ffd9c8e2d6">Allocator</a> (const <a class="el" href="classgmx_1_1Allocator.xhtml">Allocator</a>&lt; U, AllocationPolicy &gt; &amp;)</td></tr>
<tr class="memdesc:aff6e796fd68d6f9e7b9af6ffd9c8e2d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated copy constructor.  <a href="#aff6e796fd68d6f9e7b9af6ffd9c8e2d6">More...</a><br/></td></tr>
<tr class="separator:aff6e796fd68d6f9e7b9af6ffd9c8e2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace00f232d83508c89bfb218307ecabeb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Allocator.xhtml#ace00f232d83508c89bfb218307ecabeb">Allocator</a> ()=default</td></tr>
<tr class="memdesc:ace00f232d83508c89bfb218307ecabeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ace00f232d83508c89bfb218307ecabeb">More...</a><br/></td></tr>
<tr class="separator:ace00f232d83508c89bfb218307ecabeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1fded5606714bab5418ff5400e6e35"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Allocator.xhtml#a7e1fded5606714bab5418ff5400e6e35">Allocator</a> (const AllocationPolicy &amp;p)</td></tr>
<tr class="memdesc:a7e1fded5606714bab5418ff5400e6e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to accept an AllocationPolicy.  <a href="#a7e1fded5606714bab5418ff5400e6e35">More...</a><br/></td></tr>
<tr class="separator:a7e1fded5606714bab5418ff5400e6e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3f127c814c0331a9cea3da8a0322a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgmx_1_1Allocator.xhtml#af87f6d52282a6833058ce45ac7f92920">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Allocator.xhtml#afd3f127c814c0331a9cea3da8a0322a3">address</a> (<a class="el" href="classgmx_1_1Allocator.xhtml#a36defaf0a6325bb34eea401fe8b63240">reference</a> r) const </td></tr>
<tr class="memdesc:afd3f127c814c0331a9cea3da8a0322a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return address of an object.  <a href="#afd3f127c814c0331a9cea3da8a0322a3">More...</a><br/></td></tr>
<tr class="separator:afd3f127c814c0331a9cea3da8a0322a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489865152903a4afb74bd0dccc192e88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgmx_1_1Allocator.xhtml#a9bb62396cdb47cf800966ae6a56d7fb7">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Allocator.xhtml#a489865152903a4afb74bd0dccc192e88">address</a> (<a class="el" href="classgmx_1_1Allocator.xhtml#a253b7a6112bbac509fea1828cd47854e">const_reference</a> r) const </td></tr>
<tr class="memdesc:a489865152903a4afb74bd0dccc192e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return address of a const object.  <a href="#a489865152903a4afb74bd0dccc192e88">More...</a><br/></td></tr>
<tr class="separator:a489865152903a4afb74bd0dccc192e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05badb023820e38444720cc9a53fe9f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgmx_1_1Allocator.xhtml#af87f6d52282a6833058ce45ac7f92920">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Allocator.xhtml#a05badb023820e38444720cc9a53fe9f8">allocate</a> (std::size_t n, typename std::allocator&lt; void &gt;::<a class="el" href="classgmx_1_1Allocator.xhtml#a9bb62396cdb47cf800966ae6a56d7fb7">const_pointer</a> hint=nullptr)</td></tr>
<tr class="memdesc:a05badb023820e38444720cc9a53fe9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do the actual memory allocation.  <a href="#a05badb023820e38444720cc9a53fe9f8">More...</a><br/></td></tr>
<tr class="separator:a05badb023820e38444720cc9a53fe9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fff7ab9e9339f243535c5bca7eaab0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Allocator.xhtml#a9fff7ab9e9339f243535c5bca7eaab0a">deallocate</a> (<a class="el" href="classgmx_1_1Allocator.xhtml#af87f6d52282a6833058ce45ac7f92920">pointer</a> p, std::size_t n)</td></tr>
<tr class="memdesc:a9fff7ab9e9339f243535c5bca7eaab0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release memory.  <a href="#a9fff7ab9e9339f243535c5bca7eaab0a">More...</a><br/></td></tr>
<tr class="separator:a9fff7ab9e9339f243535c5bca7eaab0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7209c45b6693a651b37d1a8806c28b25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7209c45b6693a651b37d1a8806c28b25"></a>
AllocationPolicy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Allocator.xhtml#a7209c45b6693a651b37d1a8806c28b25">getPolicy</a> () const </td></tr>
<tr class="memdesc:a7209c45b6693a651b37d1a8806c28b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the policy object for this allocator. <br/></td></tr>
<tr class="separator:a7209c45b6693a651b37d1a8806c28b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1f11b0928ba7849d2082eae759094d"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a1b1f11b0928ba7849d2082eae759094d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgmx_1_1Allocator.xhtml#a1b1f11b0928ba7849d2082eae759094d">construct</a> (<a class="el" href="classgmx_1_1Allocator.xhtml#af87f6d52282a6833058ce45ac7f92920">pointer</a> p, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a1b1f11b0928ba7849d2082eae759094d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an object without allocating memory.  <a href="#a1b1f11b0928ba7849d2082eae759094d">More...</a><br/></td></tr>
<tr class="separator:a1b1f11b0928ba7849d2082eae759094d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87823e74db870801b59affe0390c3ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Allocator.xhtml#ae87823e74db870801b59affe0390c3ba">destroy</a> (<a class="el" href="classgmx_1_1Allocator.xhtml#af87f6d52282a6833058ce45ac7f92920">pointer</a> p)</td></tr>
<tr class="memdesc:ae87823e74db870801b59affe0390c3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the destructor of object without releasing memory.  <a href="#ae87823e74db870801b59affe0390c3ba">More...</a><br/></td></tr>
<tr class="separator:ae87823e74db870801b59affe0390c3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a1dfa4400d3aca70526e19f1d0d69a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Allocator.xhtml#a84a1dfa4400d3aca70526e19f1d0d69a">max_size</a> () const </td></tr>
<tr class="memdesc:a84a1dfa4400d3aca70526e19f1d0d69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return largest number of objects that can be allocated.  <a href="#a84a1dfa4400d3aca70526e19f1d0d69a">More...</a><br/></td></tr>
<tr class="separator:a84a1dfa4400d3aca70526e19f1d0d69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb705d3e4c2aa0da9c1720badad6763a"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:adb705d3e4c2aa0da9c1720badad6763a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgmx_1_1Allocator.xhtml#adb705d3e4c2aa0da9c1720badad6763a">operator==</a> (const <a class="el" href="classgmx_1_1Allocator.xhtml">Allocator</a>&lt; T2, AllocationPolicy &gt; &amp;) const </td></tr>
<tr class="memdesc:adb705d3e4c2aa0da9c1720badad6763a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if two allocators are identical.  <a href="#adb705d3e4c2aa0da9c1720badad6763a">More...</a><br/></td></tr>
<tr class="separator:adb705d3e4c2aa0da9c1720badad6763a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc167365c488e4909ae78c64ea1afc7e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Allocator.xhtml#afc167365c488e4909ae78c64ea1afc7e">operator!=</a> (const <a class="el" href="classgmx_1_1Allocator.xhtml">Allocator</a> &amp;rhs) const </td></tr>
<tr class="memdesc:afc167365c488e4909ae78c64ea1afc7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if two allocators are different.  <a href="#afc167365c488e4909ae78c64ea1afc7e">More...</a><br/></td></tr>
<tr class="separator:afc167365c488e4909ae78c64ea1afc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aff6e796fd68d6f9e7b9af6ffd9c8e2d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename AllocationPolicy &gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgmx_1_1Allocator.xhtml">gmx::Allocator</a>&lt; T, AllocationPolicy &gt;::<a class="el" href="classgmx_1_1Allocator.xhtml">Allocator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgmx_1_1Allocator.xhtml">Allocator</a>&lt; U, AllocationPolicy &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Templated copy constructor. </p>
<p>This template constructor cannot be auto-generated, and is normally unused, except e.g. MSVC2015 standard library uses it in debug mode, presumably to implement some checks. </p>

</div>
</div>
<a class="anchor" id="ace00f232d83508c89bfb218307ecabeb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename AllocationPolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgmx_1_1Allocator.xhtml">gmx::Allocator</a>&lt; T, AllocationPolicy &gt;::<a class="el" href="classgmx_1_1Allocator.xhtml">Allocator</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>No constructor can be auto-generated in the presence of any user-defined constructor, but we want the default constructor. </p>

</div>
</div>
<a class="anchor" id="a7e1fded5606714bab5418ff5400e6e35"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename AllocationPolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgmx_1_1Allocator.xhtml">gmx::Allocator</a>&lt; T, AllocationPolicy &gt;::<a class="el" href="classgmx_1_1Allocator.xhtml">Allocator</a> </td>
          <td>(</td>
          <td class="paramtype">const AllocationPolicy &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor to accept an AllocationPolicy. </p>
<p>This is useful for AllocationPolicies with state. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="afd3f127c814c0331a9cea3da8a0322a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename AllocationPolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgmx_1_1Allocator.xhtml#af87f6d52282a6833058ce45ac7f92920">pointer</a> <a class="el" href="classgmx_1_1Allocator.xhtml">gmx::Allocator</a>&lt; T, AllocationPolicy &gt;::address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgmx_1_1Allocator.xhtml#a36defaf0a6325bb34eea401fe8b63240">reference</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return address of an object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Reference to object of type T </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to T memory </dd></dl>

</div>
</div>
<a class="anchor" id="a489865152903a4afb74bd0dccc192e88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename AllocationPolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgmx_1_1Allocator.xhtml#a9bb62396cdb47cf800966ae6a56d7fb7">const_pointer</a> <a class="el" href="classgmx_1_1Allocator.xhtml">gmx::Allocator</a>&lt; T, AllocationPolicy &gt;::address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgmx_1_1Allocator.xhtml#a253b7a6112bbac509fea1828cd47854e">const_reference</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return address of a const object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Const reference to object of type T </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to T memory </dd></dl>

</div>
</div>
<a class="anchor" id="a05badb023820e38444720cc9a53fe9f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename AllocationPolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgmx_1_1Allocator.xhtml#af87f6d52282a6833058ce45ac7f92920">pointer</a> <a class="el" href="classgmx_1_1Allocator.xhtml">gmx::Allocator</a>&lt; T, AllocationPolicy &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::allocator&lt; void &gt;::<a class="el" href="classgmx_1_1Allocator.xhtml#a9bb62396cdb47cf800966ae6a56d7fb7">const_pointer</a>&#160;</td>
          <td class="paramname"><em>hint</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do the actual memory allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of elements of type T to allocate. n can be 0 bytes, which will return a non-null properly aligned and padded pointer that should not be used. </td></tr>
    <tr><td class="paramname">hint</td><td>Optional value returned from previous call to allocate. For now this is not used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to allocated memory</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if the allocation fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b1f11b0928ba7849d2082eae759094d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename AllocationPolicy &gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgmx_1_1Allocator.xhtml">gmx::Allocator</a>&lt; T, AllocationPolicy &gt;::construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgmx_1_1Allocator.xhtml#af87f6d52282a6833058ce45ac7f92920">pointer</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an object without allocating memory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Variable-length list of types for constructor args </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Adress of memory where to construct object </td></tr>
    <tr><td class="paramname">args</td><td>Variable-length list of arguments to constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9fff7ab9e9339f243535c5bca7eaab0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename AllocationPolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgmx_1_1Allocator.xhtml">gmx::Allocator</a>&lt; T, AllocationPolicy &gt;::deallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgmx_1_1Allocator.xhtml#af87f6d52282a6833058ce45ac7f92920">pointer</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to previously allocated memory returned from <a class="el" href="classgmx_1_1Allocator.xhtml#a05badb023820e38444720cc9a53fe9f8" title="Do the actual memory allocation. ">allocate()</a> </td></tr>
    <tr><td class="paramname">n</td><td>number of objects previously passed to <a class="el" href="classgmx_1_1Allocator.xhtml#a05badb023820e38444720cc9a53fe9f8" title="Do the actual memory allocation. ">allocate()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae87823e74db870801b59affe0390c3ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename AllocationPolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgmx_1_1Allocator.xhtml">gmx::Allocator</a>&lt; T, AllocationPolicy &gt;::destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgmx_1_1Allocator.xhtml#af87f6d52282a6833058ce45ac7f92920">pointer</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call the destructor of object without releasing memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Address of memory where to destroy object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84a1dfa4400d3aca70526e19f1d0d69a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename AllocationPolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classgmx_1_1Allocator.xhtml">gmx::Allocator</a>&lt; T, AllocationPolicy &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return largest number of objects that can be allocated. </p>
<p>This will be set such that the number of objects T multiplied by the size of each object is the largest value that can be represented by size_type. </p>

</div>
</div>
<a class="anchor" id="afc167365c488e4909ae78c64ea1afc7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename AllocationPolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgmx_1_1Allocator.xhtml">gmx::Allocator</a>&lt; T, AllocationPolicy &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgmx_1_1Allocator.xhtml">Allocator</a>&lt; T, AllocationPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if two allocators are different. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Other allocator.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a member function of the left-hand-side allocator. </p>

</div>
</div>
<a class="anchor" id="adb705d3e4c2aa0da9c1720badad6763a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename AllocationPolicy &gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgmx_1_1Allocator.xhtml">gmx::Allocator</a>&lt; T, AllocationPolicy &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgmx_1_1Allocator.xhtml">Allocator</a>&lt; T2, AllocationPolicy &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if two allocators are identical. </p>
<p>This is a member function of the left-hand-side allocator. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/gromacs/utility/<a class="el" href="allocator_8h.xhtml">allocator.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 23 2018 14:56:16 for Gromacs by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
