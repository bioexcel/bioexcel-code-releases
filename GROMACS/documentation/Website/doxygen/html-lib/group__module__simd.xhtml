<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Gromacs: SIMD intrinsics interface (simd)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Gromacs
   &#160;<span id="projectnumber">2018.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.xhtml"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.xhtml"><span>Modules</span></a></li>
      <li><a href="pages.xhtml"><span>Other&#160;Docs</span></a></li>
      <li><a href="namespaces.xhtml"><span>Namespaces</span></a></li>
      <li><a href="annotated.xhtml"><span>Classes</span></a></li>
      <li><a href="files.xhtml"><span>Files</span></a></li>
      <li><a href="examples.xhtml"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#dirs">Directories</a> &#124;
<a href="#files">Files</a>  </div>
  <div class="headertitle">
<div class="title">SIMD intrinsics interface (simd)<div class="ingroups"><a class="el" href="group__group__utilitymodules.xhtml">Utility Modules</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for SIMD intrinsics interface (simd):</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<center><table><tr><td><div class="center"><iframe scrolling="no" frameborder="0" src="group__module__simd.svg" width="586" height="186"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</td></tr></table></center>
</div>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>Provides an architecture-independent way of doing SIMD coding. </p>
<p>Overview of the SIMD implementation is provided in <a class="el" href="page_simd.xhtml">Single-instruction Multiple-data (SIMD) coding</a>. The details are documented in <a class="el" href="simd_8h.xhtml" title="Definitions, capabilities, and wrappers for SIMD module. ">gromacs/simd/simd.h</a> and the reference implementation <a class="el" href="impl__reference_8h.xhtml" title="Reference SIMD implementation, including SIMD documentation. ">impl_reference.h</a>.</p>
<dl class="section author"><dt>Author</dt><dd>Erik Lindahl <a href="#" onclick="location.href='mai'+'lto:'+'eri'+'k.'+'lin'+'da'+'hl@'+'sc'+'ili'+'fe'+'lab'+'.s'+'e'; return false;">erik.<span style="display: none;">.nosp@m.</span>lind<span style="display: none;">.nosp@m.</span>ahl@s<span style="display: none;">.nosp@m.</span>cili<span style="display: none;">.nosp@m.</span>felab<span style="display: none;">.nosp@m.</span>.se</a> </dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacegmx"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx.xhtml">gmx</a></td></tr>
<tr class="memdesc:namespacegmx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic GROMACS namespace. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SIMD implementation capability definitions</h2></td></tr>
<tr class="memitem:ga94ddf013ff498c818811cc6cf2c3c71d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga94ddf013ff498c818811cc6cf2c3c71d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga94ddf013ff498c818811cc6cf2c3c71d">GMX_SIMD</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga94ddf013ff498c818811cc6cf2c3c71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if any SIMD support is present, otherwise 0. <br/></td></tr>
<tr class="separator:ga94ddf013ff498c818811cc6cf2c3c71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d093280bad2b3ebecbcd426bdddb73b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga8d093280bad2b3ebecbcd426bdddb73b">GMX_SIMD_HAVE_FLOAT</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga8d093280bad2b3ebecbcd426bdddb73b"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 when SIMD float support is present, otherwise 0  <a href="#ga8d093280bad2b3ebecbcd426bdddb73b">More...</a><br/></td></tr>
<tr class="separator:ga8d093280bad2b3ebecbcd426bdddb73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5545c033bb4a28657239e4c9739cefe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf5545c033bb4a28657239e4c9739cefe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaf5545c033bb4a28657239e4c9739cefe">GMX_SIMD_HAVE_DOUBLE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gaf5545c033bb4a28657239e4c9739cefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if SIMD double support is present, otherwise 0 <br/></td></tr>
<tr class="separator:gaf5545c033bb4a28657239e4c9739cefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf774b2a886d1ed4149f825c50c8fec2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacf774b2a886d1ed4149f825c50c8fec2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gacf774b2a886d1ed4149f825c50c8fec2">GMX_SIMD_HAVE_LOADU</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gacf774b2a886d1ed4149f825c50c8fec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if the SIMD implementation supports unaligned loads, otherwise 0 <br/></td></tr>
<tr class="separator:gacf774b2a886d1ed4149f825c50c8fec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38ee3ad2fadedbafff3129df1e7c15b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga38ee3ad2fadedbafff3129df1e7c15b4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga38ee3ad2fadedbafff3129df1e7c15b4">GMX_SIMD_HAVE_STOREU</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga38ee3ad2fadedbafff3129df1e7c15b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if the SIMD implementation supports unaligned stores, otherwise 0 <br/></td></tr>
<tr class="separator:ga38ee3ad2fadedbafff3129df1e7c15b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28b81d356fae5d8b1b3b76273c360360"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga28b81d356fae5d8b1b3b76273c360360">GMX_SIMD_HAVE_FMA</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga28b81d356fae5d8b1b3b76273c360360"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if the SIMD implementation has fused-multiply add hardware  <a href="#ga28b81d356fae5d8b1b3b76273c360360">More...</a><br/></td></tr>
<tr class="separator:ga28b81d356fae5d8b1b3b76273c360360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf002483e94d5f42de1d5105cf924f8b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf002483e94d5f42de1d5105cf924f8b8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaf002483e94d5f42de1d5105cf924f8b8">GMX_SIMD_HAVE_LOGICAL</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gaf002483e94d5f42de1d5105cf924f8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if SIMD impl has logical operations on floating-point data, otherwise 0 <br/></td></tr>
<tr class="separator:gaf002483e94d5f42de1d5105cf924f8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23ac53a0050467ac215f146f6afc6380"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga23ac53a0050467ac215f146f6afc6380"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga23ac53a0050467ac215f146f6afc6380">GMX_SIMD_HAVE_FINT32_EXTRACT</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga23ac53a0050467ac215f146f6afc6380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support for extracting integers from <a class="el" href="classgmx_1_1SimdFInt32.xhtml">gmx::SimdFInt32</a> (1/0 for present/absent) <br/></td></tr>
<tr class="separator:ga23ac53a0050467ac215f146f6afc6380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga354867d2570fecb6b341047947bee0d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga354867d2570fecb6b341047947bee0d1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga354867d2570fecb6b341047947bee0d1">GMX_SIMD_HAVE_FINT32_LOGICAL</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga354867d2570fecb6b341047947bee0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if SIMD logical ops are supported for <a class="el" href="classgmx_1_1SimdFInt32.xhtml">gmx::SimdFInt32</a>, otherwise 0 <br/></td></tr>
<tr class="separator:ga354867d2570fecb6b341047947bee0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9febc62e1abd58eb8a035b8b81f93292"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9febc62e1abd58eb8a035b8b81f93292"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga9febc62e1abd58eb8a035b8b81f93292">GMX_SIMD_HAVE_FINT32_ARITHMETICS</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga9febc62e1abd58eb8a035b8b81f93292"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if SIMD arithmetic ops are supported for <a class="el" href="classgmx_1_1SimdFInt32.xhtml">gmx::SimdFInt32</a>, otherwise 0 <br/></td></tr>
<tr class="separator:ga9febc62e1abd58eb8a035b8b81f93292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabae2f56a4d87b8e52b5df066888a4c07"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabae2f56a4d87b8e52b5df066888a4c07"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gabae2f56a4d87b8e52b5df066888a4c07">GMX_SIMD_HAVE_DINT32_EXTRACT</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gabae2f56a4d87b8e52b5df066888a4c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support for extracting integer from <a class="el" href="classgmx_1_1SimdDInt32.xhtml">gmx::SimdDInt32</a> (1/0 for present/absent) <br/></td></tr>
<tr class="separator:gabae2f56a4d87b8e52b5df066888a4c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ccbae145ecb27cee3c98ec7bded1d45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0ccbae145ecb27cee3c98ec7bded1d45"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga0ccbae145ecb27cee3c98ec7bded1d45">GMX_SIMD_HAVE_DINT32_LOGICAL</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga0ccbae145ecb27cee3c98ec7bded1d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if logical operations are supported for <a class="el" href="classgmx_1_1SimdDInt32.xhtml">gmx::SimdDInt32</a>, otherwise 0 <br/></td></tr>
<tr class="separator:ga0ccbae145ecb27cee3c98ec7bded1d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8469202af6999f95405779355d89c30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab8469202af6999f95405779355d89c30"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gab8469202af6999f95405779355d89c30">GMX_SIMD_HAVE_DINT32_ARITHMETICS</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gab8469202af6999f95405779355d89c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if SIMD arithmetic ops are supported for <a class="el" href="classgmx_1_1SimdDInt32.xhtml">gmx::SimdDInt32</a>, otherwise 0 <br/></td></tr>
<tr class="separator:gab8469202af6999f95405779355d89c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0ee59fd57c8ac4336ecbdafd1356fec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gae0ee59fd57c8ac4336ecbdafd1356fec">GMX_SIMD_HAVE_NATIVE_COPYSIGN_FLOAT</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gae0ee59fd57c8ac4336ecbdafd1356fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if implementation provides single precision <a class="el" href="namespacegmx.xhtml#a8ef5f6af06e493a4ae2d47109ee0e723" title="Composes single value with the magnitude of x and the sign of y. ">copysign()</a>  <a href="#gae0ee59fd57c8ac4336ecbdafd1356fec">More...</a><br/></td></tr>
<tr class="separator:gae0ee59fd57c8ac4336ecbdafd1356fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ed1e79e7680e1286e57df038c5e1a5a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga6ed1e79e7680e1286e57df038c5e1a5a">GMX_SIMD_HAVE_NATIVE_RSQRT_ITER_FLOAT</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga6ed1e79e7680e1286e57df038c5e1a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if implementation provides single precision 1/sqrt(x) N-R iterations faster than <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a>  <a href="#ga6ed1e79e7680e1286e57df038c5e1a5a">More...</a><br/></td></tr>
<tr class="separator:ga6ed1e79e7680e1286e57df038c5e1a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42b629cc80d3bb76e8a8bb84c2a11659"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga42b629cc80d3bb76e8a8bb84c2a11659">GMX_SIMD_HAVE_NATIVE_RCP_ITER_FLOAT</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga42b629cc80d3bb76e8a8bb84c2a11659"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if implementation provides single precision 1/x N-R iterations faster than <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a>  <a href="#ga42b629cc80d3bb76e8a8bb84c2a11659">More...</a><br/></td></tr>
<tr class="separator:ga42b629cc80d3bb76e8a8bb84c2a11659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e25630e2fde79d1c5dbde64293c4f8f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga4e25630e2fde79d1c5dbde64293c4f8f">GMX_SIMD_HAVE_NATIVE_LOG_FLOAT</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga4e25630e2fde79d1c5dbde64293c4f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if implementation provides single precision <a class="el" href="namespacegmx.xhtml#a7b0a25f25b649f59d96b67f2d73c8ad8" title="Float log(x). This is the natural logarithm. ">log()</a> faster than <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a>  <a href="#ga4e25630e2fde79d1c5dbde64293c4f8f">More...</a><br/></td></tr>
<tr class="separator:ga4e25630e2fde79d1c5dbde64293c4f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf481b26a00cb7a69c5b2b409cb8bf07a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaf481b26a00cb7a69c5b2b409cb8bf07a">GMX_SIMD_HAVE_NATIVE_EXP2_FLOAT</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gaf481b26a00cb7a69c5b2b409cb8bf07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if implementation provides single precision <a class="el" href="namespacegmx.xhtml#a643a4be46c81b885274394cd9ac1a30a" title="Float 2^x. ">exp2()</a> faster than <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a>  <a href="#gaf481b26a00cb7a69c5b2b409cb8bf07a">More...</a><br/></td></tr>
<tr class="separator:gaf481b26a00cb7a69c5b2b409cb8bf07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c2bc0bba4513b830bad32f3fc5f54a1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga5c2bc0bba4513b830bad32f3fc5f54a1">GMX_SIMD_HAVE_NATIVE_EXP_FLOAT</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga5c2bc0bba4513b830bad32f3fc5f54a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if implementation provides single precision <a class="el" href="namespacegmx.xhtml#aa22dfb3027cee75bbc9686094f928050" title="Float exp(x). ">exp()</a> faster than <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a>  <a href="#ga5c2bc0bba4513b830bad32f3fc5f54a1">More...</a><br/></td></tr>
<tr class="separator:ga5c2bc0bba4513b830bad32f3fc5f54a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fb93edfc149ac6d5351d5d7fd327b80"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga5fb93edfc149ac6d5351d5d7fd327b80">GMX_SIMD_HAVE_NATIVE_COPYSIGN_DOUBLE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga5fb93edfc149ac6d5351d5d7fd327b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if implementation provides double precision <a class="el" href="namespacegmx.xhtml#a8ef5f6af06e493a4ae2d47109ee0e723" title="Composes single value with the magnitude of x and the sign of y. ">copysign()</a>  <a href="#ga5fb93edfc149ac6d5351d5d7fd327b80">More...</a><br/></td></tr>
<tr class="separator:ga5fb93edfc149ac6d5351d5d7fd327b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c8c664c67f7287baf890c69bfa72814"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga2c8c664c67f7287baf890c69bfa72814">GMX_SIMD_HAVE_NATIVE_RSQRT_ITER_DOUBLE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga2c8c664c67f7287baf890c69bfa72814"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if implementation provides double precision 1/sqrt(x) N-R iterations faster than <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a>  <a href="#ga2c8c664c67f7287baf890c69bfa72814">More...</a><br/></td></tr>
<tr class="separator:ga2c8c664c67f7287baf890c69bfa72814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9094d49ecb55b7140d68b7d402b3dadd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga9094d49ecb55b7140d68b7d402b3dadd">GMX_SIMD_HAVE_NATIVE_RCP_ITER_DOUBLE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga9094d49ecb55b7140d68b7d402b3dadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if implementation provides double precision 1/x N-R iterations faster than <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a>  <a href="#ga9094d49ecb55b7140d68b7d402b3dadd">More...</a><br/></td></tr>
<tr class="separator:ga9094d49ecb55b7140d68b7d402b3dadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad770ccd6aca01544454e2bb6c45491ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gad770ccd6aca01544454e2bb6c45491ce">GMX_SIMD_HAVE_NATIVE_LOG_DOUBLE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gad770ccd6aca01544454e2bb6c45491ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if implementation provides double precision <a class="el" href="namespacegmx.xhtml#a7b0a25f25b649f59d96b67f2d73c8ad8" title="Float log(x). This is the natural logarithm. ">log()</a> faster than <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a>  <a href="#gad770ccd6aca01544454e2bb6c45491ce">More...</a><br/></td></tr>
<tr class="separator:gad770ccd6aca01544454e2bb6c45491ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05f50a78bbd133cde5ebc83e2ac13a9b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga05f50a78bbd133cde5ebc83e2ac13a9b">GMX_SIMD_HAVE_NATIVE_EXP2_DOUBLE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga05f50a78bbd133cde5ebc83e2ac13a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if implementation provides double precision <a class="el" href="namespacegmx.xhtml#a643a4be46c81b885274394cd9ac1a30a" title="Float 2^x. ">exp2()</a> faster than <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a>  <a href="#ga05f50a78bbd133cde5ebc83e2ac13a9b">More...</a><br/></td></tr>
<tr class="separator:ga05f50a78bbd133cde5ebc83e2ac13a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d3931388f0a22ac74af34709cffaabb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga9d3931388f0a22ac74af34709cffaabb">GMX_SIMD_HAVE_NATIVE_EXP_DOUBLE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga9d3931388f0a22ac74af34709cffaabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if implementation provides double precision <a class="el" href="namespacegmx.xhtml#aa22dfb3027cee75bbc9686094f928050" title="Float exp(x). ">exp()</a> faster than <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a>  <a href="#ga9d3931388f0a22ac74af34709cffaabb">More...</a><br/></td></tr>
<tr class="separator:ga9d3931388f0a22ac74af34709cffaabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ba6c684641af238fb2a5a7d4c6e0237"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5ba6c684641af238fb2a5a7d4c6e0237"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga5ba6c684641af238fb2a5a7d4c6e0237">GMX_SIMD_HAVE_GATHER_LOADU_BYSIMDINT_TRANSPOSE_FLOAT</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga5ba6c684641af238fb2a5a7d4c6e0237"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if <a class="el" href="group__module__simd.xhtml#gad15c3a27898a9f9dbb2963dee1a7cacf">gmx::gatherLoadUBySimdIntTranspose</a> is present, otherwise 0 <br/></td></tr>
<tr class="separator:ga5ba6c684641af238fb2a5a7d4c6e0237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f609eec37d8c92163def72ec28bb435"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5f609eec37d8c92163def72ec28bb435"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga5f609eec37d8c92163def72ec28bb435">GMX_SIMD_HAVE_GATHER_LOADU_BYSIMDINT_TRANSPOSE_DOUBLE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga5f609eec37d8c92163def72ec28bb435"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if <a class="el" href="group__module__simd.xhtml#gad15c3a27898a9f9dbb2963dee1a7cacf">gmx::gatherLoadUBySimdIntTranspose</a> is present, otherwise 0 <br/></td></tr>
<tr class="separator:ga5f609eec37d8c92163def72ec28bb435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac40bf3261e36fb7ff022e8ab37b04fcf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac40bf3261e36fb7ff022e8ab37b04fcf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gac40bf3261e36fb7ff022e8ab37b04fcf">GMX_SIMD_HAVE_HSIMD_UTIL_FLOAT</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gac40bf3261e36fb7ff022e8ab37b04fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if float half-register load/store/reduce utils present, otherwise 0 <br/></td></tr>
<tr class="separator:gac40bf3261e36fb7ff022e8ab37b04fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadef533340f8e648dfb550cbd8cfd9fc7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadef533340f8e648dfb550cbd8cfd9fc7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gadef533340f8e648dfb550cbd8cfd9fc7">GMX_SIMD_HAVE_HSIMD_UTIL_DOUBLE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gadef533340f8e648dfb550cbd8cfd9fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if double half-register load/store/reduce utils present, otherwise 0 <br/></td></tr>
<tr class="separator:gadef533340f8e648dfb550cbd8cfd9fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdbf804a40bfa3dcb15bc50055e58e74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafdbf804a40bfa3dcb15bc50055e58e74"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gafdbf804a40bfa3dcb15bc50055e58e74">GMX_SIMD_FLOAT_WIDTH</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:gafdbf804a40bfa3dcb15bc50055e58e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Width of the <a class="el" href="classgmx_1_1SimdFloat.xhtml">gmx::SimdFloat</a> datatype. <br/></td></tr>
<tr class="separator:gafdbf804a40bfa3dcb15bc50055e58e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga417e9d28b6310876bb2c69eb528c0a86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga417e9d28b6310876bb2c69eb528c0a86"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga417e9d28b6310876bb2c69eb528c0a86">GMX_SIMD_DOUBLE_WIDTH</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:ga417e9d28b6310876bb2c69eb528c0a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Width of the <a class="el" href="classgmx_1_1SimdDouble.xhtml">gmx::SimdDouble</a> datatype. <br/></td></tr>
<tr class="separator:ga417e9d28b6310876bb2c69eb528c0a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a32ff26e38f94fdffdc253d1a871ca4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5a32ff26e38f94fdffdc253d1a871ca4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga5a32ff26e38f94fdffdc253d1a871ca4">GMX_SIMD_HAVE_4NSIMD_UTIL_FLOAT</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga5a32ff26e38f94fdffdc253d1a871ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if float 4xN load utils present, otherwise 0 <br/></td></tr>
<tr class="separator:ga5a32ff26e38f94fdffdc253d1a871ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad27c7840e17aec417f07c73362efb87d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad27c7840e17aec417f07c73362efb87d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gad27c7840e17aec417f07c73362efb87d">GMX_SIMD_HAVE_4NSIMD_UTIL_DOUBLE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gad27c7840e17aec417f07c73362efb87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if double 4xN load utils present, otherwise 0 <br/></td></tr>
<tr class="separator:gad27c7840e17aec417f07c73362efb87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86b316f5c5de088d4cb073300198f4d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga86b316f5c5de088d4cb073300198f4d3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga86b316f5c5de088d4cb073300198f4d3">GMX_SIMD4_HAVE_FLOAT</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga86b316f5c5de088d4cb073300198f4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if implementation provides <a class="el" href="classgmx_1_1Simd4Float.xhtml">gmx::Simd4Float</a>, otherwise 0. <br/></td></tr>
<tr class="separator:ga86b316f5c5de088d4cb073300198f4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a245d615fbc175986d8bd51d816e46d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5a245d615fbc175986d8bd51d816e46d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga5a245d615fbc175986d8bd51d816e46d">GMX_SIMD4_HAVE_DOUBLE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga5a245d615fbc175986d8bd51d816e46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if the implementation provides <a class="el" href="classgmx_1_1Simd4Double.xhtml">gmx::Simd4Double</a>, otherwise 0. <br/></td></tr>
<tr class="separator:ga5a245d615fbc175986d8bd51d816e46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf6ba3755c28114d0eec8a71e94175c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaf6ba3755c28114d0eec8a71e94175c6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaaf6ba3755c28114d0eec8a71e94175c6">GMX_SIMD_FINT32_WIDTH</a>&#160;&#160;&#160;<a class="el" href="group__module__simd.xhtml#gafdbf804a40bfa3dcb15bc50055e58e74">GMX_SIMD_FLOAT_WIDTH</a></td></tr>
<tr class="memdesc:gaaf6ba3755c28114d0eec8a71e94175c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Width of the <a class="el" href="classgmx_1_1SimdFInt32.xhtml">gmx::SimdFInt32</a> datatype. <br/></td></tr>
<tr class="separator:gaaf6ba3755c28114d0eec8a71e94175c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8cb1c966b6eafe85d1c56bc52ecfded"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae8cb1c966b6eafe85d1c56bc52ecfded"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gae8cb1c966b6eafe85d1c56bc52ecfded">GMX_SIMD_DINT32_WIDTH</a>&#160;&#160;&#160;<a class="el" href="group__module__simd.xhtml#ga417e9d28b6310876bb2c69eb528c0a86">GMX_SIMD_DOUBLE_WIDTH</a></td></tr>
<tr class="memdesc:gae8cb1c966b6eafe85d1c56bc52ecfded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Width of the <a class="el" href="classgmx_1_1SimdDInt32.xhtml">gmx::SimdDInt32</a> datatype. <br/></td></tr>
<tr class="separator:gae8cb1c966b6eafe85d1c56bc52ecfded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga103880e9c6120155f60f16f440aa5b37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga103880e9c6120155f60f16f440aa5b37"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga103880e9c6120155f60f16f440aa5b37">GMX_SIMD4_WIDTH</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:ga103880e9c6120155f60f16f440aa5b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SIMD4 type is always four units wide, but this makes code more explicit. <br/></td></tr>
<tr class="separator:ga103880e9c6120155f60f16f440aa5b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga713bd430a84635d19ba40d21c921756b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga713bd430a84635d19ba40d21c921756b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga713bd430a84635d19ba40d21c921756b">GMX_SIMD_ALIGNMENT</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:ga713bd430a84635d19ba40d21c921756b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Required alignment in bytes for aligned load/store (always defined, even without SIMD) <br/></td></tr>
<tr class="separator:ga713bd430a84635d19ba40d21c921756b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e207d56564fc020b246563d09214aac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7e207d56564fc020b246563d09214aac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga7e207d56564fc020b246563d09214aac">GMX_SIMD_RSQRT_BITS</a>&#160;&#160;&#160;23</td></tr>
<tr class="memdesc:ga7e207d56564fc020b246563d09214aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accuracy of SIMD 1/sqrt(x) lookup. Used to determine number of iterations. <br/></td></tr>
<tr class="separator:ga7e207d56564fc020b246563d09214aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b7a7c4421c0ce401b74c469a109e82c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8b7a7c4421c0ce401b74c469a109e82c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga8b7a7c4421c0ce401b74c469a109e82c">GMX_SIMD_RCP_BITS</a>&#160;&#160;&#160;23</td></tr>
<tr class="memdesc:ga8b7a7c4421c0ce401b74c469a109e82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accuracy of SIMD 1/x lookup. Used to determine number of iterations. <br/></td></tr>
<tr class="separator:ga8b7a7c4421c0ce401b74c469a109e82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Constant width-4 double precision SIMD types and instructions</h2></td></tr>
<tr class="memitem:ga66ff320228b17e4c9fbbb61c7acde2eb"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga66ff320228b17e4c9fbbb61c7acde2eb">gmx::load4</a> (const double *m)</td></tr>
<tr class="memdesc:ga66ff320228b17e4c9fbbb61c7acde2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 4 double values from aligned memory into SIMD4 variable.  <a href="#ga66ff320228b17e4c9fbbb61c7acde2eb">More...</a><br/></td></tr>
<tr class="separator:ga66ff320228b17e4c9fbbb61c7acde2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6c0b04d40ff74a4ad39c24f9fd3da20"><td class="memItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaf6c0b04d40ff74a4ad39c24f9fd3da20">gmx::store4</a> (double *m, Simd4Double a)</td></tr>
<tr class="memdesc:gaf6c0b04d40ff74a4ad39c24f9fd3da20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the contents of SIMD4 double to aligned memory m.  <a href="#gaf6c0b04d40ff74a4ad39c24f9fd3da20">More...</a><br/></td></tr>
<tr class="separator:gaf6c0b04d40ff74a4ad39c24f9fd3da20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e92b72e3e3a4f159180cf15da1889c8"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga8e92b72e3e3a4f159180cf15da1889c8">gmx::load4U</a> (const double *m)</td></tr>
<tr class="memdesc:ga8e92b72e3e3a4f159180cf15da1889c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load SIMD4 double from unaligned memory.  <a href="#ga8e92b72e3e3a4f159180cf15da1889c8">More...</a><br/></td></tr>
<tr class="separator:ga8e92b72e3e3a4f159180cf15da1889c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61ae7be76c3865fcfe038dd2457a09cd"><td class="memItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga61ae7be76c3865fcfe038dd2457a09cd">gmx::store4U</a> (double *m, Simd4Double a)</td></tr>
<tr class="memdesc:ga61ae7be76c3865fcfe038dd2457a09cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store SIMD4 double to unaligned memory.  <a href="#ga61ae7be76c3865fcfe038dd2457a09cd">More...</a><br/></td></tr>
<tr class="separator:ga61ae7be76c3865fcfe038dd2457a09cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac88aa19e4c856c2333bf814c3521c488"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gac88aa19e4c856c2333bf814c3521c488">gmx::simd4SetZeroD</a> ()</td></tr>
<tr class="memdesc:gac88aa19e4c856c2333bf814c3521c488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all SIMD4 double elements to 0.  <a href="#gac88aa19e4c856c2333bf814c3521c488">More...</a><br/></td></tr>
<tr class="separator:gac88aa19e4c856c2333bf814c3521c488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d555bbdc50b7b523ef3f0e6383808ef"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga0d555bbdc50b7b523ef3f0e6383808ef">gmx::operator&amp;</a> (Simd4Double a, Simd4Double b)</td></tr>
<tr class="memdesc:ga0d555bbdc50b7b523ef3f0e6383808ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise and for two SIMD4 double variables.  <a href="#ga0d555bbdc50b7b523ef3f0e6383808ef">More...</a><br/></td></tr>
<tr class="separator:ga0d555bbdc50b7b523ef3f0e6383808ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga847080625fcb1aff7a1db138afd57222"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga847080625fcb1aff7a1db138afd57222">gmx::andNot</a> (Simd4Double a, Simd4Double b)</td></tr>
<tr class="memdesc:ga847080625fcb1aff7a1db138afd57222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise andnot for two SIMD4 double variables. c=(~a) &amp; b.  <a href="#ga847080625fcb1aff7a1db138afd57222">More...</a><br/></td></tr>
<tr class="separator:ga847080625fcb1aff7a1db138afd57222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcaa9a287c021ad7e3507311ffe23497"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gabcaa9a287c021ad7e3507311ffe23497">gmx::operator|</a> (Simd4Double a, Simd4Double b)</td></tr>
<tr class="memdesc:gabcaa9a287c021ad7e3507311ffe23497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise or for two SIMD4 doubles.  <a href="#gabcaa9a287c021ad7e3507311ffe23497">More...</a><br/></td></tr>
<tr class="separator:gabcaa9a287c021ad7e3507311ffe23497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad7bb7baf5edd91a8707584c9cdc086e"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaad7bb7baf5edd91a8707584c9cdc086e">gmx::operator^</a> (Simd4Double a, Simd4Double b)</td></tr>
<tr class="memdesc:gaad7bb7baf5edd91a8707584c9cdc086e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise xor for two SIMD4 double variables.  <a href="#gaad7bb7baf5edd91a8707584c9cdc086e">More...</a><br/></td></tr>
<tr class="separator:gaad7bb7baf5edd91a8707584c9cdc086e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07f6ab30b594fa03c4975bed7bffab81"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga07f6ab30b594fa03c4975bed7bffab81">gmx::operator+</a> (Simd4Double a, Simd4Double b)</td></tr>
<tr class="memdesc:ga07f6ab30b594fa03c4975bed7bffab81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two double SIMD4 variables.  <a href="#ga07f6ab30b594fa03c4975bed7bffab81">More...</a><br/></td></tr>
<tr class="separator:ga07f6ab30b594fa03c4975bed7bffab81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab08e1e219e78b06a60cc995ae663dbab"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gab08e1e219e78b06a60cc995ae663dbab">gmx::operator-</a> (Simd4Double a, Simd4Double b)</td></tr>
<tr class="memdesc:gab08e1e219e78b06a60cc995ae663dbab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two SIMD4 variables.  <a href="#gab08e1e219e78b06a60cc995ae663dbab">More...</a><br/></td></tr>
<tr class="separator:gab08e1e219e78b06a60cc995ae663dbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b75b800db84a744c11534a41f3c08c6"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga4b75b800db84a744c11534a41f3c08c6">gmx::operator-</a> (Simd4Double a)</td></tr>
<tr class="memdesc:ga4b75b800db84a744c11534a41f3c08c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD4 floating-point negate.  <a href="#ga4b75b800db84a744c11534a41f3c08c6">More...</a><br/></td></tr>
<tr class="separator:ga4b75b800db84a744c11534a41f3c08c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59d8295d88c9f60db412cb53eb47b768"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga59d8295d88c9f60db412cb53eb47b768">gmx::operator*</a> (Simd4Double a, Simd4Double b)</td></tr>
<tr class="memdesc:ga59d8295d88c9f60db412cb53eb47b768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two SIMD4 variables.  <a href="#ga59d8295d88c9f60db412cb53eb47b768">More...</a><br/></td></tr>
<tr class="separator:ga59d8295d88c9f60db412cb53eb47b768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68d608d0650ac219cb4c0d3034ee855f"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga68d608d0650ac219cb4c0d3034ee855f">gmx::fma</a> (Simd4Double a, Simd4Double b, Simd4Double c)</td></tr>
<tr class="memdesc:ga68d608d0650ac219cb4c0d3034ee855f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD4 Fused-multiply-add. Result is a*b+c.  <a href="#ga68d608d0650ac219cb4c0d3034ee855f">More...</a><br/></td></tr>
<tr class="separator:ga68d608d0650ac219cb4c0d3034ee855f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78a3204bd78e9122ba1998e985d1a5bd"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga78a3204bd78e9122ba1998e985d1a5bd">gmx::fms</a> (Simd4Double a, Simd4Double b, Simd4Double c)</td></tr>
<tr class="memdesc:ga78a3204bd78e9122ba1998e985d1a5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD4 Fused-multiply-subtract. Result is a*b-c.  <a href="#ga78a3204bd78e9122ba1998e985d1a5bd">More...</a><br/></td></tr>
<tr class="separator:ga78a3204bd78e9122ba1998e985d1a5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9ec59669729860c9efd1b9c70f3911b"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gae9ec59669729860c9efd1b9c70f3911b">gmx::fnma</a> (Simd4Double a, Simd4Double b, Simd4Double c)</td></tr>
<tr class="memdesc:gae9ec59669729860c9efd1b9c70f3911b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD4 Fused-negated-multiply-add. Result is -a*b+c.  <a href="#gae9ec59669729860c9efd1b9c70f3911b">More...</a><br/></td></tr>
<tr class="separator:gae9ec59669729860c9efd1b9c70f3911b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7afe2f2f840c1de18cb7c61917ba11c"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gac7afe2f2f840c1de18cb7c61917ba11c">gmx::fnms</a> (Simd4Double a, Simd4Double b, Simd4Double c)</td></tr>
<tr class="memdesc:gac7afe2f2f840c1de18cb7c61917ba11c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD4 Fused-negated-multiply-subtract. Result is -a*b-c.  <a href="#gac7afe2f2f840c1de18cb7c61917ba11c">More...</a><br/></td></tr>
<tr class="separator:gac7afe2f2f840c1de18cb7c61917ba11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga535ead71c3aeb4caaae55d6aefc78799"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga535ead71c3aeb4caaae55d6aefc78799">gmx::rsqrt</a> (Simd4Double x)</td></tr>
<tr class="memdesc:ga535ead71c3aeb4caaae55d6aefc78799"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD4 1.0/sqrt(x) lookup.  <a href="#ga535ead71c3aeb4caaae55d6aefc78799">More...</a><br/></td></tr>
<tr class="separator:ga535ead71c3aeb4caaae55d6aefc78799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9339c53d13a59e946834c14d565f1e18"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga9339c53d13a59e946834c14d565f1e18">gmx::abs</a> (Simd4Double a)</td></tr>
<tr class="memdesc:ga9339c53d13a59e946834c14d565f1e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD4 Floating-point <a class="el" href="group__module__simd.xhtml#ga9339c53d13a59e946834c14d565f1e18" title="SIMD4 Floating-point abs(). ">abs()</a>.  <a href="#ga9339c53d13a59e946834c14d565f1e18">More...</a><br/></td></tr>
<tr class="separator:ga9339c53d13a59e946834c14d565f1e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68bbfb58d0ab7d2362d0efde15c14ca3"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga68bbfb58d0ab7d2362d0efde15c14ca3">gmx::max</a> (Simd4Double a, Simd4Double b)</td></tr>
<tr class="memdesc:ga68bbfb58d0ab7d2362d0efde15c14ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set each SIMD4 element to the largest from two variables.  <a href="#ga68bbfb58d0ab7d2362d0efde15c14ca3">More...</a><br/></td></tr>
<tr class="separator:ga68bbfb58d0ab7d2362d0efde15c14ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf515651ecc6efcf3ec65a8ff488ea02"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gacf515651ecc6efcf3ec65a8ff488ea02">gmx::min</a> (Simd4Double a, Simd4Double b)</td></tr>
<tr class="memdesc:gacf515651ecc6efcf3ec65a8ff488ea02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set each SIMD4 element to the largest from two variables.  <a href="#gacf515651ecc6efcf3ec65a8ff488ea02">More...</a><br/></td></tr>
<tr class="separator:gacf515651ecc6efcf3ec65a8ff488ea02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b425556720d8ff72c1998c86c777e75"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga3b425556720d8ff72c1998c86c777e75">gmx::round</a> (Simd4Double a)</td></tr>
<tr class="memdesc:ga3b425556720d8ff72c1998c86c777e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD4 Round to nearest integer value (in floating-point format).  <a href="#ga3b425556720d8ff72c1998c86c777e75">More...</a><br/></td></tr>
<tr class="separator:ga3b425556720d8ff72c1998c86c777e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4383bb9ab1055fc9888e65655db350ba"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga4383bb9ab1055fc9888e65655db350ba">gmx::trunc</a> (Simd4Double a)</td></tr>
<tr class="memdesc:ga4383bb9ab1055fc9888e65655db350ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate SIMD4, i.e. round towards zero - common hardware instruction.  <a href="#ga4383bb9ab1055fc9888e65655db350ba">More...</a><br/></td></tr>
<tr class="separator:ga4383bb9ab1055fc9888e65655db350ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48eb5014bfc9c6c43e9e21bf8c87ecc4"><td class="memItemLeft" align="right" valign="top">static double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga48eb5014bfc9c6c43e9e21bf8c87ecc4">gmx::dotProduct</a> (Simd4Double a, Simd4Double b)</td></tr>
<tr class="memdesc:ga48eb5014bfc9c6c43e9e21bf8c87ecc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return dot product of two double precision SIMD4 variables.  <a href="#ga48eb5014bfc9c6c43e9e21bf8c87ecc4">More...</a><br/></td></tr>
<tr class="separator:ga48eb5014bfc9c6c43e9e21bf8c87ecc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7a690a2d884f1210349194e3c07a5a3"><td class="memItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaf7a690a2d884f1210349194e3c07a5a3">gmx::transpose</a> (Simd4Double *v0, Simd4Double *v1, Simd4Double *v2, Simd4Double *v3)</td></tr>
<tr class="memdesc:gaf7a690a2d884f1210349194e3c07a5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD4 double transpose.  <a href="#gaf7a690a2d884f1210349194e3c07a5a3">More...</a><br/></td></tr>
<tr class="separator:gaf7a690a2d884f1210349194e3c07a5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga905fa4e11c1b9d4628ea5bdeeed3ca77"><td class="memItemLeft" align="right" valign="top">static Simd4DBool gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga905fa4e11c1b9d4628ea5bdeeed3ca77">gmx::operator==</a> (Simd4Double a, Simd4Double b)</td></tr>
<tr class="memdesc:ga905fa4e11c1b9d4628ea5bdeeed3ca77"><td class="mdescLeft">&#160;</td><td class="mdescRight">a==b for SIMD4 double  <a href="#ga905fa4e11c1b9d4628ea5bdeeed3ca77">More...</a><br/></td></tr>
<tr class="separator:ga905fa4e11c1b9d4628ea5bdeeed3ca77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55e1d875f190a65651a57df761799027"><td class="memItemLeft" align="right" valign="top">static Simd4DBool gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga55e1d875f190a65651a57df761799027">gmx::operator!=</a> (Simd4Double a, Simd4Double b)</td></tr>
<tr class="memdesc:ga55e1d875f190a65651a57df761799027"><td class="mdescLeft">&#160;</td><td class="mdescRight">a!=b for SIMD4 double  <a href="#ga55e1d875f190a65651a57df761799027">More...</a><br/></td></tr>
<tr class="separator:ga55e1d875f190a65651a57df761799027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga161caa368bcf9f1d566b6bbb81b23a5f"><td class="memItemLeft" align="right" valign="top">static Simd4DBool gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga161caa368bcf9f1d566b6bbb81b23a5f">gmx::operator&lt;</a> (Simd4Double a, Simd4Double b)</td></tr>
<tr class="memdesc:ga161caa368bcf9f1d566b6bbb81b23a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">a&lt;b for SIMD4 double  <a href="#ga161caa368bcf9f1d566b6bbb81b23a5f">More...</a><br/></td></tr>
<tr class="separator:ga161caa368bcf9f1d566b6bbb81b23a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65c76bc6290f217b5fce5d5538c5f342"><td class="memItemLeft" align="right" valign="top">static Simd4DBool gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga65c76bc6290f217b5fce5d5538c5f342">gmx::operator&lt;=</a> (Simd4Double a, Simd4Double b)</td></tr>
<tr class="memdesc:ga65c76bc6290f217b5fce5d5538c5f342"><td class="mdescLeft">&#160;</td><td class="mdescRight">a&lt;=b for SIMD4 double.  <a href="#ga65c76bc6290f217b5fce5d5538c5f342">More...</a><br/></td></tr>
<tr class="separator:ga65c76bc6290f217b5fce5d5538c5f342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacd2b1a31c667bffa467f02e57b191e5"><td class="memItemLeft" align="right" valign="top">static Simd4DBool gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaacd2b1a31c667bffa467f02e57b191e5">gmx::operator&amp;&amp;</a> (Simd4DBool a, Simd4DBool b)</td></tr>
<tr class="memdesc:gaacd2b1a31c667bffa467f02e57b191e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical <em>and</em> on single precision SIMD4 booleans.  <a href="#gaacd2b1a31c667bffa467f02e57b191e5">More...</a><br/></td></tr>
<tr class="separator:gaacd2b1a31c667bffa467f02e57b191e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d5483d15fe15e3c3eaf1e4e90e53f90"><td class="memItemLeft" align="right" valign="top">static Simd4DBool gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga5d5483d15fe15e3c3eaf1e4e90e53f90">gmx::operator||</a> (Simd4DBool a, Simd4DBool b)</td></tr>
<tr class="memdesc:ga5d5483d15fe15e3c3eaf1e4e90e53f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical <em>or</em> on single precision SIMD4 booleans.  <a href="#ga5d5483d15fe15e3c3eaf1e4e90e53f90">More...</a><br/></td></tr>
<tr class="separator:ga5d5483d15fe15e3c3eaf1e4e90e53f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga314f00cbdc12d0615a873dff3bdd38db"><td class="memItemLeft" align="right" valign="top">static bool gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga314f00cbdc12d0615a873dff3bdd38db">gmx::anyTrue</a> (Simd4DBool a)</td></tr>
<tr class="memdesc:ga314f00cbdc12d0615a873dff3bdd38db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if any of the boolean in SIMD4 a is True, otherwise 0.  <a href="#ga314f00cbdc12d0615a873dff3bdd38db">More...</a><br/></td></tr>
<tr class="separator:ga314f00cbdc12d0615a873dff3bdd38db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga223de776671702527c62b4da8f6e570a"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga223de776671702527c62b4da8f6e570a">gmx::selectByMask</a> (Simd4Double a, Simd4DBool mask)</td></tr>
<tr class="memdesc:ga223de776671702527c62b4da8f6e570a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from single precision SIMD4 variable where boolean is true.  <a href="#ga223de776671702527c62b4da8f6e570a">More...</a><br/></td></tr>
<tr class="separator:ga223de776671702527c62b4da8f6e570a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga388cbdee2056718a2d23b3080d4c9b84"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga388cbdee2056718a2d23b3080d4c9b84">gmx::selectByNotMask</a> (Simd4Double a, Simd4DBool mask)</td></tr>
<tr class="memdesc:ga388cbdee2056718a2d23b3080d4c9b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from single precision SIMD4 variable where boolean is false.  <a href="#ga388cbdee2056718a2d23b3080d4c9b84">More...</a><br/></td></tr>
<tr class="separator:ga388cbdee2056718a2d23b3080d4c9b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa1d01238ab3305ab17f301f73eaeaa1"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gafa1d01238ab3305ab17f301f73eaeaa1">gmx::blend</a> (Simd4Double a, Simd4Double b, Simd4DBool sel)</td></tr>
<tr class="memdesc:gafa1d01238ab3305ab17f301f73eaeaa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector-blend SIMD4 selection.  <a href="#gafa1d01238ab3305ab17f301f73eaeaa1">More...</a><br/></td></tr>
<tr class="separator:gafa1d01238ab3305ab17f301f73eaeaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ee526de5755cc7bb8d7c46c532483e4"><td class="memItemLeft" align="right" valign="top">static double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga5ee526de5755cc7bb8d7c46c532483e4">gmx::reduce</a> (Simd4Double a)</td></tr>
<tr class="memdesc:ga5ee526de5755cc7bb8d7c46c532483e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sum of all elements in SIMD4 double variable.  <a href="#ga5ee526de5755cc7bb8d7c46c532483e4">More...</a><br/></td></tr>
<tr class="separator:ga5ee526de5755cc7bb8d7c46c532483e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Constant width-4 single precision SIMD types and instructions</h2></td></tr>
<tr class="memitem:ga0c25c98d5fca0e4c2294d775f75949f4"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga0c25c98d5fca0e4c2294d775f75949f4">gmx::load4</a> (const float *m)</td></tr>
<tr class="memdesc:ga0c25c98d5fca0e4c2294d775f75949f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 4 float values from aligned memory into SIMD4 variable.  <a href="#ga0c25c98d5fca0e4c2294d775f75949f4">More...</a><br/></td></tr>
<tr class="separator:ga0c25c98d5fca0e4c2294d775f75949f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc95fcf592b08dfca9aabc44cf994ece"><td class="memItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gafc95fcf592b08dfca9aabc44cf994ece">gmx::store4</a> (float *m, Simd4Float a)</td></tr>
<tr class="memdesc:gafc95fcf592b08dfca9aabc44cf994ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the contents of SIMD4 float to aligned memory m.  <a href="#gafc95fcf592b08dfca9aabc44cf994ece">More...</a><br/></td></tr>
<tr class="separator:gafc95fcf592b08dfca9aabc44cf994ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30c2c73886641040a0f0d5c1f16da97d"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga30c2c73886641040a0f0d5c1f16da97d">gmx::load4U</a> (const float *m)</td></tr>
<tr class="memdesc:ga30c2c73886641040a0f0d5c1f16da97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load SIMD4 float from unaligned memory.  <a href="#ga30c2c73886641040a0f0d5c1f16da97d">More...</a><br/></td></tr>
<tr class="separator:ga30c2c73886641040a0f0d5c1f16da97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a91843f00041c799a995535a7cdc12f"><td class="memItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga8a91843f00041c799a995535a7cdc12f">gmx::store4U</a> (float *m, Simd4Float a)</td></tr>
<tr class="memdesc:ga8a91843f00041c799a995535a7cdc12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store SIMD4 float to unaligned memory.  <a href="#ga8a91843f00041c799a995535a7cdc12f">More...</a><br/></td></tr>
<tr class="separator:ga8a91843f00041c799a995535a7cdc12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa583e5ea332a308e773ad9422e0d080"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gafa583e5ea332a308e773ad9422e0d080">gmx::simd4SetZeroF</a> ()</td></tr>
<tr class="memdesc:gafa583e5ea332a308e773ad9422e0d080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all SIMD4 float elements to 0.  <a href="#gafa583e5ea332a308e773ad9422e0d080">More...</a><br/></td></tr>
<tr class="separator:gafa583e5ea332a308e773ad9422e0d080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1b1d6f3300a808b8b3a3b516dd39b15"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gab1b1d6f3300a808b8b3a3b516dd39b15">gmx::operator&amp;</a> (Simd4Float a, Simd4Float b)</td></tr>
<tr class="memdesc:gab1b1d6f3300a808b8b3a3b516dd39b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise and for two SIMD4 float variables.  <a href="#gab1b1d6f3300a808b8b3a3b516dd39b15">More...</a><br/></td></tr>
<tr class="separator:gab1b1d6f3300a808b8b3a3b516dd39b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dfe3fded0fc0c151f918e6892603121"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga4dfe3fded0fc0c151f918e6892603121">gmx::andNot</a> (Simd4Float a, Simd4Float b)</td></tr>
<tr class="memdesc:ga4dfe3fded0fc0c151f918e6892603121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise andnot for two SIMD4 float variables. c=(~a) &amp; b.  <a href="#ga4dfe3fded0fc0c151f918e6892603121">More...</a><br/></td></tr>
<tr class="separator:ga4dfe3fded0fc0c151f918e6892603121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad759e852213903c61d6d4b9053e794fc"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gad759e852213903c61d6d4b9053e794fc">gmx::operator|</a> (Simd4Float a, Simd4Float b)</td></tr>
<tr class="memdesc:gad759e852213903c61d6d4b9053e794fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise or for two SIMD4 floats.  <a href="#gad759e852213903c61d6d4b9053e794fc">More...</a><br/></td></tr>
<tr class="separator:gad759e852213903c61d6d4b9053e794fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8385ef4b8312eff3f715d2f817604e51"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga8385ef4b8312eff3f715d2f817604e51">gmx::operator^</a> (Simd4Float a, Simd4Float b)</td></tr>
<tr class="memdesc:ga8385ef4b8312eff3f715d2f817604e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise xor for two SIMD4 float variables.  <a href="#ga8385ef4b8312eff3f715d2f817604e51">More...</a><br/></td></tr>
<tr class="separator:ga8385ef4b8312eff3f715d2f817604e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd943dd0c83fa26c6eb5805ad5025e17"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gafd943dd0c83fa26c6eb5805ad5025e17">gmx::operator+</a> (Simd4Float a, Simd4Float b)</td></tr>
<tr class="memdesc:gafd943dd0c83fa26c6eb5805ad5025e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two float SIMD4 variables.  <a href="#gafd943dd0c83fa26c6eb5805ad5025e17">More...</a><br/></td></tr>
<tr class="separator:gafd943dd0c83fa26c6eb5805ad5025e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb00887996b2ed9e672c7b556c53cb98"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gadb00887996b2ed9e672c7b556c53cb98">gmx::operator-</a> (Simd4Float a, Simd4Float b)</td></tr>
<tr class="memdesc:gadb00887996b2ed9e672c7b556c53cb98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two SIMD4 variables.  <a href="#gadb00887996b2ed9e672c7b556c53cb98">More...</a><br/></td></tr>
<tr class="separator:gadb00887996b2ed9e672c7b556c53cb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad9353fb4bd3db4bb232f65d47a6abcf"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaad9353fb4bd3db4bb232f65d47a6abcf">gmx::operator-</a> (Simd4Float a)</td></tr>
<tr class="memdesc:gaad9353fb4bd3db4bb232f65d47a6abcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD4 floating-point negate.  <a href="#gaad9353fb4bd3db4bb232f65d47a6abcf">More...</a><br/></td></tr>
<tr class="separator:gaad9353fb4bd3db4bb232f65d47a6abcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42f5e1c65d65ad34afa31b6d0e5f7c7b"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga42f5e1c65d65ad34afa31b6d0e5f7c7b">gmx::operator*</a> (Simd4Float a, Simd4Float b)</td></tr>
<tr class="memdesc:ga42f5e1c65d65ad34afa31b6d0e5f7c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two SIMD4 variables.  <a href="#ga42f5e1c65d65ad34afa31b6d0e5f7c7b">More...</a><br/></td></tr>
<tr class="separator:ga42f5e1c65d65ad34afa31b6d0e5f7c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2db026253ce788e7f136326089e8a77"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaa2db026253ce788e7f136326089e8a77">gmx::fma</a> (Simd4Float a, Simd4Float b, Simd4Float c)</td></tr>
<tr class="memdesc:gaa2db026253ce788e7f136326089e8a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD4 Fused-multiply-add. Result is a*b+c.  <a href="#gaa2db026253ce788e7f136326089e8a77">More...</a><br/></td></tr>
<tr class="separator:gaa2db026253ce788e7f136326089e8a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb3861a4cc7cae530fcf5bf83955da1b"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gafb3861a4cc7cae530fcf5bf83955da1b">gmx::fms</a> (Simd4Float a, Simd4Float b, Simd4Float c)</td></tr>
<tr class="memdesc:gafb3861a4cc7cae530fcf5bf83955da1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD4 Fused-multiply-subtract. Result is a*b-c.  <a href="#gafb3861a4cc7cae530fcf5bf83955da1b">More...</a><br/></td></tr>
<tr class="separator:gafb3861a4cc7cae530fcf5bf83955da1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf4df87eca51bb2f57ffe0bcb1c9de02"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaaf4df87eca51bb2f57ffe0bcb1c9de02">gmx::fnma</a> (Simd4Float a, Simd4Float b, Simd4Float c)</td></tr>
<tr class="memdesc:gaaf4df87eca51bb2f57ffe0bcb1c9de02"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD4 Fused-negated-multiply-add. Result is -a*b+c.  <a href="#gaaf4df87eca51bb2f57ffe0bcb1c9de02">More...</a><br/></td></tr>
<tr class="separator:gaaf4df87eca51bb2f57ffe0bcb1c9de02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace0a9be42a2c83de88e9de207cd82e80"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gace0a9be42a2c83de88e9de207cd82e80">gmx::fnms</a> (Simd4Float a, Simd4Float b, Simd4Float c)</td></tr>
<tr class="memdesc:gace0a9be42a2c83de88e9de207cd82e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD4 Fused-negated-multiply-subtract. Result is -a*b-c.  <a href="#gace0a9be42a2c83de88e9de207cd82e80">More...</a><br/></td></tr>
<tr class="separator:gace0a9be42a2c83de88e9de207cd82e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae4a6def215dcf244fcba8ba06eb1f26"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaae4a6def215dcf244fcba8ba06eb1f26">gmx::rsqrt</a> (Simd4Float x)</td></tr>
<tr class="memdesc:gaae4a6def215dcf244fcba8ba06eb1f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD4 1.0/sqrt(x) lookup.  <a href="#gaae4a6def215dcf244fcba8ba06eb1f26">More...</a><br/></td></tr>
<tr class="separator:gaae4a6def215dcf244fcba8ba06eb1f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4555c730e6119f070664703072a7235c"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga4555c730e6119f070664703072a7235c">gmx::abs</a> (Simd4Float a)</td></tr>
<tr class="memdesc:ga4555c730e6119f070664703072a7235c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD4 Floating-point fabs().  <a href="#ga4555c730e6119f070664703072a7235c">More...</a><br/></td></tr>
<tr class="separator:ga4555c730e6119f070664703072a7235c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c66081dde9666200461f364725a4085"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga3c66081dde9666200461f364725a4085">gmx::max</a> (Simd4Float a, Simd4Float b)</td></tr>
<tr class="memdesc:ga3c66081dde9666200461f364725a4085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set each SIMD4 element to the largest from two variables.  <a href="#ga3c66081dde9666200461f364725a4085">More...</a><br/></td></tr>
<tr class="separator:ga3c66081dde9666200461f364725a4085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2da2e85aea6a6eef4add06627566b8ab"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga2da2e85aea6a6eef4add06627566b8ab">gmx::min</a> (Simd4Float a, Simd4Float b)</td></tr>
<tr class="memdesc:ga2da2e85aea6a6eef4add06627566b8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set each SIMD4 element to the largest from two variables.  <a href="#ga2da2e85aea6a6eef4add06627566b8ab">More...</a><br/></td></tr>
<tr class="separator:ga2da2e85aea6a6eef4add06627566b8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf1bf91a0d1377886282a96f558798c8"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gacf1bf91a0d1377886282a96f558798c8">gmx::round</a> (Simd4Float a)</td></tr>
<tr class="memdesc:gacf1bf91a0d1377886282a96f558798c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD4 Round to nearest integer value (in floating-point format).  <a href="#gacf1bf91a0d1377886282a96f558798c8">More...</a><br/></td></tr>
<tr class="separator:gacf1bf91a0d1377886282a96f558798c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97c12b8d0415b8633da6b48f437d6078"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga97c12b8d0415b8633da6b48f437d6078">gmx::trunc</a> (Simd4Float a)</td></tr>
<tr class="memdesc:ga97c12b8d0415b8633da6b48f437d6078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate SIMD4, i.e. round towards zero - common hardware instruction.  <a href="#ga97c12b8d0415b8633da6b48f437d6078">More...</a><br/></td></tr>
<tr class="separator:ga97c12b8d0415b8633da6b48f437d6078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0420b0ba8ce5c0bbdf94d69c67ab563"><td class="memItemLeft" align="right" valign="top">static float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gac0420b0ba8ce5c0bbdf94d69c67ab563">gmx::dotProduct</a> (Simd4Float a, Simd4Float b)</td></tr>
<tr class="memdesc:gac0420b0ba8ce5c0bbdf94d69c67ab563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return dot product of two single precision SIMD4 variables.  <a href="#gac0420b0ba8ce5c0bbdf94d69c67ab563">More...</a><br/></td></tr>
<tr class="separator:gac0420b0ba8ce5c0bbdf94d69c67ab563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga059f7a354565ad8c1494853ec9a00d3f"><td class="memItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga059f7a354565ad8c1494853ec9a00d3f">gmx::transpose</a> (Simd4Float *v0, Simd4Float *v1, Simd4Float *v2, Simd4Float *v3)</td></tr>
<tr class="memdesc:ga059f7a354565ad8c1494853ec9a00d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD4 float transpose.  <a href="#ga059f7a354565ad8c1494853ec9a00d3f">More...</a><br/></td></tr>
<tr class="separator:ga059f7a354565ad8c1494853ec9a00d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae817b7cf5e876f1c6357e14a4666a3c6"><td class="memItemLeft" align="right" valign="top">static Simd4FBool gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gae817b7cf5e876f1c6357e14a4666a3c6">gmx::operator==</a> (Simd4Float a, Simd4Float b)</td></tr>
<tr class="memdesc:gae817b7cf5e876f1c6357e14a4666a3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">a==b for SIMD4 float  <a href="#gae817b7cf5e876f1c6357e14a4666a3c6">More...</a><br/></td></tr>
<tr class="separator:gae817b7cf5e876f1c6357e14a4666a3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabe89c1073d64ee649e9cd7b37c85e2e"><td class="memItemLeft" align="right" valign="top">static Simd4FBool gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaabe89c1073d64ee649e9cd7b37c85e2e">gmx::operator!=</a> (Simd4Float a, Simd4Float b)</td></tr>
<tr class="memdesc:gaabe89c1073d64ee649e9cd7b37c85e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">a!=b for SIMD4 float  <a href="#gaabe89c1073d64ee649e9cd7b37c85e2e">More...</a><br/></td></tr>
<tr class="separator:gaabe89c1073d64ee649e9cd7b37c85e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf02163d0cb41985160b79503ef1d53d0"><td class="memItemLeft" align="right" valign="top">static Simd4FBool gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaf02163d0cb41985160b79503ef1d53d0">gmx::operator&lt;</a> (Simd4Float a, Simd4Float b)</td></tr>
<tr class="memdesc:gaf02163d0cb41985160b79503ef1d53d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">a&lt;b for SIMD4 float  <a href="#gaf02163d0cb41985160b79503ef1d53d0">More...</a><br/></td></tr>
<tr class="separator:gaf02163d0cb41985160b79503ef1d53d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46491dc3239fcdcd48c55e00184c81ec"><td class="memItemLeft" align="right" valign="top">static Simd4FBool gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga46491dc3239fcdcd48c55e00184c81ec">gmx::operator&lt;=</a> (Simd4Float a, Simd4Float b)</td></tr>
<tr class="memdesc:ga46491dc3239fcdcd48c55e00184c81ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">a&lt;=b for SIMD4 float.  <a href="#ga46491dc3239fcdcd48c55e00184c81ec">More...</a><br/></td></tr>
<tr class="separator:ga46491dc3239fcdcd48c55e00184c81ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab72a2c3a96ed9681d4df89e38ec1583e"><td class="memItemLeft" align="right" valign="top">static Simd4FBool gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gab72a2c3a96ed9681d4df89e38ec1583e">gmx::operator&amp;&amp;</a> (Simd4FBool a, Simd4FBool b)</td></tr>
<tr class="memdesc:gab72a2c3a96ed9681d4df89e38ec1583e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical <em>and</em> on single precision SIMD4 booleans.  <a href="#gab72a2c3a96ed9681d4df89e38ec1583e">More...</a><br/></td></tr>
<tr class="separator:gab72a2c3a96ed9681d4df89e38ec1583e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2ab4b4f3d3e7f6e9a012df64c1d9f3c"><td class="memItemLeft" align="right" valign="top">static Simd4FBool gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaf2ab4b4f3d3e7f6e9a012df64c1d9f3c">gmx::operator||</a> (Simd4FBool a, Simd4FBool b)</td></tr>
<tr class="memdesc:gaf2ab4b4f3d3e7f6e9a012df64c1d9f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical <em>or</em> on single precision SIMD4 booleans.  <a href="#gaf2ab4b4f3d3e7f6e9a012df64c1d9f3c">More...</a><br/></td></tr>
<tr class="separator:gaf2ab4b4f3d3e7f6e9a012df64c1d9f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b8118b5d14f17aa83d64531e7793e4e"><td class="memItemLeft" align="right" valign="top">static bool gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga5b8118b5d14f17aa83d64531e7793e4e">gmx::anyTrue</a> (Simd4FBool a)</td></tr>
<tr class="memdesc:ga5b8118b5d14f17aa83d64531e7793e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if any of the boolean in SIMD4 a is True, otherwise 0.  <a href="#ga5b8118b5d14f17aa83d64531e7793e4e">More...</a><br/></td></tr>
<tr class="separator:ga5b8118b5d14f17aa83d64531e7793e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76ed0866ac21967e0a9641acca32ab50"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga76ed0866ac21967e0a9641acca32ab50">gmx::selectByMask</a> (Simd4Float a, Simd4FBool mask)</td></tr>
<tr class="memdesc:ga76ed0866ac21967e0a9641acca32ab50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from single precision SIMD4 variable where boolean is true.  <a href="#ga76ed0866ac21967e0a9641acca32ab50">More...</a><br/></td></tr>
<tr class="separator:ga76ed0866ac21967e0a9641acca32ab50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaff9aa6673f42b4d0d4f3b154deac384"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaaff9aa6673f42b4d0d4f3b154deac384">gmx::selectByNotMask</a> (Simd4Float a, Simd4FBool mask)</td></tr>
<tr class="memdesc:gaaff9aa6673f42b4d0d4f3b154deac384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from single precision SIMD4 variable where boolean is false.  <a href="#gaaff9aa6673f42b4d0d4f3b154deac384">More...</a><br/></td></tr>
<tr class="separator:gaaff9aa6673f42b4d0d4f3b154deac384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a3c7493047defc21bf934ca9fc39476"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga9a3c7493047defc21bf934ca9fc39476">gmx::blend</a> (Simd4Float a, Simd4Float b, Simd4FBool sel)</td></tr>
<tr class="memdesc:ga9a3c7493047defc21bf934ca9fc39476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector-blend SIMD4 selection.  <a href="#ga9a3c7493047defc21bf934ca9fc39476">More...</a><br/></td></tr>
<tr class="separator:ga9a3c7493047defc21bf934ca9fc39476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga072c4a40acda5dbbd28687df84331335"><td class="memItemLeft" align="right" valign="top">static float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga072c4a40acda5dbbd28687df84331335">gmx::reduce</a> (Simd4Float a)</td></tr>
<tr class="memdesc:ga072c4a40acda5dbbd28687df84331335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sum of all elements in SIMD4 float variable.  <a href="#ga072c4a40acda5dbbd28687df84331335">More...</a><br/></td></tr>
<tr class="separator:ga072c4a40acda5dbbd28687df84331335"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SIMD predefined macros to describe high-level capabilities</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp6b4778a88467a820bdbf09f3d243e88e"></a>These macros are used to describe the features available in default Gromacs real precision. They are set from the lower-level implementation files that have macros describing single and double precision individually, as well as the implementation details. </p>
</td></tr>
<tr class="memitem:ga1578fccdb327f36a2bea338457cbf883"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga1578fccdb327f36a2bea338457cbf883">GMX_SIMD_HAVE_REAL</a>&#160;&#160;&#160;<a class="el" href="group__module__simd.xhtml#ga8d093280bad2b3ebecbcd426bdddb73b">GMX_SIMD_HAVE_FLOAT</a></td></tr>
<tr class="memdesc:ga1578fccdb327f36a2bea338457cbf883"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if SimdReal is available, otherwise 0.  <a href="#ga1578fccdb327f36a2bea338457cbf883">More...</a><br/></td></tr>
<tr class="separator:ga1578fccdb327f36a2bea338457cbf883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga586ccc19c21a1d5e9c97e15b70822fba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga586ccc19c21a1d5e9c97e15b70822fba">GMX_SIMD_REAL_WIDTH</a>&#160;&#160;&#160;<a class="el" href="group__module__simd.xhtml#gafdbf804a40bfa3dcb15bc50055e58e74">GMX_SIMD_FLOAT_WIDTH</a></td></tr>
<tr class="memdesc:ga586ccc19c21a1d5e9c97e15b70822fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Width of SimdReal.  <a href="#ga586ccc19c21a1d5e9c97e15b70822fba">More...</a><br/></td></tr>
<tr class="separator:ga586ccc19c21a1d5e9c97e15b70822fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga036e9a3893a355aa51267fef7b5d4cae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga036e9a3893a355aa51267fef7b5d4cae">GMX_SIMD_HAVE_INT32_EXTRACT</a>&#160;&#160;&#160;<a class="el" href="group__module__simd.xhtml#ga23ac53a0050467ac215f146f6afc6380">GMX_SIMD_HAVE_FINT32_EXTRACT</a></td></tr>
<tr class="memdesc:ga036e9a3893a355aa51267fef7b5d4cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if support is available for extracting elements from SimdInt32, otherwise 0  <a href="#ga036e9a3893a355aa51267fef7b5d4cae">More...</a><br/></td></tr>
<tr class="separator:ga036e9a3893a355aa51267fef7b5d4cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69de9b6e1473a9dc3ab6a5588d00192a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga69de9b6e1473a9dc3ab6a5588d00192a">GMX_SIMD_HAVE_INT32_LOGICAL</a>&#160;&#160;&#160;<a class="el" href="group__module__simd.xhtml#ga354867d2570fecb6b341047947bee0d1">GMX_SIMD_HAVE_FINT32_LOGICAL</a></td></tr>
<tr class="memdesc:ga69de9b6e1473a9dc3ab6a5588d00192a"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if logical ops are supported on SimdInt32, otherwise 0.  <a href="#ga69de9b6e1473a9dc3ab6a5588d00192a">More...</a><br/></td></tr>
<tr class="separator:ga69de9b6e1473a9dc3ab6a5588d00192a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a9534860edf5a3f2b9cd1bc60529b39"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga8a9534860edf5a3f2b9cd1bc60529b39">GMX_SIMD_HAVE_INT32_ARITHMETICS</a>&#160;&#160;&#160;<a class="el" href="group__module__simd.xhtml#ga9febc62e1abd58eb8a035b8b81f93292">GMX_SIMD_HAVE_FINT32_ARITHMETICS</a></td></tr>
<tr class="memdesc:ga8a9534860edf5a3f2b9cd1bc60529b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if arithmetic ops are supported on SimdInt32, otherwise 0.  <a href="#ga8a9534860edf5a3f2b9cd1bc60529b39">More...</a><br/></td></tr>
<tr class="separator:ga8a9534860edf5a3f2b9cd1bc60529b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1350cf295aeed5d4fce461ca2048c56"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gad1350cf295aeed5d4fce461ca2048c56">GMX_SIMD_HAVE_GATHER_LOADU_BYSIMDINT_TRANSPOSE_REAL</a>&#160;&#160;&#160;<a class="el" href="group__module__simd.xhtml#ga5ba6c684641af238fb2a5a7d4c6e0237">GMX_SIMD_HAVE_GATHER_LOADU_BYSIMDINT_TRANSPOSE_FLOAT</a></td></tr>
<tr class="memdesc:gad1350cf295aeed5d4fce461ca2048c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if gmx::simdGatherLoadUBySimdIntTranspose is present, otherwise 0  <a href="#gad1350cf295aeed5d4fce461ca2048c56">More...</a><br/></td></tr>
<tr class="separator:gad1350cf295aeed5d4fce461ca2048c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d9f8d6284ecbbd135b89f2ad8999839"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga0d9f8d6284ecbbd135b89f2ad8999839">GMX_SIMD_HAVE_HSIMD_UTIL_REAL</a>&#160;&#160;&#160;<a class="el" href="group__module__simd.xhtml#gac40bf3261e36fb7ff022e8ab37b04fcf">GMX_SIMD_HAVE_HSIMD_UTIL_FLOAT</a></td></tr>
<tr class="memdesc:ga0d9f8d6284ecbbd135b89f2ad8999839"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if real half-register load/store/reduce utils present, otherwise 0  <a href="#ga0d9f8d6284ecbbd135b89f2ad8999839">More...</a><br/></td></tr>
<tr class="separator:ga0d9f8d6284ecbbd135b89f2ad8999839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c015b9c619e63324df85f91e25191c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga6c015b9c619e63324df85f91e25191c5">GMX_SIMD4_HAVE_REAL</a>&#160;&#160;&#160;<a class="el" href="group__module__simd.xhtml#ga86b316f5c5de088d4cb073300198f4d3">GMX_SIMD4_HAVE_FLOAT</a></td></tr>
<tr class="memdesc:ga6c015b9c619e63324df85f91e25191c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if Simd4Real is available, otherwise 0.  <a href="#ga6c015b9c619e63324df85f91e25191c5">More...</a><br/></td></tr>
<tr class="separator:ga6c015b9c619e63324df85f91e25191c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Single precision SIMD math functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpc5662730b93597438bd3ff63e882f8f7"></a></p>
<dl class="section note"><dt>Note</dt><dd>In most cases you should use the real-precision functions instead. </dd></dl>
</td></tr>
<tr class="memitem:gacb8a1939549a71a3c2861de9ce865301"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gacb8a1939549a71a3c2861de9ce865301">gmx::copysign</a> (SimdFloat x, SimdFloat y)</td></tr>
<tr class="memdesc:gacb8a1939549a71a3c2861de9ce865301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes floating point value with the magnitude of x and the sign of y.  <a href="#gacb8a1939549a71a3c2861de9ce865301">More...</a><br/></td></tr>
<tr class="separator:gacb8a1939549a71a3c2861de9ce865301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade7401625051e95c057a8f5fe6dc5fbc"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gade7401625051e95c057a8f5fe6dc5fbc">gmx::rsqrtIter</a> (SimdFloat lu, SimdFloat x)</td></tr>
<tr class="memdesc:gade7401625051e95c057a8f5fe6dc5fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform one Newton-Raphson iteration to improve 1/sqrt(x) for SIMD float.  <a href="#gade7401625051e95c057a8f5fe6dc5fbc">More...</a><br/></td></tr>
<tr class="separator:gade7401625051e95c057a8f5fe6dc5fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bf9fd932f39d4ad83b360395f1c3986"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga1bf9fd932f39d4ad83b360395f1c3986">gmx::invsqrt</a> (SimdFloat x)</td></tr>
<tr class="memdesc:ga1bf9fd932f39d4ad83b360395f1c3986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for SIMD float.  <a href="#ga1bf9fd932f39d4ad83b360395f1c3986">More...</a><br/></td></tr>
<tr class="separator:ga1bf9fd932f39d4ad83b360395f1c3986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a4b0a1815e2a09330e4e61444b3f630"><td class="memItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga2a4b0a1815e2a09330e4e61444b3f630">gmx::invsqrtPair</a> (SimdFloat x0, SimdFloat x1, SimdFloat *out0, SimdFloat *out1)</td></tr>
<tr class="memdesc:ga2a4b0a1815e2a09330e4e61444b3f630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for two SIMD floats.  <a href="#ga2a4b0a1815e2a09330e4e61444b3f630">More...</a><br/></td></tr>
<tr class="separator:ga2a4b0a1815e2a09330e4e61444b3f630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85e439a79e5b92d8544451b8c1ba41f5"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga85e439a79e5b92d8544451b8c1ba41f5">gmx::rcpIter</a> (SimdFloat lu, SimdFloat x)</td></tr>
<tr class="memdesc:ga85e439a79e5b92d8544451b8c1ba41f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform one Newton-Raphson iteration to improve 1/x for SIMD float.  <a href="#ga85e439a79e5b92d8544451b8c1ba41f5">More...</a><br/></td></tr>
<tr class="separator:ga85e439a79e5b92d8544451b8c1ba41f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a3c6ca88a6073aba3eb600da20cc92b"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga6a3c6ca88a6073aba3eb600da20cc92b">gmx::inv</a> (SimdFloat x)</td></tr>
<tr class="memdesc:ga6a3c6ca88a6073aba3eb600da20cc92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/x for SIMD float.  <a href="#ga6a3c6ca88a6073aba3eb600da20cc92b">More...</a><br/></td></tr>
<tr class="separator:ga6a3c6ca88a6073aba3eb600da20cc92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f60c988e122306d212679a83bd12910"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga0f60c988e122306d212679a83bd12910">gmx::operator/</a> (SimdFloat nom, SimdFloat denom)</td></tr>
<tr class="memdesc:ga0f60c988e122306d212679a83bd12910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division for SIMD floats.  <a href="#ga0f60c988e122306d212679a83bd12910">More...</a><br/></td></tr>
<tr class="separator:ga0f60c988e122306d212679a83bd12910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab41aa57f986f3983040e5f589e3eb07c"><td class="memItemLeft" align="right" valign="top">static SimdFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gab41aa57f986f3983040e5f589e3eb07c">gmx::maskzInvsqrt</a> (SimdFloat x, SimdFBool m)</td></tr>
<tr class="memdesc:gab41aa57f986f3983040e5f589e3eb07c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for masked entries of SIMD float.  <a href="#gab41aa57f986f3983040e5f589e3eb07c">More...</a><br/></td></tr>
<tr class="separator:gab41aa57f986f3983040e5f589e3eb07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1968e5334b953108c682435b6e59694"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gae1968e5334b953108c682435b6e59694">gmx::maskzInv</a> (SimdFloat x, SimdFBool m)</td></tr>
<tr class="memdesc:gae1968e5334b953108c682435b6e59694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/x for SIMD float, masked version.  <a href="#gae1968e5334b953108c682435b6e59694">More...</a><br/></td></tr>
<tr class="separator:gae1968e5334b953108c682435b6e59694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf84cf0860622bb52d9ef8d62563a7815"><td class="memTemplParams" colspan="2">template&lt;MathOptimization opt = MathOptimization::Safe&gt; </td></tr>
<tr class="memitem:gaf84cf0860622bb52d9ef8d62563a7815"><td class="memTemplItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaf84cf0860622bb52d9ef8d62563a7815">gmx::sqrt</a> (SimdFloat x)</td></tr>
<tr class="memdesc:gaf84cf0860622bb52d9ef8d62563a7815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate sqrt(x) for SIMD floats.  <a href="#gaf84cf0860622bb52d9ef8d62563a7815">More...</a><br/></td></tr>
<tr class="separator:gaf84cf0860622bb52d9ef8d62563a7815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga332f838e799c55c26e23126ea2aeace5"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga332f838e799c55c26e23126ea2aeace5">gmx::log</a> (SimdFloat x)</td></tr>
<tr class="memdesc:ga332f838e799c55c26e23126ea2aeace5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float log(x). This is the natural logarithm.  <a href="#ga332f838e799c55c26e23126ea2aeace5">More...</a><br/></td></tr>
<tr class="separator:ga332f838e799c55c26e23126ea2aeace5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53b14cbaf68e8e449f610ae172c39699"><td class="memTemplParams" colspan="2">template&lt;MathOptimization opt = MathOptimization::Safe&gt; </td></tr>
<tr class="memitem:ga53b14cbaf68e8e449f610ae172c39699"><td class="memTemplItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga53b14cbaf68e8e449f610ae172c39699">gmx::exp2</a> (SimdFloat x)</td></tr>
<tr class="memdesc:ga53b14cbaf68e8e449f610ae172c39699"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float 2^x.  <a href="#ga53b14cbaf68e8e449f610ae172c39699">More...</a><br/></td></tr>
<tr class="separator:ga53b14cbaf68e8e449f610ae172c39699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf6583b14086a1a6b6947838ccc7301e"><td class="memTemplParams" colspan="2">template&lt;MathOptimization opt = MathOptimization::Safe&gt; </td></tr>
<tr class="memitem:gacf6583b14086a1a6b6947838ccc7301e"><td class="memTemplItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gacf6583b14086a1a6b6947838ccc7301e">gmx::exp</a> (SimdFloat x)</td></tr>
<tr class="memdesc:gacf6583b14086a1a6b6947838ccc7301e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float exp(x).  <a href="#gacf6583b14086a1a6b6947838ccc7301e">More...</a><br/></td></tr>
<tr class="separator:gacf6583b14086a1a6b6947838ccc7301e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60e354f86286dc5b7620f6bc663bb089"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga60e354f86286dc5b7620f6bc663bb089">gmx::erf</a> (SimdFloat x)</td></tr>
<tr class="memdesc:ga60e354f86286dc5b7620f6bc663bb089"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float erf(x).  <a href="#ga60e354f86286dc5b7620f6bc663bb089">More...</a><br/></td></tr>
<tr class="separator:ga60e354f86286dc5b7620f6bc663bb089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e169e3f45d0532ab2350daad387ca57"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga1e169e3f45d0532ab2350daad387ca57">gmx::erfc</a> (SimdFloat x)</td></tr>
<tr class="memdesc:ga1e169e3f45d0532ab2350daad387ca57"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float erfc(x).  <a href="#ga1e169e3f45d0532ab2350daad387ca57">More...</a><br/></td></tr>
<tr class="separator:ga1e169e3f45d0532ab2350daad387ca57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2640bfdb9db1762df1b5da82d80e73b8"><td class="memItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga2640bfdb9db1762df1b5da82d80e73b8">gmx::sincos</a> (SimdFloat x, SimdFloat *sinval, SimdFloat *cosval)</td></tr>
<tr class="memdesc:ga2640bfdb9db1762df1b5da82d80e73b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float sin &amp; cos.  <a href="#ga2640bfdb9db1762df1b5da82d80e73b8">More...</a><br/></td></tr>
<tr class="separator:ga2640bfdb9db1762df1b5da82d80e73b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ef875418e7985b298af5f6d58f32e23"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga9ef875418e7985b298af5f6d58f32e23">gmx::sin</a> (SimdFloat x)</td></tr>
<tr class="memdesc:ga9ef875418e7985b298af5f6d58f32e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float sin(x).  <a href="#ga9ef875418e7985b298af5f6d58f32e23">More...</a><br/></td></tr>
<tr class="separator:ga9ef875418e7985b298af5f6d58f32e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c58146cc6b29eaa9756faea26eba851"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga9c58146cc6b29eaa9756faea26eba851">gmx::cos</a> (SimdFloat x)</td></tr>
<tr class="memdesc:ga9c58146cc6b29eaa9756faea26eba851"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float cos(x).  <a href="#ga9c58146cc6b29eaa9756faea26eba851">More...</a><br/></td></tr>
<tr class="separator:ga9c58146cc6b29eaa9756faea26eba851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9b029f69c4afa8bbe7941990507d0f5"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaa9b029f69c4afa8bbe7941990507d0f5">gmx::tan</a> (SimdFloat x)</td></tr>
<tr class="memdesc:gaa9b029f69c4afa8bbe7941990507d0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float tan(x).  <a href="#gaa9b029f69c4afa8bbe7941990507d0f5">More...</a><br/></td></tr>
<tr class="separator:gaa9b029f69c4afa8bbe7941990507d0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabad1890270f5f95bf48d2decd31c7a1a"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gabad1890270f5f95bf48d2decd31c7a1a">gmx::asin</a> (SimdFloat x)</td></tr>
<tr class="memdesc:gabad1890270f5f95bf48d2decd31c7a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float asin(x).  <a href="#gabad1890270f5f95bf48d2decd31c7a1a">More...</a><br/></td></tr>
<tr class="separator:gabad1890270f5f95bf48d2decd31c7a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95f617b5ff9a30dde812f59c8c50bab4"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga95f617b5ff9a30dde812f59c8c50bab4">gmx::acos</a> (SimdFloat x)</td></tr>
<tr class="memdesc:ga95f617b5ff9a30dde812f59c8c50bab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float acos(x).  <a href="#ga95f617b5ff9a30dde812f59c8c50bab4">More...</a><br/></td></tr>
<tr class="separator:ga95f617b5ff9a30dde812f59c8c50bab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4afec2509b0edcdae7fe2ddfc2f3ecc"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gac4afec2509b0edcdae7fe2ddfc2f3ecc">gmx::atan</a> (SimdFloat x)</td></tr>
<tr class="memdesc:gac4afec2509b0edcdae7fe2ddfc2f3ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float asin(x).  <a href="#gac4afec2509b0edcdae7fe2ddfc2f3ecc">More...</a><br/></td></tr>
<tr class="separator:gac4afec2509b0edcdae7fe2ddfc2f3ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f1a591557aea01675643b86653ca136"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga7f1a591557aea01675643b86653ca136">gmx::atan2</a> (SimdFloat y, SimdFloat x)</td></tr>
<tr class="memdesc:ga7f1a591557aea01675643b86653ca136"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float atan2(y,x).  <a href="#ga7f1a591557aea01675643b86653ca136">More...</a><br/></td></tr>
<tr class="separator:ga7f1a591557aea01675643b86653ca136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7ea15fc154a3be2831f786b660b8a6c"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gae7ea15fc154a3be2831f786b660b8a6c">gmx::pmeForceCorrection</a> (SimdFloat z2)</td></tr>
<tr class="memdesc:gae7ea15fc154a3be2831f786b660b8a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the force correction due to PME analytically in SIMD float.  <a href="#gae7ea15fc154a3be2831f786b660b8a6c">More...</a><br/></td></tr>
<tr class="separator:gae7ea15fc154a3be2831f786b660b8a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5324a396c60387bdb3cf42e734f6b465"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga5324a396c60387bdb3cf42e734f6b465">gmx::pmePotentialCorrection</a> (SimdFloat z2)</td></tr>
<tr class="memdesc:ga5324a396c60387bdb3cf42e734f6b465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the potential correction due to PME analytically in SIMD float.  <a href="#ga5324a396c60387bdb3cf42e734f6b465">More...</a><br/></td></tr>
<tr class="separator:ga5324a396c60387bdb3cf42e734f6b465"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Double precision SIMD math functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp4bb293112effeac0507c2750ec65af1f"></a></p>
<dl class="section note"><dt>Note</dt><dd>In most cases you should use the real-precision functions instead. </dd></dl>
</td></tr>
<tr class="memitem:ga3013bbebe9a43572658b37ad9b6b13be"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga3013bbebe9a43572658b37ad9b6b13be">gmx::copysign</a> (SimdDouble x, SimdDouble y)</td></tr>
<tr class="memdesc:ga3013bbebe9a43572658b37ad9b6b13be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes floating point value with the magnitude of x and the sign of y.  <a href="#ga3013bbebe9a43572658b37ad9b6b13be">More...</a><br/></td></tr>
<tr class="separator:ga3013bbebe9a43572658b37ad9b6b13be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dfcf89d49e6e2f75f1249972f2e270f"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga9dfcf89d49e6e2f75f1249972f2e270f">gmx::rsqrtIter</a> (SimdDouble lu, SimdDouble x)</td></tr>
<tr class="memdesc:ga9dfcf89d49e6e2f75f1249972f2e270f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform one Newton-Raphson iteration to improve 1/sqrt(x) for SIMD double.  <a href="#ga9dfcf89d49e6e2f75f1249972f2e270f">More...</a><br/></td></tr>
<tr class="separator:ga9dfcf89d49e6e2f75f1249972f2e270f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7e05436d95febdcc32866b5e8eca46a"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gae7e05436d95febdcc32866b5e8eca46a">gmx::invsqrt</a> (SimdDouble x)</td></tr>
<tr class="memdesc:gae7e05436d95febdcc32866b5e8eca46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for SIMD double.  <a href="#gae7e05436d95febdcc32866b5e8eca46a">More...</a><br/></td></tr>
<tr class="separator:gae7e05436d95febdcc32866b5e8eca46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a20afb3111cd1748f262a693338362b"><td class="memItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga4a20afb3111cd1748f262a693338362b">gmx::invsqrtPair</a> (SimdDouble x0, SimdDouble x1, SimdDouble *out0, SimdDouble *out1)</td></tr>
<tr class="memdesc:ga4a20afb3111cd1748f262a693338362b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for two SIMD doubles.  <a href="#ga4a20afb3111cd1748f262a693338362b">More...</a><br/></td></tr>
<tr class="separator:ga4a20afb3111cd1748f262a693338362b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0f0ffc8730b377743e0b5433d4e2f1a"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaa0f0ffc8730b377743e0b5433d4e2f1a">gmx::rcpIter</a> (SimdDouble lu, SimdDouble x)</td></tr>
<tr class="memdesc:gaa0f0ffc8730b377743e0b5433d4e2f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform one Newton-Raphson iteration to improve 1/x for SIMD double.  <a href="#gaa0f0ffc8730b377743e0b5433d4e2f1a">More...</a><br/></td></tr>
<tr class="separator:gaa0f0ffc8730b377743e0b5433d4e2f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga698c7785928f003a6f8f0218550ef3af"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga698c7785928f003a6f8f0218550ef3af">gmx::inv</a> (SimdDouble x)</td></tr>
<tr class="memdesc:ga698c7785928f003a6f8f0218550ef3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/x for SIMD double.  <a href="#ga698c7785928f003a6f8f0218550ef3af">More...</a><br/></td></tr>
<tr class="separator:ga698c7785928f003a6f8f0218550ef3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d5275903c74226798172bd46bac3e87"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga0d5275903c74226798172bd46bac3e87">gmx::operator/</a> (SimdDouble nom, SimdDouble denom)</td></tr>
<tr class="memdesc:ga0d5275903c74226798172bd46bac3e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division for SIMD doubles.  <a href="#ga0d5275903c74226798172bd46bac3e87">More...</a><br/></td></tr>
<tr class="separator:ga0d5275903c74226798172bd46bac3e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3342ee008526f40deb602eb1024ba895"><td class="memItemLeft" align="right" valign="top">static SimdDouble&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga3342ee008526f40deb602eb1024ba895">gmx::maskzInvsqrt</a> (SimdDouble x, SimdDBool m)</td></tr>
<tr class="memdesc:ga3342ee008526f40deb602eb1024ba895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for masked entries of SIMD double.  <a href="#ga3342ee008526f40deb602eb1024ba895">More...</a><br/></td></tr>
<tr class="separator:ga3342ee008526f40deb602eb1024ba895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91e427c6575308730c135fb8de51a7c9"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga91e427c6575308730c135fb8de51a7c9">gmx::maskzInv</a> (SimdDouble x, SimdDBool m)</td></tr>
<tr class="memdesc:ga91e427c6575308730c135fb8de51a7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/x for SIMD double, masked version.  <a href="#ga91e427c6575308730c135fb8de51a7c9">More...</a><br/></td></tr>
<tr class="separator:ga91e427c6575308730c135fb8de51a7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga784105c21023a67e981521b259481730"><td class="memTemplParams" colspan="2">template&lt;MathOptimization opt = MathOptimization::Safe&gt; </td></tr>
<tr class="memitem:ga784105c21023a67e981521b259481730"><td class="memTemplItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga784105c21023a67e981521b259481730">gmx::sqrt</a> (SimdDouble x)</td></tr>
<tr class="memdesc:ga784105c21023a67e981521b259481730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate sqrt(x) for SIMD doubles.  <a href="#ga784105c21023a67e981521b259481730">More...</a><br/></td></tr>
<tr class="separator:ga784105c21023a67e981521b259481730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b6148113de97d3d9e2c9340c72debae"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga2b6148113de97d3d9e2c9340c72debae">gmx::log</a> (SimdDouble x)</td></tr>
<tr class="memdesc:ga2b6148113de97d3d9e2c9340c72debae"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD double log(x). This is the natural logarithm.  <a href="#ga2b6148113de97d3d9e2c9340c72debae">More...</a><br/></td></tr>
<tr class="separator:ga2b6148113de97d3d9e2c9340c72debae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade7a25b3812d52c1f0c1392d2cc686ea"><td class="memTemplParams" colspan="2">template&lt;MathOptimization opt = MathOptimization::Safe&gt; </td></tr>
<tr class="memitem:gade7a25b3812d52c1f0c1392d2cc686ea"><td class="memTemplItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gade7a25b3812d52c1f0c1392d2cc686ea">gmx::exp2</a> (SimdDouble x)</td></tr>
<tr class="memdesc:gade7a25b3812d52c1f0c1392d2cc686ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD double 2^x.  <a href="#gade7a25b3812d52c1f0c1392d2cc686ea">More...</a><br/></td></tr>
<tr class="separator:gade7a25b3812d52c1f0c1392d2cc686ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98d13cb67fc6c5fefc32992673bf0637"><td class="memTemplParams" colspan="2">template&lt;MathOptimization opt = MathOptimization::Safe&gt; </td></tr>
<tr class="memitem:ga98d13cb67fc6c5fefc32992673bf0637"><td class="memTemplItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga98d13cb67fc6c5fefc32992673bf0637">gmx::exp</a> (SimdDouble x)</td></tr>
<tr class="memdesc:ga98d13cb67fc6c5fefc32992673bf0637"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD double exp(x).  <a href="#ga98d13cb67fc6c5fefc32992673bf0637">More...</a><br/></td></tr>
<tr class="separator:ga98d13cb67fc6c5fefc32992673bf0637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga900477ac8042bfd9d6c85a06e3f003c8"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga900477ac8042bfd9d6c85a06e3f003c8">gmx::erf</a> (SimdDouble x)</td></tr>
<tr class="memdesc:ga900477ac8042bfd9d6c85a06e3f003c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD double erf(x).  <a href="#ga900477ac8042bfd9d6c85a06e3f003c8">More...</a><br/></td></tr>
<tr class="separator:ga900477ac8042bfd9d6c85a06e3f003c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd11e43f0479bca8e5b9d58b73307ae6"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gabd11e43f0479bca8e5b9d58b73307ae6">gmx::erfc</a> (SimdDouble x)</td></tr>
<tr class="memdesc:gabd11e43f0479bca8e5b9d58b73307ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD double erfc(x).  <a href="#gabd11e43f0479bca8e5b9d58b73307ae6">More...</a><br/></td></tr>
<tr class="separator:gabd11e43f0479bca8e5b9d58b73307ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga532aa17b3c80780baf5c123eb64cf645"><td class="memItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga532aa17b3c80780baf5c123eb64cf645">gmx::sincos</a> (SimdDouble x, SimdDouble *sinval, SimdDouble *cosval)</td></tr>
<tr class="memdesc:ga532aa17b3c80780baf5c123eb64cf645"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD double sin &amp; cos.  <a href="#ga532aa17b3c80780baf5c123eb64cf645">More...</a><br/></td></tr>
<tr class="separator:ga532aa17b3c80780baf5c123eb64cf645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab860ef109b42bb7e0ce25bdc304e8492"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gab860ef109b42bb7e0ce25bdc304e8492">gmx::sin</a> (SimdDouble x)</td></tr>
<tr class="memdesc:gab860ef109b42bb7e0ce25bdc304e8492"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD double sin(x).  <a href="#gab860ef109b42bb7e0ce25bdc304e8492">More...</a><br/></td></tr>
<tr class="separator:gab860ef109b42bb7e0ce25bdc304e8492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb04efe2288b65a54c4e8fd5585f125"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga4fb04efe2288b65a54c4e8fd5585f125">gmx::cos</a> (SimdDouble x)</td></tr>
<tr class="memdesc:ga4fb04efe2288b65a54c4e8fd5585f125"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD double cos(x).  <a href="#ga4fb04efe2288b65a54c4e8fd5585f125">More...</a><br/></td></tr>
<tr class="separator:ga4fb04efe2288b65a54c4e8fd5585f125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f1b0a83035fb507f2827fb510fcf084"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga9f1b0a83035fb507f2827fb510fcf084">gmx::tan</a> (SimdDouble x)</td></tr>
<tr class="memdesc:ga9f1b0a83035fb507f2827fb510fcf084"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD double tan(x).  <a href="#ga9f1b0a83035fb507f2827fb510fcf084">More...</a><br/></td></tr>
<tr class="separator:ga9f1b0a83035fb507f2827fb510fcf084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc20a60ae6b0e838d65d127e944effbb"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gafc20a60ae6b0e838d65d127e944effbb">gmx::asin</a> (SimdDouble x)</td></tr>
<tr class="memdesc:gafc20a60ae6b0e838d65d127e944effbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD double asin(x).  <a href="#gafc20a60ae6b0e838d65d127e944effbb">More...</a><br/></td></tr>
<tr class="separator:gafc20a60ae6b0e838d65d127e944effbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5459281155e8be7fd6356c5e366acb0e"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga5459281155e8be7fd6356c5e366acb0e">gmx::acos</a> (SimdDouble x)</td></tr>
<tr class="memdesc:ga5459281155e8be7fd6356c5e366acb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD double acos(x).  <a href="#ga5459281155e8be7fd6356c5e366acb0e">More...</a><br/></td></tr>
<tr class="separator:ga5459281155e8be7fd6356c5e366acb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e327fdca86999b2716b5109621b1936"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga0e327fdca86999b2716b5109621b1936">gmx::atan</a> (SimdDouble x)</td></tr>
<tr class="memdesc:ga0e327fdca86999b2716b5109621b1936"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD double asin(x).  <a href="#ga0e327fdca86999b2716b5109621b1936">More...</a><br/></td></tr>
<tr class="separator:ga0e327fdca86999b2716b5109621b1936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3d1e53759871924024fc4bfa8cd7e41"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gae3d1e53759871924024fc4bfa8cd7e41">gmx::atan2</a> (SimdDouble y, SimdDouble x)</td></tr>
<tr class="memdesc:gae3d1e53759871924024fc4bfa8cd7e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD double atan2(y,x).  <a href="#gae3d1e53759871924024fc4bfa8cd7e41">More...</a><br/></td></tr>
<tr class="separator:gae3d1e53759871924024fc4bfa8cd7e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad35bd0d2751d6097b63b26b7077ad53c"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gad35bd0d2751d6097b63b26b7077ad53c">gmx::pmeForceCorrection</a> (SimdDouble z2)</td></tr>
<tr class="memdesc:gad35bd0d2751d6097b63b26b7077ad53c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the force correction due to PME analytically in SIMD double.  <a href="#gad35bd0d2751d6097b63b26b7077ad53c">More...</a><br/></td></tr>
<tr class="separator:gad35bd0d2751d6097b63b26b7077ad53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e52f9306e036285c0a9ac5f55565cc0"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga6e52f9306e036285c0a9ac5f55565cc0">gmx::pmePotentialCorrection</a> (SimdDouble z2)</td></tr>
<tr class="memdesc:ga6e52f9306e036285c0a9ac5f55565cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the potential correction due to PME analytically in SIMD double.  <a href="#ga6e52f9306e036285c0a9ac5f55565cc0">More...</a><br/></td></tr>
<tr class="separator:ga6e52f9306e036285c0a9ac5f55565cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SIMD math functions for double prec. data, single prec. accuracy</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpa48898c0f1f44106e4995c9fb12f9dd3"></a></p>
<dl class="section note"><dt>Note</dt><dd>In some cases we do not need full double accuracy of individual SIMD math functions, although the data is stored in double precision SIMD registers. This might be the case for special algorithms, or if the architecture does not support single precision. Since the full double precision evaluation of math functions typically require much more expensive polynomial approximations these functions implement the algorithms used in the single precision SIMD math functions, but they operate on double precision SIMD variables. </dd></dl>
</td></tr>
<tr class="memitem:ga539e3c6e2f58dbd5e59d444707237691"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga539e3c6e2f58dbd5e59d444707237691">gmx::invsqrtSingleAccuracy</a> (SimdDouble x)</td></tr>
<tr class="memdesc:ga539e3c6e2f58dbd5e59d444707237691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for SIMD double, but in single accuracy.  <a href="#ga539e3c6e2f58dbd5e59d444707237691">More...</a><br/></td></tr>
<tr class="separator:ga539e3c6e2f58dbd5e59d444707237691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19373a6a16b4e74441b86bdcabe1bbcb"><td class="memItemLeft" align="right" valign="top">static SimdDouble&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga19373a6a16b4e74441b86bdcabe1bbcb">gmx::maskzInvsqrtSingleAccuracy</a> (SimdDouble x, SimdDBool m)</td></tr>
<tr class="memdesc:ga19373a6a16b4e74441b86bdcabe1bbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">1/sqrt(x) for masked-in entries of SIMD double, but in single accuracy.  <a href="#ga19373a6a16b4e74441b86bdcabe1bbcb">More...</a><br/></td></tr>
<tr class="separator:ga19373a6a16b4e74441b86bdcabe1bbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cde0a4bdb349db5235f05fc93c0441d"><td class="memItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga0cde0a4bdb349db5235f05fc93c0441d">gmx::invsqrtPairSingleAccuracy</a> (SimdDouble x0, SimdDouble x1, SimdDouble *out0, SimdDouble *out1)</td></tr>
<tr class="memdesc:ga0cde0a4bdb349db5235f05fc93c0441d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for two SIMD doubles, but single accuracy.  <a href="#ga0cde0a4bdb349db5235f05fc93c0441d">More...</a><br/></td></tr>
<tr class="separator:ga0cde0a4bdb349db5235f05fc93c0441d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad500e0cd00f7c9a8b65448d3a428c57d"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gad500e0cd00f7c9a8b65448d3a428c57d">gmx::invSingleAccuracy</a> (SimdDouble x)</td></tr>
<tr class="memdesc:gad500e0cd00f7c9a8b65448d3a428c57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/x for SIMD double, but in single accuracy.  <a href="#gad500e0cd00f7c9a8b65448d3a428c57d">More...</a><br/></td></tr>
<tr class="separator:gad500e0cd00f7c9a8b65448d3a428c57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed815c342f2554cecb7045da5ba52e57"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaed815c342f2554cecb7045da5ba52e57">gmx::maskzInvSingleAccuracy</a> (SimdDouble x, SimdDBool m)</td></tr>
<tr class="memdesc:gaed815c342f2554cecb7045da5ba52e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">1/x for masked entries of SIMD double, single accuracy.  <a href="#gaed815c342f2554cecb7045da5ba52e57">More...</a><br/></td></tr>
<tr class="separator:gaed815c342f2554cecb7045da5ba52e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga645dad540cadbef1d60a831d41c46cfe"><td class="memTemplParams" colspan="2">template&lt;MathOptimization opt = MathOptimization::Safe&gt; </td></tr>
<tr class="memitem:ga645dad540cadbef1d60a831d41c46cfe"><td class="memTemplItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga645dad540cadbef1d60a831d41c46cfe">gmx::sqrtSingleAccuracy</a> (SimdDouble x)</td></tr>
<tr class="memdesc:ga645dad540cadbef1d60a831d41c46cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate sqrt(x) (correct for 0.0) for SIMD double, with single accuracy.  <a href="#ga645dad540cadbef1d60a831d41c46cfe">More...</a><br/></td></tr>
<tr class="separator:ga645dad540cadbef1d60a831d41c46cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29dcfc4f360ed173f66b26ad9ac3b28b"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga29dcfc4f360ed173f66b26ad9ac3b28b">gmx::logSingleAccuracy</a> (SimdDouble x)</td></tr>
<tr class="memdesc:ga29dcfc4f360ed173f66b26ad9ac3b28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD log(x). Double precision SIMD data, single accuracy.  <a href="#ga29dcfc4f360ed173f66b26ad9ac3b28b">More...</a><br/></td></tr>
<tr class="separator:ga29dcfc4f360ed173f66b26ad9ac3b28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67c6ce3061f04d7438eff1c4a124737d"><td class="memTemplParams" colspan="2">template&lt;MathOptimization opt = MathOptimization::Safe&gt; </td></tr>
<tr class="memitem:ga67c6ce3061f04d7438eff1c4a124737d"><td class="memTemplItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga67c6ce3061f04d7438eff1c4a124737d">gmx::exp2SingleAccuracy</a> (SimdDouble x)</td></tr>
<tr class="memdesc:ga67c6ce3061f04d7438eff1c4a124737d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD 2^x. Double precision SIMD, single accuracy.  <a href="#ga67c6ce3061f04d7438eff1c4a124737d">More...</a><br/></td></tr>
<tr class="separator:ga67c6ce3061f04d7438eff1c4a124737d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bc997f231867640d8030d2c8886a922"><td class="memTemplParams" colspan="2">template&lt;MathOptimization opt = MathOptimization::Safe&gt; </td></tr>
<tr class="memitem:ga9bc997f231867640d8030d2c8886a922"><td class="memTemplItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga9bc997f231867640d8030d2c8886a922">gmx::expSingleAccuracy</a> (SimdDouble x)</td></tr>
<tr class="memdesc:ga9bc997f231867640d8030d2c8886a922"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD exp(x). Double precision SIMD, single accuracy.  <a href="#ga9bc997f231867640d8030d2c8886a922">More...</a><br/></td></tr>
<tr class="separator:ga9bc997f231867640d8030d2c8886a922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6ce232cb0593b32dc9789e04679bc6c"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gac6ce232cb0593b32dc9789e04679bc6c">gmx::erfSingleAccuracy</a> (SimdDouble x)</td></tr>
<tr class="memdesc:gac6ce232cb0593b32dc9789e04679bc6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD erf(x). Double precision SIMD data, single accuracy.  <a href="#gac6ce232cb0593b32dc9789e04679bc6c">More...</a><br/></td></tr>
<tr class="separator:gac6ce232cb0593b32dc9789e04679bc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8d996acb25e6bdb2d08ca2b26bb19c3"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gae8d996acb25e6bdb2d08ca2b26bb19c3">gmx::erfcSingleAccuracy</a> (SimdDouble x)</td></tr>
<tr class="memdesc:gae8d996acb25e6bdb2d08ca2b26bb19c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD erfc(x). Double precision SIMD data, single accuracy.  <a href="#gae8d996acb25e6bdb2d08ca2b26bb19c3">More...</a><br/></td></tr>
<tr class="separator:gae8d996acb25e6bdb2d08ca2b26bb19c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80d8d17a5843dfa4126ce3d6672d2c5d"><td class="memItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga80d8d17a5843dfa4126ce3d6672d2c5d">gmx::sinCosSingleAccuracy</a> (SimdDouble x, SimdDouble *sinval, SimdDouble *cosval)</td></tr>
<tr class="memdesc:ga80d8d17a5843dfa4126ce3d6672d2c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD sin &amp; cos. Double precision SIMD data, single accuracy.  <a href="#ga80d8d17a5843dfa4126ce3d6672d2c5d">More...</a><br/></td></tr>
<tr class="separator:ga80d8d17a5843dfa4126ce3d6672d2c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga322afd1e05781ae2cd10ec6fdb1fb2be"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga322afd1e05781ae2cd10ec6fdb1fb2be">gmx::sinSingleAccuracy</a> (SimdDouble x)</td></tr>
<tr class="memdesc:ga322afd1e05781ae2cd10ec6fdb1fb2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD sin(x). Double precision SIMD data, single accuracy.  <a href="#ga322afd1e05781ae2cd10ec6fdb1fb2be">More...</a><br/></td></tr>
<tr class="separator:ga322afd1e05781ae2cd10ec6fdb1fb2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b867b3b628740d6f710a480626cffa8"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga1b867b3b628740d6f710a480626cffa8">gmx::cosSingleAccuracy</a> (SimdDouble x)</td></tr>
<tr class="memdesc:ga1b867b3b628740d6f710a480626cffa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD cos(x). Double precision SIMD data, single accuracy.  <a href="#ga1b867b3b628740d6f710a480626cffa8">More...</a><br/></td></tr>
<tr class="separator:ga1b867b3b628740d6f710a480626cffa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97094c3429db78b1a101aa994a69f162"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga97094c3429db78b1a101aa994a69f162">gmx::tanSingleAccuracy</a> (SimdDouble x)</td></tr>
<tr class="memdesc:ga97094c3429db78b1a101aa994a69f162"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD tan(x). Double precision SIMD data, single accuracy.  <a href="#ga97094c3429db78b1a101aa994a69f162">More...</a><br/></td></tr>
<tr class="separator:ga97094c3429db78b1a101aa994a69f162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e098546fed7424b9c449588ebb84252"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga7e098546fed7424b9c449588ebb84252">gmx::asinSingleAccuracy</a> (SimdDouble x)</td></tr>
<tr class="memdesc:ga7e098546fed7424b9c449588ebb84252"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD asin(x). Double precision SIMD data, single accuracy.  <a href="#ga7e098546fed7424b9c449588ebb84252">More...</a><br/></td></tr>
<tr class="separator:ga7e098546fed7424b9c449588ebb84252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73027d18d5366998dbf0af8c52f68b60"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga73027d18d5366998dbf0af8c52f68b60">gmx::acosSingleAccuracy</a> (SimdDouble x)</td></tr>
<tr class="memdesc:ga73027d18d5366998dbf0af8c52f68b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD acos(x). Double precision SIMD data, single accuracy.  <a href="#ga73027d18d5366998dbf0af8c52f68b60">More...</a><br/></td></tr>
<tr class="separator:ga73027d18d5366998dbf0af8c52f68b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39be2b2651b8a68340c2132becf1c372"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga39be2b2651b8a68340c2132becf1c372">gmx::atanSingleAccuracy</a> (SimdDouble x)</td></tr>
<tr class="memdesc:ga39be2b2651b8a68340c2132becf1c372"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD asin(x). Double precision SIMD data, single accuracy.  <a href="#ga39be2b2651b8a68340c2132becf1c372">More...</a><br/></td></tr>
<tr class="separator:ga39be2b2651b8a68340c2132becf1c372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga193d8e790944928be53940809d6f2385"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga193d8e790944928be53940809d6f2385">gmx::atan2SingleAccuracy</a> (SimdDouble y, SimdDouble x)</td></tr>
<tr class="memdesc:ga193d8e790944928be53940809d6f2385"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD atan2(y,x). Double precision SIMD data, single accuracy.  <a href="#ga193d8e790944928be53940809d6f2385">More...</a><br/></td></tr>
<tr class="separator:ga193d8e790944928be53940809d6f2385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c64f03842963e248fba796bead3c5ce"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga7c64f03842963e248fba796bead3c5ce">gmx::pmeForceCorrectionSingleAccuracy</a> (SimdDouble z2)</td></tr>
<tr class="memdesc:ga7c64f03842963e248fba796bead3c5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analytical PME force correction, double SIMD data, single accuracy.  <a href="#ga7c64f03842963e248fba796bead3c5ce">More...</a><br/></td></tr>
<tr class="separator:ga7c64f03842963e248fba796bead3c5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad079618800dfdfb943ca73f89f63d45e"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gad079618800dfdfb943ca73f89f63d45e">gmx::pmePotentialCorrectionSingleAccuracy</a> (SimdDouble z2)</td></tr>
<tr class="memdesc:gad079618800dfdfb943ca73f89f63d45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analytical PME potential correction, double SIMD data, single accuracy.  <a href="#gad079618800dfdfb943ca73f89f63d45e">More...</a><br/></td></tr>
<tr class="separator:gad079618800dfdfb943ca73f89f63d45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SIMD4 math functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp6c047f3236c68a61817ffe5256488c4b"></a></p>
<dl class="section note"><dt>Note</dt><dd>Only a subset of the math functions are implemented for SIMD4. </dd></dl>
</td></tr>
<tr class="memitem:ga4be9c1041c5ce806e1262c9469a4a625"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga4be9c1041c5ce806e1262c9469a4a625">gmx::rsqrtIter</a> (Simd4Float lu, Simd4Float x)</td></tr>
<tr class="memdesc:ga4be9c1041c5ce806e1262c9469a4a625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform one Newton-Raphson iteration to improve 1/sqrt(x) for SIMD4 float.  <a href="#ga4be9c1041c5ce806e1262c9469a4a625">More...</a><br/></td></tr>
<tr class="separator:ga4be9c1041c5ce806e1262c9469a4a625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8ed1f98091a17221318dfd97e52c916"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gab8ed1f98091a17221318dfd97e52c916">gmx::invsqrt</a> (Simd4Float x)</td></tr>
<tr class="memdesc:gab8ed1f98091a17221318dfd97e52c916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for SIMD4 float.  <a href="#gab8ed1f98091a17221318dfd97e52c916">More...</a><br/></td></tr>
<tr class="separator:gab8ed1f98091a17221318dfd97e52c916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b6db4a7ce63f7c3c6e7a0d3008dea6b"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga4b6db4a7ce63f7c3c6e7a0d3008dea6b">gmx::rsqrtIter</a> (Simd4Double lu, Simd4Double x)</td></tr>
<tr class="memdesc:ga4b6db4a7ce63f7c3c6e7a0d3008dea6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform one Newton-Raphson iteration to improve 1/sqrt(x) for SIMD4 double.  <a href="#ga4b6db4a7ce63f7c3c6e7a0d3008dea6b">More...</a><br/></td></tr>
<tr class="separator:ga4b6db4a7ce63f7c3c6e7a0d3008dea6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d84208bf91d57b70761d4c161f2f9de"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga9d84208bf91d57b70761d4c161f2f9de">gmx::invsqrt</a> (Simd4Double x)</td></tr>
<tr class="memdesc:ga9d84208bf91d57b70761d4c161f2f9de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for SIMD4 double.  <a href="#ga9d84208bf91d57b70761d4c161f2f9de">More...</a><br/></td></tr>
<tr class="separator:ga9d84208bf91d57b70761d4c161f2f9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b4da22bcb5cebd8721f180626d11fbf"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga0b4da22bcb5cebd8721f180626d11fbf">gmx::invsqrtSingleAccuracy</a> (Simd4Double x)</td></tr>
<tr class="memdesc:ga0b4da22bcb5cebd8721f180626d11fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for SIMD4 double, but in single accuracy.  <a href="#ga0b4da22bcb5cebd8721f180626d11fbf">More...</a><br/></td></tr>
<tr class="separator:ga0b4da22bcb5cebd8721f180626d11fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Simd4Double.xhtml">gmx::Simd4Double</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD4 double type.  <a href="classgmx_1_1Simd4Double.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Simd4DBool.xhtml">gmx::Simd4DBool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD4 variable type to use for logical comparisons on doubles.  <a href="classgmx_1_1Simd4DBool.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Simd4Float.xhtml">gmx::Simd4Float</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD4 float type.  <a href="classgmx_1_1Simd4Float.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1Simd4FBool.xhtml">gmx::Simd4FBool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD4 variable type to use for logical comparisons on floats.  <a href="classgmx_1_1Simd4FBool.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1SimdDouble.xhtml">gmx::SimdDouble</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double SIMD variable. Available if GMX_SIMD_HAVE_DOUBLE is 1.  <a href="classgmx_1_1SimdDouble.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1SimdDInt32.xhtml">gmx::SimdDInt32</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer SIMD variable type to use for conversions to/from double.  <a href="classgmx_1_1SimdDInt32.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1SimdDBool.xhtml">gmx::SimdDBool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean type for double SIMD data.  <a href="classgmx_1_1SimdDBool.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1SimdDIBool.xhtml">gmx::SimdDIBool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean type for integer datatypes corresponding to double SIMD.  <a href="classgmx_1_1SimdDIBool.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1SimdFloat.xhtml">gmx::SimdFloat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float SIMD variable. Available if GMX_SIMD_HAVE_FLOAT is 1.  <a href="classgmx_1_1SimdFloat.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1SimdFInt32.xhtml">gmx::SimdFInt32</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer SIMD variable type to use for conversions to/from float.  <a href="classgmx_1_1SimdFInt32.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1SimdFBool.xhtml">gmx::SimdFBool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean type for float SIMD data.  <a href="classgmx_1_1SimdFBool.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1SimdFIBool.xhtml">gmx::SimdFIBool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean type for integer datatypes corresponding to float SIMD.  <a href="classgmx_1_1SimdFIBool.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga725596b415f4bca94e71321b6845bed4"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:ga725596b415f4bca94e71321b6845bed4"><td class="memTemplItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga725596b415f4bca94e71321b6845bed4">gmx::gatherLoadTranspose</a> (const double *base, const std::int32_t offset[], SimdDouble *v0, SimdDouble *v1, SimdDouble *v2, SimdDouble *v3)</td></tr>
<tr class="memdesc:ga725596b415f4bca94e71321b6845bed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 4 consecutive double from each of GMX_SIMD_DOUBLE_WIDTH offsets, and transpose into 4 SIMD double variables.  <a href="#ga725596b415f4bca94e71321b6845bed4">More...</a><br/></td></tr>
<tr class="separator:ga725596b415f4bca94e71321b6845bed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1b51d9220213996033e5dce938c926f"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:gad1b51d9220213996033e5dce938c926f"><td class="memTemplItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gad1b51d9220213996033e5dce938c926f">gmx::gatherLoadTranspose</a> (const double *base, const std::int32_t offset[], SimdDouble *v0, SimdDouble *v1)</td></tr>
<tr class="memdesc:gad1b51d9220213996033e5dce938c926f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 2 consecutive double from each of GMX_SIMD_DOUBLE_WIDTH offsets, and transpose into 2 SIMD double variables.  <a href="#gad1b51d9220213996033e5dce938c926f">More...</a><br/></td></tr>
<tr class="separator:gad1b51d9220213996033e5dce938c926f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafc4e2f213c40bba66c83e6524445523"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:gaafc4e2f213c40bba66c83e6524445523"><td class="memTemplItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaafc4e2f213c40bba66c83e6524445523">gmx::gatherLoadUTranspose</a> (const double *base, const std::int32_t offset[], SimdDouble *v0, SimdDouble *v1, SimdDouble *v2)</td></tr>
<tr class="memdesc:gaafc4e2f213c40bba66c83e6524445523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 3 consecutive doubles from each of GMX_SIMD_DOUBLE_WIDTH offsets, and transpose into 3 SIMD double variables.  <a href="#gaafc4e2f213c40bba66c83e6524445523">More...</a><br/></td></tr>
<tr class="separator:gaafc4e2f213c40bba66c83e6524445523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa23e5431ddc22611d3304ac96c461cc5"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:gaa23e5431ddc22611d3304ac96c461cc5"><td class="memTemplItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaa23e5431ddc22611d3304ac96c461cc5">gmx::transposeScatterStoreU</a> (double *base, const std::int32_t offset[], SimdDouble v0, SimdDouble v1, SimdDouble v2)</td></tr>
<tr class="memdesc:gaa23e5431ddc22611d3304ac96c461cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose and store 3 SIMD doubles to 3 consecutive addresses at GMX_SIMD_DOUBLE_WIDTH offsets.  <a href="#gaa23e5431ddc22611d3304ac96c461cc5">More...</a><br/></td></tr>
<tr class="separator:gaa23e5431ddc22611d3304ac96c461cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecbb196e76a516c1e3672a8fa0df6f87"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:gaecbb196e76a516c1e3672a8fa0df6f87"><td class="memTemplItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaecbb196e76a516c1e3672a8fa0df6f87">gmx::transposeScatterIncrU</a> (double *base, const std::int32_t offset[], SimdDouble v0, SimdDouble v1, SimdDouble v2)</td></tr>
<tr class="memdesc:gaecbb196e76a516c1e3672a8fa0df6f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose and add 3 SIMD doubles to 3 consecutive addresses at GMX_SIMD_DOUBLE_WIDTH offsets.  <a href="#gaecbb196e76a516c1e3672a8fa0df6f87">More...</a><br/></td></tr>
<tr class="separator:gaecbb196e76a516c1e3672a8fa0df6f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15283d6034452bcbee9c5f7538d7b560"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:ga15283d6034452bcbee9c5f7538d7b560"><td class="memTemplItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga15283d6034452bcbee9c5f7538d7b560">gmx::transposeScatterDecrU</a> (double *base, const std::int32_t offset[], SimdDouble v0, SimdDouble v1, SimdDouble v2)</td></tr>
<tr class="memdesc:ga15283d6034452bcbee9c5f7538d7b560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose and subtract 3 SIMD doubles to 3 consecutive addresses at GMX_SIMD_DOUBLE_WIDTH offsets.  <a href="#ga15283d6034452bcbee9c5f7538d7b560">More...</a><br/></td></tr>
<tr class="separator:ga15283d6034452bcbee9c5f7538d7b560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8d730c26297155e1aa934c2bc91e750"><td class="memItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gad8d730c26297155e1aa934c2bc91e750">gmx::expandScalarsToTriplets</a> (SimdDouble scalar, SimdDouble *triplets0, SimdDouble *triplets1, SimdDouble *triplets2)</td></tr>
<tr class="memdesc:gad8d730c26297155e1aa934c2bc91e750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand each element of double SIMD variable into three identical consecutive elements in three SIMD outputs.  <a href="#gad8d730c26297155e1aa934c2bc91e750">More...</a><br/></td></tr>
<tr class="separator:gad8d730c26297155e1aa934c2bc91e750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1008329474744f6987edf28c4124ac24"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:ga1008329474744f6987edf28c4124ac24"><td class="memTemplItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga1008329474744f6987edf28c4124ac24">gmx::gatherLoadBySimdIntTranspose</a> (const double *base, SimdDInt32 offset, SimdDouble *v0, SimdDouble *v1, SimdDouble *v2, SimdDouble *v3)</td></tr>
<tr class="memdesc:ga1008329474744f6987edf28c4124ac24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 4 consecutive doubles from each of GMX_SIMD_DOUBLE_WIDTH offsets specified by a SIMD integer, transpose into 4 SIMD double variables.  <a href="#ga1008329474744f6987edf28c4124ac24">More...</a><br/></td></tr>
<tr class="separator:ga1008329474744f6987edf28c4124ac24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad15c3a27898a9f9dbb2963dee1a7cacf"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:gad15c3a27898a9f9dbb2963dee1a7cacf"><td class="memTemplItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gad15c3a27898a9f9dbb2963dee1a7cacf">gmx::gatherLoadUBySimdIntTranspose</a> (const double *base, SimdDInt32 offset, SimdDouble *v0, SimdDouble *v1)</td></tr>
<tr class="memdesc:gad15c3a27898a9f9dbb2963dee1a7cacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 2 consecutive doubles from each of GMX_SIMD_DOUBLE_WIDTH offsets (unaligned) specified by SIMD integer, transpose into 2 SIMD doubles.  <a href="#gad15c3a27898a9f9dbb2963dee1a7cacf">More...</a><br/></td></tr>
<tr class="separator:gad15c3a27898a9f9dbb2963dee1a7cacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11385272a2b5123ca3aa3e5696e55dbc"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:ga11385272a2b5123ca3aa3e5696e55dbc"><td class="memTemplItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga11385272a2b5123ca3aa3e5696e55dbc">gmx::gatherLoadBySimdIntTranspose</a> (const double *base, SimdDInt32 offset, SimdDouble *v0, SimdDouble *v1)</td></tr>
<tr class="memdesc:ga11385272a2b5123ca3aa3e5696e55dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 2 consecutive doubles from each of GMX_SIMD_DOUBLE_WIDTH offsets specified by a SIMD integer, transpose into 2 SIMD double variables.  <a href="#ga11385272a2b5123ca3aa3e5696e55dbc">More...</a><br/></td></tr>
<tr class="separator:ga11385272a2b5123ca3aa3e5696e55dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace1c53e05ba045977e06eb98778c0123"><td class="memItemLeft" align="right" valign="top">static double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gace1c53e05ba045977e06eb98778c0123">gmx::reduceIncr4ReturnSum</a> (double *m, SimdDouble v0, SimdDouble v1, SimdDouble v2, SimdDouble v3)</td></tr>
<tr class="memdesc:gace1c53e05ba045977e06eb98778c0123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce each of four SIMD doubles, add those values to four consecutive doubles in memory, return sum.  <a href="#gace1c53e05ba045977e06eb98778c0123">More...</a><br/></td></tr>
<tr class="separator:gace1c53e05ba045977e06eb98778c0123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f9f9c71226ae1d2f0065dd66e1027f0"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:ga0f9f9c71226ae1d2f0065dd66e1027f0"><td class="memTemplItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga0f9f9c71226ae1d2f0065dd66e1027f0">gmx::gatherLoadTranspose</a> (const float *base, const std::int32_t offset[], SimdFloat *v0, SimdFloat *v1, SimdFloat *v2, SimdFloat *v3)</td></tr>
<tr class="memdesc:ga0f9f9c71226ae1d2f0065dd66e1027f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 4 consecutive floats from each of GMX_SIMD_FLOAT_WIDTH offsets, and transpose into 4 SIMD float variables.  <a href="#ga0f9f9c71226ae1d2f0065dd66e1027f0">More...</a><br/></td></tr>
<tr class="separator:ga0f9f9c71226ae1d2f0065dd66e1027f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6823a0b3cbc43eee3918b137d2b18384"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:ga6823a0b3cbc43eee3918b137d2b18384"><td class="memTemplItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga6823a0b3cbc43eee3918b137d2b18384">gmx::gatherLoadTranspose</a> (const float *base, const std::int32_t offset[], SimdFloat *v0, SimdFloat *v1)</td></tr>
<tr class="memdesc:ga6823a0b3cbc43eee3918b137d2b18384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 2 consecutive floats from each of GMX_SIMD_FLOAT_WIDTH offsets, and transpose into 2 SIMD float variables.  <a href="#ga6823a0b3cbc43eee3918b137d2b18384">More...</a><br/></td></tr>
<tr class="separator:ga6823a0b3cbc43eee3918b137d2b18384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5581add75787fa1304acdac5af0ad7d"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:gaa5581add75787fa1304acdac5af0ad7d"><td class="memTemplItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaa5581add75787fa1304acdac5af0ad7d">gmx::gatherLoadUTranspose</a> (const float *base, const std::int32_t offset[], SimdFloat *v0, SimdFloat *v1, SimdFloat *v2)</td></tr>
<tr class="memdesc:gaa5581add75787fa1304acdac5af0ad7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 3 consecutive floats from each of GMX_SIMD_FLOAT_WIDTH offsets, and transpose into 3 SIMD float variables.  <a href="#gaa5581add75787fa1304acdac5af0ad7d">More...</a><br/></td></tr>
<tr class="separator:gaa5581add75787fa1304acdac5af0ad7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba67dbea2a790730dfa78999209959b2"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:gaba67dbea2a790730dfa78999209959b2"><td class="memTemplItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaba67dbea2a790730dfa78999209959b2">gmx::transposeScatterStoreU</a> (float *base, const std::int32_t offset[], SimdFloat v0, SimdFloat v1, SimdFloat v2)</td></tr>
<tr class="memdesc:gaba67dbea2a790730dfa78999209959b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose and store 3 SIMD floats to 3 consecutive addresses at GMX_SIMD_FLOAT_WIDTH offsets.  <a href="#gaba67dbea2a790730dfa78999209959b2">More...</a><br/></td></tr>
<tr class="separator:gaba67dbea2a790730dfa78999209959b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac36c2fd8a466fb309ba9ae1dbf8dffbd"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:gac36c2fd8a466fb309ba9ae1dbf8dffbd"><td class="memTemplItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gac36c2fd8a466fb309ba9ae1dbf8dffbd">gmx::transposeScatterIncrU</a> (float *base, const std::int32_t offset[], SimdFloat v0, SimdFloat v1, SimdFloat v2)</td></tr>
<tr class="memdesc:gac36c2fd8a466fb309ba9ae1dbf8dffbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose and add 3 SIMD floats to 3 consecutive addresses at GMX_SIMD_FLOAT_WIDTH offsets.  <a href="#gac36c2fd8a466fb309ba9ae1dbf8dffbd">More...</a><br/></td></tr>
<tr class="separator:gac36c2fd8a466fb309ba9ae1dbf8dffbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6889b6665cbfc5fa0bce09fe5db5e49c"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:ga6889b6665cbfc5fa0bce09fe5db5e49c"><td class="memTemplItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga6889b6665cbfc5fa0bce09fe5db5e49c">gmx::transposeScatterDecrU</a> (float *base, const std::int32_t offset[], SimdFloat v0, SimdFloat v1, SimdFloat v2)</td></tr>
<tr class="memdesc:ga6889b6665cbfc5fa0bce09fe5db5e49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose and subtract 3 SIMD floats to 3 consecutive addresses at GMX_SIMD_FLOAT_WIDTH offsets.  <a href="#ga6889b6665cbfc5fa0bce09fe5db5e49c">More...</a><br/></td></tr>
<tr class="separator:ga6889b6665cbfc5fa0bce09fe5db5e49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82af54acc2b9eae6e58b646b5022aef5"><td class="memItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga82af54acc2b9eae6e58b646b5022aef5">gmx::expandScalarsToTriplets</a> (SimdFloat scalar, SimdFloat *triplets0, SimdFloat *triplets1, SimdFloat *triplets2)</td></tr>
<tr class="memdesc:ga82af54acc2b9eae6e58b646b5022aef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand each element of float SIMD variable into three identical consecutive elements in three SIMD outputs.  <a href="#ga82af54acc2b9eae6e58b646b5022aef5">More...</a><br/></td></tr>
<tr class="separator:ga82af54acc2b9eae6e58b646b5022aef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7ba60b7340036a984888bbca43616e4"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:gac7ba60b7340036a984888bbca43616e4"><td class="memTemplItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gac7ba60b7340036a984888bbca43616e4">gmx::gatherLoadBySimdIntTranspose</a> (const float *base, SimdFInt32 offset, SimdFloat *v0, SimdFloat *v1, SimdFloat *v2, SimdFloat *v3)</td></tr>
<tr class="memdesc:gac7ba60b7340036a984888bbca43616e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 4 consecutive floats from each of GMX_SIMD_FLOAT_WIDTH offsets specified by a SIMD integer, transpose into 4 SIMD float variables.  <a href="#gac7ba60b7340036a984888bbca43616e4">More...</a><br/></td></tr>
<tr class="separator:gac7ba60b7340036a984888bbca43616e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b26c79db832542ab73a692f7db941c2"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:ga4b26c79db832542ab73a692f7db941c2"><td class="memTemplItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga4b26c79db832542ab73a692f7db941c2">gmx::gatherLoadUBySimdIntTranspose</a> (const float *base, SimdFInt32 offset, SimdFloat *v0, SimdFloat *v1)</td></tr>
<tr class="memdesc:ga4b26c79db832542ab73a692f7db941c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 2 consecutive floats from each of GMX_SIMD_FLOAT_WIDTH offsets (unaligned) specified by SIMD integer, transpose into 2 SIMD floats.  <a href="#ga4b26c79db832542ab73a692f7db941c2">More...</a><br/></td></tr>
<tr class="separator:ga4b26c79db832542ab73a692f7db941c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98bde531b096434095b228308e7a3025"><td class="memTemplParams" colspan="2">template&lt;int align&gt; </td></tr>
<tr class="memitem:ga98bde531b096434095b228308e7a3025"><td class="memTemplItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga98bde531b096434095b228308e7a3025">gmx::gatherLoadBySimdIntTranspose</a> (const float *base, SimdFInt32 offset, SimdFloat *v0, SimdFloat *v1)</td></tr>
<tr class="memdesc:ga98bde531b096434095b228308e7a3025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 2 consecutive floats from each of GMX_SIMD_FLOAT_WIDTH offsets specified by a SIMD integer, transpose into 2 SIMD float variables.  <a href="#ga98bde531b096434095b228308e7a3025">More...</a><br/></td></tr>
<tr class="separator:ga98bde531b096434095b228308e7a3025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e64aefa14afa2f473c4db52e82d4a99"><td class="memItemLeft" align="right" valign="top">static float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga1e64aefa14afa2f473c4db52e82d4a99">gmx::reduceIncr4ReturnSum</a> (float *m, SimdFloat v0, SimdFloat v1, SimdFloat v2, SimdFloat v3)</td></tr>
<tr class="memdesc:ga1e64aefa14afa2f473c4db52e82d4a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce each of four SIMD floats, add those values to four consecutive floats in memory, return sum.  <a href="#ga1e64aefa14afa2f473c4db52e82d4a99">More...</a><br/></td></tr>
<tr class="separator:ga1e64aefa14afa2f473c4db52e82d4a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e9692244890665c6dc8f81fc3536f38"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga8e9692244890665c6dc8f81fc3536f38">gmx::invsqrtSingleAccuracy</a> (SimdFloat x)</td></tr>
<tr class="memdesc:ga8e9692244890665c6dc8f81fc3536f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for SIMD float, only targeting single accuracy.  <a href="#ga8e9692244890665c6dc8f81fc3536f38">More...</a><br/></td></tr>
<tr class="separator:ga8e9692244890665c6dc8f81fc3536f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e6086a4db51ceeeb8fe18e8884248f4"><td class="memItemLeft" align="right" valign="top">static SimdFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga7e6086a4db51ceeeb8fe18e8884248f4">gmx::maskzInvsqrtSingleAccuracy</a> (SimdFloat x, SimdFBool m)</td></tr>
<tr class="memdesc:ga7e6086a4db51ceeeb8fe18e8884248f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for masked SIMD floats, only targeting single accuracy.  <a href="#ga7e6086a4db51ceeeb8fe18e8884248f4">More...</a><br/></td></tr>
<tr class="separator:ga7e6086a4db51ceeeb8fe18e8884248f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3685e3466dd242fee652e51ff27decc7"><td class="memItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga3685e3466dd242fee652e51ff27decc7">gmx::invsqrtPairSingleAccuracy</a> (SimdFloat x0, SimdFloat x1, SimdFloat *out0, SimdFloat *out1)</td></tr>
<tr class="memdesc:ga3685e3466dd242fee652e51ff27decc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for two SIMD floats, only targeting single accuracy.  <a href="#ga3685e3466dd242fee652e51ff27decc7">More...</a><br/></td></tr>
<tr class="separator:ga3685e3466dd242fee652e51ff27decc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8db3b7c11cb80b5baca2cd42463e5c8e"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga8db3b7c11cb80b5baca2cd42463e5c8e">gmx::invSingleAccuracy</a> (SimdFloat x)</td></tr>
<tr class="memdesc:ga8db3b7c11cb80b5baca2cd42463e5c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/x for SIMD float, only targeting single accuracy.  <a href="#ga8db3b7c11cb80b5baca2cd42463e5c8e">More...</a><br/></td></tr>
<tr class="separator:ga8db3b7c11cb80b5baca2cd42463e5c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6704608858869fb062f53fcc40d7642"><td class="memItemLeft" align="right" valign="top">static SimdFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gac6704608858869fb062f53fcc40d7642">gmx::maskzInvSingleAccuracy</a> (SimdFloat x, SimdFBool m)</td></tr>
<tr class="memdesc:gac6704608858869fb062f53fcc40d7642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/x for masked SIMD floats, only targeting single accuracy.  <a href="#gac6704608858869fb062f53fcc40d7642">More...</a><br/></td></tr>
<tr class="separator:gac6704608858869fb062f53fcc40d7642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f7d261e770760618221865c64cc4e4c"><td class="memTemplParams" colspan="2">template&lt;MathOptimization opt = MathOptimization::Safe&gt; </td></tr>
<tr class="memitem:ga3f7d261e770760618221865c64cc4e4c"><td class="memTemplItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga3f7d261e770760618221865c64cc4e4c">gmx::sqrtSingleAccuracy</a> (SimdFloat x)</td></tr>
<tr class="memdesc:ga3f7d261e770760618221865c64cc4e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate sqrt(x) for SIMD float, always targeting single accuracy.  <a href="#ga3f7d261e770760618221865c64cc4e4c">More...</a><br/></td></tr>
<tr class="separator:ga3f7d261e770760618221865c64cc4e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f81e3b80f7edc6e4f2722a6ee94a5de"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga6f81e3b80f7edc6e4f2722a6ee94a5de">gmx::logSingleAccuracy</a> (SimdFloat x)</td></tr>
<tr class="memdesc:ga6f81e3b80f7edc6e4f2722a6ee94a5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float log(x), only targeting single accuracy. This is the natural logarithm.  <a href="#ga6f81e3b80f7edc6e4f2722a6ee94a5de">More...</a><br/></td></tr>
<tr class="separator:ga6f81e3b80f7edc6e4f2722a6ee94a5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61a99b57e09349d83ddab13dd7e8ecb7"><td class="memTemplParams" colspan="2">template&lt;MathOptimization opt = MathOptimization::Safe&gt; </td></tr>
<tr class="memitem:ga61a99b57e09349d83ddab13dd7e8ecb7"><td class="memTemplItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga61a99b57e09349d83ddab13dd7e8ecb7">gmx::exp2SingleAccuracy</a> (SimdFloat x)</td></tr>
<tr class="memdesc:ga61a99b57e09349d83ddab13dd7e8ecb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float 2^x, only targeting single accuracy.  <a href="#ga61a99b57e09349d83ddab13dd7e8ecb7">More...</a><br/></td></tr>
<tr class="separator:ga61a99b57e09349d83ddab13dd7e8ecb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43240f3ca7edd0885d809b68d04664cf"><td class="memTemplParams" colspan="2">template&lt;MathOptimization opt = MathOptimization::Safe&gt; </td></tr>
<tr class="memitem:ga43240f3ca7edd0885d809b68d04664cf"><td class="memTemplItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga43240f3ca7edd0885d809b68d04664cf">gmx::expSingleAccuracy</a> (SimdFloat x)</td></tr>
<tr class="memdesc:ga43240f3ca7edd0885d809b68d04664cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float e^x, only targeting single accuracy.  <a href="#ga43240f3ca7edd0885d809b68d04664cf">More...</a><br/></td></tr>
<tr class="separator:ga43240f3ca7edd0885d809b68d04664cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b00659cd28d0255ee51fcfd9693209f"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga6b00659cd28d0255ee51fcfd9693209f">gmx::erfSingleAccuracy</a> (SimdFloat x)</td></tr>
<tr class="memdesc:ga6b00659cd28d0255ee51fcfd9693209f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float erf(x), only targeting single accuracy.  <a href="#ga6b00659cd28d0255ee51fcfd9693209f">More...</a><br/></td></tr>
<tr class="separator:ga6b00659cd28d0255ee51fcfd9693209f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga606009ab68825981a67be586f77fb38e"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga606009ab68825981a67be586f77fb38e">gmx::erfcSingleAccuracy</a> (SimdFloat x)</td></tr>
<tr class="memdesc:ga606009ab68825981a67be586f77fb38e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float erfc(x), only targeting single accuracy.  <a href="#ga606009ab68825981a67be586f77fb38e">More...</a><br/></td></tr>
<tr class="separator:ga606009ab68825981a67be586f77fb38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6afcbeed45441fb9624fece5906b8a17"><td class="memItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga6afcbeed45441fb9624fece5906b8a17">gmx::sinCosSingleAccuracy</a> (SimdFloat x, SimdFloat *sinval, SimdFloat *cosval)</td></tr>
<tr class="memdesc:ga6afcbeed45441fb9624fece5906b8a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float sin &amp; cos, only targeting single accuracy.  <a href="#ga6afcbeed45441fb9624fece5906b8a17">More...</a><br/></td></tr>
<tr class="separator:ga6afcbeed45441fb9624fece5906b8a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ba00dcc0a9e1342d1af6952e0d2e1e7"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga0ba00dcc0a9e1342d1af6952e0d2e1e7">gmx::sinSingleAccuracy</a> (SimdFloat x)</td></tr>
<tr class="memdesc:ga0ba00dcc0a9e1342d1af6952e0d2e1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float sin(x), only targeting single accuracy.  <a href="#ga0ba00dcc0a9e1342d1af6952e0d2e1e7">More...</a><br/></td></tr>
<tr class="separator:ga0ba00dcc0a9e1342d1af6952e0d2e1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1ecd6647f33b8bd12c43a3f3de95fb3"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaa1ecd6647f33b8bd12c43a3f3de95fb3">gmx::cosSingleAccuracy</a> (SimdFloat x)</td></tr>
<tr class="memdesc:gaa1ecd6647f33b8bd12c43a3f3de95fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float cos(x), only targeting single accuracy.  <a href="#gaa1ecd6647f33b8bd12c43a3f3de95fb3">More...</a><br/></td></tr>
<tr class="separator:gaa1ecd6647f33b8bd12c43a3f3de95fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a534183c1fe54e0eccabbff0000990b"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga6a534183c1fe54e0eccabbff0000990b">gmx::tanSingleAccuracy</a> (SimdFloat x)</td></tr>
<tr class="memdesc:ga6a534183c1fe54e0eccabbff0000990b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float tan(x), only targeting single accuracy.  <a href="#ga6a534183c1fe54e0eccabbff0000990b">More...</a><br/></td></tr>
<tr class="separator:ga6a534183c1fe54e0eccabbff0000990b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50ad685f412725bacde7687e43bab092"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga50ad685f412725bacde7687e43bab092">gmx::asinSingleAccuracy</a> (SimdFloat x)</td></tr>
<tr class="memdesc:ga50ad685f412725bacde7687e43bab092"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float asin(x), only targeting single accuracy.  <a href="#ga50ad685f412725bacde7687e43bab092">More...</a><br/></td></tr>
<tr class="separator:ga50ad685f412725bacde7687e43bab092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79f0bb956500fceaff7db7c496cb8dde"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga79f0bb956500fceaff7db7c496cb8dde">gmx::acosSingleAccuracy</a> (SimdFloat x)</td></tr>
<tr class="memdesc:ga79f0bb956500fceaff7db7c496cb8dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float acos(x), only targeting single accuracy.  <a href="#ga79f0bb956500fceaff7db7c496cb8dde">More...</a><br/></td></tr>
<tr class="separator:ga79f0bb956500fceaff7db7c496cb8dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94615aced90295d0c008dbe576bfb535"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga94615aced90295d0c008dbe576bfb535">gmx::atanSingleAccuracy</a> (SimdFloat x)</td></tr>
<tr class="memdesc:ga94615aced90295d0c008dbe576bfb535"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float atan(x), only targeting single accuracy.  <a href="#ga94615aced90295d0c008dbe576bfb535">More...</a><br/></td></tr>
<tr class="separator:ga94615aced90295d0c008dbe576bfb535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73a666e50ed9883d77a2664cd9f9768c"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga73a666e50ed9883d77a2664cd9f9768c">gmx::atan2SingleAccuracy</a> (SimdFloat y, SimdFloat x)</td></tr>
<tr class="memdesc:ga73a666e50ed9883d77a2664cd9f9768c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float atan2(y,x), only targeting single accuracy.  <a href="#ga73a666e50ed9883d77a2664cd9f9768c">More...</a><br/></td></tr>
<tr class="separator:ga73a666e50ed9883d77a2664cd9f9768c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50c70d6df3435d9235cdf34589f9225c"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga50c70d6df3435d9235cdf34589f9225c">gmx::pmeForceCorrectionSingleAccuracy</a> (SimdFloat z2)</td></tr>
<tr class="memdesc:ga50c70d6df3435d9235cdf34589f9225c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD Analytic PME force correction, only targeting single accuracy.  <a href="#ga50c70d6df3435d9235cdf34589f9225c">More...</a><br/></td></tr>
<tr class="separator:ga50c70d6df3435d9235cdf34589f9225c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf555c7f9fb09586e8c809283b8210ed0"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gaf555c7f9fb09586e8c809283b8210ed0">gmx::pmePotentialCorrectionSingleAccuracy</a> (SimdFloat z2)</td></tr>
<tr class="memdesc:gaf555c7f9fb09586e8c809283b8210ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD Analytic PME potential correction, only targeting single accuracy.  <a href="#gaf555c7f9fb09586e8c809283b8210ed0">More...</a><br/></td></tr>
<tr class="separator:gaf555c7f9fb09586e8c809283b8210ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63a4c301efefb218bd1256e877610c1e"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga63a4c301efefb218bd1256e877610c1e">gmx::invsqrtSingleAccuracy</a> (Simd4Float x)</td></tr>
<tr class="memdesc:ga63a4c301efefb218bd1256e877610c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 1/sqrt(x) for SIMD4 float, only targeting single accuracy.  <a href="#ga63a4c301efefb218bd1256e877610c1e">More...</a><br/></td></tr>
<tr class="separator:ga63a4c301efefb218bd1256e877610c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0087673fec98bdc89b553f7f349e22d2"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga0087673fec98bdc89b553f7f349e22d2">gmx::iprod</a> (SimdFloat ax, SimdFloat ay, SimdFloat az, SimdFloat bx, SimdFloat by, SimdFloat bz)</td></tr>
<tr class="memdesc:ga0087673fec98bdc89b553f7f349e22d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float inner product of multiple float vectors.  <a href="#ga0087673fec98bdc89b553f7f349e22d2">More...</a><br/></td></tr>
<tr class="separator:ga0087673fec98bdc89b553f7f349e22d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86f01f74a7ab4156ec123146fd0b7de7"><td class="memItemLeft" align="right" valign="top">static SimdFloat gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga86f01f74a7ab4156ec123146fd0b7de7">gmx::norm2</a> (SimdFloat ax, SimdFloat ay, SimdFloat az)</td></tr>
<tr class="memdesc:ga86f01f74a7ab4156ec123146fd0b7de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float norm squared of multiple vectors.  <a href="#ga86f01f74a7ab4156ec123146fd0b7de7">More...</a><br/></td></tr>
<tr class="separator:ga86f01f74a7ab4156ec123146fd0b7de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54124af0ff118d3f171b0eef07105c76"><td class="memItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga54124af0ff118d3f171b0eef07105c76">gmx::cprod</a> (SimdFloat ax, SimdFloat ay, SimdFloat az, SimdFloat bx, SimdFloat by, SimdFloat bz, SimdFloat *cx, SimdFloat *cy, SimdFloat *cz)</td></tr>
<tr class="memdesc:ga54124af0ff118d3f171b0eef07105c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD float cross-product of multiple vectors.  <a href="#ga54124af0ff118d3f171b0eef07105c76">More...</a><br/></td></tr>
<tr class="separator:ga54124af0ff118d3f171b0eef07105c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc26031cf2fbf6cb1cee4e38d4cf6e3b"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gacc26031cf2fbf6cb1cee4e38d4cf6e3b">gmx::iprod</a> (SimdDouble ax, SimdDouble ay, SimdDouble az, SimdDouble bx, SimdDouble by, SimdDouble bz)</td></tr>
<tr class="memdesc:gacc26031cf2fbf6cb1cee4e38d4cf6e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD double inner product of multiple double vectors.  <a href="#gacc26031cf2fbf6cb1cee4e38d4cf6e3b">More...</a><br/></td></tr>
<tr class="separator:gacc26031cf2fbf6cb1cee4e38d4cf6e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga689e3ff037f04bcf9d3c3bfc896d50f6"><td class="memItemLeft" align="right" valign="top">static SimdDouble gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga689e3ff037f04bcf9d3c3bfc896d50f6">gmx::norm2</a> (SimdDouble ax, SimdDouble ay, SimdDouble az)</td></tr>
<tr class="memdesc:ga689e3ff037f04bcf9d3c3bfc896d50f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD double norm squared of multiple vectors.  <a href="#ga689e3ff037f04bcf9d3c3bfc896d50f6">More...</a><br/></td></tr>
<tr class="separator:ga689e3ff037f04bcf9d3c3bfc896d50f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bda1e7f61ac88be5176195e3676a6d4"><td class="memItemLeft" align="right" valign="top">static void gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga5bda1e7f61ac88be5176195e3676a6d4">gmx::cprod</a> (SimdDouble ax, SimdDouble ay, SimdDouble az, SimdDouble bx, SimdDouble by, SimdDouble bz, SimdDouble *cx, SimdDouble *cy, SimdDouble *cz)</td></tr>
<tr class="memdesc:ga5bda1e7f61ac88be5176195e3676a6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD double cross-product of multiple vectors.  <a href="#ga5bda1e7f61ac88be5176195e3676a6d4">More...</a><br/></td></tr>
<tr class="separator:ga5bda1e7f61ac88be5176195e3676a6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aaaf08ce309b237501775f56590ee53"><td class="memItemLeft" align="right" valign="top">static Simd4Float gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga5aaaf08ce309b237501775f56590ee53">gmx::norm2</a> (Simd4Float ax, Simd4Float ay, Simd4Float az)</td></tr>
<tr class="memdesc:ga5aaaf08ce309b237501775f56590ee53"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD4 float norm squared of multiple vectors.  <a href="#ga5aaaf08ce309b237501775f56590ee53">More...</a><br/></td></tr>
<tr class="separator:ga5aaaf08ce309b237501775f56590ee53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae78d49a68930c6290f4fadd7f02b77e4"><td class="memItemLeft" align="right" valign="top">static Simd4Double gmx_simdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gae78d49a68930c6290f4fadd7f02b77e4">gmx::norm2</a> (Simd4Double ax, Simd4Double ay, Simd4Double az)</td></tr>
<tr class="memdesc:gae78d49a68930c6290f4fadd7f02b77e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD4 double norm squared of multiple vectors.  <a href="#gae78d49a68930c6290f4fadd7f02b77e4">More...</a><br/></td></tr>
<tr class="separator:gae78d49a68930c6290f4fadd7f02b77e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga9237b6439778ed0fdfd9008a78c25f3c"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#ga9237b6439778ed0fdfd9008a78c25f3c">gmx::c_simdBestPairAlignmentDouble</a> = 2</td></tr>
<tr class="memdesc:ga9237b6439778ed0fdfd9008a78c25f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Best alignment to use for aligned pairs of double data.  <a href="#ga9237b6439778ed0fdfd9008a78c25f3c">More...</a><br/></td></tr>
<tr class="separator:ga9237b6439778ed0fdfd9008a78c25f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc4ad17022538e3d670e55694e55ccc2"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__simd.xhtml#gacc4ad17022538e3d670e55694e55ccc2">gmx::c_simdBestPairAlignmentFloat</a> = 2</td></tr>
<tr class="memdesc:gacc4ad17022538e3d670e55694e55ccc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Best alignment to use for aligned pairs of float data.  <a href="#gacc4ad17022538e3d670e55694e55ccc2">More...</a><br/></td></tr>
<tr class="separator:gacc4ad17022538e3d670e55694e55ccc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="dirs"></a>
Directories</h2></td></tr>
<tr class="memitem:dir_32d26fbaf0abd8bf4548e7cba9bbcf59"><td class="memItemLeft" align="right" valign="top">directory&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dir_32d26fbaf0abd8bf4548e7cba9bbcf59.xhtml">simd</a></td></tr>
<tr class="memdesc:dir_32d26fbaf0abd8bf4548e7cba9bbcf59"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__module__simd.xhtml">SIMD intrinsics interface (simd)</a> <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dir_e6a8df90faa71fbc1a1982c7ab1ea2c4"><td class="memItemLeft" align="right" valign="top">directory&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dir_e6a8df90faa71fbc1a1982c7ab1ea2c4.xhtml">tests</a></td></tr>
<tr class="memdesc:dir_e6a8df90faa71fbc1a1982c7ab1ea2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit tests for <a class="el" href="group__module__simd.xhtml">SIMD intrinsics interface (simd)</a>. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:impl__reference_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="impl__reference_8h.xhtml">impl_reference.h</a></td></tr>
<tr class="memdesc:impl__reference_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference SIMD implementation, including SIMD documentation. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:impl__reference__definitions_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="impl__reference__definitions_8h.xhtml">impl_reference_definitions.h</a></td></tr>
<tr class="memdesc:impl__reference__definitions_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference SIMD implementation, including SIMD documentation. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:impl__reference__general_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="impl__reference__general_8h.xhtml">impl_reference_general.h</a></td></tr>
<tr class="memdesc:impl__reference__general_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference SIMD implementation, general utility functions. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:impl__reference__simd4__double_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="impl__reference__simd4__double_8h.xhtml">impl_reference_simd4_double.h</a></td></tr>
<tr class="memdesc:impl__reference__simd4__double_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference implementation, SIMD4 single precision. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:impl__reference__simd4__float_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="impl__reference__simd4__float_8h.xhtml">impl_reference_simd4_float.h</a></td></tr>
<tr class="memdesc:impl__reference__simd4__float_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference implementation, SIMD4 single precision. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:impl__reference__simd__double_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="impl__reference__simd__double_8h.xhtml">impl_reference_simd_double.h</a></td></tr>
<tr class="memdesc:impl__reference__simd__double_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference implementation, SIMD double precision. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:impl__reference__simd__float_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="impl__reference__simd__float_8h.xhtml">impl_reference_simd_float.h</a></td></tr>
<tr class="memdesc:impl__reference__simd__float_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference implementation, SIMD single precision. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:impl__reference__util__double_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="impl__reference__util__double_8h.xhtml">impl_reference_util_double.h</a></td></tr>
<tr class="memdesc:impl__reference__util__double_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference impl., higher-level double prec. SIMD utility functions. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:impl__reference__util__float_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="impl__reference__util__float_8h.xhtml">impl_reference_util_float.h</a></td></tr>
<tr class="memdesc:impl__reference__util__float_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference impl., higher-level single prec. SIMD utility functions. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:scalar_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="scalar_8h.xhtml">scalar.h</a></td></tr>
<tr class="memdesc:scalar_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar float functions corresponding to GROMACS SIMD functions. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:scalar__math_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="scalar__math_8h.xhtml">scalar_math.h</a></td></tr>
<tr class="memdesc:scalar__math_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar math functions mimicking GROMACS SIMD math functions. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:scalar__util_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="scalar__util_8h.xhtml">scalar_util.h</a></td></tr>
<tr class="memdesc:scalar__util_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar utility functions mimicking GROMACS SIMD utility functions. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:simd_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simd_8h.xhtml">simd.h</a></td></tr>
<tr class="memdesc:simd_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions, capabilities, and wrappers for SIMD module. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:simd__math_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simd__math_8h.xhtml">simd_math.h</a></td></tr>
<tr class="memdesc:simd__math_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Math functions for SIMD datatypes. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:simd__memory_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simd__memory_8h.xhtml">simd_memory.h</a></td></tr>
<tr class="memdesc:simd__memory_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares SimdArrayRef. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:support_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8h.xhtml">support.h</a></td></tr>
<tr class="memdesc:support_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions to query compiled and supported SIMD architectures. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:vector__operations_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vector__operations_8h.xhtml">vector_operations.h</a></td></tr>
<tr class="memdesc:vector__operations_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD operations corresponding to Gromacs rvec datatypes. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga6c015b9c619e63324df85f91e25191c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GMX_SIMD4_HAVE_REAL&#160;&#160;&#160;<a class="el" href="group__module__simd.xhtml#ga86b316f5c5de088d4cb073300198f4d3">GMX_SIMD4_HAVE_FLOAT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 if Simd4Real is available, otherwise 0. </p>
<p><a class="el" href="group__module__simd.xhtml#ga5a245d615fbc175986d8bd51d816e46d">GMX_SIMD4_HAVE_DOUBLE</a> if GMX_DOUBLE is 1, otherwise <a class="el" href="group__module__simd.xhtml#ga86b316f5c5de088d4cb073300198f4d3">GMX_SIMD4_HAVE_FLOAT</a>. </p>

</div>
</div>
<a class="anchor" id="ga8d093280bad2b3ebecbcd426bdddb73b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GMX_SIMD_HAVE_FLOAT&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 when SIMD float support is present, otherwise 0 </p>
<p>You should only use this to specifically check for single precision SIMD, support, even when the rest of Gromacs uses double precision. </p>

</div>
</div>
<a class="anchor" id="ga28b81d356fae5d8b1b3b76273c360360"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GMX_SIMD_HAVE_FMA&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 if the SIMD implementation has fused-multiply add hardware </p>
<dl class="section note"><dt>Note</dt><dd>All the fused multiply-add functions are always available and can be used in any code (by executing separate multiply and add ops), but in a few very tight loops you might be able to save a few instructions with a separate non-FMA code path. </dd></dl>

</div>
</div>
<a class="anchor" id="gad1350cf295aeed5d4fce461ca2048c56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GMX_SIMD_HAVE_GATHER_LOADU_BYSIMDINT_TRANSPOSE_REAL&#160;&#160;&#160;<a class="el" href="group__module__simd.xhtml#ga5ba6c684641af238fb2a5a7d4c6e0237">GMX_SIMD_HAVE_GATHER_LOADU_BYSIMDINT_TRANSPOSE_FLOAT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 if gmx::simdGatherLoadUBySimdIntTranspose is present, otherwise 0 </p>
<p><a class="el" href="group__module__simd.xhtml#ga5f609eec37d8c92163def72ec28bb435">GMX_SIMD_HAVE_GATHER_LOADU_BYSIMDINT_TRANSPOSE_DOUBLE</a> if GMX_DOUBLE is 1, otherwise <a class="el" href="group__module__simd.xhtml#ga5ba6c684641af238fb2a5a7d4c6e0237">GMX_SIMD_HAVE_GATHER_LOADU_BYSIMDINT_TRANSPOSE_FLOAT</a>. </p>

</div>
</div>
<a class="anchor" id="ga0d9f8d6284ecbbd135b89f2ad8999839"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GMX_SIMD_HAVE_HSIMD_UTIL_REAL&#160;&#160;&#160;<a class="el" href="group__module__simd.xhtml#gac40bf3261e36fb7ff022e8ab37b04fcf">GMX_SIMD_HAVE_HSIMD_UTIL_FLOAT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 if real half-register load/store/reduce utils present, otherwise 0 </p>
<p><a class="el" href="group__module__simd.xhtml#gadef533340f8e648dfb550cbd8cfd9fc7">GMX_SIMD_HAVE_HSIMD_UTIL_DOUBLE</a> if GMX_DOUBLE is 1, otherwise <a class="el" href="group__module__simd.xhtml#gac40bf3261e36fb7ff022e8ab37b04fcf">GMX_SIMD_HAVE_HSIMD_UTIL_FLOAT</a>. </p>

</div>
</div>
<a class="anchor" id="ga8a9534860edf5a3f2b9cd1bc60529b39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GMX_SIMD_HAVE_INT32_ARITHMETICS&#160;&#160;&#160;<a class="el" href="group__module__simd.xhtml#ga9febc62e1abd58eb8a035b8b81f93292">GMX_SIMD_HAVE_FINT32_ARITHMETICS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 if arithmetic ops are supported on SimdInt32, otherwise 0. </p>
<p><a class="el" href="group__module__simd.xhtml#gab8469202af6999f95405779355d89c30">GMX_SIMD_HAVE_DINT32_ARITHMETICS</a> if GMX_DOUBLE is 1, otherwise <a class="el" href="group__module__simd.xhtml#ga9febc62e1abd58eb8a035b8b81f93292">GMX_SIMD_HAVE_FINT32_ARITHMETICS</a>. </p>

</div>
</div>
<a class="anchor" id="ga036e9a3893a355aa51267fef7b5d4cae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GMX_SIMD_HAVE_INT32_EXTRACT&#160;&#160;&#160;<a class="el" href="group__module__simd.xhtml#ga23ac53a0050467ac215f146f6afc6380">GMX_SIMD_HAVE_FINT32_EXTRACT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 if support is available for extracting elements from SimdInt32, otherwise 0 </p>
<p><a class="el" href="group__module__simd.xhtml#gabae2f56a4d87b8e52b5df066888a4c07">GMX_SIMD_HAVE_DINT32_EXTRACT</a> if GMX_DOUBLE is 1, otherwise <a class="el" href="group__module__simd.xhtml#ga23ac53a0050467ac215f146f6afc6380">GMX_SIMD_HAVE_FINT32_EXTRACT</a>. </p>

</div>
</div>
<a class="anchor" id="ga69de9b6e1473a9dc3ab6a5588d00192a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GMX_SIMD_HAVE_INT32_LOGICAL&#160;&#160;&#160;<a class="el" href="group__module__simd.xhtml#ga354867d2570fecb6b341047947bee0d1">GMX_SIMD_HAVE_FINT32_LOGICAL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 if logical ops are supported on SimdInt32, otherwise 0. </p>
<p><a class="el" href="group__module__simd.xhtml#ga0ccbae145ecb27cee3c98ec7bded1d45">GMX_SIMD_HAVE_DINT32_LOGICAL</a> if GMX_DOUBLE is 1, otherwise <a class="el" href="group__module__simd.xhtml#ga354867d2570fecb6b341047947bee0d1">GMX_SIMD_HAVE_FINT32_LOGICAL</a>. </p>

</div>
</div>
<a class="anchor" id="ga5fb93edfc149ac6d5351d5d7fd327b80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GMX_SIMD_HAVE_NATIVE_COPYSIGN_DOUBLE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 if implementation provides double precision <a class="el" href="namespacegmx.xhtml#a8ef5f6af06e493a4ae2d47109ee0e723" title="Composes single value with the magnitude of x and the sign of y. ">copysign()</a> </p>
<p>Only used in <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a> to selectively override the generic implementation. </p>

</div>
</div>
<a class="anchor" id="gae0ee59fd57c8ac4336ecbdafd1356fec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GMX_SIMD_HAVE_NATIVE_COPYSIGN_FLOAT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 if implementation provides single precision <a class="el" href="namespacegmx.xhtml#a8ef5f6af06e493a4ae2d47109ee0e723" title="Composes single value with the magnitude of x and the sign of y. ">copysign()</a> </p>
<p>Only used in <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a> to selectively override the generic implementation. </p>

</div>
</div>
<a class="anchor" id="ga05f50a78bbd133cde5ebc83e2ac13a9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GMX_SIMD_HAVE_NATIVE_EXP2_DOUBLE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 if implementation provides double precision <a class="el" href="namespacegmx.xhtml#a643a4be46c81b885274394cd9ac1a30a" title="Float 2^x. ">exp2()</a> faster than <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a> </p>
<p>Only used in <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a> to selectively override the generic implementation. </p>

</div>
</div>
<a class="anchor" id="gaf481b26a00cb7a69c5b2b409cb8bf07a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GMX_SIMD_HAVE_NATIVE_EXP2_FLOAT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 if implementation provides single precision <a class="el" href="namespacegmx.xhtml#a643a4be46c81b885274394cd9ac1a30a" title="Float 2^x. ">exp2()</a> faster than <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a> </p>
<p>Only used in <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a> to selectively override the generic implementation. </p>

</div>
</div>
<a class="anchor" id="ga9d3931388f0a22ac74af34709cffaabb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GMX_SIMD_HAVE_NATIVE_EXP_DOUBLE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 if implementation provides double precision <a class="el" href="namespacegmx.xhtml#aa22dfb3027cee75bbc9686094f928050" title="Float exp(x). ">exp()</a> faster than <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a> </p>
<p>Only used in <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a> to selectively override the generic implementation. </p>

</div>
</div>
<a class="anchor" id="ga5c2bc0bba4513b830bad32f3fc5f54a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GMX_SIMD_HAVE_NATIVE_EXP_FLOAT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 if implementation provides single precision <a class="el" href="namespacegmx.xhtml#aa22dfb3027cee75bbc9686094f928050" title="Float exp(x). ">exp()</a> faster than <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a> </p>
<p>Only used in <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a> to selectively override the generic implementation. </p>

</div>
</div>
<a class="anchor" id="gad770ccd6aca01544454e2bb6c45491ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GMX_SIMD_HAVE_NATIVE_LOG_DOUBLE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 if implementation provides double precision <a class="el" href="namespacegmx.xhtml#a7b0a25f25b649f59d96b67f2d73c8ad8" title="Float log(x). This is the natural logarithm. ">log()</a> faster than <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a> </p>
<p>Only used in <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a> to selectively override the generic implementation. </p>

</div>
</div>
<a class="anchor" id="ga4e25630e2fde79d1c5dbde64293c4f8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GMX_SIMD_HAVE_NATIVE_LOG_FLOAT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 if implementation provides single precision <a class="el" href="namespacegmx.xhtml#a7b0a25f25b649f59d96b67f2d73c8ad8" title="Float log(x). This is the natural logarithm. ">log()</a> faster than <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a> </p>
<p>Only used in <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a> to selectively override the generic implementation. </p>

</div>
</div>
<a class="anchor" id="ga9094d49ecb55b7140d68b7d402b3dadd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GMX_SIMD_HAVE_NATIVE_RCP_ITER_DOUBLE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 if implementation provides double precision 1/x N-R iterations faster than <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a> </p>
<p>Only used in <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a> to selectively override the generic implementation. </p>

</div>
</div>
<a class="anchor" id="ga42b629cc80d3bb76e8a8bb84c2a11659"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GMX_SIMD_HAVE_NATIVE_RCP_ITER_FLOAT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 if implementation provides single precision 1/x N-R iterations faster than <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a> </p>
<p>Only used in <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a> to selectively override the generic implementation. </p>

</div>
</div>
<a class="anchor" id="ga2c8c664c67f7287baf890c69bfa72814"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GMX_SIMD_HAVE_NATIVE_RSQRT_ITER_DOUBLE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 if implementation provides double precision 1/sqrt(x) N-R iterations faster than <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a> </p>
<p>Only used in <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a> to selectively override the generic implementation. </p>

</div>
</div>
<a class="anchor" id="ga6ed1e79e7680e1286e57df038c5e1a5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GMX_SIMD_HAVE_NATIVE_RSQRT_ITER_FLOAT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 if implementation provides single precision 1/sqrt(x) N-R iterations faster than <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a> </p>
<p>Only used in <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a> to selectively override the generic implementation. </p>

</div>
</div>
<a class="anchor" id="ga1578fccdb327f36a2bea338457cbf883"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GMX_SIMD_HAVE_REAL&#160;&#160;&#160;<a class="el" href="group__module__simd.xhtml#ga8d093280bad2b3ebecbcd426bdddb73b">GMX_SIMD_HAVE_FLOAT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 if SimdReal is available, otherwise 0. </p>
<p><a class="el" href="group__module__simd.xhtml#gaf5545c033bb4a28657239e4c9739cefe">GMX_SIMD_HAVE_DOUBLE</a> if GMX_DOUBLE is 1, otherwise <a class="el" href="group__module__simd.xhtml#ga8d093280bad2b3ebecbcd426bdddb73b">GMX_SIMD_HAVE_FLOAT</a>. </p>

</div>
</div>
<a class="anchor" id="ga586ccc19c21a1d5e9c97e15b70822fba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GMX_SIMD_REAL_WIDTH&#160;&#160;&#160;<a class="el" href="group__module__simd.xhtml#gafdbf804a40bfa3dcb15bc50055e58e74">GMX_SIMD_FLOAT_WIDTH</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Width of SimdReal. </p>
<p><a class="el" href="group__module__simd.xhtml#ga417e9d28b6310876bb2c69eb528c0a86">GMX_SIMD_DOUBLE_WIDTH</a> if GMX_DOUBLE is 1, otherwise <a class="el" href="group__module__simd.xhtml#gafdbf804a40bfa3dcb15bc50055e58e74">GMX_SIMD_FLOAT_WIDTH</a>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga4555c730e6119f070664703072a7235c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::abs </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD4 Floating-point fabs(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>any floating point values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fabs(a) for each element. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9339c53d13a59e946834c14d565f1e18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::abs </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD4 Floating-point <a class="el" href="group__module__simd.xhtml#ga9339c53d13a59e946834c14d565f1e18" title="SIMD4 Floating-point abs(). ">abs()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>any floating point values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fabs(a) for each element. </dd></dl>

</div>
</div>
<a class="anchor" id="ga95f617b5ff9a30dde812f59c8c50bab4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::acos </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float acos(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate acos for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Acos(x) </dd></dl>

</div>
</div>
<a class="anchor" id="ga5459281155e8be7fd6356c5e366acb0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::acos </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD double acos(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate acos for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Acos(x) </dd></dl>

</div>
</div>
<a class="anchor" id="ga73027d18d5366998dbf0af8c52f68b60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::acosSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD acos(x). Double precision SIMD data, single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate acos for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Acos(x) </dd></dl>

</div>
</div>
<a class="anchor" id="ga79f0bb956500fceaff7db7c496cb8dde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::acosSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float acos(x), only targeting single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate acos for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Acos(x) </dd></dl>

</div>
</div>
<a class="anchor" id="ga847080625fcb1aff7a1db138afd57222"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::andNot </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise andnot for two SIMD4 double variables. c=(~a) &amp; b. </p>
<p>Available if <a class="el" href="group__module__simd.xhtml#gaf002483e94d5f42de1d5105cf924f8b8">GMX_SIMD_HAVE_LOGICAL</a> is 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>data1 </td></tr>
    <tr><td class="paramname">b</td><td>data2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(~data1) &amp; data2 </dd></dl>

</div>
</div>
<a class="anchor" id="ga4dfe3fded0fc0c151f918e6892603121"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::andNot </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise andnot for two SIMD4 float variables. c=(~a) &amp; b. </p>
<p>Available if <a class="el" href="group__module__simd.xhtml#gaf002483e94d5f42de1d5105cf924f8b8">GMX_SIMD_HAVE_LOGICAL</a> is 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>data1 </td></tr>
    <tr><td class="paramname">b</td><td>data2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(~data1) &amp; data2 </dd></dl>

</div>
</div>
<a class="anchor" id="ga5b8118b5d14f17aa83d64531e7793e4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool gmx_simdcall gmx::anyTrue </td>
          <td>(</td>
          <td class="paramtype">Simd4FBool&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns non-zero if any of the boolean in SIMD4 a is True, otherwise 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Logical variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any element in a is true, otherwise false.</dd></dl>
<p>The actual return value for truth will depend on the architecture, so any non-zero value is considered truth. </p>

</div>
</div>
<a class="anchor" id="ga314f00cbdc12d0615a873dff3bdd38db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool gmx_simdcall gmx::anyTrue </td>
          <td>(</td>
          <td class="paramtype">Simd4DBool&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns non-zero if any of the boolean in SIMD4 a is True, otherwise 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Logical variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any element in a is true, otherwise false.</dd></dl>
<p>The actual return value for truth will depend on the architecture, so any non-zero value is considered truth. </p>

</div>
</div>
<a class="anchor" id="gabad1890270f5f95bf48d2decd31c7a1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::asin </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float asin(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate asin for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Asin(x) </dd></dl>

</div>
</div>
<a class="anchor" id="gafc20a60ae6b0e838d65d127e944effbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::asin </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD double asin(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate asin for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Asin(x) </dd></dl>

</div>
</div>
<a class="anchor" id="ga7e098546fed7424b9c449588ebb84252"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::asinSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD asin(x). Double precision SIMD data, single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate asin for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Asin(x) </dd></dl>

</div>
</div>
<a class="anchor" id="ga50ad685f412725bacde7687e43bab092"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::asinSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float asin(x), only targeting single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate asin for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Asin(x) </dd></dl>

</div>
</div>
<a class="anchor" id="gac4afec2509b0edcdae7fe2ddfc2f3ecc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::atan </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float asin(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate atan for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Atan(x), same argument/value range as standard math library. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0e327fdca86999b2716b5109621b1936"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::atan </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD double asin(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate atan for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Atan(x), same argument/value range as standard math library. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7f1a591557aea01675643b86653ca136"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::atan2 </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float atan2(y,x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Y component of vector, any quartile </td></tr>
    <tr><td class="paramname">x</td><td>X component of vector, any quartile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Atan(y,x), same argument/value range as standard math library.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This routine should provide correct results for all finite non-zero or positive-zero arguments. However, negative zero arguments will be treated as positive zero, which means the return value will deviate from the standard math library atan2(y,x) for those cases. That should not be of any concern in Gromacs, and in particular it will not affect calculations of angles from vectors. </dd></dl>

</div>
</div>
<a class="anchor" id="gae3d1e53759871924024fc4bfa8cd7e41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::atan2 </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD double atan2(y,x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Y component of vector, any quartile </td></tr>
    <tr><td class="paramname">x</td><td>X component of vector, any quartile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Atan(y,x), same argument/value range as standard math library.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This routine should provide correct results for all finite non-zero or positive-zero arguments. However, negative zero arguments will be treated as positive zero, which means the return value will deviate from the standard math library atan2(y,x) for those cases. That should not be of any concern in Gromacs, and in particular it will not affect calculations of angles from vectors. </dd></dl>

</div>
</div>
<a class="anchor" id="ga193d8e790944928be53940809d6f2385"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::atan2SingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD atan2(y,x). Double precision SIMD data, single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Y component of vector, any quartile </td></tr>
    <tr><td class="paramname">x</td><td>X component of vector, any quartile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Atan(y,x), same argument/value range as standard math library.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This routine should provide correct results for all finite non-zero or positive-zero arguments. However, negative zero arguments will be treated as positive zero, which means the return value will deviate from the standard math library atan2(y,x) for those cases. That should not be of any concern in Gromacs, and in particular it will not affect calculations of angles from vectors. </dd></dl>

</div>
</div>
<a class="anchor" id="ga73a666e50ed9883d77a2664cd9f9768c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::atan2SingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float atan2(y,x), only targeting single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Y component of vector, any quartile </td></tr>
    <tr><td class="paramname">x</td><td>X component of vector, any quartile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Atan(y,x), same argument/value range as standard math library.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This routine should provide correct results for all finite non-zero or positive-zero arguments. However, negative zero arguments will be treated as positive zero, which means the return value will deviate from the standard math library atan2(y,x) for those cases. That should not be of any concern in Gromacs, and in particular it will not affect calculations of angles from vectors. </dd></dl>

</div>
</div>
<a class="anchor" id="ga39be2b2651b8a68340c2132becf1c372"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::atanSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD asin(x). Double precision SIMD data, single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate atan for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Atan(x), same argument/value range as standard math library. </dd></dl>

</div>
</div>
<a class="anchor" id="ga94615aced90295d0c008dbe576bfb535"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::atanSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float atan(x), only targeting single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate atan for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Atan(x), same argument/value range as standard math library. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9a3c7493047defc21bf934ca9fc39476"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::blend </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4FBool&#160;</td>
          <td class="paramname"><em>sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector-blend SIMD4 selection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First source </td></tr>
    <tr><td class="paramname">b</td><td>Second source </td></tr>
    <tr><td class="paramname">sel</td><td>Boolean selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>For each element, select b if sel is true, a otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gafa1d01238ab3305ab17f301f73eaeaa1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::blend </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4DBool&#160;</td>
          <td class="paramname"><em>sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector-blend SIMD4 selection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First source </td></tr>
    <tr><td class="paramname">b</td><td>Second source </td></tr>
    <tr><td class="paramname">sel</td><td>Boolean selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>For each element, select b if sel is true, a otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gacb8a1939549a71a3c2861de9ce865301"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::copysign </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes floating point value with the magnitude of x and the sign of y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Values to set sign for </td></tr>
    <tr><td class="paramname">y</td><td>Values used to set sign </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Magnitude of x, sign of y </dd></dl>

</div>
</div>
<a class="anchor" id="ga3013bbebe9a43572658b37ad9b6b13be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::copysign </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes floating point value with the magnitude of x and the sign of y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Values to set sign for </td></tr>
    <tr><td class="paramname">y</td><td>Values used to set sign </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Magnitude of x, sign of y </dd></dl>

</div>
</div>
<a class="anchor" id="ga9c58146cc6b29eaa9756faea26eba851"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::cos </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float cos(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate cos for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cos(x)</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Do NOT call both sin &amp; cos if you need both results, since each of them will then call <a class="el" href="namespacegmx.xhtml#a3191310c1a122aafe946f0caf2fdf364">sincos</a> and waste a factor 2 in performance. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4fb04efe2288b65a54c4e8fd5585f125"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::cos </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD double cos(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate cos for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cos(x)</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Do NOT call both sin &amp; cos if you need both results, since each of them will then call <a class="el" href="namespacegmx.xhtml#a3191310c1a122aafe946f0caf2fdf364">sincos</a> and waste a factor 2 in performance. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1b867b3b628740d6f710a480626cffa8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::cosSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD cos(x). Double precision SIMD data, single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate cos for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cos(x)</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Do NOT call both sin &amp; cos if you need both results, since each of them will then call <a class="el" href="namespacegmx.xhtml#a3191310c1a122aafe946f0caf2fdf364">sincos</a> and waste a factor 2 in performance. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa1ecd6647f33b8bd12c43a3f3de95fb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::cosSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float cos(x), only targeting single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate cos for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cos(x)</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Do NOT call both sin &amp; cos if you need both results, since each of them will then call <a class="el" href="namespacegmx.xhtml#a3191310c1a122aafe946f0caf2fdf364">sincos</a> and waste a factor 2 in performance. </dd></dl>

</div>
</div>
<a class="anchor" id="ga54124af0ff118d3f171b0eef07105c76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::cprod </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>ay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>az</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>bx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>bz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>cz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float cross-product of multiple vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ax</td><td>X components of first vectors </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ay</td><td>Y components of first vectors </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">az</td><td>Z components of first vectors </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">bx</td><td>X components of second vectors </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">by</td><td>Y components of second vectors </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">bz</td><td>Z components of second vectors </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cx</td><td>X components of cross product vectors </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cy</td><td>Y components of cross product vectors </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cz</td><td>Z components of cross product vectors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This calculates C = A x B, where the cross denotes the cross product. The arguments x/y/z denotes the different components, and each element corresponds to a separate vector. </p>

</div>
</div>
<a class="anchor" id="ga5bda1e7f61ac88be5176195e3676a6d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::cprod </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>ay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>az</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>bx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>bz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>cz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD double cross-product of multiple vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ax</td><td>X components of first vectors </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ay</td><td>Y components of first vectors </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">az</td><td>Z components of first vectors </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">bx</td><td>X components of second vectors </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">by</td><td>Y components of second vectors </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">bz</td><td>Z components of second vectors </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cx</td><td>X components of cross product vectors </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cy</td><td>Y components of cross product vectors </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cz</td><td>Z components of cross product vectors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This calculates C = A x B, where the cross denotes the cross product. The arguments x/y/z denotes the different components, and each element corresponds to a separate vector. </p>

</div>
</div>
<a class="anchor" id="gac0420b0ba8ce5c0bbdf94d69c67ab563"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx_simdcall gmx::dotProduct </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return dot product of two single precision SIMD4 variables. </p>
<p>The dot product is calculated between the first three elements in the two vectors, while the fourth is ignored. The result is returned as a scalar.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>vector1 </td></tr>
    <tr><td class="paramname">b</td><td>vector2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a[0]*b[0]+a[1]*b[1]+a[2]*b[2], returned as scalar. Last element is ignored. </dd></dl>

</div>
</div>
<a class="anchor" id="ga48eb5014bfc9c6c43e9e21bf8c87ecc4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx_simdcall gmx::dotProduct </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return dot product of two double precision SIMD4 variables. </p>
<p>The dot product is calculated between the first three elements in the two vectors, while the fourth is ignored. The result is returned as a scalar.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>vector1 </td></tr>
    <tr><td class="paramname">b</td><td>vector2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a[0]*b[0]+a[1]*b[1]+a[2]*b[2], returned as scalar. Last element is ignored. </dd></dl>

</div>
</div>
<a class="anchor" id="ga60e354f86286dc5b7620f6bc663bb089"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::erf </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float erf(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to calculate erf(x) for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>erf(x)</dd></dl>
<p>This routine achieves very close to full precision, but we do not care about the last bit or the subnormal result range. </p>

</div>
</div>
<a class="anchor" id="ga900477ac8042bfd9d6c85a06e3f003c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::erf </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD double erf(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to calculate erf(x) for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>erf(x)</dd></dl>
<p>This routine achieves very close to full precision, but we do not care about the last bit or the subnormal result range. </p>

</div>
</div>
<a class="anchor" id="ga1e169e3f45d0532ab2350daad387ca57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::erfc </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float erfc(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to calculate erfc(x) for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>erfc(x)</dd></dl>
<p>This routine achieves full precision (bar the last bit) over most of the input range, but for large arguments where the result is getting close to the minimum representable numbers we accept slightly larger errors (think results that are in the ballpark of 10^-30 for single precision) since that is not relevant for MD. </p>

</div>
</div>
<a class="anchor" id="gabd11e43f0479bca8e5b9d58b73307ae6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::erfc </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD double erfc(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to calculate erfc(x) for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>erfc(x)</dd></dl>
<p>This routine achieves full precision (bar the last bit) over most of the input range, but for large arguments where the result is getting close to the minimum representable numbers we accept slightly larger errors (think results that are in the ballpark of 10^-200 for double) since that is not relevant for MD. </p>

</div>
</div>
<a class="anchor" id="gae8d996acb25e6bdb2d08ca2b26bb19c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::erfcSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD erfc(x). Double precision SIMD data, single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to calculate erfc(x) for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>erfc(x)</dd></dl>
<p>This routine achieves singleprecision (bar the last bit) over most of the input range, but for large arguments where the result is getting close to the minimum representable numbers we accept slightly larger errors (think results that are in the ballpark of 10^-30) since that is not relevant for MD. </p>

</div>
</div>
<a class="anchor" id="ga606009ab68825981a67be586f77fb38e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::erfcSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float erfc(x), only targeting single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to calculate erfc(x) for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>erfc(x)</dd></dl>
<p>This routine achieves singleprecision (bar the last bit) over most of the input range, but for large arguments where the result is getting close to the minimum representable numbers we accept slightly larger errors (think results that are in the ballpark of 10^-30) since that is not relevant for MD. </p>

</div>
</div>
<a class="anchor" id="gac6ce232cb0593b32dc9789e04679bc6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::erfSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD erf(x). Double precision SIMD data, single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to calculate erf(x) for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>erf(x)</dd></dl>
<p>This routine achieves very close to single precision, but we do not care about the last bit or the subnormal result range. </p>

</div>
</div>
<a class="anchor" id="ga6b00659cd28d0255ee51fcfd9693209f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::erfSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float erf(x), only targeting single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to calculate erf(x) for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>erf(x)</dd></dl>
<p>This routine achieves very close to single precision, but we do not care about the last bit or the subnormal result range. </p>

</div>
</div>
<a class="anchor" id="gacf6583b14086a1a6b6947838ccc7301e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MathOptimization opt = MathOptimization::Safe&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::exp </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float exp(x). </p>
<p>In addition to scaling the argument for 2^x this routine correctly does extended precision arithmetics to improve accuracy.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">opt</td><td>If this is changed from the default (safe) into the unsafe option, input values that would otherwise lead to zero-clamped results are not allowed and will lead to undefined results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. For the default (safe) function version this can be arbitrarily small value, but the routine might clamp the result to zero for arguments that would produce subnormal IEEE754-2008 results. This corresponds to input arguments reaching -126*ln(2)=-87.3 in single, or -1022*ln(2)=-708.4 (double). Similarly, it might overflow for arguments reaching 127*ln(2)=88.0 (single) or 1023*ln(2)=709.1 (double). If the unsafe math optimizations are enabled, small input values that would result in zero-clamped output are not allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>exp(x). Overflowing arguments are likely to either return 0 or inf, depending on the underlying implementation. If unsafe optimizations are enabled, this is also true for very small values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The definition range of this function is just-so-slightly smaller than the allowed IEEE exponents for many architectures. This is due to the implementation, which will hopefully improve in the future.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>You cannot rely on this implementation returning inf for arguments that cause overflow. If you have some very large values and need to rely on getting a valid numerical output, take the minimum of your variable and the largest valid argument before calling this routine. </dd></dl>

</div>
</div>
<a class="anchor" id="ga98d13cb67fc6c5fefc32992673bf0637"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MathOptimization opt = MathOptimization::Safe&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::exp </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD double exp(x). </p>
<p>In addition to scaling the argument for 2^x this routine correctly does extended precision arithmetics to improve accuracy.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">opt</td><td>If this is changed from the default (safe) into the unsafe option, input values that would otherwise lead to zero-clamped results are not allowed and will lead to undefined results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. For the default (safe) function version this can be arbitrarily small value, but the routine might clamp the result to zero for arguments that would produce subnormal IEEE754-2008 results. This corresponds to input arguments reaching -126*ln(2)=-87.3 in single, or -1022*ln(2)=-708.4 (double). Similarly, it might overflow for arguments reaching 127*ln(2)=88.0 (single) or 1023*ln(2)=709.1 (double). If the unsafe math optimizations are enabled, small input values that would result in zero-clamped output are not allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>exp(x). Overflowing arguments are likely to either return 0 or inf, depending on the underlying implementation. If unsafe optimizations are enabled, this is also true for very small values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The definition range of this function is just-so-slightly smaller than the allowed IEEE exponents for many architectures. This is due to the implementation, which will hopefully improve in the future.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>You cannot rely on this implementation returning inf for arguments that cause overflow. If you have some very large values and need to rely on getting a valid numerical output, take the minimum of your variable and the largest valid argument before calling this routine. </dd></dl>

</div>
</div>
<a class="anchor" id="ga53b14cbaf68e8e449f610ae172c39699"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MathOptimization opt = MathOptimization::Safe&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::exp2 </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float 2^x. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">opt</td><td>If this is changed from the default (safe) into the unsafe option, input values that would otherwise lead to zero-clamped results are not allowed and will lead to undefined results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. For the default (safe) function version this can be arbitrarily small value, but the routine might clamp the result to zero for arguments that would produce subnormal IEEE754-2008 results. This corresponds to inputs below -126 in single or -1022 in double, and it might overflow for arguments reaching 127 (single) or 1023 (double). If you enable the unsafe math optimization, very small arguments will not necessarily be zero-clamped, but can produce undefined results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2^x. The result is undefined for very large arguments that cause internal floating-point overflow. If unsafe optimizations are enabled, this is also true for very small values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The definition range of this function is just-so-slightly smaller than the allowed IEEE exponents for many architectures. This is due to the implementation, which will hopefully improve in the future.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>You cannot rely on this implementation returning inf for arguments that cause overflow. If you have some very large values and need to rely on getting a valid numerical output, take the minimum of your variable and the largest valid argument before calling this routine. </dd></dl>

</div>
</div>
<a class="anchor" id="gade7a25b3812d52c1f0c1392d2cc686ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MathOptimization opt = MathOptimization::Safe&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::exp2 </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD double 2^x. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">opt</td><td>If this is changed from the default (safe) into the unsafe option, input values that would otherwise lead to zero-clamped results are not allowed and will lead to undefined results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. For the default (safe) function version this can be arbitrarily small value, but the routine might clamp the result to zero for arguments that would produce subnormal IEEE754-2008 results. This corresponds to inputs below -126 in single or -1022 in double, and it might overflow for arguments reaching 127 (single) or 1023 (double). If you enable the unsafe math optimization, very small arguments will not necessarily be zero-clamped, but can produce undefined results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2^x. The result is undefined for very large arguments that cause internal floating-point overflow. If unsafe optimizations are enabled, this is also true for very small values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The definition range of this function is just-so-slightly smaller than the allowed IEEE exponents for many architectures. This is due to the implementation, which will hopefully improve in the future.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>You cannot rely on this implementation returning inf for arguments that cause overflow. If you have some very large values and need to rely on getting a valid numerical output, take the minimum of your variable and the largest valid argument before calling this routine. </dd></dl>

</div>
</div>
<a class="anchor" id="ga67c6ce3061f04d7438eff1c4a124737d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MathOptimization opt = MathOptimization::Safe&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::exp2SingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD 2^x. Double precision SIMD, single accuracy. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">opt</td><td>If this is changed from the default (safe) into the unsafe option, input values that would otherwise lead to zero-clamped results are not allowed and will lead to undefined results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. For the default (safe) function version this can be arbitrarily small value, but the routine might clamp the result to zero for arguments that would produce subnormal IEEE754-2008 results. This corresponds to inputs below -126 in single or -1022 in double, and it might overflow for arguments reaching 127 (single) or 1023 (double). If you enable the unsafe math optimization, very small arguments will not necessarily be zero-clamped, but can produce undefined results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2^x. The result is undefined for very large arguments that cause internal floating-point overflow. If unsafe optimizations are enabled, this is also true for very small values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The definition range of this function is just-so-slightly smaller than the allowed IEEE exponents for many architectures. This is due to the implementation, which will hopefully improve in the future.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>You cannot rely on this implementation returning inf for arguments that cause overflow. If you have some very large values and need to rely on getting a valid numerical output, take the minimum of your variable and the largest valid argument before calling this routine. </dd></dl>

</div>
</div>
<a class="anchor" id="ga61a99b57e09349d83ddab13dd7e8ecb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MathOptimization opt = MathOptimization::Safe&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::exp2SingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float 2^x, only targeting single accuracy. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">opt</td><td>If this is changed from the default (safe) into the unsafe option, input values that would otherwise lead to zero-clamped results are not allowed and will lead to undefined results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. For the default (safe) function version this can be arbitrarily small value, but the routine might clamp the result to zero for arguments that would produce subnormal IEEE754-2008 results. This corresponds to inputs below -126 in single or -1022 in double, and it might overflow for arguments reaching 127 (single) or 1023 (double). If you enable the unsafe math optimization, very small arguments will not necessarily be zero-clamped, but can produce undefined results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2^x. The result is undefined for very large arguments that cause internal floating-point overflow. If unsafe optimizations are enabled, this is also true for very small values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The definition range of this function is just-so-slightly smaller than the allowed IEEE exponents for many architectures. This is due to the implementation, which will hopefully improve in the future.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>You cannot rely on this implementation returning inf for arguments that cause overflow. If you have some very large values and need to rely on getting a valid numerical output, take the minimum of your variable and the largest valid argument before calling this routine. </dd></dl>

</div>
</div>
<a class="anchor" id="gad8d730c26297155e1aa934c2bc91e750"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::expandScalarsToTriplets </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>triplets0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>triplets1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>triplets2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expand each element of double SIMD variable into three identical consecutive elements in three SIMD outputs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">scalar</td><td>Floating-point input, e.g. [s0 s1 s2 s3] if width=4. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">triplets0</td><td>First output, e.g. [s0 s0 s0 s1] if width=4. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">triplets1</td><td>Second output, e.g. [s1 s1 s2 s2] if width=4. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">triplets2</td><td>Third output, e.g. [s2 s3 s3 s3] if width=4.</td></tr>
  </table>
  </dd>
</dl>
<p>This routine is meant to use for things like scalar-vector multiplication, where the vectors are stored in a merged format like [x0 y0 z0 x1 y1 z1 ...], while the scalars are stored as [s0 s1 s2...], and the data cannot easily be changed to SIMD-friendly layout.</p>
<p>In this case, load 3 full-width SIMD variables from the vector array (This will always correspond to GMX_SIMD_DOUBLE_WIDTH triplets), load a single full-width variable from the scalar array, and call this routine to expand the data. You can then simply multiply the first, second and third pair of SIMD variables, and store the three results back into a suitable vector-format array. </p>

</div>
</div>
<a class="anchor" id="ga82af54acc2b9eae6e58b646b5022aef5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::expandScalarsToTriplets </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>triplets0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>triplets1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>triplets2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expand each element of float SIMD variable into three identical consecutive elements in three SIMD outputs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">scalar</td><td>Floating-point input, e.g. [s0 s1 s2 s3] if width=4. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">triplets0</td><td>First output, e.g. [s0 s0 s0 s1] if width=4. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">triplets1</td><td>Second output, e.g. [s1 s1 s2 s2] if width=4. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">triplets2</td><td>Third output, e.g. [s2 s3 s3 s3] if width=4.</td></tr>
  </table>
  </dd>
</dl>
<p>This routine is meant to use for things like scalar-vector multiplication, where the vectors are stored in a merged format like [x0 y0 z0 x1 y1 z1 ...], while the scalars are stored as [s0 s1 s2...], and the data cannot easily be changed to SIMD-friendly layout.</p>
<p>In this case, load 3 full-width SIMD variables from the vector array (This will always correspond to GMX_SIMD_FLOAT_WIDTH triplets), load a single full-width variable from the scalar array, and call this routine to expand the data. You can then simply multiply the first, second and third pair of SIMD variables, and store the three results back into a suitable vector-format array. </p>

</div>
</div>
<a class="anchor" id="ga9bc997f231867640d8030d2c8886a922"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MathOptimization opt = MathOptimization::Safe&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::expSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD exp(x). Double precision SIMD, single accuracy. </p>
<p>In addition to scaling the argument for 2^x this routine correctly does extended precision arithmetics to improve accuracy.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">opt</td><td>If this is changed from the default (safe) into the unsafe option, input values that would otherwise lead to zero-clamped results are not allowed and will lead to undefined results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. For the default (safe) function version this can be arbitrarily small value, but the routine might clamp the result to zero for arguments that would produce subnormal IEEE754-2008 results. This corresponds to input arguments reaching -126*ln(2)=-87.3 in single, or -1022*ln(2)=-708.4 (double). Similarly, it might overflow for arguments reaching 127*ln(2)=88.0 (single) or 1023*ln(2)=709.1 (double). If the unsafe math optimizations are enabled, small input values that would result in zero-clamped output are not allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>exp(x). Overflowing arguments are likely to either return 0 or inf, depending on the underlying implementation. If unsafe optimizations are enabled, this is also true for very small values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The definition range of this function is just-so-slightly smaller than the allowed IEEE exponents for many architectures. This is due to the implementation, which will hopefully improve in the future.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>You cannot rely on this implementation returning inf for arguments that cause overflow. If you have some very large values and need to rely on getting a valid numerical output, take the minimum of your variable and the largest valid argument before calling this routine. </dd></dl>

</div>
</div>
<a class="anchor" id="ga43240f3ca7edd0885d809b68d04664cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MathOptimization opt = MathOptimization::Safe&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::expSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float e^x, only targeting single accuracy. </p>
<p>In addition to scaling the argument for 2^x this routine correctly does extended precision arithmetics to improve accuracy.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">opt</td><td>If this is changed from the default (safe) into the unsafe option, input values that would otherwise lead to zero-clamped results are not allowed and will lead to undefined results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. For the default (safe) function version this can be arbitrarily small value, but the routine might clamp the result to zero for arguments that would produce subnormal IEEE754-2008 results. This corresponds to input arguments reaching -126*ln(2)=-87.3 in single, or -1022*ln(2)=-708.4 (double). Similarly, it might overflow for arguments reaching 127*ln(2)=88.0 (single) or 1023*ln(2)=709.1 (double). If the unsafe math optimizations are enabled, small input values that would result in zero-clamped output are not allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>exp(x). Overflowing arguments are likely to either return 0 or inf, depending on the underlying implementation. If unsafe optimizations are enabled, this is also true for very small values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The definition range of this function is just-so-slightly smaller than the allowed IEEE exponents for many architectures. This is due to the implementation, which will hopefully improve in the future.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>You cannot rely on this implementation returning inf for arguments that cause overflow. If you have some very large values and need to rely on getting a valid numerical output, take the minimum of your variable and the largest valid argument before calling this routine. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa2db026253ce788e7f136326089e8a77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::fma </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD4 Fused-multiply-add. Result is a*b+c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a*b+c </dd></dl>

</div>
</div>
<a class="anchor" id="ga68d608d0650ac219cb4c0d3034ee855f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::fma </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD4 Fused-multiply-add. Result is a*b+c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a*b+c </dd></dl>

</div>
</div>
<a class="anchor" id="gafb3861a4cc7cae530fcf5bf83955da1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::fms </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD4 Fused-multiply-subtract. Result is a*b-c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a*b-c </dd></dl>

</div>
</div>
<a class="anchor" id="ga78a3204bd78e9122ba1998e985d1a5bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::fms </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD4 Fused-multiply-subtract. Result is a*b-c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a*b-c </dd></dl>

</div>
</div>
<a class="anchor" id="gae9ec59669729860c9efd1b9c70f3911b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::fnma </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD4 Fused-negated-multiply-add. Result is -a*b+c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-a*b+c </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf4df87eca51bb2f57ffe0bcb1c9de02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::fnma </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD4 Fused-negated-multiply-add. Result is -a*b+c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-a*b+c </dd></dl>

</div>
</div>
<a class="anchor" id="gac7afe2f2f840c1de18cb7c61917ba11c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::fnms </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD4 Fused-negated-multiply-subtract. Result is -a*b-c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-a*b-c </dd></dl>

</div>
</div>
<a class="anchor" id="gace0a9be42a2c83de88e9de207cd82e80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::fnms </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD4 Fused-negated-multiply-subtract. Result is -a*b-c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
    <tr><td class="paramname">c</td><td>term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-a*b-c </dd></dl>

</div>
</div>
<a class="anchor" id="ga1008329474744f6987edf28c4124ac24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::gatherLoadBySimdIntTranspose </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDInt32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 4 consecutive doubles from each of GMX_SIMD_DOUBLE_WIDTH offsets specified by a SIMD integer, transpose into 4 SIMD double variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 4 for this routine) the input data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Aligned pointer to the start of the memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>SIMD integer type with offsets to the start of each triplet. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>First component, base[align*offset[i]] for each i. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>Second component, base[align*offset[i] + 1] for each i. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v2</td><td>Third component, base[align*offset[i] + 2] for each i. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v3</td><td>Fourth component, base[align*offset[i] + 3] for each i.</td></tr>
  </table>
  </dd>
</dl>
<p>The floating-point memory locations must be aligned, but only to the smaller of four elements and the floating-point SIMD width.</p>
<dl class="section note"><dt>Note</dt><dd>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </dd>
<dd>
This is a special routine primarily intended for loading Gromacs table data as efficiently as possible - this is the reason for using a SIMD offset index, since the result of the real-to-integer conversion is present in a SIMD register just before calling this routine. </dd></dl>

</div>
</div>
<a class="anchor" id="gac7ba60b7340036a984888bbca43616e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::gatherLoadBySimdIntTranspose </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFInt32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 4 consecutive floats from each of GMX_SIMD_FLOAT_WIDTH offsets specified by a SIMD integer, transpose into 4 SIMD float variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 4 for this routine) the input data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Aligned pointer to the start of the memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>SIMD integer type with offsets to the start of each triplet. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>First component, base[align*offset[i]] for each i. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>Second component, base[align*offset[i] + 1] for each i. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v2</td><td>Third component, base[align*offset[i] + 2] for each i. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v3</td><td>Fourth component, base[align*offset[i] + 3] for each i.</td></tr>
  </table>
  </dd>
</dl>
<p>The floating-point memory locations must be aligned, but only to the smaller of four elements and the floating-point SIMD width.</p>
<dl class="section note"><dt>Note</dt><dd>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </dd>
<dd>
This is a special routine primarily intended for loading Gromacs table data as efficiently as possible - this is the reason for using a SIMD offset index, since the result of the real-to-integer conversion is present in a SIMD register just before calling this routine. </dd></dl>

</div>
</div>
<a class="anchor" id="ga11385272a2b5123ca3aa3e5696e55dbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::gatherLoadBySimdIntTranspose </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDInt32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 2 consecutive doubles from each of GMX_SIMD_DOUBLE_WIDTH offsets specified by a SIMD integer, transpose into 2 SIMD double variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 2 for this routine) the input data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Aligned pointer to the start of the memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>SIMD integer type with offsets to the start of each triplet. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>First component, base[align*offset[i]] for each i. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>Second component, base[align*offset[i] + 1] for each i.</td></tr>
  </table>
  </dd>
</dl>
<p>The floating-point memory locations must be aligned, but only to the smaller of two elements and the floating-point SIMD width.</p>
<dl class="section note"><dt>Note</dt><dd>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </dd>
<dd>
This is a special routine primarily intended for loading Gromacs table data as efficiently as possible - this is the reason for using a SIMD offset index, since the result of the real-to-integer conversion is present in a SIMD register just before calling this routine. </dd></dl>

</div>
</div>
<a class="anchor" id="ga98bde531b096434095b228308e7a3025"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::gatherLoadBySimdIntTranspose </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFInt32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 2 consecutive floats from each of GMX_SIMD_FLOAT_WIDTH offsets specified by a SIMD integer, transpose into 2 SIMD float variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 2 for this routine) the input data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Aligned pointer to the start of the memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>SIMD integer type with offsets to the start of each triplet. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>First component, base[align*offset[i]] for each i. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>Second component, base[align*offset[i] + 1] for each i.</td></tr>
  </table>
  </dd>
</dl>
<p>The floating-point memory locations must be aligned, but only to the smaller of two elements and the floating-point SIMD width.</p>
<dl class="section note"><dt>Note</dt><dd>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </dd>
<dd>
This is a special routine primarily intended for loading Gromacs table data as efficiently as possible - this is the reason for using a SIMD offset index, since the result of the real-to-integer conversion is present in a SIMD register just before calling this routine. </dd></dl>

</div>
</div>
<a class="anchor" id="ga725596b415f4bca94e71321b6845bed4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::gatherLoadTranspose </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 4 consecutive double from each of GMX_SIMD_DOUBLE_WIDTH offsets, and transpose into 4 SIMD double variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 4 for this routine) the input data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Array with offsets to the start of each data point. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>1st component of data, base[align*offset[i]] for each i. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>2nd component of data, base[align*offset[i] + 1] for each i. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v2</td><td>3rd component of data, base[align*offset[i] + 2] for each i. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v3</td><td>4th component of data, base[align*offset[i] + 3] for each i.</td></tr>
  </table>
  </dd>
</dl>
<p>The floating-point memory locations must be aligned, but only to the smaller of four elements and the floating-point SIMD width.</p>
<p>The offset memory must be aligned to GMX_SIMD_DINT32_WIDTH.</p>
<dl class="section note"><dt>Note</dt><dd>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0f9f9c71226ae1d2f0065dd66e1027f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::gatherLoadTranspose </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 4 consecutive floats from each of GMX_SIMD_FLOAT_WIDTH offsets, and transpose into 4 SIMD float variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 4 for this routine) the input data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Array with offsets to the start of each data point. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>1st component of data, base[align*offset[i]] for each i. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>2nd component of data, base[align*offset[i] + 1] for each i. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v2</td><td>3rd component of data, base[align*offset[i] + 2] for each i. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v3</td><td>4th component of data, base[align*offset[i] + 3] for each i.</td></tr>
  </table>
  </dd>
</dl>
<p>The floating-point memory locations must be aligned, but only to the smaller of four elements and the floating-point SIMD width.</p>
<p>The offset memory must be aligned to GMX_SIMD_DINT32_WIDTH.</p>
<dl class="section note"><dt>Note</dt><dd>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </dd></dl>

</div>
</div>
<a class="anchor" id="gad1b51d9220213996033e5dce938c926f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::gatherLoadTranspose </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 2 consecutive double from each of GMX_SIMD_DOUBLE_WIDTH offsets, and transpose into 2 SIMD double variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 2 for this routine) the input data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Array with offsets to the start of each data point. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>1st component of data, base[align*offset[i]] for each i. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>2nd component of data, base[align*offset[i] + 1] for each i.</td></tr>
  </table>
  </dd>
</dl>
<p>The floating-point memory locations must be aligned, but only to the smaller of two elements and the floating-point SIMD width.</p>
<p>The offset memory must be aligned to GMX_SIMD_DINT32_WIDTH.</p>
<dl class="section note"><dt>Note</dt><dd>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6823a0b3cbc43eee3918b137d2b18384"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::gatherLoadTranspose </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 2 consecutive floats from each of GMX_SIMD_FLOAT_WIDTH offsets, and transpose into 2 SIMD float variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 2 for this routine) the input data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Array with offsets to the start of each data point. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>1st component of data, base[align*offset[i]] for each i. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>2nd component of data, base[align*offset[i] + 1] for each i.</td></tr>
  </table>
  </dd>
</dl>
<p>The floating-point memory locations must be aligned, but only to the smaller of two elements and the floating-point SIMD width.</p>
<p>The offset memory must be aligned to GMX_SIMD_FINT32_WIDTH.</p>
<p>To achieve the best possible performance, you should store your data with alignment <a class="el" href="group__module__simd.xhtml#gacc4ad17022538e3d670e55694e55ccc2">c_simdBestPairAlignmentFloat</a> in single, or <a class="el" href="group__module__simd.xhtml#ga9237b6439778ed0fdfd9008a78c25f3c">c_simdBestPairAlignmentDouble</a> in double.</p>
<dl class="section note"><dt>Note</dt><dd>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </dd></dl>

</div>
</div>
<a class="anchor" id="gad15c3a27898a9f9dbb2963dee1a7cacf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::gatherLoadUBySimdIntTranspose </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDInt32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 2 consecutive doubles from each of GMX_SIMD_DOUBLE_WIDTH offsets (unaligned) specified by SIMD integer, transpose into 2 SIMD doubles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 2 for this routine) the input data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Pointer to the start of the memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>SIMD integer type with offsets to the start of each triplet. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>First component, base[align*offset[i]] for each i. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>Second component, base[align*offset[i] + 1] for each i.</td></tr>
  </table>
  </dd>
</dl>
<p>Since some SIMD architectures cannot handle any unaligned loads, this routine is only available if GMX_SIMD_HAVE_GATHER_LOADU_BYSIMDINT_TRANSPOSE is 1.</p>
<dl class="section note"><dt>Note</dt><dd>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </dd>
<dd>
This is a special routine primarily intended for loading Gromacs table data as efficiently as possible - this is the reason for using a SIMD offset index, since the result of the real-to-integer conversion is present in a SIMD register just before calling this routine. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4b26c79db832542ab73a692f7db941c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::gatherLoadUBySimdIntTranspose </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFInt32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 2 consecutive floats from each of GMX_SIMD_FLOAT_WIDTH offsets (unaligned) specified by SIMD integer, transpose into 2 SIMD floats. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 2 for this routine) the input data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Pointer to the start of the memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>SIMD integer type with offsets to the start of each triplet. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>First component, base[align*offset[i]] for each i. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>Second component, base[align*offset[i] + 1] for each i.</td></tr>
  </table>
  </dd>
</dl>
<p>Since some SIMD architectures cannot handle any unaligned loads, this routine is only available if GMX_SIMD_HAVE_GATHER_LOADU_BYSIMDINT_TRANSPOSE is 1.</p>
<dl class="section note"><dt>Note</dt><dd>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </dd>
<dd>
This is a special routine primarily intended for loading Gromacs table data as efficiently as possible - this is the reason for using a SIMD offset index, since the result of the real-to-integer conversion is present in a SIMD register just before calling this routine. </dd></dl>

</div>
</div>
<a class="anchor" id="gaafc4e2f213c40bba66c83e6524445523"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::gatherLoadUTranspose </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 3 consecutive doubles from each of GMX_SIMD_DOUBLE_WIDTH offsets, and transpose into 3 SIMD double variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 3 for this routine) the input data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Array with offsets to the start of each data point. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>1st component of data, base[align*offset[i]] for each i. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>2nd component of data, base[align*offset[i] + 1] for each i. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v2</td><td>3rd component of data, base[align*offset[i] + 2] for each i.</td></tr>
  </table>
  </dd>
</dl>
<p>This function can work with both aligned (better performance) and unaligned memory. When the align parameter is not a power-of-two (align==3 would be normal for packed atomic coordinates) the memory obviously cannot be aligned, and we account for this. However, in the case where align is a power-of-two, we assume the base pointer also has the same alignment, which will enable many platforms to use faster aligned memory load operations. An easy way to think of this is that each triplet of data in memory must be aligned to the align parameter you specify when it's a power-of-two.</p>
<p>The offset memory must always be aligned to GMX_SIMD_FINT32_WIDTH, since this enables us to use SIMD loads and gather operations on platforms that support it.</p>
<dl class="section note"><dt>Note</dt><dd>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </dd>
<dd>
This routine uses a normal array for the offsets, since we typically load this data from memory. On the architectures we have tested this is faster even when a SIMD integer datatype is present. </dd>
<dd>
To improve performance, this function might use full-SIMD-width unaligned loads. This means you need to ensure the memory is padded at the end, so we always can load GMX_SIMD_REAL_WIDTH elements starting at the last offset. If you use the Gromacs aligned memory allocation routines this will always be the case. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa5581add75787fa1304acdac5af0ad7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::gatherLoadUTranspose </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 3 consecutive floats from each of GMX_SIMD_FLOAT_WIDTH offsets, and transpose into 3 SIMD float variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory from which we read, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 3 for this routine) the input data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Array with offsets to the start of each data point. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v0</td><td>1st component of data, base[align*offset[i]] for each i. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>2nd component of data, base[align*offset[i] + 1] for each i. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v2</td><td>3rd component of data, base[align*offset[i] + 2] for each i.</td></tr>
  </table>
  </dd>
</dl>
<p>This function can work with both aligned (better performance) and unaligned memory. When the align parameter is not a power-of-two (align==3 would be normal for packed atomic coordinates) the memory obviously cannot be aligned, and we account for this. However, in the case where align is a power-of-two, we assume the base pointer also has the same alignment, which will enable many platforms to use faster aligned memory load operations. An easy way to think of this is that each triplet of data in memory must be aligned to the align parameter you specify when it's a power-of-two.</p>
<p>The offset memory must always be aligned to GMX_SIMD_FINT32_WIDTH, since this enables us to use SIMD loads and gather operations on platforms that support it.</p>
<dl class="section note"><dt>Note</dt><dd>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </dd>
<dd>
This routine uses a normal array for the offsets, since we typically load this data from memory. On the architectures we have tested this is faster even when a SIMD integer datatype is present. </dd>
<dd>
To improve performance, this function might use full-SIMD-width unaligned loads. This means you need to ensure the memory is padded at the end, so we always can load GMX_SIMD_REAL_WIDTH elements starting at the last offset. If you use the Gromacs aligned memory allocation routines this will always be the case. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6a3c6ca88a6073aba3eb600da20cc92b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::inv </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/x for SIMD float. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument with magnitude larger than GMX_FLOAT_MIN and smaller than GMX_FLOAT_MAX, i.e. within the range of single precision. For the single precision implementation this is obviously always true for positive values, but for double precision it adds an extra restriction since the first lookup step might have to be performed in single precision on some architectures. Note that the responsibility for checking falls on you - this routine does not check arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/x. Result is undefined if your argument was invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="ga698c7785928f003a6f8f0218550ef3af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::inv </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/x for SIMD double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument with magnitude larger than GMX_FLOAT_MIN and smaller than GMX_FLOAT_MAX, i.e. within the range of single precision. For the single precision implementation this is obviously always true for positive values, but for double precision it adds an extra restriction since the first lookup step might have to be performed in single precision on some architectures. Note that the responsibility for checking falls on you - this routine does not check arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/x. Result is undefined if your argument was invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="gad500e0cd00f7c9a8b65448d3a428c57d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::invSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/x for SIMD double, but in single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument with magnitude larger than GMX_FLOAT_MIN and smaller than GMX_FLOAT_MAX, i.e. within the range of single precision. For the single precision implementation this is obviously always true for positive values, but for double precision it adds an extra restriction since the first lookup step might have to be performed in single precision on some architectures. Note that the responsibility for checking falls on you - this routine does not check arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/x. Result is undefined if your argument was invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8db3b7c11cb80b5baca2cd42463e5c8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::invSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/x for SIMD float, only targeting single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument with magnitude larger than GMX_FLOAT_MIN and smaller than GMX_FLOAT_MAX, i.e. within the range of single precision. For the single precision implementation this is obviously always true for positive values, but for double precision it adds an extra restriction since the first lookup step might have to be performed in single precision on some architectures. Note that the responsibility for checking falls on you - this routine does not check arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/x. Result is undefined if your argument was invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1bf9fd932f39d4ad83b360395f1c3986"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::invsqrt </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for SIMD float. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be larger than GMX_FLOAT_MIN and smaller than GMX_FLOAT_MAX, i.e. within the range of single precision. For the single precision implementation this is obviously always true for positive values, but for double precision it adds an extra restriction since the first lookup step might have to be performed in single precision on some architectures. Note that the responsibility for checking falls on you - this routine does not check arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/sqrt(x). Result is undefined if your argument was invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="gae7e05436d95febdcc32866b5e8eca46a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::invsqrt </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for SIMD double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be larger than GMX_FLOAT_MIN and smaller than GMX_FLOAT_MAX, i.e. within the range of single precision. For the single precision implementation this is obviously always true for positive values, but for double precision it adds an extra restriction since the first lookup step might have to be performed in single precision on some architectures. Note that the responsibility for checking falls on you - this routine does not check arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/sqrt(x). Result is undefined if your argument was invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="gab8ed1f98091a17221318dfd97e52c916"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::invsqrt </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for SIMD4 float. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be larger than GMX_FLOAT_MIN and smaller than GMX_FLOAT_MAX, i.e. within the range of single precision. For the single precision implementation this is obviously always true for positive values, but for double precision it adds an extra restriction since the first lookup step might have to be performed in single precision on some architectures. Note that the responsibility for checking falls on you - this routine does not check arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/sqrt(x). Result is undefined if your argument was invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9d84208bf91d57b70761d4c161f2f9de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::invsqrt </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for SIMD4 double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be larger than GMX_FLOAT_MIN and smaller than GMX_FLOAT_MAX, i.e. within the range of single precision. For the single precision implementation this is obviously always true for positive values, but for double precision it adds an extra restriction since the first lookup step might have to be performed in single precision on some architectures. Note that the responsibility for checking falls on you - this routine does not check arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/sqrt(x). Result is undefined if your argument was invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2a4b0a1815e2a09330e4e61444b3f630"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::invsqrtPair </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>out1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for two SIMD floats. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">x0</td><td>First set of arguments, x0 must be in single range (see below). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">x1</td><td>Second set of arguments, x1 must be in single range (see below). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out0</td><td>Result 1/sqrt(x0) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out1</td><td>Result 1/sqrt(x1)</td></tr>
  </table>
  </dd>
</dl>
<p>In particular for double precision we can sometimes calculate square root pairs slightly faster by using single precision until the very last step.</p>
<dl class="section note"><dt>Note</dt><dd>Both arguments must be larger than GMX_FLOAT_MIN and smaller than GMX_FLOAT_MAX, i.e. within the range of single precision. For the single precision implementation this is obviously always true for positive values, but for double precision it adds an extra restriction since the first lookup step might have to be performed in single precision on some architectures. Note that the responsibility for checking falls on you - this routine does not check arguments. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a20afb3111cd1748f262a693338362b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::invsqrtPair </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>out1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for two SIMD doubles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">x0</td><td>First set of arguments, x0 must be in single range (see below). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">x1</td><td>Second set of arguments, x1 must be in single range (see below). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out0</td><td>Result 1/sqrt(x0) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out1</td><td>Result 1/sqrt(x1)</td></tr>
  </table>
  </dd>
</dl>
<p>In particular for double precision we can sometimes calculate square root pairs slightly faster by using single precision until the very last step.</p>
<dl class="section note"><dt>Note</dt><dd>Both arguments must be larger than GMX_FLOAT_MIN and smaller than GMX_FLOAT_MAX, i.e. within the range of single precision. For the single precision implementation this is obviously always true for positive values, but for double precision it adds an extra restriction since the first lookup step might have to be performed in single precision on some architectures. Note that the responsibility for checking falls on you - this routine does not check arguments. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0cde0a4bdb349db5235f05fc93c0441d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::invsqrtPairSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>out1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for two SIMD doubles, but single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">x0</td><td>First set of arguments, x0 must be in single range (see below). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">x1</td><td>Second set of arguments, x1 must be in single range (see below). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out0</td><td>Result 1/sqrt(x0) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out1</td><td>Result 1/sqrt(x1)</td></tr>
  </table>
  </dd>
</dl>
<p>In particular for double precision we can sometimes calculate square root pairs slightly faster by using single precision until the very last step.</p>
<dl class="section note"><dt>Note</dt><dd>Both arguments must be larger than GMX_FLOAT_MIN and smaller than GMX_FLOAT_MAX, i.e. within the range of single precision. For the single precision implementation this is obviously always true for positive values, but for double precision it adds an extra restriction since the first lookup step might have to be performed in single precision on some architectures. Note that the responsibility for checking falls on you - this routine does not check arguments. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3685e3466dd242fee652e51ff27decc7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::invsqrtPairSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>out1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for two SIMD floats, only targeting single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">x0</td><td>First set of arguments, x0 must be in single range (see below). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">x1</td><td>Second set of arguments, x1 must be in single range (see below). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out0</td><td>Result 1/sqrt(x0) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out1</td><td>Result 1/sqrt(x1)</td></tr>
  </table>
  </dd>
</dl>
<p>In particular for double precision we can sometimes calculate square root pairs slightly faster by using single precision until the very last step.</p>
<dl class="section note"><dt>Note</dt><dd>Both arguments must be larger than GMX_FLOAT_MIN and smaller than GMX_FLOAT_MAX, i.e. within the range of single precision. For the single precision implementation this is obviously always true for positive values, but for double precision it adds an extra restriction since the first lookup step might have to be performed in single precision on some architectures. Note that the responsibility for checking falls on you - this routine does not check arguments. </dd></dl>

</div>
</div>
<a class="anchor" id="ga539e3c6e2f58dbd5e59d444707237691"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::invsqrtSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for SIMD double, but in single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be larger than GMX_FLOAT_MIN and smaller than GMX_FLOAT_MAX, i.e. within the range of single precision. For the single precision implementation this is obviously always true for positive values, but for double precision it adds an extra restriction since the first lookup step might have to be performed in single precision on some architectures. Note that the responsibility for checking falls on you - this routine does not check arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/sqrt(x). Result is undefined if your argument was invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0b4da22bcb5cebd8721f180626d11fbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::invsqrtSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for SIMD4 double, but in single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be larger than GMX_FLOAT_MIN and smaller than GMX_FLOAT_MAX, i.e. within the range of single precision. For the single precision implementation this is obviously always true for positive values, but for double precision it adds an extra restriction since the first lookup step might have to be performed in single precision on some architectures. Note that the responsibility for checking falls on you - this routine does not check arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/sqrt(x). Result is undefined if your argument was invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e9692244890665c6dc8f81fc3536f38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::invsqrtSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for SIMD float, only targeting single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be larger than GMX_FLOAT_MIN and smaller than GMX_FLOAT_MAX, i.e. within the range of single precision. For the single precision implementation this is obviously always true for positive values, but for double precision it adds an extra restriction since the first lookup step might have to be performed in single precision on some architectures. Note that the responsibility for checking falls on you - this routine does not check arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/sqrt(x). Result is undefined if your argument was invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="ga63a4c301efefb218bd1256e877610c1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::invsqrtSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for SIMD4 float, only targeting single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be larger than GMX_FLOAT_MIN and smaller than GMX_FLOAT_MAX, i.e. within the range of single precision. For the single precision implementation this is obviously always true for positive values, but for double precision it adds an extra restriction since the first lookup step might have to be performed in single precision on some architectures. Note that the responsibility for checking falls on you - this routine does not check arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/sqrt(x). Result is undefined if your argument was invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0087673fec98bdc89b553f7f349e22d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::iprod </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>ay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>az</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>bx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>bz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float inner product of multiple float vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ax</td><td>X components of first vectors </td></tr>
    <tr><td class="paramname">ay</td><td>Y components of first vectors </td></tr>
    <tr><td class="paramname">az</td><td>Z components of first vectors </td></tr>
    <tr><td class="paramname">bx</td><td>X components of second vectors </td></tr>
    <tr><td class="paramname">by</td><td>Y components of second vectors </td></tr>
    <tr><td class="paramname">bz</td><td>Z components of second vectors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element i will be res[i] = ax[i]*bx[i]+ay[i]*by[i]+az[i]*bz[i].</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The SIMD part is that we calculate many scalar products in one call. </dd></dl>

</div>
</div>
<a class="anchor" id="gacc26031cf2fbf6cb1cee4e38d4cf6e3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::iprod </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>ay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>az</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>bx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>bz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD double inner product of multiple double vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ax</td><td>X components of first vectors </td></tr>
    <tr><td class="paramname">ay</td><td>Y components of first vectors </td></tr>
    <tr><td class="paramname">az</td><td>Z components of first vectors </td></tr>
    <tr><td class="paramname">bx</td><td>X components of second vectors </td></tr>
    <tr><td class="paramname">by</td><td>Y components of second vectors </td></tr>
    <tr><td class="paramname">bz</td><td>Z components of second vectors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element i will be res[i] = ax[i]*bx[i]+ay[i]*by[i]+az[i]*bz[i].</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The SIMD part is that we calculate many scalar products in one call. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0c25c98d5fca0e4c2294d775f75949f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::load4 </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 4 float values from aligned memory into SIMD4 variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Pointer to memory aligned to 4 elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIMD4 variable with data loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="ga66ff320228b17e4c9fbbb61c7acde2eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::load4 </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load 4 double values from aligned memory into SIMD4 variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Pointer to memory aligned to 4 elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIMD4 variable with data loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="ga30c2c73886641040a0f0d5c1f16da97d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::load4U </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load SIMD4 float from unaligned memory. </p>
<p>Available if <a class="el" href="group__module__simd.xhtml#gacf774b2a886d1ed4149f825c50c8fec2">GMX_SIMD_HAVE_LOADU</a> is 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Pointer to memory, no alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIMD4 variable with data loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e92b72e3e3a4f159180cf15da1889c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::load4U </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load SIMD4 double from unaligned memory. </p>
<p>Available if <a class="el" href="group__module__simd.xhtml#gacf774b2a886d1ed4149f825c50c8fec2">GMX_SIMD_HAVE_LOADU</a> is 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Pointer to memory, no alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIMD4 variable with data loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="ga332f838e799c55c26e23126ea2aeace5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::log </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float log(x). This is the natural logarithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, should be &gt;0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural logarithm of x. Undefined if argument is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b6148113de97d3d9e2c9340c72debae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::log </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD double log(x). This is the natural logarithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, should be &gt;0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural logarithm of x. Undefined if argument is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="ga29dcfc4f360ed173f66b26ad9ac3b28b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::logSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD log(x). Double precision SIMD data, single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, should be &gt;0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural logarithm of x. Undefined if argument is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6f81e3b80f7edc6e4f2722a6ee94a5de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::logSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float log(x), only targeting single accuracy. This is the natural logarithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, should be &gt;0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural logarithm of x. Undefined if argument is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="gae1968e5334b953108c682435b6e59694"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::maskzInv </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFBool&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/x for SIMD float, masked version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument with magnitude larger than GMX_FLOAT_MIN and smaller than GMX_FLOAT_MAX for masked-in entries. See <a class="el" href="namespacegmx.xhtml#a953226d61f6527af6485ea56a8384c85">invsqrt</a> for the discussion about argument restrictions. </td></tr>
    <tr><td class="paramname">m</td><td>Mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/x for elements where m is true, or 0.0 for masked-out entries. </dd></dl>

</div>
</div>
<a class="anchor" id="ga91e427c6575308730c135fb8de51a7c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::maskzInv </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDBool&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/x for SIMD double, masked version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument with magnitude larger than GMX_FLOAT_MIN and smaller than GMX_FLOAT_MAX for masked-in entries. See <a class="el" href="namespacegmx.xhtml#a953226d61f6527af6485ea56a8384c85">invsqrt</a> for the discussion about argument restrictions. </td></tr>
    <tr><td class="paramname">m</td><td>Mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/x for elements where m is true, or 0.0 for masked-out entries. </dd></dl>

</div>
</div>
<a class="anchor" id="gaed815c342f2554cecb7045da5ba52e57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::maskzInvSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDBool&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1/x for masked entries of SIMD double, single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument with magnitude larger than GMX_FLOAT_MIN and smaller than GMX_FLOAT_MAX, i.e. within the range of single precision. For the single precision implementation this is obviously always true for positive values, but for double precision it adds an extra restriction since the first lookup step might have to be performed in single precision on some architectures. Note that the responsibility for checking falls on you - this routine does not check arguments.</td></tr>
    <tr><td class="paramname">m</td><td>Mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/x for elements where m is true, or 0.0 for masked-out entries. </dd></dl>

</div>
</div>
<a class="anchor" id="gac6704608858869fb062f53fcc40d7642"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx::maskzInvSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFBool&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/x for masked SIMD floats, only targeting single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument with magnitude larger than GMX_FLOAT_MIN and smaller than GMX_FLOAT_MAX, i.e. within the range of single precision. For the single precision implementation this is obviously always true for positive values, but for double precision it adds an extra restriction since the first lookup step might have to be performed in single precision on some architectures. Note that the responsibility for checking falls on you - this routine does not check arguments. </td></tr>
    <tr><td class="paramname">m</td><td>Mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/x for elements where m is true, or 0.0 for masked-out entries. </dd></dl>

</div>
</div>
<a class="anchor" id="gab41aa57f986f3983040e5f589e3eb07c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx::maskzInvsqrt </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFBool&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for masked entries of SIMD float. </p>
<p>This routine only evaluates 1/sqrt(x) for elements for which mask is true. Illegal values in the masked-out elements will not lead to floating-point exceptions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be larger than GMX_FLOAT_MIN and smaller than GMX_FLOAT_MAX for masked-in entries. See <a class="el" href="namespacegmx.xhtml#a953226d61f6527af6485ea56a8384c85">invsqrt</a> for the discussion about argument restrictions. </td></tr>
    <tr><td class="paramname">m</td><td>Mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/sqrt(x). Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3342ee008526f40deb602eb1024ba895"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx::maskzInvsqrt </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDBool&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for masked entries of SIMD double. </p>
<p>This routine only evaluates 1/sqrt(x) for elements for which mask is true. Illegal values in the masked-out elements will not lead to floating-point exceptions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be larger than GMX_FLOAT_MIN and smaller than GMX_FLOAT_MAX for masked-in entries. See <a class="el" href="namespacegmx.xhtml#a953226d61f6527af6485ea56a8384c85">invsqrt</a> for the discussion about argument restrictions. </td></tr>
    <tr><td class="paramname">m</td><td>Mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/sqrt(x). Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries. </dd></dl>

</div>
</div>
<a class="anchor" id="ga19373a6a16b4e74441b86bdcabe1bbcb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx::maskzInvsqrtSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDBool&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1/sqrt(x) for masked-in entries of SIMD double, but in single accuracy. </p>
<p>This routine only evaluates 1/sqrt(x) for elements for which mask is true. Illegal values in the masked-out elements will not lead to floating-point exceptions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be larger than GMX_FLOAT_MIN and smaller than GMX_FLOAT_MAX, i.e. within the range of single precision. For the single precision implementation this is obviously always true for positive values, but for double precision it adds an extra restriction since the first lookup step might have to be performed in single precision on some architectures. Note that the responsibility for checking falls on you - this routine does not check arguments.</td></tr>
    <tr><td class="paramname">m</td><td>Mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/sqrt(x). Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7e6086a4db51ceeeb8fe18e8884248f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx::maskzInvsqrtSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFBool&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate 1/sqrt(x) for masked SIMD floats, only targeting single accuracy. </p>
<p>This routine only evaluates 1/sqrt(x) for elements for which mask is true. Illegal values in the masked-out elements will not lead to floating-point exceptions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be larger than GMX_FLOAT_MIN and smaller than GMX_FLOAT_MAX, i.e. within the range of single precision. For the single precision implementation this is obviously always true for positive values, but for double precision it adds an extra restriction since the first lookup step might have to be performed in single precision on some architectures. Note that the responsibility for checking falls on you - this routine does not check arguments. </td></tr>
    <tr><td class="paramname">m</td><td>Mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1/sqrt(x). Result is undefined if your argument was invalid or entry was not masked, and 0.0 for masked-out entries. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3c66081dde9666200461f364725a4085"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::max </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set each SIMD4 element to the largest from two variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Any floating-point value </td></tr>
    <tr><td class="paramname">b</td><td>Any floating-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>max(a,b) for each element. </dd></dl>

</div>
</div>
<a class="anchor" id="ga68bbfb58d0ab7d2362d0efde15c14ca3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::max </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set each SIMD4 element to the largest from two variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Any floating-point value </td></tr>
    <tr><td class="paramname">b</td><td>Any floating-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>max(a,b) for each element. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2da2e85aea6a6eef4add06627566b8ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::min </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set each SIMD4 element to the largest from two variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Any floating-point value </td></tr>
    <tr><td class="paramname">b</td><td>Any floating-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>max(a,b) for each element. </dd></dl>

</div>
</div>
<a class="anchor" id="gacf515651ecc6efcf3ec65a8ff488ea02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::min </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set each SIMD4 element to the largest from two variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Any floating-point value </td></tr>
    <tr><td class="paramname">b</td><td>Any floating-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>max(a,b) for each element. </dd></dl>

</div>
</div>
<a class="anchor" id="ga86f01f74a7ab4156ec123146fd0b7de7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::norm2 </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>ay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>az</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float norm squared of multiple vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ax</td><td>X components of vectors </td></tr>
    <tr><td class="paramname">ay</td><td>Y components of vectors </td></tr>
    <tr><td class="paramname">az</td><td>Z components of vectors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element i will be res[i] = ax[i]*ax[i]+ay[i]*ay[i]+az[i]*az[i].</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This corresponds to the scalar product of the vector with itself, but the compiler might be able to optimize it better with identical vectors. </dd></dl>

</div>
</div>
<a class="anchor" id="ga689e3ff037f04bcf9d3c3bfc896d50f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::norm2 </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>ay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>az</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD double norm squared of multiple vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ax</td><td>X components of vectors </td></tr>
    <tr><td class="paramname">ay</td><td>Y components of vectors </td></tr>
    <tr><td class="paramname">az</td><td>Z components of vectors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element i will be res[i] = ax[i]*ax[i]+ay[i]*ay[i]+az[i]*az[i].</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This corresponds to the scalar product of the vector with itself, but the compiler might be able to optimize it better with identical vectors. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5aaaf08ce309b237501775f56590ee53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::norm2 </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>ay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>az</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD4 float norm squared of multiple vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ax</td><td>X components of vectors </td></tr>
    <tr><td class="paramname">ay</td><td>Y components of vectors </td></tr>
    <tr><td class="paramname">az</td><td>Z components of vectors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element i will be res[i] = ax[i]*ax[i]+ay[i]*ay[i]+az[i]*az[i].</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This corresponds to the scalar product of the vector with itself, but the compiler might be able to optimize it better with identical vectors. </dd></dl>

</div>
</div>
<a class="anchor" id="gae78d49a68930c6290f4fadd7f02b77e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::norm2 </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>ay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>az</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD4 double norm squared of multiple vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ax</td><td>X components of vectors </td></tr>
    <tr><td class="paramname">ay</td><td>Y components of vectors </td></tr>
    <tr><td class="paramname">az</td><td>Z components of vectors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element i will be res[i] = ax[i]*ax[i]+ay[i]*ay[i]+az[i]*az[i].</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This corresponds to the scalar product of the vector with itself, but the compiler might be able to optimize it better with identical vectors. </dd></dl>

</div>
</div>
<a class="anchor" id="gaabe89c1073d64ee649e9cd7b37c85e2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4FBool gmx_simdcall gmx::operator!= </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a!=b for SIMD4 float </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>value1 </td></tr>
    <tr><td class="paramname">b</td><td>value2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Each element of the boolean will be set to true if a!=b. </dd></dl>

</div>
</div>
<a class="anchor" id="ga55e1d875f190a65651a57df761799027"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4DBool gmx_simdcall gmx::operator!= </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a!=b for SIMD4 double </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>value1 </td></tr>
    <tr><td class="paramname">b</td><td>value2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Each element of the boolean will be set to true if a!=b. </dd></dl>

</div>
</div>
<a class="anchor" id="gab1b1d6f3300a808b8b3a3b516dd39b15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise and for two SIMD4 float variables. </p>
<p>Supported if <a class="el" href="group__module__simd.xhtml#gaf002483e94d5f42de1d5105cf924f8b8">GMX_SIMD_HAVE_LOGICAL</a> is 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>data1 </td></tr>
    <tr><td class="paramname">b</td><td>data2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>data1 &amp; data2 </dd></dl>

</div>
</div>
<a class="anchor" id="ga0d555bbdc50b7b523ef3f0e6383808ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise and for two SIMD4 double variables. </p>
<p>Supported if <a class="el" href="group__module__simd.xhtml#gaf002483e94d5f42de1d5105cf924f8b8">GMX_SIMD_HAVE_LOGICAL</a> is 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>data1 </td></tr>
    <tr><td class="paramname">b</td><td>data2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>data1 &amp; data2 </dd></dl>

</div>
</div>
<a class="anchor" id="gab72a2c3a96ed9681d4df89e38ec1583e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4FBool gmx_simdcall gmx::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">Simd4FBool&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4FBool&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logical <em>and</em> on single precision SIMD4 booleans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>logical vars 1 </td></tr>
    <tr><td class="paramname">b</td><td>logical vars 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>For each element, the result boolean is true if a &amp; b are true.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is not necessarily a bitwise operation - the storage format of booleans is implementation-dependent. </dd></dl>

</div>
</div>
<a class="anchor" id="gaacd2b1a31c667bffa467f02e57b191e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4DBool gmx_simdcall gmx::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">Simd4DBool&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4DBool&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logical <em>and</em> on single precision SIMD4 booleans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>logical vars 1 </td></tr>
    <tr><td class="paramname">b</td><td>logical vars 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>For each element, the result boolean is true if a &amp; b are true.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is not necessarily a bitwise operation - the storage format of booleans is implementation-dependent. </dd></dl>

</div>
</div>
<a class="anchor" id="ga42f5e1c65d65ad34afa31b6d0e5f7c7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::operator* </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two SIMD4 variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a*b. </dd></dl>

</div>
</div>
<a class="anchor" id="ga59d8295d88c9f60db412cb53eb47b768"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::operator* </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two SIMD4 variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>factor1 </td></tr>
    <tr><td class="paramname">b</td><td>factor2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a*b. </dd></dl>

</div>
</div>
<a class="anchor" id="ga07f6ab30b594fa03c4975bed7bffab81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::operator+ </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add two double SIMD4 variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>term1 </td></tr>
    <tr><td class="paramname">b</td><td>term2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a+b </dd></dl>

</div>
</div>
<a class="anchor" id="gafd943dd0c83fa26c6eb5805ad5025e17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::operator+ </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add two float SIMD4 variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>term1 </td></tr>
    <tr><td class="paramname">b</td><td>term2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a+b </dd></dl>

</div>
</div>
<a class="anchor" id="gadb00887996b2ed9e672c7b556c53cb98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::operator- </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract two SIMD4 variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>term1 </td></tr>
    <tr><td class="paramname">b</td><td>term2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a-b </dd></dl>

</div>
</div>
<a class="anchor" id="gab08e1e219e78b06a60cc995ae663dbab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::operator- </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract two SIMD4 variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>term1 </td></tr>
    <tr><td class="paramname">b</td><td>term2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a-b </dd></dl>

</div>
</div>
<a class="anchor" id="ga4b75b800db84a744c11534a41f3c08c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::operator- </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD4 floating-point negate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>SIMD4 floating-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-a </dd></dl>

</div>
</div>
<a class="anchor" id="gaad9353fb4bd3db4bb232f65d47a6abcf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::operator- </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD4 floating-point negate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>SIMD4 floating-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-a </dd></dl>

</div>
</div>
<a class="anchor" id="ga0f60c988e122306d212679a83bd12910"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::operator/ </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>nom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>denom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division for SIMD floats. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nom</td><td>Nominator </td></tr>
    <tr><td class="paramname">denom</td><td>Denominator, with magnitude in range (GMX_FLOAT_MIN,GMX_FLOAT_MAX). For single precision this is equivalent to a nonzero argument, but in double precision it adds an extra restriction since the first lookup step might have to be performed in single precision on some architectures. Note that the responsibility for checking falls on you - this routine does not check arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nom/denom</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function does not use any masking to avoid problems with zero values in the denominator. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0d5275903c74226798172bd46bac3e87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::operator/ </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>nom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>denom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division for SIMD doubles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nom</td><td>Nominator </td></tr>
    <tr><td class="paramname">denom</td><td>Denominator, with magnitude in range (GMX_FLOAT_MIN,GMX_FLOAT_MAX). For single precision this is equivalent to a nonzero argument, but in double precision it adds an extra restriction since the first lookup step might have to be performed in single precision on some architectures. Note that the responsibility for checking falls on you - this routine does not check arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nom/denom</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function does not use any masking to avoid problems with zero values in the denominator. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf02163d0cb41985160b79503ef1d53d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4FBool gmx_simdcall gmx::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a&lt;b for SIMD4 float </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>value1 </td></tr>
    <tr><td class="paramname">b</td><td>value2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Each element of the boolean will be set to true if a&lt;b. </dd></dl>

</div>
</div>
<a class="anchor" id="ga161caa368bcf9f1d566b6bbb81b23a5f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4DBool gmx_simdcall gmx::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a&lt;b for SIMD4 double </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>value1 </td></tr>
    <tr><td class="paramname">b</td><td>value2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Each element of the boolean will be set to true if a&lt;b. </dd></dl>

</div>
</div>
<a class="anchor" id="ga46491dc3239fcdcd48c55e00184c81ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4FBool gmx_simdcall gmx::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a&lt;=b for SIMD4 float. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>value1 </td></tr>
    <tr><td class="paramname">b</td><td>value2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Each element of the boolean will be set to true if a&lt;=b. </dd></dl>

</div>
</div>
<a class="anchor" id="ga65c76bc6290f217b5fce5d5538c5f342"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4DBool gmx_simdcall gmx::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a&lt;=b for SIMD4 double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>value1 </td></tr>
    <tr><td class="paramname">b</td><td>value2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Each element of the boolean will be set to true if a&lt;=b. </dd></dl>

</div>
</div>
<a class="anchor" id="gae817b7cf5e876f1c6357e14a4666a3c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4FBool gmx_simdcall gmx::operator== </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a==b for SIMD4 float </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>value1 </td></tr>
    <tr><td class="paramname">b</td><td>value2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Each element of the boolean will be set to true if a==b. </dd></dl>

</div>
</div>
<a class="anchor" id="ga905fa4e11c1b9d4628ea5bdeeed3ca77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4DBool gmx_simdcall gmx::operator== </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a==b for SIMD4 double </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>value1 </td></tr>
    <tr><td class="paramname">b</td><td>value2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Each element of the boolean will be set to true if a==b. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8385ef4b8312eff3f715d2f817604e51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::operator^ </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise xor for two SIMD4 float variables. </p>
<p>Available if <a class="el" href="group__module__simd.xhtml#gaf002483e94d5f42de1d5105cf924f8b8">GMX_SIMD_HAVE_LOGICAL</a> is 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>data1 </td></tr>
    <tr><td class="paramname">b</td><td>data2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>data1 ^ data2 </dd></dl>

</div>
</div>
<a class="anchor" id="gaad7bb7baf5edd91a8707584c9cdc086e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::operator^ </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise xor for two SIMD4 double variables. </p>
<p>Available if <a class="el" href="group__module__simd.xhtml#gaf002483e94d5f42de1d5105cf924f8b8">GMX_SIMD_HAVE_LOGICAL</a> is 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>data1 </td></tr>
    <tr><td class="paramname">b</td><td>data2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>data1 ^ data2 </dd></dl>

</div>
</div>
<a class="anchor" id="gad759e852213903c61d6d4b9053e794fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::operator| </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise or for two SIMD4 floats. </p>
<p>Available if <a class="el" href="group__module__simd.xhtml#gaf002483e94d5f42de1d5105cf924f8b8">GMX_SIMD_HAVE_LOGICAL</a> is 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>data1 </td></tr>
    <tr><td class="paramname">b</td><td>data2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>data1 | data2 </dd></dl>

</div>
</div>
<a class="anchor" id="gabcaa9a287c021ad7e3507311ffe23497"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::operator| </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise or for two SIMD4 doubles. </p>
<p>Available if <a class="el" href="group__module__simd.xhtml#gaf002483e94d5f42de1d5105cf924f8b8">GMX_SIMD_HAVE_LOGICAL</a> is 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>data1 </td></tr>
    <tr><td class="paramname">b</td><td>data2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>data1 | data2 </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2ab4b4f3d3e7f6e9a012df64c1d9f3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4FBool gmx_simdcall gmx::operator|| </td>
          <td>(</td>
          <td class="paramtype">Simd4FBool&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4FBool&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logical <em>or</em> on single precision SIMD4 booleans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>logical vars 1 </td></tr>
    <tr><td class="paramname">b</td><td>logical vars 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>For each element, the result boolean is true if a or b is true.</dd></dl>
<p>Note that this is not necessarily a bitwise operation - the storage format of booleans is implementation-dependent. </p>

</div>
</div>
<a class="anchor" id="ga5d5483d15fe15e3c3eaf1e4e90e53f90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4DBool gmx_simdcall gmx::operator|| </td>
          <td>(</td>
          <td class="paramtype">Simd4DBool&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4DBool&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logical <em>or</em> on single precision SIMD4 booleans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>logical vars 1 </td></tr>
    <tr><td class="paramname">b</td><td>logical vars 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>For each element, the result boolean is true if a or b is true.</dd></dl>
<p>Note that this is not necessarily a bitwise operation - the storage format of booleans is implementation-dependent. </p>

</div>
</div>
<a class="anchor" id="gae7ea15fc154a3be2831f786b660b8a6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::pmeForceCorrection </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>z2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the force correction due to PME analytically in SIMD float. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z2</td><td><img class="formulaInl" alt="$(r \beta)^2$" src="form_12.png"/> - see below for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Correction factor to coulomb force - see below for details.</dd></dl>
<p>This routine is meant to enable analytical evaluation of the direct-space PME electrostatic force to avoid tables.</p>
<p>The direct-space potential should be <img class="formulaInl" alt="$ \mbox{erfc}(\beta r)/r$" src="form_13.png"/>, but there are some problems evaluating that:</p>
<p>First, the error function is difficult (read: expensive) to approxmiate accurately for intermediate to large arguments, and this happens already in ranges of <img class="formulaInl" alt="$(\beta r)$" src="form_14.png"/> that occur in simulations. Second, we now try to avoid calculating potentials in Gromacs but use forces directly.</p>
<p>We can simply things slight by noting that the PME part is really a correction to the normal Coulomb force since <img class="formulaInl" alt="$\mbox{erfc}(z)=1-\mbox{erf}(z)$" src="form_15.png"/>, i.e. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ V = \frac{1}{r} - \frac{\mbox{erf}(\beta r)}{r} \]" src="form_16.png"/>
</p>
<p> The first term we already have from the inverse square root, so that we can leave out of this routine.</p>
<p>For pme tolerances of 1e-3 to 1e-8 and cutoffs of 0.5nm to 1.8nm, the argument <img class="formulaInl" alt="$beta r$" src="form_17.png"/> will be in the range 0.15 to ~4, which is the range used for the minimax fit. Use your favorite plotting program to realize how well-behaved <img class="formulaInl" alt="$\frac{\mbox{erf}(z)}{z}$" src="form_18.png"/> is in this range!</p>
<p>We approximate <img class="formulaInl" alt="$f(z)=\mbox{erf}(z)/z$" src="form_19.png"/> with a rational minimax polynomial. However, it turns out it is more efficient to approximate <img class="formulaInl" alt="$f(z)/z$" src="form_20.png"/> and then only use even powers. This is another minor optimization, since we actually <em>want</em> <img class="formulaInl" alt="$f(z)/z$" src="form_20.png"/>, because it is going to be multiplied by the vector between the two atoms to get the vectorial force. The fastest flops are the ones we can avoid calculating!</p>
<p>So, here's how it should be used:</p>
<ol type="1">
<li>Calculate <img class="formulaInl" alt="$r^2$" src="form_21.png"/>.</li>
<li>Multiply by <img class="formulaInl" alt="$\beta^2$" src="form_22.png"/>, so you get <img class="formulaInl" alt="$z^2=(\beta r)^2$" src="form_23.png"/>.</li>
<li>Evaluate this routine with <img class="formulaInl" alt="$z^2$" src="form_24.png"/> as the argument.</li>
<li><p class="startli">The return value is the expression:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{2 \exp{-z^2}}{\sqrt{\pi} z^2}-\frac{\mbox{erf}(z)}{z^3} \]" src="form_25.png"/>
</p>
</li>
<li><p class="startli">Multiply the entire expression by <img class="formulaInl" alt="$\beta^3$" src="form_26.png"/>. This will get you</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{2 \beta^3 \exp(-z^2)}{\sqrt{\pi} z^2} - \frac{\beta^3 \mbox{erf}(z)}{z^3} \]" src="form_27.png"/>
</p>
<p class="startli">or, switching back to <img class="formulaInl" alt="$r$" src="form_28.png"/> (since <img class="formulaInl" alt="$z=r \beta$" src="form_29.png"/>):</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{2 \beta \exp(-r^2 \beta^2)}{\sqrt{\pi} r^2} - \frac{\mbox{erf}(r \beta)}{r^3} \]" src="form_30.png"/>
</p>
<p class="startli">With a bit of math exercise you should be able to confirm that this is exactly</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\frac{d}{dr}\left( \frac{\mbox{erf}(\beta r)}{r} \right)}{r} \]" src="form_31.png"/>
</p>
</li>
<li>Add the result to <img class="formulaInl" alt="$r^{-3}$" src="form_32.png"/>, multiply by the product of the charges, and you have your force (divided by <img class="formulaInl" alt="$r$" src="form_28.png"/>). A final multiplication with the vector connecting the two particles and you have your vectorial force to add to the particles.</li>
</ol>
<p>This approximation achieves an error slightly lower than 1e-6 in single precision and 1e-11 in double precision for arguments smaller than 16 ( <img class="formulaInl" alt="$\beta r \leq 4 $" src="form_33.png"/>); when added to <img class="formulaInl" alt="$1/r$" src="form_34.png"/> the error will be insignificant. For <img class="formulaInl" alt="$\beta r \geq 7206$" src="form_35.png"/> the return value can be inf or NaN. </p>

</div>
</div>
<a class="anchor" id="gad35bd0d2751d6097b63b26b7077ad53c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::pmeForceCorrection </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>z2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the force correction due to PME analytically in SIMD double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z2</td><td>This should be the value <img class="formulaInl" alt="$(r \beta)^2$" src="form_12.png"/>, where r is your interaction distance and beta the ewald splitting parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Correction factor to coulomb force.</dd></dl>
<p>This routine is meant to enable analytical evaluation of the direct-space PME electrostatic force to avoid tables. For details, see the single precision function. </p>

</div>
</div>
<a class="anchor" id="ga7c64f03842963e248fba796bead3c5ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::pmeForceCorrectionSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>z2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Analytical PME force correction, double SIMD data, single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z2</td><td><img class="formulaInl" alt="$(r \beta)^2$" src="form_12.png"/> - see below for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Correction factor to coulomb force - see below for details.</dd></dl>
<p>This routine is meant to enable analytical evaluation of the direct-space PME electrostatic force to avoid tables.</p>
<p>The direct-space potential should be <img class="formulaInl" alt="$ \mbox{erfc}(\beta r)/r$" src="form_13.png"/>, but there are some problems evaluating that:</p>
<p>First, the error function is difficult (read: expensive) to approxmiate accurately for intermediate to large arguments, and this happens already in ranges of <img class="formulaInl" alt="$(\beta r)$" src="form_14.png"/> that occur in simulations. Second, we now try to avoid calculating potentials in Gromacs but use forces directly.</p>
<p>We can simply things slight by noting that the PME part is really a correction to the normal Coulomb force since <img class="formulaInl" alt="$\mbox{erfc}(z)=1-\mbox{erf}(z)$" src="form_15.png"/>, i.e. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ V = \frac{1}{r} - \frac{\mbox{erf}(\beta r)}{r} \]" src="form_16.png"/>
</p>
<p> The first term we already have from the inverse square root, so that we can leave out of this routine.</p>
<p>For pme tolerances of 1e-3 to 1e-8 and cutoffs of 0.5nm to 1.8nm, the argument <img class="formulaInl" alt="$beta r$" src="form_17.png"/> will be in the range 0.15 to ~4. Use your favorite plotting program to realize how well-behaved <img class="formulaInl" alt="$\frac{\mbox{erf}(z)}{z}$" src="form_18.png"/> is in this range!</p>
<p>We approximate <img class="formulaInl" alt="$f(z)=\mbox{erf}(z)/z$" src="form_19.png"/> with a rational minimax polynomial. However, it turns out it is more efficient to approximate <img class="formulaInl" alt="$f(z)/z$" src="form_20.png"/> and then only use even powers. This is another minor optimization, since we actually <em>want</em> <img class="formulaInl" alt="$f(z)/z$" src="form_20.png"/>, because it is going to be multiplied by the vector between the two atoms to get the vectorial force. The fastest flops are the ones we can avoid calculating!</p>
<p>So, here's how it should be used:</p>
<ol type="1">
<li>Calculate <img class="formulaInl" alt="$r^2$" src="form_21.png"/>.</li>
<li>Multiply by <img class="formulaInl" alt="$\beta^2$" src="form_22.png"/>, so you get <img class="formulaInl" alt="$z^2=(\beta r)^2$" src="form_23.png"/>.</li>
<li>Evaluate this routine with <img class="formulaInl" alt="$z^2$" src="form_24.png"/> as the argument.</li>
<li><p class="startli">The return value is the expression:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{2 \exp{-z^2}}{\sqrt{\pi} z^2}-\frac{\mbox{erf}(z)}{z^3} \]" src="form_25.png"/>
</p>
</li>
<li><p class="startli">Multiply the entire expression by <img class="formulaInl" alt="$\beta^3$" src="form_26.png"/>. This will get you</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{2 \beta^3 \exp(-z^2)}{\sqrt{\pi} z^2} - \frac{\beta^3 \mbox{erf}(z)}{z^3} \]" src="form_27.png"/>
</p>
<p class="startli">or, switching back to <img class="formulaInl" alt="$r$" src="form_28.png"/> (since <img class="formulaInl" alt="$z=r \beta$" src="form_29.png"/>):</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{2 \beta \exp(-r^2 \beta^2)}{\sqrt{\pi} r^2} - \frac{\mbox{erf}(r \beta)}{r^3} \]" src="form_30.png"/>
</p>
<p class="startli">With a bit of math exercise you should be able to confirm that this is exactly</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\frac{d}{dr}\left( \frac{\mbox{erf}(\beta r)}{r} \right)}{r} \]" src="form_31.png"/>
</p>
</li>
<li>Add the result to <img class="formulaInl" alt="$r^{-3}$" src="form_32.png"/>, multiply by the product of the charges, and you have your force (divided by <img class="formulaInl" alt="$r$" src="form_28.png"/>). A final multiplication with the vector connecting the two particles and you have your vectorial force to add to the particles.</li>
</ol>
<p>This approximation achieves an accuracy slightly lower than 1e-6; when added to <img class="formulaInl" alt="$1/r$" src="form_34.png"/> the error will be insignificant. </p>

</div>
</div>
<a class="anchor" id="ga50c70d6df3435d9235cdf34589f9225c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::pmeForceCorrectionSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>z2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD Analytic PME force correction, only targeting single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z2</td><td><img class="formulaInl" alt="$(r \beta)^2$" src="form_12.png"/> - see default single precision version for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Correction factor to coulomb force. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5324a396c60387bdb3cf42e734f6b465"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::pmePotentialCorrection </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>z2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the potential correction due to PME analytically in SIMD float. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z2</td><td><img class="formulaInl" alt="$(r \beta)^2$" src="form_12.png"/> - see below for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Correction factor to coulomb potential - see below for details.</dd></dl>
<p>See <a class="el" href="namespacegmx.xhtml#a1e5b1230d0301fa6760e34d7641ca7e4">pmeForceCorrection</a> for details about the approximation.</p>
<p>This routine calculates <img class="formulaInl" alt="$\mbox{erf}(z)/z$" src="form_36.png"/>, although you should provide <img class="formulaInl" alt="$z^2$" src="form_24.png"/> as the input argument.</p>
<p>Here's how it should be used:</p>
<ol type="1">
<li>Calculate <img class="formulaInl" alt="$r^2$" src="form_21.png"/>.</li>
<li>Multiply by <img class="formulaInl" alt="$\beta^2$" src="form_22.png"/>, so you get <img class="formulaInl" alt="$z^2=\beta^2*r^2$" src="form_37.png"/>.</li>
<li>Evaluate this routine with z^2 as the argument.</li>
<li><p class="startli">The return value is the expression:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\mbox{erf}(z)}{z} \]" src="form_38.png"/>
</p>
</li>
<li><p class="startli">Multiply the entire expression by beta and switching back to <img class="formulaInl" alt="$r$" src="form_28.png"/> (since <img class="formulaInl" alt="$z=r \beta$" src="form_29.png"/>):</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\mbox{erf}(r \beta)}{r} \]" src="form_39.png"/>
</p>
</li>
<li>Subtract the result from <img class="formulaInl" alt="$1/r$" src="form_34.png"/>, multiply by the product of the charges, and you have your potential.</li>
</ol>
<p>This approximation achieves an error slightly lower than 1e-6 in single precision and 4e-11 in double precision for arguments smaller than 16 ( <img class="formulaInl" alt="$ 0.15 \leq \beta r \leq 4 $" src="form_40.png"/>); for <img class="formulaInl" alt="$ \beta r \leq 0.15$" src="form_41.png"/> the error can be twice as high; when added to <img class="formulaInl" alt="$1/r$" src="form_34.png"/> the error will be insignificant. For <img class="formulaInl" alt="$\beta r \geq 7142$" src="form_42.png"/> the return value can be inf or NaN. </p>

</div>
</div>
<a class="anchor" id="ga6e52f9306e036285c0a9ac5f55565cc0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::pmePotentialCorrection </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>z2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the potential correction due to PME analytically in SIMD double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z2</td><td>This should be the value <img class="formulaInl" alt="$(r \beta)^2$" src="form_12.png"/>, where r is your interaction distance and beta the ewald splitting parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Correction factor to coulomb force.</dd></dl>
<p>This routine is meant to enable analytical evaluation of the direct-space PME electrostatic potential to avoid tables. For details, see the single precision function. </p>

</div>
</div>
<a class="anchor" id="gad079618800dfdfb943ca73f89f63d45e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::pmePotentialCorrectionSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>z2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Analytical PME potential correction, double SIMD data, single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z2</td><td><img class="formulaInl" alt="$(r \beta)^2$" src="form_12.png"/> - see below for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Correction factor to coulomb potential - see below for details.</dd></dl>
<p>This routine calculates <img class="formulaInl" alt="$\mbox{erf}(z)/z$" src="form_36.png"/>, although you should provide <img class="formulaInl" alt="$z^2$" src="form_24.png"/> as the input argument.</p>
<p>Here's how it should be used:</p>
<ol type="1">
<li>Calculate <img class="formulaInl" alt="$r^2$" src="form_21.png"/>.</li>
<li>Multiply by <img class="formulaInl" alt="$\beta^2$" src="form_22.png"/>, so you get <img class="formulaInl" alt="$z^2=\beta^2*r^2$" src="form_37.png"/>.</li>
<li>Evaluate this routine with z^2 as the argument.</li>
<li><p class="startli">The return value is the expression:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\mbox{erf}(z)}{z} \]" src="form_38.png"/>
</p>
</li>
<li><p class="startli">Multiply the entire expression by beta and switching back to <img class="formulaInl" alt="$r$" src="form_28.png"/> (since <img class="formulaInl" alt="$z=r \beta$" src="form_29.png"/>):</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\mbox{erf}(r \beta)}{r} \]" src="form_39.png"/>
</p>
</li>
<li>Subtract the result from <img class="formulaInl" alt="$1/r$" src="form_34.png"/>, multiply by the product of the charges, and you have your potential.</li>
</ol>
<p>This approximation achieves an accuracy slightly lower than 1e-6; when added to <img class="formulaInl" alt="$1/r$" src="form_34.png"/> the error will be insignificant. </p>

</div>
</div>
<a class="anchor" id="gaf555c7f9fb09586e8c809283b8210ed0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::pmePotentialCorrectionSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>z2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD Analytic PME potential correction, only targeting single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z2</td><td><img class="formulaInl" alt="$(r \beta)^2$" src="form_12.png"/> - see default single precision version for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Correction factor to coulomb force. </dd></dl>

</div>
</div>
<a class="anchor" id="ga85e439a79e5b92d8544451b8c1ba41f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::rcpIter </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>lu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform one Newton-Raphson iteration to improve 1/x for SIMD float. </p>
<p>This is a low-level routine that should only be used by SIMD math routine that evaluates the reciprocal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lu</td><td>Approximation of 1/x, typically obtained from lookup. </td></tr>
    <tr><td class="paramname">x</td><td>The reference (starting) value x for which we want 1/x. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An improved approximation with roughly twice as many bits of accuracy. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa0f0ffc8730b377743e0b5433d4e2f1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::rcpIter </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>lu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform one Newton-Raphson iteration to improve 1/x for SIMD double. </p>
<p>This is a low-level routine that should only be used by SIMD math routine that evaluates the reciprocal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lu</td><td>Approximation of 1/x, typically obtained from lookup. </td></tr>
    <tr><td class="paramname">x</td><td>The reference (starting) value x for which we want 1/x. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An improved approximation with roughly twice as many bits of accuracy. </dd></dl>

</div>
</div>
<a class="anchor" id="ga072c4a40acda5dbbd28687df84331335"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx_simdcall gmx::reduce </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return sum of all elements in SIMD4 float variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>SIMD4 variable to reduce/sum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of all elements in the argument variable. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5ee526de5755cc7bb8d7c46c532483e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx_simdcall gmx::reduce </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return sum of all elements in SIMD4 double variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>SIMD4 variable to reduce/sum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of all elements in the argument variable. </dd></dl>

</div>
</div>
<a class="anchor" id="gace1c53e05ba045977e06eb98778c0123"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double gmx_simdcall gmx::reduceIncr4ReturnSum </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce each of four SIMD doubles, add those values to four consecutive doubles in memory, return sum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Pointer to memory where four doubles should be incremented </td></tr>
    <tr><td class="paramname">v0</td><td>SIMD variable whose sum should be added to m[0] </td></tr>
    <tr><td class="paramname">v1</td><td>SIMD variable whose sum should be added to m[1] </td></tr>
    <tr><td class="paramname">v2</td><td>SIMD variable whose sum should be added to m[2] </td></tr>
    <tr><td class="paramname">v3</td><td>SIMD variable whose sum should be added to m[3]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of all elements in the four SIMD variables.</dd></dl>
<p>The pointer m must be aligned to the smaller of four elements and the floating-point SIMD width.</p>
<dl class="section note"><dt>Note</dt><dd>This is a special routine intended for the Gromacs nonbonded kernels. It is used in the epilogue of the outer loop, where the variables will contain unrolled forces for one outer-loop-particle each, corresponding to a single coordinate (i.e, say, four x-coordinate force variables). These should be summed and added to the force array in memory. Since we always work with contiguous SIMD-layout , we can use efficient aligned loads/stores. When calculating the virial, we also need the total sum of all forces for each coordinate. This is provided as the return value. For routines that do not need these, this extra code will be optimized away completely if you just ignore the return value (Checked with gcc-4.9.1 and clang-3.6 for AVX). </dd></dl>

</div>
</div>
<a class="anchor" id="ga1e64aefa14afa2f473c4db52e82d4a99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float gmx_simdcall gmx::reduceIncr4ReturnSum </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce each of four SIMD floats, add those values to four consecutive floats in memory, return sum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Pointer to memory where four floats should be incremented </td></tr>
    <tr><td class="paramname">v0</td><td>SIMD variable whose sum should be added to m[0] </td></tr>
    <tr><td class="paramname">v1</td><td>SIMD variable whose sum should be added to m[1] </td></tr>
    <tr><td class="paramname">v2</td><td>SIMD variable whose sum should be added to m[2] </td></tr>
    <tr><td class="paramname">v3</td><td>SIMD variable whose sum should be added to m[3]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of all elements in the four SIMD variables.</dd></dl>
<p>The pointer m must be aligned to the smaller of four elements and the floating-point SIMD width.</p>
<dl class="section note"><dt>Note</dt><dd>This is a special routine intended for the Gromacs nonbonded kernels. It is used in the epilogue of the outer loop, where the variables will contain unrolled forces for one outer-loop-particle each, corresponding to a single coordinate (i.e, say, four x-coordinate force variables). These should be summed and added to the force array in memory. Since we always work with contiguous SIMD-layout , we can use efficient aligned loads/stores. When calculating the virial, we also need the total sum of all forces for each coordinate. This is provided as the return value. For routines that do not need these, this extra code will be optimized away completely if you just ignore the return value (Checked with gcc-4.9.1 and clang-3.6 for AVX). </dd></dl>

</div>
</div>
<a class="anchor" id="gacf1bf91a0d1377886282a96f558798c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::round </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD4 Round to nearest integer value (in floating-point format). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Any floating-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The nearest integer, represented in floating-point format. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3b425556720d8ff72c1998c86c777e75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::round </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD4 Round to nearest integer value (in floating-point format). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Any floating-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The nearest integer, represented in floating-point format. </dd></dl>

</div>
</div>
<a class="anchor" id="ga535ead71c3aeb4caaae55d6aefc78799"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::rsqrt </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD4 1.0/sqrt(x) lookup. </p>
<p>This is a low-level instruction that should only be called from routines implementing the inverse square root in <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, x&gt;0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Approximation of 1/sqrt(x), accuracy is <a class="el" href="group__module__simd.xhtml#ga7e207d56564fc020b246563d09214aac">GMX_SIMD_RSQRT_BITS</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaae4a6def215dcf244fcba8ba06eb1f26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::rsqrt </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD4 1.0/sqrt(x) lookup. </p>
<p>This is a low-level instruction that should only be called from routines implementing the inverse square root in <a class="el" href="simd__math_8h.xhtml" title="Math functions for SIMD datatypes. ">simd_math.h</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument, x&gt;0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Approximation of 1/sqrt(x), accuracy is <a class="el" href="group__module__simd.xhtml#ga7e207d56564fc020b246563d09214aac">GMX_SIMD_RSQRT_BITS</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gade7401625051e95c057a8f5fe6dc5fbc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::rsqrtIter </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>lu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform one Newton-Raphson iteration to improve 1/sqrt(x) for SIMD float. </p>
<p>This is a low-level routine that should only be used by SIMD math routine that evaluates the inverse square root.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lu</td><td>Approximation of 1/sqrt(x), typically obtained from lookup. </td></tr>
    <tr><td class="paramname">x</td><td>The reference (starting) value x for which we want 1/sqrt(x). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An improved approximation with roughly twice as many bits of accuracy. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9dfcf89d49e6e2f75f1249972f2e270f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::rsqrtIter </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>lu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform one Newton-Raphson iteration to improve 1/sqrt(x) for SIMD double. </p>
<p>This is a low-level routine that should only be used by SIMD math routine that evaluates the inverse square root.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lu</td><td>Approximation of 1/sqrt(x), typically obtained from lookup. </td></tr>
    <tr><td class="paramname">x</td><td>The reference (starting) value x for which we want 1/sqrt(x). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An improved approximation with roughly twice as many bits of accuracy. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4be9c1041c5ce806e1262c9469a4a625"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::rsqrtIter </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>lu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform one Newton-Raphson iteration to improve 1/sqrt(x) for SIMD4 float. </p>
<p>This is a low-level routine that should only be used by SIMD math routine that evaluates the inverse square root.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lu</td><td>Approximation of 1/sqrt(x), typically obtained from lookup. </td></tr>
    <tr><td class="paramname">x</td><td>The reference (starting) value x for which we want 1/sqrt(x). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An improved approximation with roughly twice as many bits of accuracy. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4b6db4a7ce63f7c3c6e7a0d3008dea6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::rsqrtIter </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>lu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform one Newton-Raphson iteration to improve 1/sqrt(x) for SIMD4 double. </p>
<p>This is a low-level routine that should only be used by SIMD math routine that evaluates the inverse square root.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lu</td><td>Approximation of 1/sqrt(x), typically obtained from lookup. </td></tr>
    <tr><td class="paramname">x</td><td>The reference (starting) value x for which we want 1/sqrt(x). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An improved approximation with roughly twice as many bits of accuracy. </dd></dl>

</div>
</div>
<a class="anchor" id="ga76ed0866ac21967e0a9641acca32ab50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::selectByMask </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4FBool&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select from single precision SIMD4 variable where boolean is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Floating-point variable to select from </td></tr>
    <tr><td class="paramname">mask</td><td>Boolean selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>For each element, a is selected for true, 0 for false. </dd></dl>

</div>
</div>
<a class="anchor" id="ga223de776671702527c62b4da8f6e570a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::selectByMask </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4DBool&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select from single precision SIMD4 variable where boolean is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Floating-point variable to select from </td></tr>
    <tr><td class="paramname">mask</td><td>Boolean selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>For each element, a is selected for true, 0 for false. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaff9aa6673f42b4d0d4f3b154deac384"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::selectByNotMask </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4FBool&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select from single precision SIMD4 variable where boolean is false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Floating-point variable to select from </td></tr>
    <tr><td class="paramname">mask</td><td>Boolean selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>For each element, a is selected for false, 0 for true (sic). </dd></dl>

</div>
</div>
<a class="anchor" id="ga388cbdee2056718a2d23b3080d4c9b84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::selectByNotMask </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4DBool&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select from single precision SIMD4 variable where boolean is false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Floating-point variable to select from </td></tr>
    <tr><td class="paramname">mask</td><td>Boolean selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>For each element, a is selected for false, 0 for true (sic). </dd></dl>

</div>
</div>
<a class="anchor" id="gac88aa19e4c856c2333bf814c3521c488"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::simd4SetZeroD </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all SIMD4 double elements to 0. </p>
<p>You should typically just call <a class="el" href="namespacegmx.xhtml#a1b9689c4629a14843a0464a0053c8e9e">gmx::setZero()</a>, which uses proxy objects internally to handle all types rather than adding the suffix used here.</p>
<dl class="section return"><dt>Returns</dt><dd>SIMD4 0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="gafa583e5ea332a308e773ad9422e0d080"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::simd4SetZeroF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all SIMD4 float elements to 0. </p>
<p>You should typically just call <a class="el" href="namespacegmx.xhtml#a1b9689c4629a14843a0464a0053c8e9e">gmx::setZero()</a>, which uses proxy objects internally to handle all types rather than adding the suffix used here.</p>
<dl class="section return"><dt>Returns</dt><dd>SIMD4 0.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ga9ef875418e7985b298af5f6d58f32e23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::sin </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float sin(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate sin for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sin(x)</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Do NOT call both sin &amp; cos if you need both results, since each of them will then call <a class="el" href="namespacegmx.xhtml#a3191310c1a122aafe946f0caf2fdf364">sincos</a> and waste a factor 2 in performance. </dd></dl>

</div>
</div>
<a class="anchor" id="gab860ef109b42bb7e0ce25bdc304e8492"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::sin </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD double sin(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate sin for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sin(x)</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Do NOT call both sin &amp; cos if you need both results, since each of them will then call <a class="el" href="namespacegmx.xhtml#a3191310c1a122aafe946f0caf2fdf364">sincos</a> and waste a factor 2 in performance. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2640bfdb9db1762df1b5da82d80e73b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::sincos </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>sinval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>cosval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float sin &amp; cos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">x</td><td>The argument to evaluate sin/cos for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sinval</td><td>Sin(x) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cosval</td><td>Cos(x)</td></tr>
  </table>
  </dd>
</dl>
<p>This version achieves close to machine precision, but for very large magnitudes of the argument we inherently begin to lose accuracy due to the argument reduction, despite using extended precision arithmetics internally. </p>

</div>
</div>
<a class="anchor" id="ga532aa17b3c80780baf5c123eb64cf645"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::sincos </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>sinval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>cosval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD double sin &amp; cos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">x</td><td>The argument to evaluate sin/cos for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sinval</td><td>Sin(x) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cosval</td><td>Cos(x)</td></tr>
  </table>
  </dd>
</dl>
<p>This version achieves close to machine precision, but for very large magnitudes of the argument we inherently begin to lose accuracy due to the argument reduction, despite using extended precision arithmetics internally. </p>

</div>
</div>
<a class="anchor" id="ga80d8d17a5843dfa4126ce3d6672d2c5d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::sinCosSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>sinval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble *&#160;</td>
          <td class="paramname"><em>cosval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD sin &amp; cos. Double precision SIMD data, single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">x</td><td>The argument to evaluate sin/cos for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sinval</td><td>Sin(x) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cosval</td><td>Cos(x) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6afcbeed45441fb9624fece5906b8a17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::sinCosSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>sinval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat *&#160;</td>
          <td class="paramname"><em>cosval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float sin &amp; cos, only targeting single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">x</td><td>The argument to evaluate sin/cos for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sinval</td><td>Sin(x) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cosval</td><td>Cos(x) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga322afd1e05781ae2cd10ec6fdb1fb2be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::sinSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD sin(x). Double precision SIMD data, single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate sin for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sin(x)</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Do NOT call both sin &amp; cos if you need both results, since each of them will then call <a class="el" href="namespacegmx.xhtml#a3191310c1a122aafe946f0caf2fdf364">sincos</a> and waste a factor 2 in performance. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0ba00dcc0a9e1342d1af6952e0d2e1e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::sinSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float sin(x), only targeting single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate sin for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sin(x)</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Do NOT call both sin &amp; cos if you need both results, since each of them will then call <a class="el" href="namespacegmx.xhtml#a3191310c1a122aafe946f0caf2fdf364">sincos</a> and waste a factor 2 in performance. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf84cf0860622bb52d9ef8d62563a7815"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MathOptimization opt = MathOptimization::Safe&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::sqrt </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate sqrt(x) for SIMD floats. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">opt</td><td>By default, this function checks if the input value is 0.0 and masks this to return the correct result. If you are certain your argument will never be zero, and you know you need to save every single cycle you can, you can alternatively call the function as sqrt&lt;MathOptimization::Unsafe&gt;(x).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be in range 0 &lt;=x &lt;= GMX_FLOAT_MAX, since the lookup step often has to be implemented in single precision. Arguments smaller than GMX_FLOAT_MIN will always lead to a zero result, even in double precision. If you are using the unsafe math optimization parameter, the argument must be in the range GMX_FLOAT_MIN &lt;= x &lt;= GMX_FLOAT_MAX.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sqrt(x). The result is undefined if the input value does not fall in the allowed range specified for the argument. </dd></dl>

</div>
</div>
<a class="anchor" id="ga784105c21023a67e981521b259481730"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MathOptimization opt = MathOptimization::Safe&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::sqrt </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate sqrt(x) for SIMD doubles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">opt</td><td>By default, this function checks if the input value is 0.0 and masks this to return the correct result. If you are certain your argument will never be zero, and you know you need to save every single cycle you can, you can alternatively call the function as sqrt&lt;MathOptimization::Unsafe&gt;(x).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be in range 0 &lt;=x &lt;= GMX_FLOAT_MAX, since the lookup step often has to be implemented in single precision. Arguments smaller than GMX_FLOAT_MIN will always lead to a zero result, even in double precision. If you are using the unsafe math optimization parameter, the argument must be in the range GMX_FLOAT_MIN &lt;= x &lt;= GMX_FLOAT_MAX.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sqrt(x). The result is undefined if the input value does not fall in the allowed range specified for the argument. </dd></dl>

</div>
</div>
<a class="anchor" id="ga645dad540cadbef1d60a831d41c46cfe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MathOptimization opt = MathOptimization::Safe&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::sqrtSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate sqrt(x) (correct for 0.0) for SIMD double, with single accuracy. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">opt</td><td>By default, this function checks if the input value is 0.0 and masks this to return the correct result. If you are certain your argument will never be zero, and you know you need to save every single cycle you can, you can alternatively call the function as sqrt&lt;MathOptimization::Unsafe&gt;(x).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be in range 0 &lt;=x &lt;= GMX_FLOAT_MAX, since the lookup step often has to be implemented in single precision. Arguments smaller than GMX_FLOAT_MIN will always lead to a zero result, even in double precision. If you are using the unsafe math optimization parameter, the argument must be in the range GMX_FLOAT_MIN &lt;= x &lt;= GMX_FLOAT_MAX.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sqrt(x). The result is undefined if the input value does not fall in the allowed range specified for the argument. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3f7d261e770760618221865c64cc4e4c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MathOptimization opt = MathOptimization::Safe&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::sqrtSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate sqrt(x) for SIMD float, always targeting single accuracy. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">opt</td><td>By default, this function checks if the input value is 0.0 and masks this to return the correct result. If you are certain your argument will never be zero, and you know you need to save every single cycle you can, you can alternatively call the function as sqrt&lt;MathOptimization::Unsafe&gt;(x).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument that must be in range 0 &lt;=x &lt;= GMX_FLOAT_MAX, since the lookup step often has to be implemented in single precision. Arguments smaller than GMX_FLOAT_MIN will always lead to a zero result, even in double precision. If you are using the unsafe math optimization parameter, the argument must be in the range GMX_FLOAT_MIN &lt;= x &lt;= GMX_FLOAT_MAX.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sqrt(x). The result is undefined if the input value does not fall in the allowed range specified for the argument. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf6c0b04d40ff74a4ad39c24f9fd3da20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::store4 </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store the contents of SIMD4 double to aligned memory m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>Pointer to memory, aligned to 4 elements. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>SIMD4 variable to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafc95fcf592b08dfca9aabc44cf994ece"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::store4 </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store the contents of SIMD4 float to aligned memory m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>Pointer to memory, aligned to 4 elements. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>SIMD4 variable to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8a91843f00041c799a995535a7cdc12f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::store4U </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store SIMD4 float to unaligned memory. </p>
<p>Available if <a class="el" href="group__module__simd.xhtml#ga38ee3ad2fadedbafff3129df1e7c15b4">GMX_SIMD_HAVE_STOREU</a> is 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>Pointer to memory, no alignment requirement. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>SIMD4 variable to store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga61ae7be76c3865fcfe038dd2457a09cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::store4U </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store SIMD4 double to unaligned memory. </p>
<p>Available if <a class="el" href="group__module__simd.xhtml#ga38ee3ad2fadedbafff3129df1e7c15b4">GMX_SIMD_HAVE_STOREU</a> is 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>Pointer to memory, no alignment requirement. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>SIMD4 variable to store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa9b029f69c4afa8bbe7941990507d0f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::tan </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float tan(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate tan for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tan(x) </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f1b0a83035fb507f2827fb510fcf084"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::tan </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD double tan(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate tan for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tan(x) </dd></dl>

</div>
</div>
<a class="anchor" id="ga97094c3429db78b1a101aa994a69f162"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdDouble gmx_simdcall gmx::tanSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD tan(x). Double precision SIMD data, single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate tan for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tan(x) </dd></dl>

</div>
</div>
<a class="anchor" id="ga6a534183c1fe54e0eccabbff0000990b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimdFloat gmx_simdcall gmx::tanSingleAccuracy </td>
          <td>(</td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD float tan(x), only targeting single accuracy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument to evaluate tan for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tan(x) </dd></dl>

</div>
</div>
<a class="anchor" id="ga059f7a354565ad8c1494853ec9a00d3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::transpose </td>
          <td>(</td>
          <td class="paramtype">Simd4Float *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Float *&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD4 float transpose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">v0</td><td>Row 0 on input, column 0 on output </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">v1</td><td>Row 1 on input, column 1 on output </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">v2</td><td>Row 2 on input, column 2 on output </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">v3</td><td>Row 3 on input, column 3 on output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf7a690a2d884f1210349194e3c07a5a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::transpose </td>
          <td>(</td>
          <td class="paramtype">Simd4Double *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Simd4Double *&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD4 double transpose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">v0</td><td>Row 0 on input, column 0 on output </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">v1</td><td>Row 1 on input, column 1 on output </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">v2</td><td>Row 2 on input, column 2 on output </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">v3</td><td>Row 3 on input, column 3 on output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga15283d6034452bcbee9c5f7538d7b560"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::transposeScatterDecrU </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transpose and subtract 3 SIMD doubles to 3 consecutive addresses at GMX_SIMD_DOUBLE_WIDTH offsets. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 3 for this routine) the output data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">base</td><td>Pointer to start of memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Aligned array with offsets to the start of each triplet. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v0</td><td>1st component, subtracted from base[align*offset[i]] </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v1</td><td>2nd component, subtracted from base[align*offset[i]+1] </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v2</td><td>3rd component, subtracted from base[align*offset[i]+2]</td></tr>
  </table>
  </dd>
</dl>
<p>This function can work with both aligned (better performance) and unaligned memory. When the align parameter is not a power-of-two (align==3 would be normal for packed atomic coordinates) the memory obviously cannot be aligned, and we account for this. However, in the case where align is a power-of-two, we assume the base pointer also has the same alignment, which will enable many platforms to use faster aligned memory load/store operations. An easy way to think of this is that each triplet of data in memory must be aligned to the align parameter you specify when it's a power-of-two.</p>
<p>The offset memory must always be aligned to GMX_SIMD_FINT32_WIDTH, since this enables us to use SIMD loads and gather operations on platforms that support it.</p>
<dl class="section note"><dt>Note</dt><dd>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </dd>
<dd>
This routine uses a normal array for the offsets, since we typically load the data from memory. On the architectures we have tested this is faster even when a SIMD integer datatype is present. </dd>
<dd>
To improve performance, this function might use full-SIMD-width unaligned load/store, and subtract 0.0 from the extra elements. This means you need to ensure the memory is padded at the end, so we always can load GMX_SIMD_REAL_WIDTH elements starting at the last offset. If you use the Gromacs aligned memory allocation routines this will always be the case. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6889b6665cbfc5fa0bce09fe5db5e49c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::transposeScatterDecrU </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transpose and subtract 3 SIMD floats to 3 consecutive addresses at GMX_SIMD_FLOAT_WIDTH offsets. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 3 for this routine) the output data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">base</td><td>Pointer to start of memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Aligned array with offsets to the start of each triplet. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v0</td><td>1st component, subtracted from base[align*offset[i]] </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v1</td><td>2nd component, subtracted from base[align*offset[i]+1] </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v2</td><td>3rd component, subtracted from base[align*offset[i]+2]</td></tr>
  </table>
  </dd>
</dl>
<p>This function can work with both aligned (better performance) and unaligned memory. When the align parameter is not a power-of-two (align==3 would be normal for packed atomic coordinates) the memory obviously cannot be aligned, and we account for this. However, in the case where align is a power-of-two, we assume the base pointer also has the same alignment, which will enable many platforms to use faster aligned memory load/store operations. An easy way to think of this is that each triplet of data in memory must be aligned to the align parameter you specify when it's a power-of-two.</p>
<p>The offset memory must always be aligned to GMX_SIMD_FINT32_WIDTH, since this enables us to use SIMD loads and gather operations on platforms that support it.</p>
<dl class="section note"><dt>Note</dt><dd>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </dd>
<dd>
This routine uses a normal array for the offsets, since we typically load the data from memory. On the architectures we have tested this is faster even when a SIMD integer datatype is present. </dd>
<dd>
To improve performance, this function might use full-SIMD-width unaligned load/store, and subtract 0.0 from the extra elements. This means you need to ensure the memory is padded at the end, so we always can load GMX_SIMD_REAL_WIDTH elements starting at the last offset. If you use the Gromacs aligned memory allocation routines this will always be the case. </dd></dl>

</div>
</div>
<a class="anchor" id="gaecbb196e76a516c1e3672a8fa0df6f87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::transposeScatterIncrU </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transpose and add 3 SIMD doubles to 3 consecutive addresses at GMX_SIMD_DOUBLE_WIDTH offsets. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 3 for this routine) the output data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Aligned array with offsets to the start of each triplet. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v0</td><td>1st component of triplets, added to base[align*offset[i]]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v1</td><td>2nd component of triplets, added to base[align*offset[i] + 1]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v2</td><td>3rd component of triplets, added to base[align*offset[i] + 2].</td></tr>
  </table>
  </dd>
</dl>
<p>This function can work with both aligned (better performance) and unaligned memory. When the align parameter is not a power-of-two (align==3 would be normal for packed atomic coordinates) the memory obviously cannot be aligned, and we account for this. However, in the case where align is a power-of-two, we assume the base pointer also has the same alignment, which will enable many platforms to use faster aligned memory load/store operations. An easy way to think of this is that each triplet of data in memory must be aligned to the align parameter you specify when it's a power-of-two.</p>
<p>The offset memory must always be aligned to GMX_SIMD_FINT32_WIDTH, since this enables us to use SIMD loads and gather operations on platforms that support it.</p>
<dl class="section note"><dt>Note</dt><dd>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </dd>
<dd>
This routine uses a normal array for the offsets, since we typically load the data from memory. On the architectures we have tested this is faster even when a SIMD integer datatype is present. </dd>
<dd>
To improve performance, this function might use full-SIMD-width unaligned load/store, and add 0.0 to the extra elements. This means you need to ensure the memory is padded at the end, so we always can load GMX_SIMD_REAL_WIDTH elements starting at the last offset. If you use the Gromacs aligned memory allocation routines this will always be the case. </dd></dl>

</div>
</div>
<a class="anchor" id="gac36c2fd8a466fb309ba9ae1dbf8dffbd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::transposeScatterIncrU </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transpose and add 3 SIMD floats to 3 consecutive addresses at GMX_SIMD_FLOAT_WIDTH offsets. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 3 for this routine) the output data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Aligned array with offsets to the start of each triplet. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v0</td><td>1st component of triplets, added to base[align*offset[i]]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v1</td><td>2nd component of triplets, added to base[align*offset[i] + 1]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v2</td><td>3rd component of triplets, added to base[align*offset[i] + 2].</td></tr>
  </table>
  </dd>
</dl>
<p>This function can work with both aligned (better performance) and unaligned memory. When the align parameter is not a power-of-two (align==3 would be normal for packed atomic coordinates) the memory obviously cannot be aligned, and we account for this. However, in the case where align is a power-of-two, we assume the base pointer also has the same alignment, which will enable many platforms to use faster aligned memory load/store operations. An easy way to think of this is that each triplet of data in memory must be aligned to the align parameter you specify when it's a power-of-two.</p>
<p>The offset memory must always be aligned to GMX_SIMD_FINT32_WIDTH, since this enables us to use SIMD loads and gather operations on platforms that support it.</p>
<dl class="section note"><dt>Note</dt><dd>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </dd>
<dd>
This routine uses a normal array for the offsets, since we typically load the data from memory. On the architectures we have tested this is faster even when a SIMD integer datatype is present. </dd>
<dd>
To improve performance, this function might use full-SIMD-width unaligned load/store, and add 0.0 to the extra elements. This means you need to ensure the memory is padded at the end, so we always can load GMX_SIMD_REAL_WIDTH elements starting at the last offset. If you use the Gromacs aligned memory allocation routines this will always be the case. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa23e5431ddc22611d3304ac96c461cc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::transposeScatterStoreU </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdDouble&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transpose and store 3 SIMD doubles to 3 consecutive addresses at GMX_SIMD_DOUBLE_WIDTH offsets. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 3 for this routine) the output data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Aligned array with offsets to the start of each triplet. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v0</td><td>1st component of triplets, written to base[align*offset[i]]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v1</td><td>2nd component of triplets, written to base[align*offset[i] + 1]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v2</td><td>3rd component of triplets, written to base[align*offset[i] + 2].</td></tr>
  </table>
  </dd>
</dl>
<p>This function can work with both aligned (better performance) and unaligned memory. When the align parameter is not a power-of-two (align==3 would be normal for packed atomic coordinates) the memory obviously cannot be aligned, and we account for this. However, in the case where align is a power-of-two, we assume the base pointer also has the same alignment, which will enable many platforms to use faster aligned memory store operations. An easy way to think of this is that each triplet of data in memory must be aligned to the align parameter you specify when it's a power-of-two.</p>
<p>The offset memory must always be aligned to GMX_SIMD_FINT32_WIDTH, since this enables us to use SIMD loads and gather operations on platforms that support it.</p>
<dl class="section note"><dt>Note</dt><dd>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </dd>
<dd>
This routine uses a normal array for the offsets, since we typically load the data from memory. On the architectures we have tested this is faster even when a SIMD integer datatype is present. </dd></dl>

</div>
</div>
<a class="anchor" id="gaba67dbea2a790730dfa78999209959b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gmx_simdcall gmx::transposeScatterStoreU </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>offset</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimdFloat&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transpose and store 3 SIMD floats to 3 consecutive addresses at GMX_SIMD_FLOAT_WIDTH offsets. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">align</td><td>Alignment of the memory to which we write, i.e. distance (measured in elements, not bytes) between index points. When this is identical to the number of SIMD variables (i.e., 3 for this routine) the output data is packed without padding in memory. See the SIMD parameters for exactly what memory positions are written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">base</td><td>Pointer to the start of the memory area </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Aligned array with offsets to the start of each triplet. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v0</td><td>1st component of triplets, written to base[align*offset[i]]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v1</td><td>2nd component of triplets, written to base[align*offset[i] + 1]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v2</td><td>3rd component of triplets, written to base[align*offset[i] + 2].</td></tr>
  </table>
  </dd>
</dl>
<p>This function can work with both aligned (better performance) and unaligned memory. When the align parameter is not a power-of-two (align==3 would be normal for packed atomic coordinates) the memory obviously cannot be aligned, and we account for this. However, in the case where align is a power-of-two, we assume the base pointer also has the same alignment, which will enable many platforms to use faster aligned memory store operations. An easy way to think of this is that each triplet of data in memory must be aligned to the align parameter you specify when it's a power-of-two.</p>
<p>The offset memory must always be aligned to GMX_SIMD_FINT32_WIDTH, since this enables us to use SIMD loads and gather operations on platforms that support it.</p>
<dl class="section note"><dt>Note</dt><dd>You should NOT scale offsets before calling this routine; it is done internally by using the alignment template parameter instead. </dd>
<dd>
This routine uses a normal array for the offsets, since we typically load the data from memory. On the architectures we have tested this is faster even when a SIMD integer datatype is present. </dd></dl>

</div>
</div>
<a class="anchor" id="ga97c12b8d0415b8633da6b48f437d6078"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Float gmx_simdcall gmx::trunc </td>
          <td>(</td>
          <td class="paramtype">Simd4Float&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncate SIMD4, i.e. round towards zero - common hardware instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Any floating-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer rounded towards zero, represented in floating-point format.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is truncation towards zero, not floor(). The reason for this is that truncation is virtually always present as a dedicated hardware instruction, but floor() frequently isn't. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4383bb9ab1055fc9888e65655db350ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Simd4Double gmx_simdcall gmx::trunc </td>
          <td>(</td>
          <td class="paramtype">Simd4Double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncate SIMD4, i.e. round towards zero - common hardware instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Any floating-point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer rounded towards zero, represented in floating-point format.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is truncation towards zero, not floor(). The reason for this is that truncation is virtually always present as a dedicated hardware instruction, but floor() frequently isn't. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga9237b6439778ed0fdfd9008a78c25f3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int gmx::c_simdBestPairAlignmentDouble = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Best alignment to use for aligned pairs of double data. </p>
<p>The routines to load and transpose data will work with a wide range of alignments, but some might be faster than others, depending on the load instructions available in the hardware. This specifies the best alignment for each implementation when working with pairs of data.</p>
<p>To allow each architecture to use the most optimal form, we use a constant that code outside the SIMD module should use to store things properly. It must be at least 2. For example, a value of 2 means the two parameters A &amp; B are stored as [A0 B0 A1 B1] while align-4 means [A0 B0 - - A1 B1 - -].</p>
<p>This alignment depends on the efficiency of partial-register load/store operations, and will depend on the architecture. </p>

</div>
</div>
<a class="anchor" id="gacc4ad17022538e3d670e55694e55ccc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int gmx::c_simdBestPairAlignmentFloat = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Best alignment to use for aligned pairs of float data. </p>
<p>The routines to load and transpose data will work with a wide range of alignments, but some might be faster than others, depending on the load instructions available in the hardware. This specifies the best alignment for each implementation when working with pairs of data.</p>
<p>To allow each architecture to use the most optimal form, we use a constant that code outside the SIMD module should use to store things properly. It must be at least 2. For example, a value of 2 means the two parameters A &amp; B are stored as [A0 B0 A1 B1] while align-4 means [A0 B0 - - A1 B1 - -].</p>
<p>This alignment depends on the efficiency of partial-register load/store operations, and will depend on the architecture. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 23 2018 14:56:12 for Gromacs by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
