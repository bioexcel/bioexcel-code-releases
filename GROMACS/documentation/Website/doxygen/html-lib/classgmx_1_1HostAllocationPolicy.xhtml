<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Gromacs: gmx::HostAllocationPolicy Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Gromacs
   &#160;<span id="projectnumber">2018.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.xhtml"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.xhtml"><span>Modules</span></a></li>
      <li><a href="pages.xhtml"><span>Other&#160;Docs</span></a></li>
      <li><a href="namespaces.xhtml"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.xhtml"><span>Classes</span></a></li>
      <li><a href="files.xhtml"><span>Files</span></a></li>
      <li><a href="examples.xhtml"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.xhtml"><span>Class&#160;List</span></a></li>
      <li><a href="classes.xhtml"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.xhtml"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.xhtml"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegmx.xhtml">gmx</a></li><li class="navelem"><a class="el" href="classgmx_1_1HostAllocationPolicy.xhtml">HostAllocationPolicy</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classgmx_1_1HostAllocationPolicy-members.xhtml">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">gmx::HostAllocationPolicy Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;gromacs/gpu_utils/hostallocator.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Policy class for configuring <a class="el" href="classgmx_1_1Allocator.xhtml" title="Policy-based memory allocator. ">gmx::Allocator</a>, to manage allocations of memory that may be needed for e.g. GPU transfers. </p>
<p>This allocator has state, so is most useful in cases where it is not known at compile time whether the allocated memory will be transferred to some device. It will increase the size of containers that use it. If the GROMACS build is configured with CUDA support, then memory will be allocated with PageAlignedAllocator, and that page pinned to physical memory if the pinning mode has been activated. If pinning mode is deactivated, or the GROMACS build does not support CUDA, then the memory will be allocated with AlignedAllocator. The <a class="el" href="classgmx_1_1HostAllocationPolicy.xhtml#a7c860b64868b432e71f9a2ab28426244" title="Pin the allocation to physical memory, if appropriate. ">pin()</a> and <a class="el" href="classgmx_1_1HostAllocationPolicy.xhtml#af5d51a9c9df85a8b402a3451c51d17c5" title="Unpin the allocation, if appropriate. ">unpin()</a> methods work with the CUDA build, and silently do nothing otherwise. In future, we may modify or generalize this to work differently in other cases.</p>
<p>The intended use is to configure <a class="el" href="classgmx_1_1Allocator.xhtml" title="Policy-based memory allocator. ">gmx::Allocator</a> with this class as its policy class, and then to use e.g. std::vector::get_allocator().getPolicy() to control whether the allocation policy should activate its pinning mode. The policy object can also be used to explicitly <a class="el" href="classgmx_1_1HostAllocationPolicy.xhtml#a7c860b64868b432e71f9a2ab28426244" title="Pin the allocation to physical memory, if appropriate. ">pin()</a> and <a class="el" href="classgmx_1_1HostAllocationPolicy.xhtml#af5d51a9c9df85a8b402a3451c51d17c5" title="Unpin the allocation, if appropriate. ">unpin()</a> the buffer when it is using PinningPolicy::CanBePinned. The policy object is returned by value (as required by the C++ standard for get_allocator(), which copies a std::shared_ptr, so the policy object should be retrieved sparingly, e.g. only upon resize of the allocation. (Normal operation of the vector, e.g. during resize, incurs only the cost of the pointer indirection needed to consult the current state of the allocation policy.)</p>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000029">Todo:</a></b></dt><dd>As a minor optimization, consider also having a stateless version of this policy, which might be slightly faster or more convenient to use in the cases where it is known at compile time that the allocation will be used to transfer to a GPU. </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab694e3975366f5f27938cc8f1f159452"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab694e3975366f5f27938cc8f1f159452"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1HostAllocationPolicy.xhtml#ab694e3975366f5f27938cc8f1f159452">propagate_on_container_copy_assignment</a> = std::true_type</td></tr>
<tr class="memdesc:ab694e3975366f5f27938cc8f1f159452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify an allocator trait so that the stateful allocator should propagate. <br/></td></tr>
<tr class="separator:ab694e3975366f5f27938cc8f1f159452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad784820686c118595c511a1c323ada53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad784820686c118595c511a1c323ada53"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1HostAllocationPolicy.xhtml#ad784820686c118595c511a1c323ada53">propagate_on_container_move_assignment</a> = std::true_type</td></tr>
<tr class="memdesc:ad784820686c118595c511a1c323ada53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify an allocator trait so that the stateful allocator should propagate. <br/></td></tr>
<tr class="separator:ad784820686c118595c511a1c323ada53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1941ab26a2198c5395d662cbe56e9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd1941ab26a2198c5395d662cbe56e9e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1HostAllocationPolicy.xhtml#afd1941ab26a2198c5395d662cbe56e9e">propagate_on_container_swap</a> = std::true_type</td></tr>
<tr class="memdesc:afd1941ab26a2198c5395d662cbe56e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify an allocator trait so that the stateful allocator should propagate. <br/></td></tr>
<tr class="separator:afd1941ab26a2198c5395d662cbe56e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a75f628187457259e4bef03bbe7fde9cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75f628187457259e4bef03bbe7fde9cd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1HostAllocationPolicy.xhtml#a75f628187457259e4bef03bbe7fde9cd">HostAllocationPolicy</a> ()</td></tr>
<tr class="memdesc:a75f628187457259e4bef03bbe7fde9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr class="separator:a75f628187457259e4bef03bbe7fde9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09a9975745638737d4eec33dd9463ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab09a9975745638737d4eec33dd9463ef"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1HostAllocationPolicy.xhtml#ab09a9975745638737d4eec33dd9463ef">alignment</a> ()</td></tr>
<tr class="memdesc:ab09a9975745638737d4eec33dd9463ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the alignment size currently used by the active pinning policy. <br/></td></tr>
<tr class="separator:ab09a9975745638737d4eec33dd9463ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea041287228e8b33c288bd9b3713b6c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1HostAllocationPolicy.xhtml#abea041287228e8b33c288bd9b3713b6c">malloc</a> (std::size_t bytes) const noexcept</td></tr>
<tr class="memdesc:abea041287228e8b33c288bd9b3713b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and perhaps pin page-aligned memory suitable for e.g. GPU transfers.  <a href="#abea041287228e8b33c288bd9b3713b6c">More...</a><br/></td></tr>
<tr class="separator:abea041287228e8b33c288bd9b3713b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9eebd779172275fb09af48d4985fb4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1HostAllocationPolicy.xhtml#ae9eebd779172275fb09af48d4985fb4d">free</a> (void *buffer) const noexcept</td></tr>
<tr class="memdesc:ae9eebd779172275fb09af48d4985fb4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the memory, after unpinning (if appropriate).  <a href="#ae9eebd779172275fb09af48d4985fb4d">More...</a><br/></td></tr>
<tr class="separator:ae9eebd779172275fb09af48d4985fb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c860b64868b432e71f9a2ab28426244"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1HostAllocationPolicy.xhtml#a7c860b64868b432e71f9a2ab28426244">pin</a> () const noexcept</td></tr>
<tr class="memdesc:a7c860b64868b432e71f9a2ab28426244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pin the allocation to physical memory, if appropriate.  <a href="#a7c860b64868b432e71f9a2ab28426244">More...</a><br/></td></tr>
<tr class="separator:a7c860b64868b432e71f9a2ab28426244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d51a9c9df85a8b402a3451c51d17c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1HostAllocationPolicy.xhtml#af5d51a9c9df85a8b402a3451c51d17c5">unpin</a> () const noexcept</td></tr>
<tr class="memdesc:af5d51a9c9df85a8b402a3451c51d17c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpin the allocation, if appropriate.  <a href="#af5d51a9c9df85a8b402a3451c51d17c5">More...</a><br/></td></tr>
<tr class="separator:af5d51a9c9df85a8b402a3451c51d17c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac568d5bd9864470a4a95cff8a0859b12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegmx.xhtml#abe4caed0469c0de84e0c1c1a81972b38">PinningPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1HostAllocationPolicy.xhtml#ac568d5bd9864470a4a95cff8a0859b12">pinningPolicy</a> () const </td></tr>
<tr class="memdesc:ac568d5bd9864470a4a95cff8a0859b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current pinning policy (which is semi-independent of whether the buffer is actually pinned).  <a href="#ac568d5bd9864470a4a95cff8a0859b12">More...</a><br/></td></tr>
<tr class="separator:ac568d5bd9864470a4a95cff8a0859b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a87e39d62fe162cd8ee9dc661b8af28fd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a87e39d62fe162cd8ee9dc661b8af28fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgmx_1_1HostAllocationPolicy.xhtml#a87e39d62fe162cd8ee9dc661b8af28fd">changePinningPolicy</a> (<a class="el" href="namespacegmx.xhtml#a15043f587f8595747fbc7c4dee890cb2">HostVector</a>&lt; T &gt; *v, <a class="el" href="namespacegmx.xhtml#abe4caed0469c0de84e0c1c1a81972b38">PinningPolicy</a> <a class="el" href="classgmx_1_1HostAllocationPolicy.xhtml#ac568d5bd9864470a4a95cff8a0859b12">pinningPolicy</a>)</td></tr>
<tr class="memdesc:a87e39d62fe162cd8ee9dc661b8af28fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare as a friend function the only supported way to change the pinning policy.  <a href="#a87e39d62fe162cd8ee9dc661b8af28fd">More...</a><br/></td></tr>
<tr class="separator:a87e39d62fe162cd8ee9dc661b8af28fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae9eebd779172275fb09af48d4985fb4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::HostAllocationPolicy::free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free the memory, after unpinning (if appropriate). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Memory pointer previously returned from <a class="el" href="classgmx_1_1HostAllocationPolicy.xhtml#abea041287228e8b33c288bd9b3713b6c" title="Allocate and perhaps pin page-aligned memory suitable for e.g. GPU transfers. ">gmx::HostAllocationPolicy::malloc()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This routine should only be called with pointers obtained from gmx:HostAllocationPolicy::<a class="el" href="classgmx_1_1HostAllocationPolicy.xhtml#abea041287228e8b33c288bd9b3713b6c" title="Allocate and perhaps pin page-aligned memory suitable for e.g. GPU transfers. ">malloc()</a>, and absolutely not any pointers obtained the system <a class="el" href="classgmx_1_1HostAllocationPolicy.xhtml#abea041287228e8b33c288bd9b3713b6c" title="Allocate and perhaps pin page-aligned memory suitable for e.g. GPU transfers. ">malloc()</a>.</dd></dl>
<p>Does not throw. </p>

</div>
</div>
<a class="anchor" id="abea041287228e8b33c288bd9b3713b6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * gmx::HostAllocationPolicy::malloc </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate and perhaps pin page-aligned memory suitable for e.g. GPU transfers. </p>
<p>Before attempting to allocate, <a class="el" href="classgmx_1_1HostAllocationPolicy.xhtml#af5d51a9c9df85a8b402a3451c51d17c5" title="Unpin the allocation, if appropriate. ">unpin()</a> is called. After a successful allocation, <a class="el" href="classgmx_1_1HostAllocationPolicy.xhtml#a7c860b64868b432e71f9a2ab28426244" title="Pin the allocation to physical memory, if appropriate. ">pin()</a> is called. (Whether these do things depends on the PinningPolicy that is in effect.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Amount of memory (bytes) to allocate. It is valid to ask for 0 bytes, which will return a non-null pointer that is properly aligned and padded (but that you should not use).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Valid pointer if the allocation+optional pinning worked, otherwise nullptr.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Memory allocated with this routine must be released with <a class="el" href="classgmx_1_1HostAllocationPolicy.xhtml#ae9eebd779172275fb09af48d4985fb4d" title="Free the memory, after unpinning (if appropriate). ">gmx::HostAllocationPolicy::free()</a>, and absolutely not the system <a class="el" href="classgmx_1_1HostAllocationPolicy.xhtml#ae9eebd779172275fb09af48d4985fb4d" title="Free the memory, after unpinning (if appropriate). ">free()</a>.</dd></dl>
<p>Does not throw. </p>

</div>
</div>
<a class="anchor" id="a7c860b64868b432e71f9a2ab28426244"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::HostAllocationPolicy::pin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pin the allocation to physical memory, if appropriate. </p>
<p>If the allocation policy is not in pinning mode, or the allocation is empty, ot the allocation is already pinned, then do nothing.</p>
<p>Does not throw. </p>

</div>
</div>
<a class="anchor" id="ac568d5bd9864470a4a95cff8a0859b12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegmx.xhtml#abe4caed0469c0de84e0c1c1a81972b38">PinningPolicy</a> gmx::HostAllocationPolicy::pinningPolicy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current pinning policy (which is semi-independent of whether the buffer is actually pinned). </p>
<p>Does not throw. </p>

</div>
</div>
<a class="anchor" id="af5d51a9c9df85a8b402a3451c51d17c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::HostAllocationPolicy::unpin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpin the allocation, if appropriate. </p>
<p>Regardless of the allocation policy, unpin the memory if previously pinned, otherwise do nothing.</p>
<p>Does not throw. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a87e39d62fe162cd8ee9dc661b8af28fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void changePinningPolicy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegmx.xhtml#a15043f587f8595747fbc7c4dee890cb2">HostVector</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegmx.xhtml#abe4caed0469c0de84e0c1c1a81972b38">PinningPolicy</a>&#160;</td>
          <td class="paramname"><em>pinningPolicy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declare as a friend function the only supported way to change the pinning policy. </p>
<p>When the pinning policy changes, we want the state of the allocation to match the new policy. However, that requires a copy and swap of the buffers, which can only take place at the level of the container. So we wrap the required operations in a helper friend function.</p>
<p>Of course, if there is no allocation because the vector is empty, then nothing will change.</p>
<p>If the vector has contents, then a full reallocation and buffer copy are needed if the policy change requires tighter restrictions, and desirable even if the policy change requires looser restrictions. That cost is OK, because GROMACS will do this operation very rarely (e.g. when auto-tuning and deciding to switch whether a task will run on a GPU, or not). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/gromacs/gpu_utils/<a class="el" href="hostallocator_8h.xhtml">hostallocator.h</a></li>
<li>src/gromacs/gpu_utils/hostallocator.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 23 2018 14:56:15 for Gromacs by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
