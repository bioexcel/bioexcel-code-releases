<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Gromacs: Analysis output data handling</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Gromacs
   &#160;<span id="projectnumber">2018.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.xhtml"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.xhtml"><span>Modules</span></a></li>
      <li class="current"><a href="pages.xhtml"><span>Other&#160;Docs</span></a></li>
      <li><a href="namespaces.xhtml"><span>Namespaces</span></a></li>
      <li><a href="annotated.xhtml"><span>Classes</span></a></li>
      <li><a href="files.xhtml"><span>Files</span></a></li>
      <li><a href="examples.xhtml"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.xhtml">GROMACS</a></li><li class="navelem"><a class="el" href="page_analysisframework.xhtml">Framework for trajectory analysis</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Analysis output data handling </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The <a class="el" href="group__module__analysisdata.xhtml">Parallelizable Handling of Output Data (analysisdata)</a> module provides support for common data analysis tasks within the <a class="el" href="page_analysisframework.xhtml">Framework for trajectory analysis</a>. The basic approach used in the module is visualized below:</p>
<div align="center">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_3.svg" width="760" height="298"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<p>Typically, an analysis tool provides its raw data output through one or more <a class="el" href="classgmx_1_1AnalysisData.xhtml" title="Parallelizable data container for raw data. ">gmx::AnalysisData</a> objects (the root <em>data object</em> in the diagram above). This object provides only storage for the data.</p>
<p>To perform operations on the data, one or more <em>data modules</em> can be attached to the data object. Examples of such operations are averaging, histogramming, and plotting the data into a file. Some data modules are provided by the <a class="el" href="group__module__analysisdata.xhtml">Parallelizable Handling of Output Data (analysisdata)</a> module. To implement new ones, it is necessary to create a class that implements <a class="el" href="classgmx_1_1IAnalysisDataModule.xhtml" title="Interface for a module that gets notified whenever data is added. ">gmx::IAnalysisDataModule</a>.</p>
<p>In many cases, such data modules also provide data that can be processed further, acting as data objects themselves. This makes it possible to attach further data modules to form a processing chain. In simple cases, such a chain ends in a module that writes the data into a file, but it is also possible to access the data in a data object (whether a plain data object or a data module) programmatically to do further computation or post-processing outside the framework. To do this, the data object typically needs to be told in advance such that it knows to store the data permanently even if attached modules do not require it.</p>
<p>The modules can do their processing online, i.e., as the data is produced. If all the attached modules support this, it is not necessary to store all the raw data in memory. The module design also supports processing frames in parallel: in such cases, the data may become available out of order. In particular for writing the per-frame data into a file, but also for other types of post-processing, it is necessary to reorder the data sequentially. This is implemented once in the framework, and analysis tools do not need to worry, other than using the provided API.</p>
<h1>Structure of data </h1>
<p>At the highest level, data can be structured into separate <a class="el" href="classgmx_1_1AbstractAnalysisData.xhtml" title="Abstract base class for all objects that provide data. ">gmx::AbstractAnalysisData</a> objects that operate independently. Each such object has an independent set of post-processing modules.</p>
<p>Within a <a class="el" href="classgmx_1_1AbstractAnalysisData.xhtml" title="Abstract base class for all objects that provide data. ">gmx::AbstractAnalysisData</a> object, data is structured along three "dimensions":</p>
<ul>
<li><em>frames</em>: There is one or more frames in each data object. For raw data produced by an analysis tool, these typically correspond to input trajectory frames. For other data set, it can be viewed as an X axis of a graph.</li>
<li><em>data sets</em>: There is one or more data sets in each data object. For most purposes, data sets work independently (i.e., the post-processing modules operate on each data set separately), but some modules reduce the data sets into single columns in the output. The main purpose for using multiple data sets is to share the same post-processing chain for multiple sets of data (e.g., multiple RDFs computed by the same tool in one pass), in particular for cases where the number of data sets is not known at compile time. Note that each data set contains the same number of frames.</li>
<li><em>columns</em>: There is one or more columns in each data set. Different data sets can contain a different number of columns. Each column in a frame can contain a single value (see below for supported values).</li>
</ul>
<p>Programmatically the data within each frame is organized into <em>point sets</em>. Each point set consists of a continuous range of columns from a single data set. There are two types of data:</p>
<ul>
<li><em>simple</em>: For each frame, there is exactly one point set for each data set, and that point set spans all columns in that data set.</li>
<li><em>multipoint</em>: For each frame, there can be any number of point sets, and they may span arbitrary columns. It is allowed that point sets overlap, i.e., that multiple point sets specify a value for the same column.</li>
</ul>
<p>The main purpose of multipoint data is to support cases where it is not known in advance how many values there will be for each frame, or where that number is impractically large. The need to do this is mainly a matter of performance/implementation complexity tradeoff: with a more complex internal implementation, it would be possible to support larger data sets without a performance/memory impact they currently impose. The current implementation places the burden of deciding on the appropriate usage pattern on the user code, allowing for much simpler internal implementation.</p>
<p>An individual value (identified by frame, data set, and column) consists of a single value of type <code>real</code>, an optional error value, and some flags. The flags identify what parts of the value are really available. The following states are possible:</p>
<ul>
<li><em>present</em>: The value is set.</li>
<li><em>missing</em>: The value is marked as missing by the data source. In this state, the value can still be accessed, and the returned <code>real</code> value has some meaning. Different data modules handle these cases differently.</li>
<li><em>unset</em>: The value is not set. It is not allowed to access the value for other than querying the state. Data modules that ignore missing values (by skipping all values not <em>present</em>) can also handle unset values. Other data modules typically do not allow unset values.</li>
</ul>
<h1>Data provider classes </h1>
<p>The base class for all data objects (including data modules that provide data) is <a class="el" href="classgmx_1_1AbstractAnalysisData.xhtml" title="Abstract base class for all objects that provide data. ">gmx::AbstractAnalysisData</a>. This class provides facilities for attaching data modules to the data, and to query the data. It does not provide any methods to alter the data; all logic for managing the actual data is in derived classes.</p>
<p>The main root (non-module) data object class for use in analysis tools is <a class="el" href="classgmx_1_1AnalysisData.xhtml" title="Parallelizable data container for raw data. ">gmx::AnalysisData</a>. This class provides methods to set properties of the data, and to add frames to it. The interface is frame-based: you construct one frame at a time, and after it is finished, you move to the next frame. The frames are not constructed directly using <a class="el" href="classgmx_1_1AnalysisData.xhtml" title="Parallelizable data container for raw data. ">gmx::AnalysisData</a>, but instead separate <em>data handles</em> are used. This is explained in more detail below under <a class="el" href="page_analysisdata.xhtml#section_analysisdata_parallelization">Parallelization </a>.</p>
<p>For simple needs and small amounts of data, <a class="el" href="classgmx_1_1AnalysisArrayData.xhtml" title="Simple in-memory data array. ">gmx::AnalysisArrayData</a> is also provided. This class allows for all the data to be prepared in memory as a single big array, and allows random access to the data while setting the values. When all the values are set to their final values, it then notifies the attached data modules by looping over the array.</p>
<h1><a class="anchor" id="section_analysisdata_parallelization"></a>
Parallelization </h1>
<p>One major driver for the design of the analysis data module has been to provide support for transparently processing multiple frames in parallel. In such cases, output data for multiple frames may be constructed simultaneously, and must be ordered correctly for some data modules, such as writing it into a file. This ordering is taken care of by the framework, allowing the analysis tool writer to concentrate on the actual analysis task.</p>
<p>From a user's point of view, the main player in this respect is the <a class="el" href="classgmx_1_1AnalysisData.xhtml" title="Parallelizable data container for raw data. ">gmx::AnalysisData</a> object. If there are two threads doing the processing in parallel, it allows creating a separate <a class="el" href="classgmx_1_1AnalysisDataHandle.xhtml" title="Handle for inserting data into AnalysisData. ">gmx::AnalysisDataHandle</a> for each object. Each of these handles can be used independently to construct frames into the output data, and the <a class="el" href="classgmx_1_1AnalysisData.xhtml" title="Parallelizable data container for raw data. ">gmx::AnalysisData</a> object internally takes care of notifying the modules correctly. If necessary, it stores finished frames into a temporary buffer until all preceding frames have also been finished.</p>
<p>For increased efficiency, some data modules are also parallelization-aware: they have the ability to process the data in any order, allowing <a class="el" href="classgmx_1_1AnalysisData.xhtml" title="Parallelizable data container for raw data. ">gmx::AnalysisData</a> to notify them as soon as a frame becomes available. If there are only parallel data modules attached, no frame reordering or temporary buffers are needed. If a non-parallel data module is attached to a parallel data module, then that parallel data module takes the responsibility of ordering its output frames. Ideally, such data modules produce significantly less data than what they take in, making it cheaper to do the ordering only at this point.</p>
<p>Currently, no parallel runner has been implemented, but it is likely that applicable tools written to use the framework require minimal or no changes to take advantage of frame-level parallelism once such a runner materializes.</p>
<h1>Provided data processing modules </h1>
<p>Data modules provided by the <a class="el" href="group__module__analysisdata.xhtml">Parallelizable Handling of Output Data (analysisdata)</a> module are listed below with a short description. See the documentation of the individual classes for more details. Note that this list is manually maintained, so it may not always be up-to-date. A comprehensive list can be found by looking at the inheritance graph of <a class="el" href="classgmx_1_1IAnalysisDataModule.xhtml" title="Interface for a module that gets notified whenever data is added. ">gmx::IAnalysisDataModule</a>, but the list here is more user-friendly.</p>
<dl>
<dt><a class="el" href="classgmx_1_1AnalysisDataAverageModule.xhtml" title="Data module for independently averaging each column in input data. ">gmx::AnalysisDataAverageModule</a> </dt>
<dd>Computes averages and standard deviations for columns in input data. One output value for each input column.  </dd>
<dt><a class="el" href="classgmx_1_1AnalysisDataFrameAverageModule.xhtml" title="Data module for averaging of columns for each frame. ">gmx::AnalysisDataFrameAverageModule</a> </dt>
<dd>Computes averages for each frame in input data. One output value for each input data set for each frame.  </dd>
<dt><a class="el" href="classgmx_1_1AnalysisDataBinAverageModule.xhtml" title="Data module for bin averages. ">gmx::AnalysisDataBinAverageModule</a> </dt>
<dd>Computes averages within bins. Input is pairs of values, where the first value defines the bin, and the second value sets the value to accumulate into the average within the bin. One output histogram for each input data set.  </dd>
<dt><a class="el" href="classgmx_1_1AnalysisDataSimpleHistogramModule.xhtml" title="Data module for per-frame histograms. ">gmx::AnalysisDataSimpleHistogramModule</a> </dt>
<dd>Computes histograms. All values within a data set are added into a histogram. One output histogram for each input data set. Provides the histogram for each input frame separately, and also the full histogram over frames (through an internal submodule).  </dd>
<dt><a class="el" href="classgmx_1_1AnalysisDataWeightedHistogramModule.xhtml" title="Data module for per-frame weighted histograms. ">gmx::AnalysisDataWeightedHistogramModule</a> </dt>
<dd>Computes histograms. Input is pairs of values, where the first value defines the bin, and the second value sets the value to add into that bin. Output like with <a class="el" href="classgmx_1_1AnalysisDataSimpleHistogramModule.xhtml" title="Data module for per-frame histograms. ">gmx::AnalysisDataSimpleHistogramModule</a>.  </dd>
<dt><a class="el" href="classgmx_1_1AnalysisDataLifetimeModule.xhtml" title="Data module for computing lifetime histograms for columns in input data. ">gmx::AnalysisDataLifetimeModule</a> </dt>
<dd>Computes lifetime histograms. For each input column, determines the time intervals during which a value is continuously present/non-zero, and creates a histogram from the lengths of these intervals. One output histogram for each input data set.  </dd>
<dt><a class="el" href="classgmx_1_1AnalysisDataPlotModule.xhtml" title="Plotting module for straightforward plotting of data. ">gmx::AnalysisDataPlotModule</a> </dt>
<dd></dd>
<dt><a class="el" href="classgmx_1_1AnalysisDataVectorPlotModule.xhtml" title="Plotting module specifically for data consisting of vectors. ">gmx::AnalysisDataVectorPlotModule</a> </dt>
<dd>Writes data into a file.  </dd>
</dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 23 2018 14:56:11 for Gromacs by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
