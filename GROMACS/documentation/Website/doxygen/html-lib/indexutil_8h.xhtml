<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Gromacs: src/gromacs/selection/indexutil.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Gromacs
   &#160;<span id="projectnumber">2018.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.xhtml"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.xhtml"><span>Modules</span></a></li>
      <li><a href="pages.xhtml"><span>Other&#160;Docs</span></a></li>
      <li><a href="namespaces.xhtml"><span>Namespaces</span></a></li>
      <li><a href="annotated.xhtml"><span>Classes</span></a></li>
      <li class="current"><a href="files.xhtml"><span>Files</span></a></li>
      <li><a href="examples.xhtml"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.xhtml"><span>File&#160;List</span></a></li>
      <li><a href="globals.xhtml"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_8a21c46af9718d1f610eb513153099d7.xhtml">src</a></li><li class="navelem"><a class="el" href="dir_a46192700e9e8ed44c648f0a55ee9a53.xhtml">gromacs</a></li><li class="navelem"><a class="el" href="dir_e7e88b26b6f22ac834fce3ecdbf03d20.xhtml">selection</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">indexutil.h File Reference<div class="ingroups"><a class="el" href="group__group__libraryapi.xhtml">Library API</a> &#124; <a class="el" href="group__module__selection.xhtml">Parsing and Evaluation of Analysis Selections (selection)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;cstdio&gt;</code><br/>
<code>#include &lt;string&gt;</code><br/>
<code>#include &quot;gromacs/topology/block.h&quot;</code><br/>
</div><div class="textblock"><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Include dependency graph for indexutil.h:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="indexutil_8h__incl.svg" width="162" height="127"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div><div class="textblock"><div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> This graph shows which files directly or indirectly include this file:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="indexutil_8h__dep__incl.svg" width="614" height="559"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div><a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>API for handling index files and index groups. </p>
<p>The API contains functions and data structures for handling index files more conveniently than as several separate variables. In addition to basic functions for initializing the data structures and making copies, functions are provided for performing (most) set operations on sorted index groups. There is also a function for partitioning a index group based on topology information such as residues or molecules. Finally, there is a set of functions for constructing mappings between an index group and its subgroups such. These can be used with dynamic index group in calculations if one needs to have a unique ID for each possible atom/residue/molecule in the selection, e.g., for analysis of dynamics or for look-up tables.</p>
<p>Mostly, these functions are used internally by the selection engine, but it is necessary to use some of these functions in order to provide external index groups to a <a class="el" href="classgmx_1_1SelectionCollection.xhtml" title="Collection of selections. ">gmx::SelectionCollection</a>. Some of the checking functions can be useful outside the selection engine to check the validity of input groups.</p>
<dl class="section author"><dt>Author</dt><dd>Teemu Murtola <a href="#" onclick="location.href='mai'+'lto:'+'tee'+'mu'+'.mu'+'rt'+'ola'+'@g'+'mai'+'l.'+'com'; return false;">teemu<span style="display: none;">.nosp@m.</span>.mur<span style="display: none;">.nosp@m.</span>tola@<span style="display: none;">.nosp@m.</span>gmai<span style="display: none;">.nosp@m.</span>l.com</a> </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a single index group.  <a href="structgmx__ana__index__t.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgmx__ana__indexmap__t.xhtml">gmx_ana_indexmap_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for calculating index group mappings.  <a href="structgmx__ana__indexmap__t.xhtml#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad7330829cb93245b9de7ed268cf6ba67"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#ad7330829cb93245b9de7ed268cf6ba67">e_index_t</a> { <br/>
&#160;&#160;<a class="el" href="indexutil_8h.xhtml#ad7330829cb93245b9de7ed268cf6ba67a5befa01b9a863bdccbfd308d0c611601">INDEX_UNKNOWN</a>, 
<a class="el" href="indexutil_8h.xhtml#ad7330829cb93245b9de7ed268cf6ba67a8270d36cd367d434ccd9fe0dc1b886d8">INDEX_ATOM</a>, 
<a class="el" href="indexutil_8h.xhtml#ad7330829cb93245b9de7ed268cf6ba67a744bebc713caa98b8bf8b837af07834d">INDEX_RES</a>, 
<a class="el" href="indexutil_8h.xhtml#ad7330829cb93245b9de7ed268cf6ba67ae082401c42a6fac46f6701a68f822c86">INDEX_MOL</a>, 
<br/>
&#160;&#160;<a class="el" href="indexutil_8h.xhtml#ad7330829cb93245b9de7ed268cf6ba67a070d857fdc650a9cc8550e231ae91578">INDEX_ALL</a>
<br/>
 }</td></tr>
<tr class="memdesc:ad7330829cb93245b9de7ed268cf6ba67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the type of index partition or index mapping in several contexts.  <a href="indexutil_8h.xhtml#ad7330829cb93245b9de7ed268cf6ba67">More...</a><br/></td></tr>
<tr class="separator:ad7330829cb93245b9de7ed268cf6ba67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions for handling gmx_ana_indexgrps_t</div></td></tr>
<tr class="memitem:a0d73c532466a6c1f16eaa79ac7779cda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a0d73c532466a6c1f16eaa79ac7779cda">gmx_ana_indexgrps_init</a> (gmx_ana_indexgrps_t **g, gmx_mtop_t *top, const char *fnm)</td></tr>
<tr class="memdesc:a0d73c532466a6c1f16eaa79ac7779cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads index groups from a file or constructs them from topology.  <a href="#a0d73c532466a6c1f16eaa79ac7779cda">More...</a><br/></td></tr>
<tr class="separator:a0d73c532466a6c1f16eaa79ac7779cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c52fc07ccfa2796785a9ca0463a28e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a7c52fc07ccfa2796785a9ca0463a28e9">gmx_ana_indexgrps_free</a> (gmx_ana_indexgrps_t *g)</td></tr>
<tr class="memdesc:a7c52fc07ccfa2796785a9ca0463a28e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory allocated for index groups.  <a href="#a7c52fc07ccfa2796785a9ca0463a28e9">More...</a><br/></td></tr>
<tr class="separator:a7c52fc07ccfa2796785a9ca0463a28e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90734f01fd06a2ae8864d8a1807edfba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a90734f01fd06a2ae8864d8a1807edfba">gmx_ana_indexgrps_is_empty</a> (gmx_ana_indexgrps_t *g)</td></tr>
<tr class="memdesc:a90734f01fd06a2ae8864d8a1807edfba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the index group structure is emtpy.  <a href="#a90734f01fd06a2ae8864d8a1807edfba">More...</a><br/></td></tr>
<tr class="separator:a90734f01fd06a2ae8864d8a1807edfba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0789934fa881d09faa55e4c280c77d68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a0789934fa881d09faa55e4c280c77d68">gmx_ana_indexgrps_get_grp</a> (gmx_ana_indexgrps_t *g, int n)</td></tr>
<tr class="memdesc:a0789934fa881d09faa55e4c280c77d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to an index group.  <a href="#a0789934fa881d09faa55e4c280c77d68">More...</a><br/></td></tr>
<tr class="separator:a0789934fa881d09faa55e4c280c77d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd435ef78f954dfe2da4333d646f2b4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#afd435ef78f954dfe2da4333d646f2b4b">gmx_ana_indexgrps_extract</a> (<a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *dest, std::string *destName, gmx_ana_indexgrps_t *src, int n)</td></tr>
<tr class="memdesc:afd435ef78f954dfe2da4333d646f2b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a single index group.  <a href="#afd435ef78f954dfe2da4333d646f2b4b">More...</a><br/></td></tr>
<tr class="separator:afd435ef78f954dfe2da4333d646f2b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e58b81f252d8d791993878fd486affb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a2e58b81f252d8d791993878fd486affb">gmx_ana_indexgrps_find</a> (<a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *dest, std::string *destName, gmx_ana_indexgrps_t *src, const char *name)</td></tr>
<tr class="memdesc:a2e58b81f252d8d791993878fd486affb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and extracts a single index group by name.  <a href="#a2e58b81f252d8d791993878fd486affb">More...</a><br/></td></tr>
<tr class="separator:a2e58b81f252d8d791993878fd486affb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95fdac296eb9b2f1e57b3efbe18c221d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a95fdac296eb9b2f1e57b3efbe18c221d">gmx_ana_indexgrps_print</a> (<a class="el" href="classgmx_1_1TextWriter.xhtml">gmx::TextWriter</a> *writer, gmx_ana_indexgrps_t *g, int maxn)</td></tr>
<tr class="memdesc:a95fdac296eb9b2f1e57b3efbe18c221d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes out a list of index groups.  <a href="#a95fdac296eb9b2f1e57b3efbe18c221d">More...</a><br/></td></tr>
<tr class="separator:a95fdac296eb9b2f1e57b3efbe18c221d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions for handling gmx_ana_index_t</div></td></tr>
<tr class="memitem:a084e5e78e92e2035a834bf7958a45b20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a084e5e78e92e2035a834bf7958a45b20">gmx_ana_index_reserve</a> (<a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *g, int isize)</td></tr>
<tr class="memdesc:a084e5e78e92e2035a834bf7958a45b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves memory to store an index group of size <code>isize</code>.  <a href="#a084e5e78e92e2035a834bf7958a45b20">More...</a><br/></td></tr>
<tr class="separator:a084e5e78e92e2035a834bf7958a45b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45d8a0b1b4bacf126a01d04e8357f49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#af45d8a0b1b4bacf126a01d04e8357f49">gmx_ana_index_squeeze</a> (<a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *g)</td></tr>
<tr class="memdesc:af45d8a0b1b4bacf126a01d04e8357f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees any memory not necessary to hold the current contents.  <a href="#af45d8a0b1b4bacf126a01d04e8357f49">More...</a><br/></td></tr>
<tr class="separator:af45d8a0b1b4bacf126a01d04e8357f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f90612207c7c5094501521b8a92689"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#af4f90612207c7c5094501521b8a92689">gmx_ana_index_clear</a> (<a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *g)</td></tr>
<tr class="memdesc:af4f90612207c7c5094501521b8a92689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an empty index group.  <a href="#af4f90612207c7c5094501521b8a92689">More...</a><br/></td></tr>
<tr class="separator:af4f90612207c7c5094501521b8a92689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b64a9302f16fbc24a1eb03bdf41d00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#ab6b64a9302f16fbc24a1eb03bdf41d00">gmx_ana_index_set</a> (<a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *g, int isize, int *index, int nalloc)</td></tr>
<tr class="memdesc:ab6b64a9302f16fbc24a1eb03bdf41d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code><a class="el" href="structgmx__ana__index__t.xhtml" title="Stores a single index group. ">gmx_ana_index_t</a></code> from given values.  <a href="#ab6b64a9302f16fbc24a1eb03bdf41d00">More...</a><br/></td></tr>
<tr class="separator:ab6b64a9302f16fbc24a1eb03bdf41d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dbfc10f956f0cf8d37a72ea6e6b005e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a3dbfc10f956f0cf8d37a72ea6e6b005e">gmx_ana_index_init_simple</a> (<a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *g, int natoms)</td></tr>
<tr class="memdesc:a3dbfc10f956f0cf8d37a72ea6e6b005e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a simple index group from the first to the <code>natoms'th</code> atom.  <a href="#a3dbfc10f956f0cf8d37a72ea6e6b005e">More...</a><br/></td></tr>
<tr class="separator:a3dbfc10f956f0cf8d37a72ea6e6b005e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f6aafce1b2234d9bd09686352dca71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#ad0f6aafce1b2234d9bd09686352dca71">gmx_ana_index_deinit</a> (<a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *g)</td></tr>
<tr class="memdesc:ad0f6aafce1b2234d9bd09686352dca71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory allocated for an index group.  <a href="#ad0f6aafce1b2234d9bd09686352dca71">More...</a><br/></td></tr>
<tr class="separator:ad0f6aafce1b2234d9bd09686352dca71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a3284db45e8ed2784201f1c3d43754"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#aa8a3284db45e8ed2784201f1c3d43754">gmx_ana_index_copy</a> (<a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *dest, <a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *src, bool bAlloc)</td></tr>
<tr class="memdesc:aa8a3284db45e8ed2784201f1c3d43754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a <code><a class="el" href="structgmx__ana__index__t.xhtml" title="Stores a single index group. ">gmx_ana_index_t</a></code>.  <a href="#aa8a3284db45e8ed2784201f1c3d43754">More...</a><br/></td></tr>
<tr class="separator:aa8a3284db45e8ed2784201f1c3d43754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b70f0aab85679c5a1aa4a2dca7921a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a93b70f0aab85679c5a1aa4a2dca7921a">gmx_ana_index_dump</a> (<a class="el" href="classgmx_1_1TextWriter.xhtml">gmx::TextWriter</a> *writer, <a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *g, int maxn)</td></tr>
<tr class="memdesc:a93b70f0aab85679c5a1aa4a2dca7921a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes out the contents of a index group.  <a href="#a93b70f0aab85679c5a1aa4a2dca7921a">More...</a><br/></td></tr>
<tr class="separator:a93b70f0aab85679c5a1aa4a2dca7921a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec35269da72e2c51e829dbd65023246"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#aaec35269da72e2c51e829dbd65023246">gmx_ana_index_get_max_index</a> (<a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *g)</td></tr>
<tr class="memdesc:aaec35269da72e2c51e829dbd65023246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns maximum atom index that appears in an index group.  <a href="#aaec35269da72e2c51e829dbd65023246">More...</a><br/></td></tr>
<tr class="separator:aaec35269da72e2c51e829dbd65023246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5b2477337e27536518be8ad4c59cc6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a3c5b2477337e27536518be8ad4c59cc6">gmx_ana_index_check_sorted</a> (<a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *g)</td></tr>
<tr class="memdesc:a3c5b2477337e27536518be8ad4c59cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether an index group is sorted.  <a href="#a3c5b2477337e27536518be8ad4c59cc6">More...</a><br/></td></tr>
<tr class="separator:a3c5b2477337e27536518be8ad4c59cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d5b4b6771696aa85f9b3cbe7320220"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a40d5b4b6771696aa85f9b3cbe7320220">gmx_ana_index_check_range</a> (<a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *g, int natoms)</td></tr>
<tr class="memdesc:a40d5b4b6771696aa85f9b3cbe7320220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether an index group has atoms from a defined range.  <a href="#a40d5b4b6771696aa85f9b3cbe7320220">More...</a><br/></td></tr>
<tr class="separator:a40d5b4b6771696aa85f9b3cbe7320220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions for set operations on gmx_ana_index_t</div></td></tr>
<tr class="memitem:a8872aa14b9b23e545bd6a6c8c49238cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a8872aa14b9b23e545bd6a6c8c49238cf">gmx_ana_index_sort</a> (<a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *g)</td></tr>
<tr class="memdesc:a8872aa14b9b23e545bd6a6c8c49238cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the indices within an index group.  <a href="#a8872aa14b9b23e545bd6a6c8c49238cf">More...</a><br/></td></tr>
<tr class="separator:a8872aa14b9b23e545bd6a6c8c49238cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e55f7dfde504062bd7611bb3c1f334"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a20e55f7dfde504062bd7611bb3c1f334">gmx_ana_index_remove_duplicates</a> (<a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *g)</td></tr>
<tr class="memdesc:a20e55f7dfde504062bd7611bb3c1f334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicates from a sorted index group.  <a href="#a20e55f7dfde504062bd7611bb3c1f334">More...</a><br/></td></tr>
<tr class="separator:a20e55f7dfde504062bd7611bb3c1f334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0f110de3e285c9d700d34876c7872e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a2a0f110de3e285c9d700d34876c7872e">gmx_ana_index_equals</a> (<a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *a, <a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *b)</td></tr>
<tr class="memdesc:a2a0f110de3e285c9d700d34876c7872e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether two index groups are equal.  <a href="#a2a0f110de3e285c9d700d34876c7872e">More...</a><br/></td></tr>
<tr class="separator:a2a0f110de3e285c9d700d34876c7872e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af353f7e48a3078579b6e032dd3affce1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#af353f7e48a3078579b6e032dd3affce1">gmx_ana_index_contains</a> (<a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *a, <a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *b)</td></tr>
<tr class="memdesc:af353f7e48a3078579b6e032dd3affce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a sorted index group contains another sorted index group.  <a href="#af353f7e48a3078579b6e032dd3affce1">More...</a><br/></td></tr>
<tr class="separator:af353f7e48a3078579b6e032dd3affce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac217ad643cf1347e01cff4cca583a0db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#ac217ad643cf1347e01cff4cca583a0db">gmx_ana_index_intersection</a> (<a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *dest, <a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *a, <a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *b)</td></tr>
<tr class="memdesc:ac217ad643cf1347e01cff4cca583a0db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the intersection between two sorted index groups.  <a href="#ac217ad643cf1347e01cff4cca583a0db">More...</a><br/></td></tr>
<tr class="separator:ac217ad643cf1347e01cff4cca583a0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36418762a1d83eed47840281d779e312"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a36418762a1d83eed47840281d779e312">gmx_ana_index_difference</a> (<a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *dest, <a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *a, <a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *b)</td></tr>
<tr class="memdesc:a36418762a1d83eed47840281d779e312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the set difference between two sorted index groups.  <a href="#a36418762a1d83eed47840281d779e312">More...</a><br/></td></tr>
<tr class="separator:a36418762a1d83eed47840281d779e312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1674b8960e0058dd3a6ab7f7f0a69841"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a1674b8960e0058dd3a6ab7f7f0a69841">gmx_ana_index_difference_size</a> (<a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *a, <a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *b)</td></tr>
<tr class="memdesc:a1674b8960e0058dd3a6ab7f7f0a69841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the size of the difference between two sorted index groups.  <a href="#a1674b8960e0058dd3a6ab7f7f0a69841">More...</a><br/></td></tr>
<tr class="separator:a1674b8960e0058dd3a6ab7f7f0a69841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42425ece80cdd7b293308fb39edf6e18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a42425ece80cdd7b293308fb39edf6e18">gmx_ana_index_union</a> (<a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *dest, <a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *a, <a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *b)</td></tr>
<tr class="memdesc:a42425ece80cdd7b293308fb39edf6e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the union of two sorted index groups.  <a href="#a42425ece80cdd7b293308fb39edf6e18">More...</a><br/></td></tr>
<tr class="separator:a42425ece80cdd7b293308fb39edf6e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f3105dac88715d0a2278a2025544da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a29f3105dac88715d0a2278a2025544da">gmx_ana_index_union_unsorted</a> (<a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *dest, <a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *a, <a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *b)</td></tr>
<tr class="memdesc:a29f3105dac88715d0a2278a2025544da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the union of two index groups, where the second group may not be sorted.  <a href="#a29f3105dac88715d0a2278a2025544da">More...</a><br/></td></tr>
<tr class="separator:a29f3105dac88715d0a2278a2025544da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a83282e2ab6166b970ab221b60e6df1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a9a83282e2ab6166b970ab221b60e6df1">gmx_ana_index_merge</a> (<a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *dest, <a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *a, <a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *b)</td></tr>
<tr class="memdesc:a9a83282e2ab6166b970ab221b60e6df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two distinct sorted index groups.  <a href="#a9a83282e2ab6166b970ab221b60e6df1">More...</a><br/></td></tr>
<tr class="separator:a9a83282e2ab6166b970ab221b60e6df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1be16095557d63b0c3a1bf7f9f29b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a1a1be16095557d63b0c3a1bf7f9f29b2">gmx_ana_index_partition</a> (<a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *dest1, <a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *dest2, <a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *src, <a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *g)</td></tr>
<tr class="memdesc:a1a1be16095557d63b0c3a1bf7f9f29b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the intersection and the difference in one call.  <a href="#a1a1be16095557d63b0c3a1bf7f9f29b2">More...</a><br/></td></tr>
<tr class="separator:a1a1be16095557d63b0c3a1bf7f9f29b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions for handling gmx_ana_indexmap_t and related things</div></td></tr>
<tr class="memitem:a2f0465bdcb2eb967ecf1e1b90c822359"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a2f0465bdcb2eb967ecf1e1b90c822359">gmx_ana_index_make_block</a> (t_blocka *t, const gmx_mtop_t *top, <a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *g, <a class="el" href="indexutil_8h.xhtml#ad7330829cb93245b9de7ed268cf6ba67">e_index_t</a> type, bool bComplete)</td></tr>
<tr class="memdesc:a2f0465bdcb2eb967ecf1e1b90c822359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition a group based on topology information.  <a href="#a2f0465bdcb2eb967ecf1e1b90c822359">More...</a><br/></td></tr>
<tr class="separator:a2f0465bdcb2eb967ecf1e1b90c822359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7cc6e551789b95a3e59fa3aa4c09df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#aca7cc6e551789b95a3e59fa3aa4c09df">gmx_ana_index_has_full_blocks</a> (const <a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *g, const t_block *b)</td></tr>
<tr class="memdesc:aca7cc6e551789b95a3e59fa3aa4c09df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a group consists of full blocks.  <a href="#aca7cc6e551789b95a3e59fa3aa4c09df">More...</a><br/></td></tr>
<tr class="separator:aca7cc6e551789b95a3e59fa3aa4c09df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63020f357a8efd413470a669e45e1696"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a63020f357a8efd413470a669e45e1696">gmx_ana_index_has_full_ablocks</a> (<a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *g, t_blocka *b)</td></tr>
<tr class="memdesc:a63020f357a8efd413470a669e45e1696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a group consists of full blocks.  <a href="#a63020f357a8efd413470a669e45e1696">More...</a><br/></td></tr>
<tr class="separator:a63020f357a8efd413470a669e45e1696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b8e2df23aaabd93b12f273eb5ad0ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a30b8e2df23aaabd93b12f273eb5ad0ec">gmx_ana_index_has_complete_elems</a> (<a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *g, <a class="el" href="indexutil_8h.xhtml#ad7330829cb93245b9de7ed268cf6ba67">e_index_t</a> type, const gmx_mtop_t *top)</td></tr>
<tr class="memdesc:a30b8e2df23aaabd93b12f273eb5ad0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a group consists of full residues/molecules.  <a href="#a30b8e2df23aaabd93b12f273eb5ad0ec">More...</a><br/></td></tr>
<tr class="separator:a30b8e2df23aaabd93b12f273eb5ad0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521bc0c5c619c566925ba515c6501a50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a521bc0c5c619c566925ba515c6501a50">gmx_ana_indexmap_clear</a> (<a class="el" href="structgmx__ana__indexmap__t.xhtml">gmx_ana_indexmap_t</a> *m)</td></tr>
<tr class="memdesc:a521bc0c5c619c566925ba515c6501a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an empty index group mapping.  <a href="#a521bc0c5c619c566925ba515c6501a50">More...</a><br/></td></tr>
<tr class="separator:a521bc0c5c619c566925ba515c6501a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81020f97f9da8509f85166d293d8575"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#ae81020f97f9da8509f85166d293d8575">gmx_ana_indexmap_reserve</a> (<a class="el" href="structgmx__ana__indexmap__t.xhtml">gmx_ana_indexmap_t</a> *m, int nr, int isize)</td></tr>
<tr class="memdesc:ae81020f97f9da8509f85166d293d8575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves memory for an index group mapping.  <a href="#ae81020f97f9da8509f85166d293d8575">More...</a><br/></td></tr>
<tr class="separator:ae81020f97f9da8509f85166d293d8575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74069ed995e7641acfd6671ea3a28f63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a74069ed995e7641acfd6671ea3a28f63">gmx_ana_indexmap_init</a> (<a class="el" href="structgmx__ana__indexmap__t.xhtml">gmx_ana_indexmap_t</a> *m, <a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *g, const gmx_mtop_t *top, <a class="el" href="indexutil_8h.xhtml#ad7330829cb93245b9de7ed268cf6ba67">e_index_t</a> type)</td></tr>
<tr class="memdesc:a74069ed995e7641acfd6671ea3a28f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an index group mapping.  <a href="#a74069ed995e7641acfd6671ea3a28f63">More...</a><br/></td></tr>
<tr class="separator:a74069ed995e7641acfd6671ea3a28f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf51b32674087a263fc7b34305b307cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#aaf51b32674087a263fc7b34305b307cc">gmx_ana_indexmap_init_orgid_group</a> (<a class="el" href="structgmx__ana__indexmap__t.xhtml">gmx_ana_indexmap_t</a> *m, const gmx_mtop_t *top, <a class="el" href="indexutil_8h.xhtml#ad7330829cb93245b9de7ed268cf6ba67">e_index_t</a> type)</td></tr>
<tr class="memdesc:aaf51b32674087a263fc7b34305b307cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes <code>orgid</code> entries based on topology grouping.  <a href="#aaf51b32674087a263fc7b34305b307cc">More...</a><br/></td></tr>
<tr class="separator:aaf51b32674087a263fc7b34305b307cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343d136c6f9999de805f7b0197707d0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a343d136c6f9999de805f7b0197707d0f">gmx_ana_indexmap_set_static</a> (<a class="el" href="structgmx__ana__indexmap__t.xhtml">gmx_ana_indexmap_t</a> *m, t_blocka *b)</td></tr>
<tr class="memdesc:a343d136c6f9999de805f7b0197707d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an index group mapping to be static.  <a href="#a343d136c6f9999de805f7b0197707d0f">More...</a><br/></td></tr>
<tr class="separator:a343d136c6f9999de805f7b0197707d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b58612d9db3c295423c4ad9fb73160"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#a03b58612d9db3c295423c4ad9fb73160">gmx_ana_indexmap_deinit</a> (<a class="el" href="structgmx__ana__indexmap__t.xhtml">gmx_ana_indexmap_t</a> *m)</td></tr>
<tr class="memdesc:a03b58612d9db3c295423c4ad9fb73160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory allocated for index group mapping.  <a href="#a03b58612d9db3c295423c4ad9fb73160">More...</a><br/></td></tr>
<tr class="separator:a03b58612d9db3c295423c4ad9fb73160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb30c49eef3b94b1d6318742cbc8662"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#accb30c49eef3b94b1d6318742cbc8662">gmx_ana_indexmap_copy</a> (<a class="el" href="structgmx__ana__indexmap__t.xhtml">gmx_ana_indexmap_t</a> *dest, <a class="el" href="structgmx__ana__indexmap__t.xhtml">gmx_ana_indexmap_t</a> *src, bool bFirst)</td></tr>
<tr class="memdesc:accb30c49eef3b94b1d6318742cbc8662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a deep copy of an index group mapping.  <a href="#accb30c49eef3b94b1d6318742cbc8662">More...</a><br/></td></tr>
<tr class="separator:accb30c49eef3b94b1d6318742cbc8662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa100f0522b7c9ad3090ee32fe7ced7ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexutil_8h.xhtml#aa100f0522b7c9ad3090ee32fe7ced7ad">gmx_ana_indexmap_update</a> (<a class="el" href="structgmx__ana__indexmap__t.xhtml">gmx_ana_indexmap_t</a> *m, <a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *g, bool bMaskOnly)</td></tr>
<tr class="memdesc:aa100f0522b7c9ad3090ee32fe7ced7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates an index group mapping.  <a href="#aa100f0522b7c9ad3090ee32fe7ced7ad">More...</a><br/></td></tr>
<tr class="separator:aa100f0522b7c9ad3090ee32fe7ced7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ad7330829cb93245b9de7ed268cf6ba67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="indexutil_8h.xhtml#ad7330829cb93245b9de7ed268cf6ba67">e_index_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the type of index partition or index mapping in several contexts. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="indexutil_8h.xhtml#a2f0465bdcb2eb967ecf1e1b90c822359" title="Partition a group based on topology information. ">gmx_ana_index_make_block()</a>, <a class="el" href="indexutil_8h.xhtml#a74069ed995e7641acfd6671ea3a28f63" title="Initializes an index group mapping. ">gmx_ana_indexmap_init()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ad7330829cb93245b9de7ed268cf6ba67a5befa01b9a863bdccbfd308d0c611601"></a>INDEX_UNKNOWN</em>&nbsp;</td><td class="fielddoc">
<p>Unknown index type. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad7330829cb93245b9de7ed268cf6ba67a8270d36cd367d434ccd9fe0dc1b886d8"></a>INDEX_ATOM</em>&nbsp;</td><td class="fielddoc">
<p>Each atom in a separate block. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad7330829cb93245b9de7ed268cf6ba67a744bebc713caa98b8bf8b837af07834d"></a>INDEX_RES</em>&nbsp;</td><td class="fielddoc">
<p>Each residue in a separate block. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad7330829cb93245b9de7ed268cf6ba67ae082401c42a6fac46f6701a68f822c86"></a>INDEX_MOL</em>&nbsp;</td><td class="fielddoc">
<p>Each molecule in a separate block. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad7330829cb93245b9de7ed268cf6ba67a070d857fdc650a9cc8550e231ae91578"></a>INDEX_ALL</em>&nbsp;</td><td class="fielddoc">
<p>All atoms in a single block. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a40d5b4b6771696aa85f9b3cbe7320220"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gmx_ana_index_check_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>natoms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether an index group has atoms from a defined range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Index group to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">natoms</td><td>Largest atom number allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all atoms in the index group are in the range 0 to <code>natoms</code> (i.e., no atoms over <code>natoms</code> are referenced). </dd></dl>

</div>
</div>
<a class="anchor" id="a3c5b2477337e27536518be8ad4c59cc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gmx_ana_index_check_sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether an index group is sorted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Index group to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the index group is sorted and has no duplicates, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af4f90612207c7c5094501521b8a92689"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_index_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an empty index group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>Output structure.</td></tr>
  </table>
  </dd>
</dl>
<p>Any contents of <code>g</code> are discarded without freeing. </p>

</div>
</div>
<a class="anchor" id="af353f7e48a3078579b6e032dd3affce1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gmx_ana_index_contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a sorted index group contains another sorted index group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Index group to check against. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Index group to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>b</code> is contained in <code>a</code>, false otherwise.</dd></dl>
<p>If the elements are not in the same order in both groups, the function fails. However, the groups do not need to be sorted. </p>

</div>
</div>
<a class="anchor" id="aa8a3284db45e8ed2784201f1c3d43754"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_index_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAlloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a <code><a class="el" href="structgmx__ana__index__t.xhtml" title="Stores a single index group. ">gmx_ana_index_t</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>Destination index group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source index group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bAlloc</td><td>If true, memory is allocated at <code>dest</code>; otherwise, it is assumed that enough memory has been allocated for index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0f6aafce1b2234d9bd09686352dca71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_index_deinit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory allocated for an index group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Index group structure.</td></tr>
  </table>
  </dd>
</dl>
<p>The pointer <code>g</code> is not freed. </p>

</div>
</div>
<a class="anchor" id="a36418762a1d83eed47840281d779e312"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_index_difference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the set difference between two sorted index groups. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>Output index group (the difference <code>a</code> - <code>b</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First index group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second index group.</td></tr>
  </table>
  </dd>
</dl>
<p><code>dest</code> can equal <code>a</code>, but not <code>b</code>. </p>

</div>
</div>
<a class="anchor" id="a1674b8960e0058dd3a6ab7f7f0a69841"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmx_ana_index_difference_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the size of the difference between two sorted index groups. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First index group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second index group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the difference <code>a</code> - <code>b</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a93b70f0aab85679c5a1aa4a2dca7921a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_index_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgmx_1_1TextWriter.xhtml">gmx::TextWriter</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes out the contents of a index group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">writer</td><td>Writer to use for output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Index group to print. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxn</td><td>Maximum number of indices to print (-1 = print all). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a0f110de3e285c9d700d34876c7872e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gmx_ana_index_equals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether two index groups are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Index group to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Index group to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>a</code> and <code>b</code> are equal, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aaec35269da72e2c51e829dbd65023246"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmx_ana_index_get_max_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns maximum atom index that appears in an index group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Index group to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Largest atom index that appears in <code>g</code>, or zero if <code>g</code> is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a30b8e2df23aaabd93b12f273eb5ad0ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gmx_ana_index_has_complete_elems </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexutil_8h.xhtml#ad7330829cb93245b9de7ed268cf6ba67">e_index_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gmx_mtop_t *&#160;</td>
          <td class="paramname"><em>top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a group consists of full residues/molecules. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Index group to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Block data to check against. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top</td><td>Topology data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>g</code> consists of one or more complete elements of type <code>type</code>, false otherwise.</dd></dl>
<p><code>g</code> is assumed to be sorted, otherwise may return false negatives.</p>
<p>If <code>type</code> is <a class="el" href="indexutil_8h.xhtml#ad7330829cb93245b9de7ed268cf6ba67a8270d36cd367d434ccd9fe0dc1b886d8">INDEX_ATOM</a>, the return value is always true. If <code>type</code> is <a class="el" href="indexutil_8h.xhtml#ad7330829cb93245b9de7ed268cf6ba67a5befa01b9a863bdccbfd308d0c611601">INDEX_UNKNOWN</a> or <a class="el" href="indexutil_8h.xhtml#ad7330829cb93245b9de7ed268cf6ba67a070d857fdc650a9cc8550e231ae91578">INDEX_ALL</a>, the return value is always false. </p>

</div>
</div>
<a class="anchor" id="a63020f357a8efd413470a669e45e1696"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gmx_ana_index_has_full_ablocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_blocka *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a group consists of full blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Index group to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Block data to check against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>g</code> consists of one or more complete blocks from <code>b</code>, false otherwise.</dd></dl>
<p>The atoms in <code>g</code> and <code>b-&gt;a</code> are assumed to be in the same order. </p>

</div>
</div>
<a class="anchor" id="aca7cc6e551789b95a3e59fa3aa4c09df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gmx_ana_index_has_full_blocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const t_block *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a group consists of full blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Index group to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Block data to check against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>g</code> consists of one or more complete blocks from <code>b</code>, false otherwise.</dd></dl>
<p>The atoms in <code>g</code> are assumed to be sorted. </p>

</div>
</div>
<a class="anchor" id="a3dbfc10f956f0cf8d37a72ea6e6b005e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_index_init_simple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>natoms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a simple index group from the first to the <code>natoms'th</code> atom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>Output structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">natoms</td><td>Number of atoms. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac217ad643cf1347e01cff4cca583a0db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_index_intersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the intersection between two sorted index groups. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>Output index group (the intersection of <code>a</code> and <code>b</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First index group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second index group.</td></tr>
  </table>
  </dd>
</dl>
<p><code>dest</code> can be the same as <code>a</code> or <code>b</code>. </p>

</div>
</div>
<a class="anchor" id="a2f0465bdcb2eb967ecf1e1b90c822359"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_index_make_block </td>
          <td>(</td>
          <td class="paramtype">t_blocka *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gmx_mtop_t *&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexutil_8h.xhtml#ad7330829cb93245b9de7ed268cf6ba67">e_index_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bComplete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partition a group based on topology information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">t</td><td>Output block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top</td><td>Topology structure (only used if <code>type</code> is <a class="el" href="indexutil_8h.xhtml#ad7330829cb93245b9de7ed268cf6ba67a744bebc713caa98b8bf8b837af07834d">INDEX_RES</a> or <a class="el" href="indexutil_8h.xhtml#ad7330829cb93245b9de7ed268cf6ba67ae082401c42a6fac46f6701a68f822c86">INDEX_MOL</a>, can be NULL otherwise). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Index group (can be NULL if <code>type</code> is <a class="el" href="indexutil_8h.xhtml#ad7330829cb93245b9de7ed268cf6ba67a5befa01b9a863bdccbfd308d0c611601">INDEX_UNKNOWN</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type of partitioning to make. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bComplete</td><td>If true, the index group is expanded to include any residue/molecule (depending on <code>type</code>) that is partially contained in the group. If <code>type</code> is not INDEX_RES or INDEX_MOL, this has no effect.</td></tr>
  </table>
  </dd>
</dl>
<p><code>m</code> should have been initialized somehow (calloc() is enough). <code>g</code> should be sorted. </p>

</div>
</div>
<a class="anchor" id="a9a83282e2ab6166b970ab221b60e6df1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_index_merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two distinct sorted index groups. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>Output index group (the union of <code>a</code> and <code>b</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First index group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second index group.</td></tr>
  </table>
  </dd>
</dl>
<p><code>a</code> and <code>b</code> should not have common items. <code>dest</code> can equal <code>a</code> or <code>b</code>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="indexutil_8h.xhtml#a42425ece80cdd7b293308fb39edf6e18" title="Calculates the union of two sorted index groups. ">gmx_ana_index_union()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1a1be16095557d63b0c3a1bf7f9f29b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_index_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>dest1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>dest2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the intersection and the difference in one call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest1</td><td>Output group 1 (will equal <code>g</code>). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest2</td><td>Output group 2 (will equal <code>src</code> - <code>g</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Group to be partitioned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>One partition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>g</code> is a subset of <code>src</code> and both sets are sorted </dd>
<dd>
<code>dest1</code> has allocated storage to store <code>src</code> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>dest1</code> == <code>g</code> </dd>
<dd>
<code>dest2</code> == <code>src</code> - <code>g</code> </dd></dl>
<p>No storage should be allocated for <code>dest2</code>; after the call, <code>dest2-&gt;index</code> points to the memory allocated for <code>dest1</code> (to a part that is not used by <code>dest1</code>).</p>
<p>The calculation can be performed in-place by setting <code>dest1</code> equal to <code>src</code>. </p>

</div>
</div>
<a class="anchor" id="a20e55f7dfde504062bd7611bb3c1f334"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_index_remove_duplicates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes duplicates from a sorted index group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">g</td><td>Index group to be processed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a084e5e78e92e2035a834bf7958a45b20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_index_reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>isize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserves memory to store an index group of size <code>isize</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">g</td><td>Index group structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isize</td><td>Maximum number of atoms to reserve space for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6b64a9302f16fbc24a1eb03bdf41d00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_index_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>isize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nalloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a <code><a class="el" href="structgmx__ana__index__t.xhtml" title="Stores a single index group. ">gmx_ana_index_t</a></code> from given values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>Output structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isize</td><td>Number of atoms in the new group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Array of <code>isize</code> atoms (can be NULL if <code>isize</code> is 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nalloc</td><td>Number of elements allocated for <code>index</code> (if 0, <code>index</code> is not freed in <a class="el" href="indexutil_8h.xhtml#ad0f6aafce1b2234d9bd09686352dca71" title="Frees memory allocated for an index group. ">gmx_ana_index_deinit()</a>)</td></tr>
  </table>
  </dd>
</dl>
<p>No copy if <code>index</code> is made. </p>

</div>
</div>
<a class="anchor" id="a8872aa14b9b23e545bd6a6c8c49238cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_index_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the indices within an index group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">g</td><td>Index group to be sorted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af45d8a0b1b4bacf126a01d04e8357f49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_index_squeeze </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees any memory not necessary to hold the current contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">g</td><td>Index group structure.</td></tr>
  </table>
  </dd>
</dl>
<p>Resizes the memory allocated for holding the indices such that the current contents fit. </p>

</div>
</div>
<a class="anchor" id="a42425ece80cdd7b293308fb39edf6e18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_index_union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the union of two sorted index groups. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>Output index group (the union of <code>a</code> and <code>b</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First index group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second index group.</td></tr>
  </table>
  </dd>
</dl>
<p><code>a</code> and <code>b</code> can have common items. <code>dest</code> can equal <code>a</code> or <code>b</code>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="indexutil_8h.xhtml#a9a83282e2ab6166b970ab221b60e6df1" title="Merges two distinct sorted index groups. ">gmx_ana_index_merge()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a29f3105dac88715d0a2278a2025544da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_index_union_unsorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the union of two index groups, where the second group may not be sorted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>Output index group (the union of <code>a</code> and <code>b</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First index group (must be sorted). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second index group.</td></tr>
  </table>
  </dd>
</dl>
<p><code>a</code> and <code>b</code> can have common items. <code>dest</code> can equal <code>a</code> or <code>b</code>. </p>

</div>
</div>
<a class="anchor" id="afd435ef78f954dfe2da4333d646f2b4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gmx_ana_indexgrps_extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>destName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_ana_indexgrps_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a single index group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>Output structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destName</td><td>Receives the name of the group if found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Input index groups. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of the group to extract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>n</code> is a valid group in <code>src</code>, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e58b81f252d8d791993878fd486affb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gmx_ana_indexgrps_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>destName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_ana_indexgrps_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds and extracts a single index group by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>Output structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destName</td><td>Receives the name of the group if found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Input index groups. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name (or part of the name) of the group to extract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>name</code> is a valid group in <code>src</code>, false otherwise.</dd></dl>
<p>Uses the Gromacs routine find_group() to find the actual group; the comparison is case-insensitive. </p>

</div>
</div>
<a class="anchor" id="a7c52fc07ccfa2796785a9ca0463a28e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_indexgrps_free </td>
          <td>(</td>
          <td class="paramtype">gmx_ana_indexgrps_t *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory allocated for index groups. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Index groups structure.</td></tr>
  </table>
  </dd>
</dl>
<p>The pointer <code>g</code> is invalid after the call. </p>

</div>
</div>
<a class="anchor" id="a0789934fa881d09faa55e4c280c77d68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a>* gmx_ana_indexgrps_get_grp </td>
          <td>(</td>
          <td class="paramtype">gmx_ana_indexgrps_t *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to an index group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Index groups structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Index group number to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the <code>n'th</code> index group in <code>g</code>.</dd></dl>
<p>The returned pointer should not be freed. </p>

</div>
</div>
<a class="anchor" id="a0d73c532466a6c1f16eaa79ac7779cda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_indexgrps_init </td>
          <td>(</td>
          <td class="paramtype">gmx_ana_indexgrps_t **&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_mtop_t *&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fnm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads index groups from a file or constructs them from topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>Index group structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top</td><td>Topology structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fnm</td><td>File name for the index file. Memory is automatically allocated.</td></tr>
  </table>
  </dd>
</dl>
<p>One or both of <code>top</code> or <code>fnm</code> can be NULL. If <code>top</code> is NULL, an index file is required and the groups are read from the file (uses Gromacs routine init_index()). If <code>fnm</code> is NULL, default groups are constructed based on the topology (uses Gromacs routine analyse()). If both are null, the index group structure is initialized empty. </p>

</div>
</div>
<a class="anchor" id="a90734f01fd06a2ae8864d8a1807edfba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gmx_ana_indexgrps_is_empty </td>
          <td>(</td>
          <td class="paramtype">gmx_ana_indexgrps_t *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the index group structure is emtpy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>Index group structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>g</code> is empty, i.e., has 0 index groups. </dd></dl>

</div>
</div>
<a class="anchor" id="a95fdac296eb9b2f1e57b3efbe18c221d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_indexgrps_print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgmx_1_1TextWriter.xhtml">gmx::TextWriter</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmx_ana_indexgrps_t *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes out a list of index groups. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">writer</td><td>Writer to use for output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Index groups to print. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxn</td><td>Maximum number of indices to print (-1 = print all, 0 = print only names). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a521bc0c5c619c566925ba515c6501a50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_indexmap_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__indexmap__t.xhtml">gmx_ana_indexmap_t</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an empty index group mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>Output structure.</td></tr>
  </table>
  </dd>
</dl>
<p>Any contents of <code>m</code> are discarded without freeing. </p>

</div>
</div>
<a class="anchor" id="accb30c49eef3b94b1d6318742cbc8662"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_indexmap_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__indexmap__t.xhtml">gmx_ana_indexmap_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgmx__ana__indexmap__t.xhtml">gmx_ana_indexmap_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a deep copy of an index group mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dest</td><td>Destination data structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source mapping. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bFirst</td><td>If true, memory is allocated for <code>dest</code> and a full copy is made; otherwise, only variable parts are copied, and no memory is allocated.</td></tr>
  </table>
  </dd>
</dl>
<p><code>dest</code> should have been initialized somehow (calloc() is enough). </p>

</div>
</div>
<a class="anchor" id="a03b58612d9db3c295423c4ad9fb73160"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_indexmap_deinit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__indexmap__t.xhtml">gmx_ana_indexmap_t</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory allocated for index group mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>Mapping structure to free.</td></tr>
  </table>
  </dd>
</dl>
<p>All the memory allocated for the mapping structure is freed, and the pointers set to NULL. The pointer <code>m</code> is not freed. </p>

</div>
</div>
<a class="anchor" id="a74069ed995e7641acfd6671ea3a28f63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_indexmap_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__indexmap__t.xhtml">gmx_ana_indexmap_t</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gmx_mtop_t *&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexutil_8h.xhtml#ad7330829cb93245b9de7ed268cf6ba67">e_index_t</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an index group mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>Mapping structure to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Index group to map (can be NULL if <code>type</code> is <a class="el" href="indexutil_8h.xhtml#ad7330829cb93245b9de7ed268cf6ba67a5befa01b9a863bdccbfd308d0c611601">INDEX_UNKNOWN</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top</td><td>Topology structure (can be NULL if <code>type</code> is not <a class="el" href="indexutil_8h.xhtml#ad7330829cb93245b9de7ed268cf6ba67a744bebc713caa98b8bf8b837af07834d">INDEX_RES</a> or <a class="el" href="indexutil_8h.xhtml#ad7330829cb93245b9de7ed268cf6ba67ae082401c42a6fac46f6701a68f822c86">INDEX_MOL</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type of mapping to construct.</td></tr>
  </table>
  </dd>
</dl>
<p>Initializes a new index group mapping. The index group provided to <a class="el" href="indexutil_8h.xhtml#aa100f0522b7c9ad3090ee32fe7ced7ad" title="Updates an index group mapping. ">gmx_ana_indexmap_update()</a> should always be a subset of the <code>g</code> given here.</p>
<p><code>m</code> should have been initialized somehow (calloc() is enough). </p>

</div>
</div>
<a class="anchor" id="aaf51b32674087a263fc7b34305b307cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmx_ana_indexmap_init_orgid_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__indexmap__t.xhtml">gmx_ana_indexmap_t</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gmx_mtop_t *&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexutil_8h.xhtml#ad7330829cb93245b9de7ed268cf6ba67">e_index_t</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes <code>orgid</code> entries based on topology grouping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>Mapping structure to use/initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top</td><td>Topology structure (can be NULL if not required for <code>type</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type of groups to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of groups of type <code>type</code> that were present in <code>m</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InconsistentInputError</td><td>if the blocks in <code>m</code> do not have a unique group (e.g., contain atoms from multiple residues with <code>type == INDEX_RES</code>).</td></tr>
  </table>
  </dd>
</dl>
<p>By default, the <a class="el" href="structgmx__ana__indexmap__t.xhtml#a480c734c65ad2a432690b7d27663fb40" title="Customizable ID numbers for the original blocks. ">gmx_ana_indexmap_t::orgid</a> fields are initialized to atom/residue/molecule indices from the topology (see documentation for the struct for more details). This function can be used to set the field to a zero-based group index instead. The first block will always get <code>orgid[0] = 0</code>, and all following blocks that belong to the same residue/molecule (<code>type</code>) will get the same index. Each time a block does not belong to the same group, it will get the next available number. If <code>type == INDEX_ATOM</code>, the <code>orgid</code> field is initialized as 0, 1, ..., independent of whether the blocks are single atoms or not.</p>
<p>Strong exception safety guarantee. </p>

</div>
</div>
<a class="anchor" id="ae81020f97f9da8509f85166d293d8575"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_indexmap_reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__indexmap__t.xhtml">gmx_ana_indexmap_t</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>isize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserves memory for an index group mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>Mapping structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nr</td><td>Maximum number of blocks to reserve space for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isize</td><td>Maximum number of atoms to reserve space for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a343d136c6f9999de805f7b0197707d0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_indexmap_set_static </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__indexmap__t.xhtml">gmx_ana_indexmap_t</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_blocka *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an index group mapping to be static. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>Mapping structure to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Block information to use for data.</td></tr>
  </table>
  </dd>
</dl>
<p>Frees some memory that is not necessary for static index group mappings. Internal pointers are set to point to data in <code>b</code>; it is the responsibility of the caller to ensure that the block information matches the contents of the mapping. After this function has been called, the index group provided to <a class="el" href="indexutil_8h.xhtml#aa100f0522b7c9ad3090ee32fe7ced7ad" title="Updates an index group mapping. ">gmx_ana_indexmap_update()</a> should always be the same as <code>g</code> given here.</p>
<p>This function breaks modularity of the index group mapping interface in an ugly way, but allows reducing memory usage of static selections by a significant amount. </p>

</div>
</div>
<a class="anchor" id="aa100f0522b7c9ad3090ee32fe7ced7ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx_ana_indexmap_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__ana__indexmap__t.xhtml">gmx_ana_indexmap_t</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgmx__ana__index__t.xhtml">gmx_ana_index_t</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMaskOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates an index group mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>Mapping structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Current index group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bMaskOnly</td><td>true if the unused blocks should be masked with -1 instead of removing them.</td></tr>
  </table>
  </dd>
</dl>
<p>Updates the index group mapping with the new index group <code>g</code>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structgmx__ana__indexmap__t.xhtml" title="Data structure for calculating index group mappings. ">gmx_ana_indexmap_t</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 23 2018 14:56:07 for Gromacs by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
