<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Gromacs: gmx::CubicSplineTable Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Gromacs
   &#160;<span id="projectnumber">2018.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.xhtml"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.xhtml"><span>Modules</span></a></li>
      <li><a href="pages.xhtml"><span>Other&#160;Docs</span></a></li>
      <li><a href="namespaces.xhtml"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.xhtml"><span>Classes</span></a></li>
      <li><a href="files.xhtml"><span>Files</span></a></li>
      <li><a href="examples.xhtml"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.xhtml"><span>Class&#160;List</span></a></li>
      <li><a href="classes.xhtml"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.xhtml"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.xhtml"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegmx.xhtml">gmx</a></li><li class="navelem"><a class="el" href="classgmx_1_1CubicSplineTable.xhtml">CubicSplineTable</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classgmx_1_1CubicSplineTable-members.xhtml">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">gmx::CubicSplineTable Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;gromacs/tables/cubicsplinetable.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Cubic spline interpolation table. </p>
<p>This class interpolates a function specified either as an analytical expression or from user-provided table data.</p>
<p>At initialization, you provide the reference function of vectors as a list of tuples that contain a brief name, the function, and derivative for each function to tabulate. To create a table with two functions this initializer list can for instance look like </p>
<pre class="fragment">{ {"LJ6", lj6Func, lj6Der}, {"LJ12", lj12Func, lj12Der} }
</pre><p>The names are only used so exceptions during initialization can be traced to a specific table.</p>
<p>When interpolating, there are methods to interpolate either 1, 2, or 3 functions in one go. By default these interpolation routines will operate on tables with the same number of functions as specified in the interpolation method (debug builds check that this is consistent with the table). However, it is also possible to use optional template parameters that specify the total number of functions in a table, and what function index to interpolate. For instance, to interpolate the derivative of the second function (i.e., index 1) in a multi-function-table with three functions in total, you can write </p>
<pre class="fragment">table.evaluateDerivative&lt;3,1&gt;(x,&amp;der);
</pre><p>Here too, debug builds will check that the template parameters are consistent with the table.</p>
<p>This class interpolates a function specified either as an analytical expression or from user-provided table data. The coefficients for each table point are precalculated such that we simply evaluate</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} V(x) = Y + F \epsilon + G \epsilon^2 + H \epsilon^3 V'(x) = (F + 2 G \epsilon + 3 H \epsilon^2)/h \end{eqnarray*}" src="form_50.png"/>
</p>
<p>Where h is the spacing and epsilon the fractional offset from table point.</p>
<p>While it is possible to create tables only from function values (i.e., no derivatives), it is recommended to provide derivatives for higher accuracy and to avoid issues with numerical differentiation. Note that the table input should be smooth, i.e. it should not contain noise e.g. from an (iterative) Boltzmann inversion procedure - you have been warned.</p>
<dl class="section note"><dt>Note</dt><dd>This class is responsible for fundamental interpolation of any function, which might or might not correspond to a potential. For this reason both input and output derivatives are proper function derivatives, and we do not swap any signs to get forces directly from the table.</dd>
<dd>
There will be a small additional accuracy loss from the internal operation where we calculate the epsilon offset from the nearest table point, since the integer part we subtract can get large in those cases. While this is technically possible to solve with extended precision arithmetics, that would introduce extra instructions in some highly performance-sensitive code parts. For typical GROMACS interaction functions the derivatives will decay faster than the potential, which means it will never play any role. For other functions it will only cause a small increase in the relative error for arguments where the magnitude of the function or derivative is very small. Since we typically sum several results in GROMACS, this should never show up in any real cases, and for this reason we choose not to do the extended precision arithmetics.</dd>
<dd>
These routines are not suitable for table ranges starting far away from zero, since we allocate memory and calculate indices starting from range zero for efficiency reasons. </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5e085fc0b25f72bef439f2031a465132"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1CubicSplineTable.xhtml#a5e085fc0b25f72bef439f2031a465132">CubicSplineTable</a> (std::initializer_list&lt; <a class="el" href="structgmx_1_1AnalyticalSplineTableInput.xhtml">AnalyticalSplineTableInput</a> &gt; analyticalInputList, const std::pair&lt; <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> &gt; &amp;range, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> tolerance=<a class="el" href="classgmx_1_1CubicSplineTable.xhtml#a336f1afeaabfe544c6e4a8135b216010">defaultTolerance</a>)</td></tr>
<tr class="memdesc:a5e085fc0b25f72bef439f2031a465132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize table data from function.  <a href="#a5e085fc0b25f72bef439f2031a465132">More...</a><br/></td></tr>
<tr class="separator:a5e085fc0b25f72bef439f2031a465132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346c3e2e67c3339507c842ca425ee773"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1CubicSplineTable.xhtml#a346c3e2e67c3339507c842ca425ee773">CubicSplineTable</a> (std::initializer_list&lt; <a class="el" href="structgmx_1_1NumericalSplineTableInput.xhtml">NumericalSplineTableInput</a> &gt; numericalInputList, const std::pair&lt; <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> &gt; &amp;range, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> tolerance=<a class="el" href="classgmx_1_1CubicSplineTable.xhtml#a336f1afeaabfe544c6e4a8135b216010">defaultTolerance</a>)</td></tr>
<tr class="memdesc:a346c3e2e67c3339507c842ca425ee773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize table data from tabulated values and derivatives.  <a href="#a346c3e2e67c3339507c842ca425ee773">More...</a><br/></td></tr>
<tr class="separator:a346c3e2e67c3339507c842ca425ee773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3756dcb30a07e457d957171e62e96f50"><td class="memTemplParams" colspan="2">template&lt;int numFuncInTable = 1, int funcIndex = 0, typename T &gt; </td></tr>
<tr class="memitem:a3756dcb30a07e457d957171e62e96f50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgmx_1_1CubicSplineTable.xhtml#a3756dcb30a07e457d957171e62e96f50">evaluateFunctionAndDerivative</a> (T r, T *functionValue, T *derivativeValue) const </td></tr>
<tr class="memdesc:a3756dcb30a07e457d957171e62e96f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate both function and derivative, single table function.  <a href="#a3756dcb30a07e457d957171e62e96f50">More...</a><br/></td></tr>
<tr class="separator:a3756dcb30a07e457d957171e62e96f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a67367a68cb0a5d59df0e0ce21dc311"><td class="memTemplParams" colspan="2">template&lt;int numFuncInTable = 1, int funcIndex = 0, typename T &gt; </td></tr>
<tr class="memitem:a5a67367a68cb0a5d59df0e0ce21dc311"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgmx_1_1CubicSplineTable.xhtml#a5a67367a68cb0a5d59df0e0ce21dc311">evaluateFunction</a> (T r, T *functionValue) const </td></tr>
<tr class="memdesc:a5a67367a68cb0a5d59df0e0ce21dc311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate function value only, single table function.  <a href="#a5a67367a68cb0a5d59df0e0ce21dc311">More...</a><br/></td></tr>
<tr class="separator:a5a67367a68cb0a5d59df0e0ce21dc311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbab9ed0cf2f6342e6f98998f29b490"><td class="memTemplParams" colspan="2">template&lt;int numFuncInTable = 1, int funcIndex = 0, typename T &gt; </td></tr>
<tr class="memitem:a9cbab9ed0cf2f6342e6f98998f29b490"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgmx_1_1CubicSplineTable.xhtml#a9cbab9ed0cf2f6342e6f98998f29b490">evaluateDerivative</a> (T r, T *derivativeValue) const </td></tr>
<tr class="memdesc:a9cbab9ed0cf2f6342e6f98998f29b490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate function derivative only, single table function.  <a href="#a9cbab9ed0cf2f6342e6f98998f29b490">More...</a><br/></td></tr>
<tr class="separator:a9cbab9ed0cf2f6342e6f98998f29b490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257c3269189ffac8955980945ff390fd"><td class="memTemplParams" colspan="2">template&lt;int numFuncInTable = 2, int funcIndex0 = 0, int funcIndex1 = 1, typename T &gt; </td></tr>
<tr class="memitem:a257c3269189ffac8955980945ff390fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgmx_1_1CubicSplineTable.xhtml#a257c3269189ffac8955980945ff390fd">evaluateFunctionAndDerivative</a> (T r, T *functionValue0, T *derivativeValue0, T *functionValue1, T *derivativeValue1) const </td></tr>
<tr class="memdesc:a257c3269189ffac8955980945ff390fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate both function and derivative, two table functions.  <a href="#a257c3269189ffac8955980945ff390fd">More...</a><br/></td></tr>
<tr class="separator:a257c3269189ffac8955980945ff390fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac721186db4029fad25565f59c9492d4b"><td class="memTemplParams" colspan="2">template&lt;int numFuncInTable = 2, int funcIndex0 = 0, int funcIndex1 = 1, typename T &gt; </td></tr>
<tr class="memitem:ac721186db4029fad25565f59c9492d4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgmx_1_1CubicSplineTable.xhtml#ac721186db4029fad25565f59c9492d4b">evaluateFunction</a> (T r, T *functionValue0, T *functionValue1) const </td></tr>
<tr class="memdesc:ac721186db4029fad25565f59c9492d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate function value only, two table functions.  <a href="#ac721186db4029fad25565f59c9492d4b">More...</a><br/></td></tr>
<tr class="separator:ac721186db4029fad25565f59c9492d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c6e4d1ba37df0a4552daac05d181ab"><td class="memTemplParams" colspan="2">template&lt;int numFuncInTable = 2, int funcIndex0 = 0, int funcIndex1 = 1, typename T &gt; </td></tr>
<tr class="memitem:a75c6e4d1ba37df0a4552daac05d181ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgmx_1_1CubicSplineTable.xhtml#a75c6e4d1ba37df0a4552daac05d181ab">evaluateDerivative</a> (T r, T *derivativeValue0, T *derivativeValue1) const </td></tr>
<tr class="memdesc:a75c6e4d1ba37df0a4552daac05d181ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate function derivative only, two table functions.  <a href="#a75c6e4d1ba37df0a4552daac05d181ab">More...</a><br/></td></tr>
<tr class="separator:a75c6e4d1ba37df0a4552daac05d181ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a92744d336e2abb9c16fb39ee24244"><td class="memTemplParams" colspan="2">template&lt;int numFuncInTable = 3, int funcIndex0 = 0, int funcIndex1 = 1, int funcIndex2 = 2, typename T &gt; </td></tr>
<tr class="memitem:ab7a92744d336e2abb9c16fb39ee24244"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgmx_1_1CubicSplineTable.xhtml#ab7a92744d336e2abb9c16fb39ee24244">evaluateFunctionAndDerivative</a> (T r, T *functionValue0, T *derivativeValue0, T *functionValue1, T *derivativeValue1, T *functionValue2, T *derivativeValue2) const </td></tr>
<tr class="memdesc:ab7a92744d336e2abb9c16fb39ee24244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate both function and derivative, three table functions.  <a href="#ab7a92744d336e2abb9c16fb39ee24244">More...</a><br/></td></tr>
<tr class="separator:ab7a92744d336e2abb9c16fb39ee24244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92085d7ebfe6d4e7180064eff2d30313"><td class="memTemplParams" colspan="2">template&lt;int numFuncInTable = 3, int funcIndex0 = 0, int funcIndex1 = 1, int funcIndex2 = 2, typename T &gt; </td></tr>
<tr class="memitem:a92085d7ebfe6d4e7180064eff2d30313"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgmx_1_1CubicSplineTable.xhtml#a92085d7ebfe6d4e7180064eff2d30313">evaluateFunction</a> (T r, T *functionValue0, T *functionValue1, T *functionValue2) const </td></tr>
<tr class="memdesc:a92085d7ebfe6d4e7180064eff2d30313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate function value only, three table functions.  <a href="#a92085d7ebfe6d4e7180064eff2d30313">More...</a><br/></td></tr>
<tr class="separator:a92085d7ebfe6d4e7180064eff2d30313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b29e8da415722a63c15cf2588c8737"><td class="memTemplParams" colspan="2">template&lt;int numFuncInTable = 3, int funcIndex0 = 0, int funcIndex1 = 1, int funcIndex2 = 2, typename T &gt; </td></tr>
<tr class="memitem:a50b29e8da415722a63c15cf2588c8737"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgmx_1_1CubicSplineTable.xhtml#a50b29e8da415722a63c15cf2588c8737">evaluateDerivative</a> (T r, T *derivativeValue0, T *derivativeValue1, T *derivativeValue2) const </td></tr>
<tr class="memdesc:a50b29e8da415722a63c15cf2588c8737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate function derivative only, three table functions.  <a href="#a50b29e8da415722a63c15cf2588c8737">More...</a><br/></td></tr>
<tr class="separator:a50b29e8da415722a63c15cf2588c8737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7a2c1163edded0f6d64a830bd33077"><td class="memItemLeft" align="right" valign="top"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1CubicSplineTable.xhtml#a3b7a2c1163edded0f6d64a830bd33077">tableSpacing</a> () const </td></tr>
<tr class="memdesc:a3b7a2c1163edded0f6d64a830bd33077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the table spacing (distance between points)  <a href="#a3b7a2c1163edded0f6d64a830bd33077">More...</a><br/></td></tr>
<tr class="separator:a3b7a2c1163edded0f6d64a830bd33077"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a336f1afeaabfe544c6e4a8135b216010"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgmx_1_1CubicSplineTable.xhtml#a336f1afeaabfe544c6e4a8135b216010">defaultTolerance</a> = 10.0 * 1.19209290e-07F</td></tr>
<tr class="memdesc:a336f1afeaabfe544c6e4a8135b216010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default tolerance for cubic spline tables.  <a href="#a336f1afeaabfe544c6e4a8135b216010">More...</a><br/></td></tr>
<tr class="separator:a336f1afeaabfe544c6e4a8135b216010"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5e085fc0b25f72bef439f2031a465132"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gmx::CubicSplineTable::CubicSplineTable </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="structgmx_1_1AnalyticalSplineTableInput.xhtml">AnalyticalSplineTableInput</a> &gt;&#160;</td>
          <td class="paramname"><em>analyticalInputList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="classgmx_1_1CubicSplineTable.xhtml#a336f1afeaabfe544c6e4a8135b216010">defaultTolerance</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize table data from function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">analyticalInputList</td><td>Initializer list with one or more functions to tabulate, specified as elements with a string description and the function as well as derivative. The function will also be called for values smaller than the lower limit of the range, but we avoid calling it for 0.0 if that value is not included in the range. Constructor will throw <a class="el" href="classgmx_1_1APIError.xhtml" title="Exception class for incorrect use of an API. ">gmx::APIError</a> for negative values. Due to the way the numerical derivative evaluation depends on machine precision internally, this range must be at least 0.001, or the constructor throws <a class="el" href="classgmx_1_1APIError.xhtml" title="Exception class for incorrect use of an API. ">gmx::APIError</a>. </td></tr>
    <tr><td class="paramname">range</td><td>Range over which the function will be tabulated. Constructor will throw <a class="el" href="classgmx_1_1APIError.xhtml" title="Exception class for incorrect use of an API. ">gmx::APIError</a> for negative values, or if the value/derivative vector does not cover the range. </td></tr>
    <tr><td class="paramname">tolerance</td><td>Requested accuracy of the table. This will be used to calculate the required internal spacing. If this cannot be achieved (for instance because the table would require too much memory) the constructor will throw <a class="el" href="classgmx_1_1ToleranceError.xhtml" title="Exception class when a specified tolerance cannot be achieved. ">gmx::ToleranceError</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The functions are always defined in double precision to avoid losing accuracy when constructing tables.</dd>
<dd>
Since we fill the table for values below range.first, you can achieve a smaller table by using a smaller range where the tolerance has to be met, and accept that a few function calls below range.first do not quite reach the tolerance.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>For efficiency reasons (since this code is used in some inner (kernels), we always allocate memory and calculate table indices for the complete interval [0,range.second], although the data will not be valid outside the definition range to avoid calling the function there. This means you should <em>not</em> use this class to tabulate functions for small ranges very far away from zero, since you would both waste a huge amount of memory and incur truncation errors when calculating the index.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classgmx_1_1ToleranceError.xhtml" title="Exception class when a specified tolerance cannot be achieved. ">gmx::ToleranceError</a></td><td>if the requested tolerance cannot be achieved, and <a class="el" href="classgmx_1_1APIError.xhtml" title="Exception class for incorrect use of an API. ">gmx::APIError</a> for other incorrect input. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a346c3e2e67c3339507c842ca425ee773"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gmx::CubicSplineTable::CubicSplineTable </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="structgmx_1_1NumericalSplineTableInput.xhtml">NumericalSplineTableInput</a> &gt;&#160;</td>
          <td class="paramname"><em>numericalInputList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="classgmx_1_1CubicSplineTable.xhtml#a336f1afeaabfe544c6e4a8135b216010">defaultTolerance</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize table data from tabulated values and derivatives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numericalInputList</td><td>Initializer list with one or more functions to tabulate, specified as a string description, vectors with function and derivative values, and the input spacing. Data points are separated by the spacing parameter, starting from 0. Values below the lower limit of the range will be used to attempt defining the table, but we avoid using index 0 unless 0.0 is included in the range. Some extra points beyond range.second are required to re-interpolate values, so add some margin. The constructor will throw <a class="el" href="classgmx_1_1APIError.xhtml" title="Exception class for incorrect use of an API. ">gmx::APIError</a> if the input vectors are too short to cover the requested range (and they must always be at least five points). </td></tr>
    <tr><td class="paramname">range</td><td>Range over which the function will be tabulated. Constructor will throw <a class="el" href="classgmx_1_1APIError.xhtml" title="Exception class for incorrect use of an API. ">gmx::APIError</a> for negative values, or if the value/derivative vector does not cover the range. </td></tr>
    <tr><td class="paramname">tolerance</td><td>Requested accuracy of the table. This will be used to calculate the required internal spacing and possibly re-interpolate. The constructor will throw <a class="el" href="classgmx_1_1ToleranceError.xhtml" title="Exception class when a specified tolerance cannot be achieved. ">gmx::ToleranceError</a> if the input spacing is too coarse to achieve this accuracy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The input data vectors are always double precision to avoid losing accuracy when constructing tables.</dd>
<dd>
Since we fill the table for values below range.first, you can achieve a smaller table by using a smaller range where the tolerance has to be met, and accept that a few function calls below range.first do not quite reach the tolerance.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>For efficiency reasons (since this code is used in some inner (kernels), we always allocate memory and calculate table indices for the complete interval [0,range.second], although the data will not be valid outside the definition range to avoid calling the function there. This means you should <em>not</em> use this class to tabulate functions for small ranges very far away from zero, since you would both waste a huge amount of memory and incur truncation errors when calculating the index. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9cbab9ed0cf2f6342e6f98998f29b490"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int numFuncInTable = 1, int funcIndex = 0, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::CubicSplineTable::evaluateDerivative </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>derivativeValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate function derivative only, single table function. </p>
<p>This is a templated method where the template can be either real or SimdReal.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">numFuncInTable</td><td>Number of separate functions in table, default is 1 </td></tr>
    <tr><td class="paramname">funcIndex</td><td>Index of function to evaluate in table, default is 0 </td></tr>
    <tr><td class="paramname">T</td><td>Type (SimdReal or real) of lookup and result </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">r</td><td>Points for which to evaluate function derivative </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">derivativeValue</td><td>Function derivative</td></tr>
  </table>
  </dd>
</dl>
<p>For debug builds we assert that the input values fall in the range specified when constructing the table. </p>

</div>
</div>
<a class="anchor" id="a75c6e4d1ba37df0a4552daac05d181ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int numFuncInTable = 2, int funcIndex0 = 0, int funcIndex1 = 1, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::CubicSplineTable::evaluateDerivative </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>derivativeValue0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>derivativeValue1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate function derivative only, two table functions. </p>
<p>This is a templated method where the template can be either real or SimdReal.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">numFuncInTable</td><td>Number of separate functions in table, default is 2 </td></tr>
    <tr><td class="paramname">funcIndex0</td><td>Index of 1st function to evaluate in table, default is 0 </td></tr>
    <tr><td class="paramname">funcIndex1</td><td>Index of 2nd function to evaluate in table, default is 1 </td></tr>
    <tr><td class="paramname">T</td><td>Type (SimdReal or real) of lookup and result </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">r</td><td>Points for which to evaluate function derivative </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">derivativeValue0</td><td>Interpolated derivative for first function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">derivativeValue1</td><td>Interpolated derivative for second function</td></tr>
  </table>
  </dd>
</dl>
<p>For debug builds we assert that the input values fall in the range specified when constructing the table. </p>

</div>
</div>
<a class="anchor" id="a50b29e8da415722a63c15cf2588c8737"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int numFuncInTable = 3, int funcIndex0 = 0, int funcIndex1 = 1, int funcIndex2 = 2, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::CubicSplineTable::evaluateDerivative </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>derivativeValue0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>derivativeValue1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>derivativeValue2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate function derivative only, three table functions. </p>
<p>This is a templated method where the template can be either real or SimdReal.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">numFuncInTable</td><td>Number of separate functions in table, default is 3 </td></tr>
    <tr><td class="paramname">funcIndex0</td><td>Index of 1st function to evaluate in table, default is 0 </td></tr>
    <tr><td class="paramname">funcIndex1</td><td>Index of 2nd function to evaluate in table, default is 1 </td></tr>
    <tr><td class="paramname">funcIndex2</td><td>Index of 3rd function to evaluate in table, default is 2 </td></tr>
    <tr><td class="paramname">T</td><td>Type (SimdReal or real) of lookup and result </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">r</td><td>Points for which to evaluate function derivative </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">derivativeValue0</td><td>Interpolated derivative for first function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">derivativeValue1</td><td>Interpolated derivative for second function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">derivativeValue2</td><td>Interpolated derivative for third function</td></tr>
  </table>
  </dd>
</dl>
<p>For debug builds we assert that the input values fall in the range specified when constructing the table. </p>

</div>
</div>
<a class="anchor" id="a5a67367a68cb0a5d59df0e0ce21dc311"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int numFuncInTable = 1, int funcIndex = 0, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::CubicSplineTable::evaluateFunction </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>functionValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate function value only, single table function. </p>
<p>This is a templated method where the template can be either real or SimdReal.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">numFuncInTable</td><td>Number of separate functions in table, default is 1 </td></tr>
    <tr><td class="paramname">funcIndex</td><td>Index of function to evaluate in table, default is 0 </td></tr>
    <tr><td class="paramname">T</td><td>Type (SimdReal or real) of lookup and result </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">r</td><td>Points for which to evaluate function value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">functionValue</td><td>Function value</td></tr>
  </table>
  </dd>
</dl>
<p>For debug builds we assert that the input values fall in the range specified when constructing the table. </p>

</div>
</div>
<a class="anchor" id="ac721186db4029fad25565f59c9492d4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int numFuncInTable = 2, int funcIndex0 = 0, int funcIndex1 = 1, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::CubicSplineTable::evaluateFunction </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>functionValue0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>functionValue1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate function value only, two table functions. </p>
<p>This is a templated method where the template can be either real or SimdReal.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">numFuncInTable</td><td>Number of separate functions in table, default is 2 </td></tr>
    <tr><td class="paramname">funcIndex0</td><td>Index of 1st function to evaluate in table, default is 0 </td></tr>
    <tr><td class="paramname">funcIndex1</td><td>Index of 2nd function to evaluate in table, default is 1 </td></tr>
    <tr><td class="paramname">T</td><td>Type (SimdReal or real) of lookup and result </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">r</td><td>Points for which to evaluate function value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">functionValue0</td><td>Interpolated value for first function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">functionValue1</td><td>Interpolated value for second function</td></tr>
  </table>
  </dd>
</dl>
<p>For debug builds we assert that the input values fall in the range specified when constructing the table. </p>

</div>
</div>
<a class="anchor" id="a92085d7ebfe6d4e7180064eff2d30313"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int numFuncInTable = 3, int funcIndex0 = 0, int funcIndex1 = 1, int funcIndex2 = 2, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::CubicSplineTable::evaluateFunction </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>functionValue0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>functionValue1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>functionValue2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate function value only, three table functions. </p>
<p>This is a templated method where the template can be either real or SimdReal.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">numFuncInTable</td><td>Number of separate functions in table, default is 3 </td></tr>
    <tr><td class="paramname">funcIndex0</td><td>Index of 1st function to evaluate in table, default is 0 </td></tr>
    <tr><td class="paramname">funcIndex1</td><td>Index of 2nd function to evaluate in table, default is 1 </td></tr>
    <tr><td class="paramname">funcIndex2</td><td>Index of 3rd function to evaluate in table, default is 2 </td></tr>
    <tr><td class="paramname">T</td><td>Type (SimdReal or real) of lookup and result </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">r</td><td>Points for which to evaluate function value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">functionValue0</td><td>Interpolated value for first function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">functionValue1</td><td>Interpolated value for second function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">functionValue2</td><td>Interpolated value for third function</td></tr>
  </table>
  </dd>
</dl>
<p>For debug builds we assert that the input values fall in the range specified when constructing the table. </p>

</div>
</div>
<a class="anchor" id="a3756dcb30a07e457d957171e62e96f50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int numFuncInTable = 1, int funcIndex = 0, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::CubicSplineTable::evaluateFunctionAndDerivative </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>functionValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>derivativeValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate both function and derivative, single table function. </p>
<p>This is a templated method where the template can be either real or SimdReal.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">numFuncInTable</td><td>Number of separate functions in table, default is 1 </td></tr>
    <tr><td class="paramname">funcIndex</td><td>Index of function to evaluate in table, default is 0 </td></tr>
    <tr><td class="paramname">T</td><td>Type (SimdReal or real) of lookup and result </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">r</td><td>Points for which to evaluate function and derivative </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">functionValue</td><td>Function value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">derivativeValue</td><td>Function derivative</td></tr>
  </table>
  </dd>
</dl>
<p>For debug builds we assert that the input values fall in the range specified when constructing the table. </p>

</div>
</div>
<a class="anchor" id="a257c3269189ffac8955980945ff390fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int numFuncInTable = 2, int funcIndex0 = 0, int funcIndex1 = 1, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::CubicSplineTable::evaluateFunctionAndDerivative </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>functionValue0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>derivativeValue0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>functionValue1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>derivativeValue1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate both function and derivative, two table functions. </p>
<p>This is a templated method where the template can be either real or SimdReal.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">numFuncInTable</td><td>Number of separate functions in table, default is 2 </td></tr>
    <tr><td class="paramname">funcIndex0</td><td>Index of 1st function to evaluate in table, default is 0 </td></tr>
    <tr><td class="paramname">funcIndex1</td><td>Index of 2nd function to evaluate in table, default is 1 </td></tr>
    <tr><td class="paramname">T</td><td>Type (SimdReal or real) of lookup and result </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">r</td><td>Points for which to evaluate function and derivative </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">functionValue0</td><td>Interpolated value for first function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">derivativeValue0</td><td>Interpolated derivative for first function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">functionValue1</td><td>Interpolated value for second function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">derivativeValue1</td><td>Interpolated derivative for second function</td></tr>
  </table>
  </dd>
</dl>
<p>For debug builds we assert that the input values fall in the range specified when constructing the table. </p>

</div>
</div>
<a class="anchor" id="ab7a92744d336e2abb9c16fb39ee24244"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int numFuncInTable = 3, int funcIndex0 = 0, int funcIndex1 = 1, int funcIndex2 = 2, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::CubicSplineTable::evaluateFunctionAndDerivative </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>functionValue0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>derivativeValue0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>functionValue1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>derivativeValue1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>functionValue2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>derivativeValue2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate both function and derivative, three table functions. </p>
<p>This is a templated method where the template can be either real or SimdReal.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">numFuncInTable</td><td>Number of separate functions in table, default is 3 </td></tr>
    <tr><td class="paramname">funcIndex0</td><td>Index of 1st function to evaluate in table, default is 0 </td></tr>
    <tr><td class="paramname">funcIndex1</td><td>Index of 2nd function to evaluate in table, default is 1 </td></tr>
    <tr><td class="paramname">funcIndex2</td><td>Index of 3rd function to evaluate in table, default is 2 </td></tr>
    <tr><td class="paramname">T</td><td>Type (SimdReal or real) of lookup and result </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">r</td><td>Points for which to evaluate function and derivative </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">functionValue0</td><td>Interpolated value for first function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">derivativeValue0</td><td>Interpolated derivative for first function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">functionValue1</td><td>Interpolated value for second function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">derivativeValue1</td><td>Interpolated derivative for second function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">functionValue2</td><td>Interpolated value for third function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">derivativeValue2</td><td>Interpolated derivative for third function</td></tr>
  </table>
  </dd>
</dl>
<p>For debug builds we assert that the input values fall in the range specified when constructing the table. </p>

</div>
</div>
<a class="anchor" id="a3b7a2c1163edded0f6d64a830bd33077"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> gmx::CubicSplineTable::tableSpacing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the table spacing (distance between points) </p>
<p>You should never have to use this for normal code, but due to the way tables are constructed internally we need this in the unit tests to check relative tolerances over each interval.</p>
<dl class="section return"><dt>Returns</dt><dd>table spacing. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a336f1afeaabfe544c6e4a8135b216010"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> gmx::CubicSplineTable::defaultTolerance = 10.0 * 1.19209290e-07F</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default tolerance for cubic spline tables. </p>
<p>This is 10*GMX_FLOAT_EPS in single precision, and 1e-10 for double precision. It might not be worth setting this tolerance lower than 1e-10 in double precision, both because you will end up with very large tables, and because functions like r^-12 become so large for small values of r the table generation code will lead to some precision loss even in double precision. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/gromacs/tables/<a class="el" href="cubicsplinetable_8h.xhtml">cubicsplinetable.h</a></li>
<li>src/gromacs/tables/<a class="el" href="cubicsplinetable_8cpp.xhtml">cubicsplinetable.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 23 2018 14:57:29 for Gromacs by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
