<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Gromacs: src/gromacs/mdlib/nbnxn_gpu.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Gromacs
   &#160;<span id="projectnumber">2018.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.xhtml"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.xhtml"><span>Modules</span></a></li>
      <li><a href="pages.xhtml"><span>Other&#160;Docs</span></a></li>
      <li><a href="namespaces.xhtml"><span>Namespaces</span></a></li>
      <li><a href="annotated.xhtml"><span>Classes</span></a></li>
      <li class="current"><a href="files.xhtml"><span>Files</span></a></li>
      <li><a href="examples.xhtml"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.xhtml"><span>File&#160;List</span></a></li>
      <li><a href="globals.xhtml"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_8a21c46af9718d1f610eb513153099d7.xhtml">src</a></li><li class="navelem"><a class="el" href="dir_a46192700e9e8ed44c648f0a55ee9a53.xhtml">gromacs</a></li><li class="navelem"><a class="el" href="dir_5c78749fb0acf3df2e9bdab18856bfa3.xhtml">mdlib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">nbnxn_gpu.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;gromacs/gpu_utils/gpu_macros.h&quot;</code><br/>
<code>#include &quot;gromacs/math/vectypes.h&quot;</code><br/>
<code>#include &quot;gromacs/mdlib/nbnxn_gpu_types.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="basedefinitions_8h.xhtml">gromacs/utility/basedefinitions.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="real_8h.xhtml">gromacs/utility/real.h</a>&quot;</code><br/>
</div><div class="textblock"><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Include dependency graph for nbnxn_gpu.h:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="nbnxn__gpu_8h__incl.svg" width="387" height="202"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div><div class="textblock"><div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> This graph shows which files directly or indirectly include this file:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="nbnxn__gpu_8h__dep__incl.svg" width="636" height="142"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div><a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Declare interface for GPU execution for NBNXN module. </p>
<dl class="section author"><dt>Author</dt><dd>Szilard Pall <a href="#" onclick="location.href='mai'+'lto:'+'pal'+'l.'+'szi'+'la'+'rd@'+'gm'+'ail'+'.c'+'om'; return false;">pall.<span style="display: none;">.nosp@m.</span>szil<span style="display: none;">.nosp@m.</span>ard@g<span style="display: none;">.nosp@m.</span>mail<span style="display: none;">.nosp@m.</span>.com</a> </dd>
<dd>
Mark Abraham <a href="#" onclick="location.href='mai'+'lto:'+'mar'+'k.'+'j.a'+'br'+'aha'+'m@'+'gma'+'il'+'.co'+'m'; return false;">mark.<span style="display: none;">.nosp@m.</span>j.ab<span style="display: none;">.nosp@m.</span>raham<span style="display: none;">.nosp@m.</span>@gma<span style="display: none;">.nosp@m.</span>il.co<span style="display: none;">.nosp@m.</span>m</a> </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ace96d16a2d1f04355fb70b13711b86b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nbnxn__gpu_8h.xhtml#ace96d16a2d1f04355fb70b13711b86b3">nbnxn_gpu_launch_kernel</a> (<a class="el" href="structgmx__nbnxn__ocl__t.xhtml">gmx_nbnxn_gpu_t</a> *nb, const struct nbnxn_atomdata_t *nbdata, int flags, int iloc)</td></tr>
<tr class="memdesc:ace96d16a2d1f04355fb70b13711b86b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch asynchronously the nonbonded force calculations.  <a href="#ace96d16a2d1f04355fb70b13711b86b3">More...</a><br/></td></tr>
<tr class="separator:ace96d16a2d1f04355fb70b13711b86b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0bf4bda78b6edfef99302196d1ffe9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nbnxn__gpu_8h.xhtml#aa0bf4bda78b6edfef99302196d1ffe9d">nbnxn_gpu_launch_kernel_pruneonly</a> (<a class="el" href="structgmx__nbnxn__ocl__t.xhtml">gmx_nbnxn_gpu_t</a> *nb, int iloc, int numParts)</td></tr>
<tr class="memdesc:aa0bf4bda78b6edfef99302196d1ffe9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch asynchronously the nonbonded prune-only kernel.  <a href="#aa0bf4bda78b6edfef99302196d1ffe9d">More...</a><br/></td></tr>
<tr class="separator:aa0bf4bda78b6edfef99302196d1ffe9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d9546662f5954ae56e3af4d09e4c4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4d9546662f5954ae56e3af4d09e4c4a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nbnxn__gpu_8h.xhtml#ac4d9546662f5954ae56e3af4d09e4c4a">nbnxn_gpu_launch_cpyback</a> (<a class="el" href="structgmx__nbnxn__ocl__t.xhtml">gmx_nbnxn_gpu_t</a> *nb, const struct nbnxn_atomdata_t *nbatom, int flags, int aloc)</td></tr>
<tr class="memdesc:ac4d9546662f5954ae56e3af4d09e4c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch asynchronously the download of nonbonded forces from the GPU (and energies/shift forces if required). <br/></td></tr>
<tr class="separator:ac4d9546662f5954ae56e3af4d09e4c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99051c642e584444b7d30cf011b3e0d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nbnxn__gpu_8h.xhtml#a99051c642e584444b7d30cf011b3e0d6">nbnxn_gpu_try_finish_task</a> (<a class="el" href="structgmx__nbnxn__ocl__t.xhtml">gmx_nbnxn_gpu_t</a> *nb, int flags, int aloc, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> *e_lj, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> *e_el, rvec *fshift, <a class="el" href="gpu__utils_8h.xhtml#aab3d31c4bd3fcb89aa5d554b125b403e">GpuTaskCompletion</a> completionKind)</td></tr>
<tr class="memdesc:a99051c642e584444b7d30cf011b3e0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to complete nonbonded GPU task.  <a href="#a99051c642e584444b7d30cf011b3e0d6">More...</a><br/></td></tr>
<tr class="separator:a99051c642e584444b7d30cf011b3e0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca8210020285dc8c926934c7d4d4b93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nbnxn__gpu_8h.xhtml#a9ca8210020285dc8c926934c7d4d4b93">nbnxn_gpu_wait_finish_task</a> (<a class="el" href="structgmx__nbnxn__ocl__t.xhtml">gmx_nbnxn_gpu_t</a> *nb, int flags, int aloc, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> *e_lj, <a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> *e_el, rvec *fshift)</td></tr>
<tr class="memdesc:a9ca8210020285dc8c926934c7d4d4b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes the nonbonded GPU task blocking until GPU tasks and data transfers to finish.  <a href="#a9ca8210020285dc8c926934c7d4d4b93">More...</a><br/></td></tr>
<tr class="separator:a9ca8210020285dc8c926934c7d4d4b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a6120b6a1b95d61a49599c35952562"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9a6120b6a1b95d61a49599c35952562"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nbnxn__gpu_8h.xhtml#ae9a6120b6a1b95d61a49599c35952562">nbnxn_gpu_pick_ewald_kernel_type</a> (bool bTwinCut)</td></tr>
<tr class="memdesc:ae9a6120b6a1b95d61a49599c35952562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the Ewald kernel type, analytical or tabulated, single or twin cut-off. <br/></td></tr>
<tr class="separator:ae9a6120b6a1b95d61a49599c35952562"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ace96d16a2d1f04355fb70b13711b86b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nbnxn_gpu_launch_kernel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__nbnxn__ocl__t.xhtml">gmx_nbnxn_ocl_t</a> *&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct nbnxn_atomdata_t *&#160;</td>
          <td class="paramname"><em>nbatom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Launch asynchronously the nonbonded force calculations. </p>
<p>This consists of the following (async) steps launched:</p>
<ul>
<li>upload x and q;</li>
<li>upload shift vector;</li>
<li>launch kernel; The local and non-local interaction calculations are launched in two separate streams.</li>
</ul>
<p>Launch asynchronously the nonbonded force calculations.</p>
<p>As we execute nonbonded workload in separate queues, before launching the kernel we need to make sure that he following operations have completed:</p>
<ul>
<li>atomdata allocation and related H2D transfers (every nstlist step);</li>
<li>pair list H2D transfer (every nstlist step);</li>
<li>shift vector H2D transfer (every nstlist step);</li>
<li>force (+shift force and energy) output clearing (every step).</li>
</ul>
<p>These operations are issued in the local queue at the beginning of the step and therefore always complete before the local kernel launch. The non-local kernel is launched after the local on the same device/context, so this is inherently scheduled after the operations in the local stream (including the above "misc_ops"). However, for the sake of having a future-proof implementation, we use the misc_ops_done event to record the point in time when the above operations are finished and synchronize with this event in the non-local stream. </p>

</div>
</div>
<a class="anchor" id="aa0bf4bda78b6edfef99302196d1ffe9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nbnxn_gpu_launch_kernel_pruneonly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__nbnxn__ocl__t.xhtml">gmx_nbnxn_gpu_t</a> *&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numParts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Launch asynchronously the nonbonded prune-only kernel. </p>
<p>The local and non-local list pruning are launched in their separate streams.</p>
<p>Notes for future scheduling tuning: Currently we schedule the dynamic pruning between two MD steps <em>after</em> both local and nonlocal force D2H transfers completed. We could launch already after the cpyback is launched, but we want to avoid prune kernels (especially in the non-local high prio-stream) competing with nonbonded work.</p>
<p>However, this is not ideal as this schedule does not expose the available concurrency. The dynamic pruning kernel:</p>
<ul>
<li>should be allowed to overlap with any task other than force compute, including transfers (F D2H and the next step's x H2D as well as force clearing).</li>
<li>we'd prefer to avoid competition with non-bonded force kernels belonging to the same rank and ideally other ranks too.</li>
</ul>
<p>In the most general case, the former would require scheduling pruning in a separate stream and adding additional event sync points to ensure that force kernels read consistent pair list data. This would lead to some overhead (due to extra cudaStreamWaitEvent calls, 3-5 us/call) which we might be able to live with. The gains from additional overlap might not be significant as long as update+constraints anyway takes longer than pruning, but there will still be use-cases where more overlap may help (e.g. multiple ranks per GPU, no/hbonds only constraints). The above second point is harder to address given that multiple ranks will often share a GPU. Ranks that complete their nonbondeds sooner can schedule pruning earlier and without a third priority level it is difficult to avoid some interference of prune kernels with force tasks (in particular preemption of low-prio local force task).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">nb</td><td>GPU nonbonded data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iloc</td><td>Interaction locality flag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numParts</td><td>Number of parts the pair list is split into in the rolling kernel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99051c642e584444b7d30cf011b3e0d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nbnxn_gpu_try_finish_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__nbnxn__ocl__t.xhtml">gmx_nbnxn_gpu_t</a> *&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> *&#160;</td>
          <td class="paramname"><em>e_lj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> *&#160;</td>
          <td class="paramname"><em>e_el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rvec *&#160;</td>
          <td class="paramname"><em>fshift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gpu__utils_8h.xhtml#aab3d31c4bd3fcb89aa5d554b125b403e">GpuTaskCompletion</a>&#160;</td>
          <td class="paramname"><em>completionKind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to complete nonbonded GPU task. </p>
<p>This function attempts to complete the nonbonded task (both GPU and CPU auxiliary work). Success, i.e. that the tasks completed and results are ready to be consumed, is signaled by the return value (always true if blocking wait mode requested).</p>
<p>The <code>completionKind</code> parameter controls whether the behavior is non-blocking (achieved by passing GpuTaskCompletion::Check) or blocking wait until the results are ready (when GpuTaskCompletion::Wait is passed). As the "Check" mode the function will return immediately if the GPU stream still contain tasks that have not completed, it allows more flexible overlapping of work on the CPU with GPU execution.</p>
<p>Note that it is only safe to use the results, and to continue to the next MD step when this function has returned true which indicates successful completion of</p>
<ul>
<li>All nonbonded GPU tasks: both compute and device transfer(s)</li>
<li>auxiliary tasks: updating the internal module state (timing accumulation, list pruning states) and</li>
<li>internal staging reduction of (<code>fshift</code>, <code>e_el</code>, <code>e_lj</code>).</li>
</ul>
<p>TODO: improve the handling of outputs e.g. by ensuring that this function explcitly returns the force buffer (instead of that being passed only to <a class="el" href="nbnxn__gpu_8h.xhtml#ac4d9546662f5954ae56e3af4d09e4c4a" title="Launch asynchronously the download of nonbonded forces from the GPU (and energies/shift forces if req...">nbnxn_gpu_launch_cpyback()</a>) and by returning the energy and Fshift contributions for some external/centralized reduction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nb</td><td>The nonbonded data GPU structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Force flags </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aloc</td><td>Atom locality identifier </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">e_lj</td><td>Pointer to the LJ energy output to accumulate into </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">e_el</td><td>Pointer to the electrostatics energy output to accumulate into </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fshift</td><td>Pointer to the shift force buffer to accumulate into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">completionKind</td><td>Indicates whether nnbonded task completion should only be checked rather than waited for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the nonbonded tasks associated with <code>aloc</code> locality have completed </dd></dl>

</div>
</div>
<a class="anchor" id="a9ca8210020285dc8c926934c7d4d4b93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nbnxn_gpu_wait_finish_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmx__nbnxn__ocl__t.xhtml">gmx_nbnxn_gpu_t</a> *&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> *&#160;</td>
          <td class="paramname"><em>e_lj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="real_8h.xhtml#a58a0c7cf2501f4492da833421be92547">real</a> *&#160;</td>
          <td class="paramname"><em>e_el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rvec *&#160;</td>
          <td class="paramname"><em>fshift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Completes the nonbonded GPU task blocking until GPU tasks and data transfers to finish. </p>
<p>Also does timing accounting and reduction of the internal staging buffers. As this is called at the end of the step, it also resets the pair list and pruning flags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nb</td><td>The nonbonded data GPU structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Force flags </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aloc</td><td>Atom locality identifier </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">e_lj</td><td>Pointer to the LJ energy output to accumulate into </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">e_el</td><td>Pointer to the electrostatics energy output to accumulate into </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fshift</td><td>Pointer to the shift force buffer to accumulate into</td></tr>
  </table>
  </dd>
</dl>
<p>Completes the nonbonded GPU task blocking until GPU tasks and data transfers to finish.</p>
<p>Also does timing accounting and reduction of the internal staging buffers. As this is called at the end of the step, it also resets the pair list and pruning flags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nb</td><td>The nonbonded data GPU structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Force flags </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aloc</td><td>Atom locality identifier </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">e_lj</td><td>Pointer to the LJ energy output to accumulate into </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">e_el</td><td>Pointer to the electrostatics energy output to accumulate into </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fshift</td><td>Pointer to the shift force buffer to accumulate into </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 23 2018 14:57:17 for Gromacs by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
