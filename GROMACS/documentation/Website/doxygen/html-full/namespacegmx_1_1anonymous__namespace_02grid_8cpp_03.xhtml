<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Gromacs: gmx::anonymous_namespace{grid.cpp} Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Gromacs
   &#160;<span id="projectnumber">2018.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.xhtml"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.xhtml"><span>Modules</span></a></li>
      <li><a href="pages.xhtml"><span>Other&#160;Docs</span></a></li>
      <li class="current"><a href="namespaces.xhtml"><span>Namespaces</span></a></li>
      <li><a href="annotated.xhtml"><span>Classes</span></a></li>
      <li><a href="files.xhtml"><span>Files</span></a></li>
      <li><a href="examples.xhtml"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.xhtml"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.xhtml"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegmx.xhtml">gmx</a></li><li class="navelem"><a class="el" href="namespacegmx_1_1anonymous__namespace_02grid_8cpp_03.xhtml">anonymous_namespace{grid.cpp}</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">gmx::anonymous_namespace{grid.cpp} Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a39c6b01f360487382bda12fbf0c8db92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx_1_1anonymous__namespace_02grid_8cpp_03.xhtml#a39c6b01f360487382bda12fbf0c8db92">centerPeriodicValueAroundZero</a> (double *x, double period)</td></tr>
<tr class="memdesc:a39c6b01f360487382bda12fbf0c8db92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify x so that it is periodic in [-period/2, +period/2).  <a href="#a39c6b01f360487382bda12fbf0c8db92">More...</a><br/></td></tr>
<tr class="separator:a39c6b01f360487382bda12fbf0c8db92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ad59eaede4409c0875ed81386fd8fb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx_1_1anonymous__namespace_02grid_8cpp_03.xhtml#a28ad59eaede4409c0875ed81386fd8fb">indexWithinPeriod</a> (int x, int period)</td></tr>
<tr class="memdesc:a28ad59eaede4409c0875ed81386fd8fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">If period&gt;0, retrun x so that it is periodic in [0, period), else return x.  <a href="#a28ad59eaede4409c0875ed81386fd8fb">More...</a><br/></td></tr>
<tr class="separator:a28ad59eaede4409c0875ed81386fd8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb8aaa55ad7ae8feb2558af904cc3e3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx_1_1anonymous__namespace_02grid_8cpp_03.xhtml#a0bb8aaa55ad7ae8feb2558af904cc3e3">getIntervalLengthPeriodic</a> (double origin, double end, double period)</td></tr>
<tr class="memdesc:a0bb8aaa55ad7ae8feb2558af904cc3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the interval (origin, end).  <a href="#a0bb8aaa55ad7ae8feb2558af904cc3e3">More...</a><br/></td></tr>
<tr class="separator:a0bb8aaa55ad7ae8feb2558af904cc3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e78c72cac8e84929c27aa47a4435550"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx_1_1anonymous__namespace_02grid_8cpp_03.xhtml#a3e78c72cac8e84929c27aa47a4435550">getDeviationPeriodic</a> (double x, double x0, double period)</td></tr>
<tr class="memdesc:a3e78c72cac8e84929c27aa47a4435550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the deviation x - x0.  <a href="#a3e78c72cac8e84929c27aa47a4435550">More...</a><br/></td></tr>
<tr class="separator:a3e78c72cac8e84929c27aa47a4435550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb5ffd801cfe99e19a3e3f8031523df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx_1_1anonymous__namespace_02grid_8cpp_03.xhtml#aafb5ffd801cfe99e19a3e3f8031523df">multiDimGridIndexToLinear</a> (const std::vector&lt; <a class="el" href="classgmx_1_1GridAxis.xhtml">GridAxis</a> &gt; &amp;axis, const <a class="el" href="namespacegmx.xhtml#a74baae008f9132c5e0daf2a02b122b3b">awh_ivec</a> indexMulti)</td></tr>
<tr class="memdesc:aafb5ffd801cfe99e19a3e3f8031523df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a multidimensional grid point index to a linear one.  <a href="#aafb5ffd801cfe99e19a3e3f8031523df">More...</a><br/></td></tr>
<tr class="separator:aafb5ffd801cfe99e19a3e3f8031523df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9ffc0bfb37b283dd98bb12f47a0568"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx_1_1anonymous__namespace_02grid_8cpp_03.xhtml#a4b9ffc0bfb37b283dd98bb12f47a0568">stepInMultiDimArray</a> (int numDim, const <a class="el" href="namespacegmx.xhtml#a74baae008f9132c5e0daf2a02b122b3b">awh_ivec</a> numPoints, <a class="el" href="namespacegmx.xhtml#a74baae008f9132c5e0daf2a02b122b3b">awh_ivec</a> indexDim)</td></tr>
<tr class="memdesc:a4b9ffc0bfb37b283dd98bb12f47a0568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a step in a multidimensional array.  <a href="#a4b9ffc0bfb37b283dd98bb12f47a0568">More...</a><br/></td></tr>
<tr class="separator:a4b9ffc0bfb37b283dd98bb12f47a0568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3313234fd5846d44bedcb861cc30f1d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx_1_1anonymous__namespace_02grid_8cpp_03.xhtml#a3313234fd5846d44bedcb861cc30f1d3">gridToSubgridIndex</a> (const <a class="el" href="classgmx_1_1Grid.xhtml">Grid</a> &amp;grid, const <a class="el" href="namespacegmx.xhtml#a74baae008f9132c5e0daf2a02b122b3b">awh_ivec</a> subgridOrigin, const <a class="el" href="namespacegmx.xhtml#a74baae008f9132c5e0daf2a02b122b3b">awh_ivec</a> subgridNpoints, int point, <a class="el" href="namespacegmx.xhtml#a74baae008f9132c5e0daf2a02b122b3b">awh_ivec</a> subgridIndex)</td></tr>
<tr class="memdesc:a3313234fd5846d44bedcb861cc30f1d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a grid point index to to the multidimensional index of a subgrid.  <a href="#a3313234fd5846d44bedcb861cc30f1d3">More...</a><br/></td></tr>
<tr class="separator:a3313234fd5846d44bedcb861cc30f1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5303c6e38c675bd86327a211e611537e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx_1_1anonymous__namespace_02grid_8cpp_03.xhtml#a5303c6e38c675bd86327a211e611537e">subgridToGridIndex</a> (const <a class="el" href="classgmx_1_1Grid.xhtml">Grid</a> &amp;grid, const <a class="el" href="namespacegmx.xhtml#a74baae008f9132c5e0daf2a02b122b3b">awh_ivec</a> subgridOrigin, const <a class="el" href="namespacegmx.xhtml#a74baae008f9132c5e0daf2a02b122b3b">awh_ivec</a> subgridIndex, int *gridIndex)</td></tr>
<tr class="memdesc:a5303c6e38c675bd86327a211e611537e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a multidimensional subgrid index to a grid point index.  <a href="#a5303c6e38c675bd86327a211e611537e">More...</a><br/></td></tr>
<tr class="separator:a5303c6e38c675bd86327a211e611537e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2df3e83b031a01af4f379e4f3c6d071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegmx_1_1anonymous__namespace_02grid_8cpp_03.xhtml#ab2df3e83b031a01af4f379e4f3c6d071">setNeighborsOfGridPoint</a> (int pointIndex, const <a class="el" href="classgmx_1_1Grid.xhtml">Grid</a> &amp;grid, std::vector&lt; int &gt; *neighborIndexArray)</td></tr>
<tr class="memdesc:ab2df3e83b031a01af4f379e4f3c6d071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and set the neighbors of a grid point.  <a href="#ab2df3e83b031a01af4f379e4f3c6d071">More...</a><br/></td></tr>
<tr class="separator:ab2df3e83b031a01af4f379e4f3c6d071"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a39c6b01f360487382bda12fbf0c8db92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::anonymous_namespace{grid.cpp}::centerPeriodicValueAroundZero </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify x so that it is periodic in [-period/2, +period/2). </p>
<p>x is modified by shifting its value by a +/- a period if needed. Thus, it is assumed that x is at most one period away from this interval. For period = 0, x is not modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Pointer to the value to modify. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>The period, or 0 if not periodic. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e78c72cac8e84929c27aa47a4435550"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double gmx::anonymous_namespace{grid.cpp}::getDeviationPeriodic </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the deviation x - x0. </p>
<p>For period &gt; 0, the deviation with minimum absolute value is returned, i.e. with a value in the interval [-period/2, +period/2). Also for period &gt; 0, it is assumed that |x - x0| &lt; period.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>From value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x0</td><td>To value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>The period, or 0 if not periodic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the deviation from x to x0. </dd></dl>

</div>
</div>
<a class="anchor" id="a0bb8aaa55ad7ae8feb2558af904cc3e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double gmx::anonymous_namespace{grid.cpp}::getIntervalLengthPeriodic </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the length of the interval (origin, end). </p>
<p>This returns the distance obtained by connecting the origin point to the end point in the positive direction. Note that this is generally not the shortest distance. For period &gt; 0, both origin and end are expected to take values in the same periodic interval, ie. |origin - end| &lt; period.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">origin</td><td>Start value of the interval. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>End value of the interval. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>The period, or 0 if not periodic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the interval length from origin to end. </dd></dl>

</div>
</div>
<a class="anchor" id="a3313234fd5846d44bedcb861cc30f1d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::anonymous_namespace{grid.cpp}::gridToSubgridIndex </td>
          <td>(</td>
          <td class="paramtype">const Grid &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const awh_ivec&#160;</td>
          <td class="paramname"><em>subgridOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const awh_ivec&#160;</td>
          <td class="paramname"><em>subgridNpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">awh_ivec&#160;</td>
          <td class="paramname"><em>subgridIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a grid point index to to the multidimensional index of a subgrid. </p>
<p>The subgrid is defined by the location of its origin and the number of points along each dimension. The index transformation thus consists of a projection of the linear index onto each dimension, followed by a translation of the origin. The subgrid may have parts that don't overlap with the grid. E.g. the origin vector can have negative components meaning the origin lies outside of the grid. However, the given point needs to be both a grid and subgrid point.</p>
<p>Periodic boundaries are taken care of by wrapping the subgrid around the grid. Thus, for periodic dimensions the number of subgrid points need to be less than the number of points in a period to prevent problems of wrapping around.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grid</td><td>The grid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subgridOrigin</td><td>Vector locating the subgrid origin relative to the grid origin. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subgridNpoints</td><td>The number of subgrid points in each dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td><a class="el" href="classgmx_1_1Grid.xhtml" title="The grid, generally multidimensional and periodic. ">Grid</a> point to get subgrid index for. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">subgridIndex</td><td>Subgrid multidimensional index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28ad59eaede4409c0875ed81386fd8fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmx::anonymous_namespace{grid.cpp}::indexWithinPeriod </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If period&gt;0, retrun x so that it is periodic in [0, period), else return x. </p>
<p>Return x is shifted its value by a +/- a period, if needed. Thus, it is assumed that x is at most one period away from this interval. For this domain and period &gt; 0 this is equivalent to x = x % period. For period = 0, x is not modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>Pointer to the value to modify, should be &gt;= 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>The period, or 0 if not periodic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>for period&gt;0: index value witin [0, period), otherwise: <code>x</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aafb5ffd801cfe99e19a3e3f8031523df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmx::anonymous_namespace{grid.cpp}::multiDimGridIndexToLinear </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; GridAxis &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const awh_ivec&#160;</td>
          <td class="paramname"><em>indexMulti</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a multidimensional grid point index to a linear one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">axis</td><td>The grid axes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indexMulti</td><td>Multidimensional grid point index to convert to a linear one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the linear index. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2df3e83b031a01af4f379e4f3c6d071"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gmx::anonymous_namespace{grid.cpp}::setNeighborsOfGridPoint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pointIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Grid &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>neighborIndexArray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find and set the neighbors of a grid point. </p>
<p>The search space for neighbors is a subgrid with size set by a scope cutoff. In general not all point within scope will be valid grid points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pointIndex</td><td><a class="el" href="classgmx_1_1Grid.xhtml" title="The grid, generally multidimensional and periodic. ">Grid</a> point index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grid</td><td>The grid. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">neighborIndexArray</td><td>Array to fill with neighbor indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b9ffc0bfb37b283dd98bb12f47a0568"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gmx::anonymous_namespace{grid.cpp}::stepInMultiDimArray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const awh_ivec&#160;</td>
          <td class="paramname"><em>numPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">awh_ivec&#160;</td>
          <td class="paramname"><em>indexDim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a step in a multidimensional array. </p>
<p>The multidimensional index gives the starting point to step from. Dimensions are stepped through in order of decreasing dimensional index such that the index is incremented in the highest dimension possible. If the starting point is the end of the array, a step cannot be taken and the index is not modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numDim</td><td>Number of dimensions of the array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numPoints</td><td>Vector with the number of points along each dimension. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">indexDim</td><td>Multidimensional index, each with values in [0, numPoints[d] - 1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a step was taken, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a5303c6e38c675bd86327a211e611537e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gmx::anonymous_namespace{grid.cpp}::subgridToGridIndex </td>
          <td>(</td>
          <td class="paramtype">const Grid &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const awh_ivec&#160;</td>
          <td class="paramname"><em>subgridOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const awh_ivec&#160;</td>
          <td class="paramname"><em>subgridIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>gridIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a multidimensional subgrid index to a grid point index. </p>
<p>If the given subgrid point is not a grid point the transformation will not be successful and the grid point index will not be set. Periodic boundaries are taken care of by wrapping the subgrid around the grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grid</td><td>The grid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subgridOrigin</td><td>Vector locating the subgrid origin relative to the grid origin. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subgridIndex</td><td>Subgrid multidimensional index to get grid point index for. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">gridIndex</td><td><a class="el" href="classgmx_1_1Grid.xhtml" title="The grid, generally multidimensional and periodic. ">Grid</a> point index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the transformation was successful. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 23 2018 14:57:30 for Gromacs by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
