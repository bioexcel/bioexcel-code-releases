
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Getting good performance from mdrun &#8212; GROMACS 2018.3 documentation</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2018.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Common errors when using GROMACS" href="run-time-errors.html" />
    <link rel="prev" title="Useful mdrun features" href="mdrun-features.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="run-time-errors.html" title="Common errors when using GROMACS"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="mdrun-features.html" title="Useful mdrun features"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">GROMACS 2018.3</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">User guide</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="getting-good-performance-from-mdrun">
<span id="gmx-performance"></span><h1>Getting good performance from <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a><a class="headerlink" href="#getting-good-performance-from-mdrun" title="Permalink to this headline">¶</a></h1>
<p>The GROMACS build system and the <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> tool has a lot of built-in
and configurable intelligence to detect your hardware and make pretty
effective use of that hardware. For a lot of casual and serious use of
<a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a>, the automatic machinery works well enough. But to get the
most from your hardware to maximize your scientific quality, read on!</p>
<div class="section" id="hardware-background-information">
<h2>Hardware background information<a class="headerlink" href="#hardware-background-information" title="Permalink to this headline">¶</a></h2>
<p>Modern computer hardware is complex and heterogeneous, so we need to
discuss a little bit of background information and set up some
definitions. Experienced HPC users can skip this section.</p>
<dl class="glossary docutils">
<dt id="term-core">core</dt>
<dd>A hardware compute unit that actually executes
instructions. There is normally more than one core in a
processor, often many more.</dd>
<dt id="term-cache">cache</dt>
<dd>A special kind of memory local to core(s) that is much faster
to access than main memory, kind of like the top of a human’s
desk, compared to their filing cabinet. There are often
several layers of caches associated with a core.</dd>
<dt id="term-socket">socket</dt>
<dd>A group of cores that share some kind of locality, such as a
shared cache. This makes it more efficient to spread
computational work over cores within a socket than over cores
in different sockets. Modern processors often have more than
one socket.</dd>
<dt id="term-node">node</dt>
<dd>A group of sockets that share coarser-level locality, such as
shared access to the same memory without requiring any network
hardware. A normal laptop or desktop computer is a node. A
node is often the smallest amount of a large compute cluster
that a user can request to use.</dd>
<dt id="term-thread">thread</dt>
<dd>A stream of instructions for a core to execute. There are many
different programming abstractions that create and manage
spreading computation over multiple threads, such as OpenMP,
pthreads, winthreads, CUDA, OpenCL, and OpenACC. Some kinds of
hardware can map more than one software thread to a core; on
Intel x86 processors this is called “hyper-threading”, while
the more general concept is often called SMT for
“simultaneous multi-threading”. IBM Power8 can for instance use
up to 8 hardware threads per core.
This feature can usually be enabled or disabled either in
the hardware bios or through a setting in the Linux operating
system. GROMACS can typically make use of this, for a moderate
free performance boost. In most cases it will be
enabled by default e.g. on new x86 processors, but in some cases
the system administrators might have disabled it. If that is the
case, ask if they can re-enable it for you. If you are not sure
if it is enabled, check the output of the CPU information in
the log file and compare with CPU specifications you find online.</dd>
<dt id="term-thread-affinity-pinning">thread affinity (pinning)</dt>
<dd>By default, most operating systems allow software threads to migrate
between cores (or hardware threads) to help automatically balance
workload. However, the performance of <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> can deteriorate
if this is permitted and will degrade dramatically especially when
relying on multi-threading within a rank. To avoid this,
<a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> will by default
set the affinity of its threads to individual cores/hardware threads,
unless the user or software environment has already done so
(or not the entire node is used for the run, i.e. there is potential
for node sharing).
Setting thread affinity is sometimes called thread “pinning”.</dd>
<dt id="term-mpi">MPI</dt>
<dd>The dominant multi-node parallelization-scheme, which provides
a standardized language in which programs can be written that
work across more than one node.</dd>
<dt id="term-rank">rank</dt>
<dd>In MPI, a rank is the smallest grouping of hardware used in
the multi-node parallelization scheme. That grouping can be
controlled by the user, and might correspond to a core, a
socket, a node, or a group of nodes. The best choice varies
with the hardware, software and compute task. Sometimes an MPI
rank is called an MPI process.</dd>
<dt id="term-gpu">GPU</dt>
<dd>A graphics processing unit, which is often faster and more
efficient than conventional processors for particular kinds of
compute workloads. A GPU is always associated with a
particular node, and often a particular socket within that
node.</dd>
<dt id="term-openmp">OpenMP</dt>
<dd>A standardized technique supported by many compilers to share
a compute workload over multiple cores. Often combined with
MPI to achieve hybrid MPI/OpenMP parallelism.</dd>
<dt id="term-cuda">CUDA</dt>
<dd>A proprietary parallel computing framework and API developed by NVIDIA
that allows targeting their accelerator hardware.
GROMACS uses CUDA for GPU acceleration support with NVIDIA hardware.</dd>
<dt id="term-opencl">OpenCL</dt>
<dd>An open standard-based parallel computing framework that consists
of a C99-based compiler and a programming API for targeting heterogeneous
and accelerator hardware. GROMACS uses OpenCL for GPU acceleration
on AMD devices (both GPUs and APUs); NVIDIA hardware is also supported.</dd>
<dt id="term-simd">SIMD</dt>
<dd>Modern CPU cores have instructions that can execute large
numbers of floating-point instructions in a single cycle.</dd>
</dl>
</div>
<div class="section" id="gromacs-background-information">
<h2>GROMACS background information<a class="headerlink" href="#gromacs-background-information" title="Permalink to this headline">¶</a></h2>
<p>The algorithms in <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> and their implementations are most relevant
when choosing how to make good use of the hardware. For details,
see the Reference Manual. The most important of these are</p>
<dl class="glossary docutils">
</dl>
<blockquote id="gmx-domain-decomp">
<div><dl class="docutils">
<dt>Domain Decomposition</dt>
<dd>The domain decomposition (DD) algorithm decomposes the
(short-ranged) component of the non-bonded interactions into
domains that share spatial locality, which permits the use of
efficient algorithms. Each domain handles all of the
particle-particle (PP) interactions for its members, and is
mapped to a single MPI rank. Within a PP rank, OpenMP threads
can share the workload, and some work can be off-loaded to a
GPU. The PP rank also handles any bonded interactions for the
members of its domain. A GPU may perform work for more than
one PP rank, but it is normally most efficient to use a single
PP rank per GPU and for that rank to have thousands of
particles. When the work of a PP rank is done on the CPU, <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a>
will make extensive use of the SIMD capabilities of the
core. There are various <cite>command-line options
&lt;controlling-the-domain-decomposition-algorithm</cite> to control
the behaviour of the DD algorithm.</dd>
<dt>Particle-mesh Ewald</dt>
<dd>The particle-mesh Ewald (PME) algorithm treats the long-ranged
components of the non-bonded interactions (Coulomb and/or
Lennard-Jones).  Either all, or just a subset of ranks may
participate in the work for computing long-ranged component
(often inaccurately called simple the “PME”
component). Because the algorithm uses a 3D FFT that requires
global communication, its performance gets worse as more ranks
participate, which can mean it is fastest to use just a subset
of ranks (e.g.  one-quarter to one-half of the ranks). If
there are separate PME ranks, then the remaining ranks handle
the PP work. Otherwise, all ranks do both PP and PME work.</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="running-mdrun-within-a-single-node">
<h2>Running <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> within a single node<a class="headerlink" href="#running-mdrun-within-a-single-node" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> can be configured and compiled in several different ways that
are efficient to use within a single <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a>. The default configuration
using a suitable compiler will deploy a multi-level hybrid parallelism
that uses CUDA, OpenMP and the threading platform native to the
hardware. For programming convenience, in GROMACS, those native
threads are used to implement on a single node the same MPI scheme as
would be used between nodes, but much more efficient; this is called
thread-MPI. From a user’s perspective, real MPI and thread-MPI look
almost the same, and GROMACS refers to MPI ranks to mean either kind,
except where noted. A real external MPI can be used for <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> within
a single node, but runs more slowly than the thread-MPI version.</p>
<p>By default, <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> will inspect the hardware available at run time
and do its best to make fairly efficient use of the whole node. The
log file, stdout and stderr are used to print diagnostics that
inform the user about the choices made and possible consequences.</p>
<p>A number of command-line parameters are available to modify the default
behavior.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">-nt</span></code></dt>
<dd>The total number of threads to use. The default, 0, will start as
many threads as available cores. Whether the threads are
thread-MPI ranks, and/or OpenMP threads within such ranks depends on
other settings.</dd>
<dt><code class="docutils literal"><span class="pre">-ntmpi</span></code></dt>
<dd>The total number of thread-MPI ranks to use. The default, 0,
will start one rank per GPU (if present), and otherwise one rank
per core.</dd>
<dt><code class="docutils literal"><span class="pre">-ntomp</span></code></dt>
<dd>The total number of OpenMP threads per rank to start. The
default, 0, will start one thread on each available core.
Alternatively, <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> will honor the appropriate system
environment variable (e.g. <code class="docutils literal"><span class="pre">OMP_NUM_THREADS</span></code>) if set.</dd>
<dt><code class="docutils literal"><span class="pre">-npme</span></code></dt>
<dd>The total number of ranks to dedicate to the long-ranged
component of PME, if used. The default, -1, will dedicate ranks
only if the total number of threads is at least 12, and will use
around a quarter of the ranks for the long-ranged component.</dd>
<dt><code class="docutils literal"><span class="pre">-ntomp_pme</span></code></dt>
<dd>When using PME with separate PME ranks,
the total number of OpenMP threads per separate PME ranks.
The default, 0, copies the value from <code class="docutils literal"><span class="pre">-ntomp</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">-pin</span></code></dt>
<dd>Can be set to “auto,” “on” or “off” to control whether
<a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> will attempt to set the affinity of threads to cores.
Defaults to “auto,” which means that if <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> detects that all the
cores on the node are being used for <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a>, then it should behave
like “on,” and attempt to set the affinities (unless they are
already set by something else).</dd>
<dt><code class="docutils literal"><span class="pre">-pinoffset</span></code></dt>
<dd>If <code class="docutils literal"><span class="pre">-pin</span> <span class="pre">on</span></code>, specifies the logical core number to
which <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> should pin the first thread. When running more than
one instance of <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> on a node, use this option to to avoid
pinning threads from different <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> instances to the same core.</dd>
<dt><code class="docutils literal"><span class="pre">-pinstride</span></code></dt>
<dd>If <code class="docutils literal"><span class="pre">-pin</span> <span class="pre">on</span></code>, specifies the stride in logical core
numbers for the cores to which <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> should pin its threads. When
running more than one instance of <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> on a node, use this option
to to avoid pinning threads from different <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> instances to the
same core.  Use the default, 0, to minimize the number of threads
per physical core - this lets <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> manage the hardware-, OS- and
configuration-specific details of how to map logical cores to
physical cores.</dd>
<dt><code class="docutils literal"><span class="pre">-ddorder</span></code></dt>
<dd>Can be set to “interleave,” “pp_pme” or “cartesian.”
Defaults to “interleave,” which means that any separate PME ranks
will be mapped to MPI ranks in an order like PP, PP, PME, PP, PP,
PME, … etc. This generally makes the best use of the available
hardware. “pp_pme” maps all PP ranks first, then all PME
ranks. “cartesian” is a special-purpose mapping generally useful
only on special torus networks with accelerated global
communication for Cartesian communicators. Has no effect if there
are no separate PME ranks.</dd>
<dt><code class="docutils literal"><span class="pre">-nb</span></code></dt>
<dd>Used to set where to execute the non-bonded interactions.
Can be set to “auto”, “cpu”, “gpu.”
Defaults to “auto,” which uses a compatible GPU if available.
Setting “cpu” requires that no GPU is used. Setting “gpu” requires
that a compatible GPU be available and will be used.</dd>
<dt><code class="docutils literal"><span class="pre">-gpu_id</span></code></dt>
<dd>A string that specifies the ID numbers of the GPUs that
are available to be used by ranks on this node. For example,
“12” specifies that the GPUs with IDs 1 and 2 (as reported
by the GPU runtime) can be used by <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a>. This is useful
when sharing a node with other computations, or if a GPU
is best used to support a display.  Without specifying this
parameter, <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> will utilize all GPUs. When many GPUs are
present, a comma may be used to separate the IDs, so
“12,13” would make GPUs 12 and 13 available to <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a>.
It could be necessary to use different GPUs on different
nodes of a simulation, in which case the environment
variable <code class="docutils literal"><span class="pre">GMX_GPU_ID</span></code> can be set differently for the ranks
on different nodes to achieve that result.
In GROMACS versions preceding 2018 this parameter used to
specify both GPU availability and GPU task assignment.
The latter is now done with the <code class="docutils literal"><span class="pre">-gputasks</span></code> parameter.</dd>
<dt><code class="docutils literal"><span class="pre">-gputasks</span></code></dt>
<dd><p class="first">A string that specifies the ID numbers of the GPUs to be
used by corresponding GPU tasks on this node. For example,
“0011” specifies that the first two GPU tasks will use GPU 0,
and the other two use GPU 1. When using this option, the
number of ranks must be known to <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a>, as well as where
tasks of different types should be run, such as by using
<code class="docutils literal"><span class="pre">-nb</span> <span class="pre">gpu</span></code> - only the tasks which are set to run on GPUs
count for parsing the mapping.
In GROMACS versions preceding 2018 only a single type
of GPU task could be run on any rank. Now that there is some
support for running PME on GPUs, the number of GPU tasks
(and the number of GPU IDs expected in the <code class="docutils literal"><span class="pre">-gputasks</span></code> string)
can actually be 2 for a single-rank simulation. The IDs
still have to be the same in this case, as using multiple GPUs
per single rank is not yet implemented.
The order of GPU tasks per rank in the string is short-range first,
PME second. The order of ranks with different kinds of GPU tasks
is the same by default, but can be influenced with the <code class="docutils literal"><span class="pre">-ddorder</span></code>
option and gets quite complex when using multiple nodes.
The GPU task assignment (whether manually set, or automated),
will be reported in the <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> output on
the first physical node of the simulation. For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">gmx</span> <span class="n">mdrun</span> <span class="o">-</span><span class="n">gputasks</span> <span class="mi">0001</span> <span class="o">-</span><span class="n">nb</span> <span class="n">gpu</span> <span class="o">-</span><span class="n">pme</span> <span class="n">gpu</span> <span class="o">-</span><span class="n">npme</span> <span class="mi">1</span> <span class="o">-</span><span class="n">ntmpi</span> <span class="mi">4</span>
</pre></div>
</div>
<p>will produce the following output in the log file/terminal:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">On</span> <span class="n">host</span> <span class="n">tcbl14</span> <span class="mi">2</span> <span class="n">GPUs</span> <span class="n">user</span><span class="o">-</span><span class="n">selected</span> <span class="k">for</span> <span class="n">this</span> <span class="n">run</span><span class="o">.</span>
<span class="n">Mapping</span> <span class="n">of</span> <span class="n">GPU</span> <span class="n">IDs</span> <span class="n">to</span> <span class="n">the</span> <span class="mi">4</span> <span class="n">GPU</span> <span class="n">tasks</span> <span class="ow">in</span> <span class="n">the</span> <span class="mi">4</span> <span class="n">ranks</span> <span class="n">on</span> <span class="n">this</span> <span class="n">node</span><span class="p">:</span>
<span class="n">PP</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="n">PP</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="n">PP</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="n">PME</span><span class="p">:</span><span class="mi">1</span>
</pre></div>
</div>
<p>In this case, 3 ranks are set by user to compute short-range work
on GPU 0, and 1 rank to compute PME on GPU 1.
The detailed indexing of the GPUs is also reported in the log file.</p>
<p class="last">For more information about GPU tasks, please refer to
<a class="reference internal" href="#gmx-gpu-tasks"><span class="std std-ref">Types of GPU tasks</span></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">-pmefft</span></code></dt>
<dd>Allows choosing whether to execute the 3D FFT computation on a CPU or GPU.
Can be set to “auto”, “cpu”, “gpu.”.
When PME is offloaded to a GPU <code class="docutils literal"><span class="pre">-pmefft</span> <span class="pre">gpu</span></code> is the default,
and the entire PME calculation is executed on the GPU. However,
in some cases, e.g. with a relatively slow or older generation GPU
combined with fast CPU cores in a run, moving some work off of the GPU
back to the CPU by computing FFTs on the CPU can improve performance.</dd>
</dl>
<div class="section" id="examples-for-mdrun-on-one-node">
<h3>Examples for <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> on one node<a class="headerlink" href="#examples-for-mdrun-on-one-node" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">gmx</span> <span class="n">mdrun</span>
</pre></div>
</div>
<p>Starts <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> using all the available resources. <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a>
will automatically choose a fairly efficient division
into thread-MPI ranks, OpenMP threads and assign work
to compatible GPUs. Details will vary with hardware
and the kind of simulation being run.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">gmx</span> <span class="n">mdrun</span> <span class="o">-</span><span class="n">nt</span> <span class="mi">8</span>
</pre></div>
</div>
<p>Starts <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> using 8 threads, which might be thread-MPI
or OpenMP threads depending on hardware and the kind
of simulation being run.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">gmx</span> <span class="n">mdrun</span> <span class="o">-</span><span class="n">ntmpi</span> <span class="mi">2</span> <span class="o">-</span><span class="n">ntomp</span> <span class="mi">4</span>
</pre></div>
</div>
<p>Starts <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> using eight total threads, with four thread-MPI
ranks and two OpenMP threads per core. You should only use
these options when seeking optimal performance, and
must take care that the ranks you create can have
all of their OpenMP threads run on the same socket.
The number of ranks must be a multiple of the number of
sockets, and the number of cores per node must be
a multiple of the number of threads per rank.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">gmx</span> <span class="n">mdrun</span> <span class="o">-</span><span class="n">gpu_id</span> <span class="mi">12</span>
</pre></div>
</div>
<p>Starts <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> using GPUs with IDs 1 and 2 (e.g. because
GPU 0 is dedicated to running a display). This requires
two thread-MPI ranks, and will split the available
CPU cores between them using OpenMP threads.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">gmx</span> <span class="n">mdrun</span> <span class="o">-</span><span class="n">ntmpi</span> <span class="mi">4</span> <span class="o">-</span><span class="n">nb</span> <span class="n">gpu</span> <span class="o">-</span><span class="n">gputasks</span> <span class="mi">1122</span>
</pre></div>
</div>
<p>Starts <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> using four thread-MPI ranks, and maps them
to GPUs with IDs 1 and 2. The CPU cores available will
be split evenly between the ranks using OpenMP threads.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">gmx</span> <span class="n">mdrun</span> <span class="o">-</span><span class="n">nt</span> <span class="mi">6</span> <span class="o">-</span><span class="n">pin</span> <span class="n">on</span> <span class="o">-</span><span class="n">pinoffset</span> <span class="mi">0</span>
<span class="n">gmx</span> <span class="n">mdrun</span> <span class="o">-</span><span class="n">nt</span> <span class="mi">6</span> <span class="o">-</span><span class="n">pin</span> <span class="n">on</span> <span class="o">-</span><span class="n">pinoffset</span> <span class="mi">3</span>
</pre></div>
</div>
<p>Starts two <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> processes, each with six total threads.
Threads will have their affinities set to particular
logical cores, beginning from the logical core
with rank 0 or 3, respectively. The above would work
well on an Intel CPU with six physical cores and
hyper-threading enabled. Use this kind of setup only
if restricting <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> to a subset of cores to share a
node with other processes.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mpirun</span> <span class="o">-</span><span class="n">np</span> <span class="mi">2</span> <span class="n">gmx_mpi</span> <span class="n">mdrun</span>
</pre></div>
</div>
<p>When using an <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> compiled with external MPI,
this will start two ranks and as many OpenMP threads
as the hardware and MPI setup will permit. If the
MPI setup is restricted to one node, then the resulting
<a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> will be local to that node.</p>
</div>
</div>
<div class="section" id="running-mdrun-on-more-than-one-node">
<h2>Running <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> on more than one node<a class="headerlink" href="#running-mdrun-on-more-than-one-node" title="Permalink to this headline">¶</a></h2>
<p>This requires configuring GROMACS to build with an external MPI
library. By default, this <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> executable is run with
<a class="reference internal" href="../onlinehelp/gmx-mdrun.html#mdrun-mpi"><span class="std std-ref">gmx mdrun</span></a>. All of the considerations for running single-node
<a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> still apply, except that <code class="docutils literal"><span class="pre">-ntmpi</span></code> and <code class="docutils literal"><span class="pre">-nt</span></code> cause a fatal
error, and instead the number of ranks is controlled by the
MPI environment.
Settings such as <code class="docutils literal"><span class="pre">-npme</span></code> are much more important when
using multiple nodes. Configuring the MPI environment to
produce one rank per core is generally good until one
approaches the strong-scaling limit. At that point, using
OpenMP to spread the work of an MPI rank over more than one
core is needed to continue to improve absolute performance.
The location of the scaling limit depends on the processor,
presence of GPUs, network, and simulation algorithm, but
it is worth measuring at around ~200 particles/core if you
need maximum throughput.</p>
<p>There are further command-line parameters that are relevant in these
cases.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">-tunepme</span></code></dt>
<dd>Defaults to “on.” If “on,” a Verlet-scheme simulation will
optimize various aspects of the PME and DD algorithms, shifting
load between ranks and/or GPUs to maximize throughput. Some
<a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> features are not compatible with this, and these ignore
this option.</dd>
<dt><code class="docutils literal"><span class="pre">-dlb</span></code></dt>
<dd>Can be set to “auto,” “no,” or “yes.”
Defaults to “auto.” Doing Dynamic Load Balancing between MPI ranks
is needed to maximize performance. This is particularly important
for molecular systems with heterogeneous particle or interaction
density. When a certain threshold for performance loss is
exceeded, DLB activates and shifts particles between ranks to improve
performance.</dd>
<dt><code class="docutils literal"><span class="pre">-gcom</span></code></dt>
<dd>During the simulation <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> must communicate between all ranks to
compute quantities such as kinetic energy. By default, this
happens whenever plausible, and is influenced by a lot of <a class="reference internal" href="mdp-options.html#mdp-general"><span class="std std-ref">[.mdp]
options.</span></a> The period between communication phases
must be a multiple of <a class="reference internal" href="mdp-options.html#mdp-nstlist"><code class="xref std std-mdp docutils literal"><span class="pre">nstlist</span></code></a>, and defaults to
the minimum of <a class="reference internal" href="mdp-options.html#mdp-nstcalcenergy"><code class="xref std std-mdp docutils literal"><span class="pre">nstcalcenergy</span></code></a> and <a class="reference internal" href="mdp-options.html#mdp-nstlist"><code class="xref std std-mdp docutils literal"><span class="pre">nstlist</span></code></a>.
<code class="docutils literal"><span class="pre">mdrun</span> <span class="pre">-gcom</span></code> sets the number of steps that must elapse between
such communication phases, which can improve performance when
running on a lot of ranks. Note that this means that _e.g._
temperature coupling algorithms will
effectively remain at constant energy until the next
communication phase. <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> will always honor the
setting of <code class="docutils literal"><span class="pre">mdrun</span> <span class="pre">-gcom</span></code>, by changing <a class="reference internal" href="mdp-options.html#mdp-nstcalcenergy"><code class="xref std std-mdp docutils literal"><span class="pre">nstcalcenergy</span></code></a>,
<a class="reference internal" href="mdp-options.html#mdp-nstenergy"><code class="xref std std-mdp docutils literal"><span class="pre">nstenergy</span></code></a>, <a class="reference internal" href="mdp-options.html#mdp-nstlog"><code class="xref std std-mdp docutils literal"><span class="pre">nstlog</span></code></a>, <a class="reference internal" href="mdp-options.html#mdp-nsttcouple"><code class="xref std std-mdp docutils literal"><span class="pre">nsttcouple</span></code></a> and/or
<a class="reference internal" href="mdp-options.html#mdp-nstpcouple"><code class="xref std std-mdp docutils literal"><span class="pre">nstpcouple</span></code></a> if necessary.</dd>
</dl>
<p>Note that <code class="docutils literal"><span class="pre">-tunepme</span></code> has more effect when there is more than one
<a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a>, because the cost of communication for the PP and PME
ranks differs. It still shifts load between PP and PME ranks, but does
not change the number of separate PME ranks in use.</p>
<p>Note also that <code class="docutils literal"><span class="pre">-dlb</span></code> and <code class="docutils literal"><span class="pre">-tunepme</span></code> can interfere with each other, so
if you experience performance variation that could result from this,
you may wish to tune PME separately, and run the result with <code class="docutils literal"><span class="pre">mdrun</span>
<span class="pre">-notunepme</span> <span class="pre">-dlb</span> <span class="pre">yes</span></code>.</p>
<p>The <a class="reference internal" href="../onlinehelp/gmx-tune_pme.html#gmx-tune-pme"><span class="std std-ref">gmx tune_pme</span></a> utility is available to search a wider
range of parameter space, including making safe
modifications to the <a class="reference internal" href="file-formats.html#tpr"><span class="std std-ref">tpr</span></a> file, and varying <code class="docutils literal"><span class="pre">-npme</span></code>.
It is only aware of the number of ranks created by
the MPI environment, and does not explicitly manage
any aspect of OpenMP during the optimization.</p>
<div class="section" id="examples-for-mdrun-on-more-than-one-node">
<h3>Examples for <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> on more than one node<a class="headerlink" href="#examples-for-mdrun-on-more-than-one-node" title="Permalink to this headline">¶</a></h3>
<p>The examples and explanations for for single-node <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> are
still relevant, but <code class="docutils literal"><span class="pre">-ntmpi</span></code> is no longer the way
to choose the number of MPI ranks.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mpirun</span> <span class="o">-</span><span class="n">np</span> <span class="mi">16</span> <span class="n">gmx_mpi</span> <span class="n">mdrun</span>
</pre></div>
</div>
<p>Starts <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#mdrun-mpi"><span class="std std-ref">gmx mdrun</span></a> with 16 ranks, which are mapped to
the hardware by the MPI library, e.g. as specified
in an MPI hostfile. The available cores will be
automatically split among ranks using OpenMP threads,
depending on the hardware and any environment settings
such as <code class="docutils literal"><span class="pre">OMP_NUM_THREADS</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mpirun</span> <span class="o">-</span><span class="n">np</span> <span class="mi">16</span> <span class="n">gmx_mpi</span> <span class="n">mdrun</span> <span class="o">-</span><span class="n">npme</span> <span class="mi">5</span>
</pre></div>
</div>
<p>Starts <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#mdrun-mpi"><span class="std std-ref">gmx mdrun</span></a> with 16 ranks, as above, and
require that 5 of them are dedicated to the PME
component.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mpirun</span> <span class="o">-</span><span class="n">np</span> <span class="mi">11</span> <span class="n">gmx_mpi</span> <span class="n">mdrun</span> <span class="o">-</span><span class="n">ntomp</span> <span class="mi">2</span> <span class="o">-</span><span class="n">npme</span> <span class="mi">6</span> <span class="o">-</span><span class="n">ntomp_pme</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Starts <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#mdrun-mpi"><span class="std std-ref">gmx mdrun</span></a> with 11 ranks, as above, and
require that six of them are dedicated to the PME
component with one OpenMP thread each. The remaining
five do the PP component, with two OpenMP threads
each.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mpirun</span> <span class="o">-</span><span class="n">np</span> <span class="mi">4</span> <span class="n">gmx_mpi</span> <span class="n">mdrun</span> <span class="o">-</span><span class="n">ntomp</span> <span class="mi">6</span> <span class="o">-</span><span class="n">nb</span> <span class="n">gpu</span> <span class="o">-</span><span class="n">gputasks</span> <span class="mi">00</span>
</pre></div>
</div>
<p>Starts <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#mdrun-mpi"><span class="std std-ref">gmx mdrun</span></a> on a machine with two nodes, using
four total ranks, each rank with six OpenMP threads,
and both ranks on a node sharing GPU with ID 0.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mpirun</span> <span class="o">-</span><span class="n">np</span> <span class="mi">8</span> <span class="n">gmx_mpi</span> <span class="n">mdrun</span> <span class="o">-</span><span class="n">ntomp</span> <span class="mi">3</span> <span class="o">-</span><span class="n">gputasks</span> <span class="mi">0000</span>
</pre></div>
</div>
<p>Using a same/similar hardware as above,
starts <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#mdrun-mpi"><span class="std std-ref">gmx mdrun</span></a> on a machine with two nodes, using
eight total ranks, each rank with three OpenMP threads,
and all four ranks on a node sharing GPU with ID 0.
This may or may not be faster than the previous setup
on the same hardware.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mpirun</span> <span class="o">-</span><span class="n">np</span> <span class="mi">20</span> <span class="n">gmx_mpi</span> <span class="n">mdrun</span> <span class="o">-</span><span class="n">ntomp</span> <span class="mi">4</span> <span class="o">-</span><span class="n">gputasks</span> <span class="mi">00</span>
</pre></div>
</div>
<p>Starts <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#mdrun-mpi"><span class="std std-ref">gmx mdrun</span></a> with 20 ranks, and assigns the CPU cores evenly
across ranks each to one OpenMP thread. This setup is likely to be
suitable when there are ten nodes, each with one GPU, and each node
has two sockets each of four cores.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mpirun</span> <span class="o">-</span><span class="n">np</span> <span class="mi">10</span> <span class="n">gmx_mpi</span> <span class="n">mdrun</span> <span class="o">-</span><span class="n">gpu_id</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Starts <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#mdrun-mpi"><span class="std std-ref">gmx mdrun</span></a> with 20 ranks, and assigns the CPU cores evenly
across ranks each to one OpenMP thread. This setup is likely to be
suitable when there are ten nodes, each with two GPUs, but another
job on each node is using GPU 0. The job scheduler should set the
affinity of threads of both jobs to their allocated cores, or the
performance of <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> will suffer greatly.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mpirun</span> <span class="o">-</span><span class="n">np</span> <span class="mi">20</span> <span class="n">gmx_mpi</span> <span class="n">mdrun</span> <span class="o">-</span><span class="n">gpu_id</span> <span class="mi">01</span>
</pre></div>
</div>
<p>Starts <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#mdrun-mpi"><span class="std std-ref">gmx mdrun</span></a> with 20 ranks. This setup is likely
to be suitable when there are ten nodes, each with two
GPUs, but there is no need to specify <code class="docutils literal"><span class="pre">-gpu_id</span></code> for the
normal case where all the GPUs on the node are available
for use.</p>
</div>
</div>
<div class="section" id="controlling-the-domain-decomposition-algorithm">
<h2>Controlling the domain decomposition algorithm<a class="headerlink" href="#controlling-the-domain-decomposition-algorithm" title="Permalink to this headline">¶</a></h2>
<p>This section lists all the options that affect how the domain
decomposition algorithm decomposes the workload to the available
parallel hardware.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">-rdd</span></code></dt>
<dd>Can be used to set the required maximum distance for inter
charge-group bonded interactions. Communication for two-body
bonded interactions below the non-bonded cut-off distance always
comes for free with the non-bonded communication. Particles beyond
the non-bonded cut-off are only communicated when they have
missing bonded interactions; this means that the extra cost is
minor and nearly independent of the value of <code class="docutils literal"><span class="pre">-rdd</span></code>. With dynamic
load balancing, option <code class="docutils literal"><span class="pre">-rdd</span></code> also sets the lower limit for the
domain decomposition cell sizes. By default <code class="docutils literal"><span class="pre">-rdd</span></code> is determined
by <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> based on the initial coordinates. The chosen value will
be a balance between interaction range and communication cost.</dd>
<dt><code class="docutils literal"><span class="pre">-ddcheck</span></code></dt>
<dd>On by default. When inter charge-group bonded interactions are
beyond the bonded cut-off distance, <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> terminates with an
error message. For pair interactions and tabulated bonds that do
not generate exclusions, this check can be turned off with the
option <code class="docutils literal"><span class="pre">-noddcheck</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">-rcon</span></code></dt>
<dd>When constraints are present, option <code class="docutils literal"><span class="pre">-rcon</span></code> influences
the cell size limit as well.
Particles connected by NC constraints, where NC is the LINCS order
plus 1, should not be beyond the smallest cell size. A error
message is generated when this happens, and the user should change
the decomposition or decrease the LINCS order and increase the
number of LINCS iterations.  By default <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> estimates the
minimum cell size required for P-LINCS in a conservative
fashion. For high parallelization, it can be useful to set the
distance required for P-LINCS with <code class="docutils literal"><span class="pre">-rcon</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">-dds</span></code></dt>
<dd>Sets the minimum allowed x, y and/or z scaling of the cells with
dynamic load balancing. <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> will ensure that the cells can
scale down by at least this factor. This option is used for the
automated spatial decomposition (when not using <code class="docutils literal"><span class="pre">-dd</span></code>) as well as
for determining the number of grid pulses, which in turn sets the
minimum allowed cell size. Under certain circumstances the value
of <code class="docutils literal"><span class="pre">-dds</span></code> might need to be adjusted to account for high or low
spatial inhomogeneity of the system.</dd>
</dl>
</div>
<div class="section" id="finding-out-how-to-run-mdrun-better">
<h2>Finding out how to run <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> better<a class="headerlink" href="#finding-out-how-to-run-mdrun-better" title="Permalink to this headline">¶</a></h2>
<p>The Wallcycle module is used for runtime performance measurement of <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a>.
At the end of the log file of each run, the “Real cycle and time accounting” section
provides a table with runtime statistics for different parts of the <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> code
in rows of the table.
The table contains colums indicating the number of ranks and threads that
executed the respective part of the run, wall-time and cycle
count aggregates (across all threads and ranks) averaged over the entire run.
The last column also shows what precentage of the total runtime each row represents.
Note that the <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> timer resetting functionalities (<cite>-resethway</cite> and <cite>-resetstep</cite>)
reset the performance counters and therefore are useful to avoid startup overhead and
performance instability (e.g. due to load balancing) at the beginning of the run.</p>
<p>The performance counters are:</p>
<ul class="simple">
<li>Particle-particle during Particle mesh Ewald</li>
<li>Domain decomposition</li>
<li>Domain decomposition communication load</li>
<li>Domain decomposition communication bounds</li>
<li>Virtual site constraints</li>
<li>Send X to Particle mesh Ewald</li>
<li>Neighbor search</li>
<li>Launch GPU operations</li>
<li>Communication of coordinates</li>
<li>Born radii</li>
<li>Force</li>
<li>Waiting + Communication of force</li>
<li>Particle mesh Ewald</li>
<li>PME redist. X/F</li>
<li>PME spread</li>
<li>PME gather</li>
<li>PME 3D-FFT</li>
<li>PME 3D-FFT Communication</li>
<li>PME solve Lennard-Jones</li>
<li>PME solve LJ</li>
<li>PME solve Elec</li>
<li>PME wait for particle-particle</li>
<li>Wait + Receive PME force</li>
<li>Wait GPU nonlocal</li>
<li>Wait GPU local</li>
<li>Wait PME GPU spread</li>
<li>Wait PME GPU gather</li>
<li>Reduce PME GPU Force</li>
<li>Non-bonded position/force buffer operations</li>
<li>Virtual site spread</li>
<li>COM pull force</li>
<li>AWH (accelerated weight histogram method)</li>
<li>Write trajectory</li>
<li>Update</li>
<li>Constraints</li>
<li>Communication of energies</li>
<li>Enforced rotation</li>
<li>Add rotational forces</li>
<li>Position swapping</li>
<li>Interactive MD</li>
</ul>
<p>As performance data is collected for every run, they are essential to assessing
and tuning the performance of <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> performance. Therefore, they benefit
both code developers as well as users of the program.
The counters are an average of the time/cycles different parts of the simulation take,
hence can not directly reveal fluctuations during a single run (although comparisons across
multiple runs are still very useful).</p>
<p>Counters will appear in MD log file only if the related parts of the code were
executed during the <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> run. There is also a special counter called “Rest” which
indicated for the amount of time not accounted for by any of the counters above. Theerfore,
a significant amount “Rest” time (more than a few percent) will often be an indication of
parallelization inefficiency (e.g. serial code) and it is recommended to be reported to the
developers.</p>
<p>An additional set of subcounters can offer more fine-grained inspection of performance. They are:</p>
<ul class="simple">
<li>Domain decomposition redistribution</li>
<li>DD neighbor search grid + sort</li>
<li>DD setup communication</li>
<li>DD make topology</li>
<li>DD make constraints</li>
<li>DD topology other</li>
<li>Neighbor search grid local</li>
<li>NS grid non-local</li>
<li>NS search local</li>
<li>NS search non-local</li>
<li>Bonded force</li>
<li>Bonded-FEP force</li>
<li>Restraints force</li>
<li>Listed buffer operations</li>
<li>Nonbonded pruning</li>
<li>Nonbonded force</li>
<li>Launch non-bonded GPU tasks</li>
<li>Launch PME GPU tasks</li>
<li>Ewald force correction</li>
<li>Non-bonded position buffer operations</li>
<li>Non-bonded force buffer operations</li>
</ul>
<p>Subcounters are geared toward developers and have to be enabled during compilation. See
<a class="reference internal" href="../dev-manual/build-system.html"><span class="doc">Build system overview</span></a> for more information.</p>
<p>TODO In future patch:
- red flags in log files, how to interpret wallcycle output
- hints to devs how to extend wallcycles</p>
<p>TODO In future patch: import wiki page stuff on performance checklist; maybe here,
maybe elsewhere</p>
</div>
<div class="section" id="running-mdrun-with-gpus">
<span id="gmx-mdrun-on-gpu"></span><h2>Running <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a> with GPUs<a class="headerlink" href="#running-mdrun-with-gpus" title="Permalink to this headline">¶</a></h2>
<p>NVIDIA GPUs from the professional line (Tesla or Quadro) starting with
the Kepler generation (compute capability 3.5 and later) support changing the
processor and memory clock frequency with the help of the applications clocks feature.
With many workloads, using higher clock rates than the default provides significant
performance improvements.
For more information see the <a class="reference external" href="https://devblogs.nvidia.com/parallelforall/increase-performance-gpu-boost-k80-autoboost/">NVIDIA blog article</a> on this topic.
For GROMACS the highest application clock rates are optimal on all hardware
available to date (up to and including Maxwell, compute capability 5.2).</p>
<p>Application clocks can be set using the NVIDIA system managemet tool
<code class="docutils literal"><span class="pre">nvidia-smi</span></code>. If the system permissions allow, <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> has
built-in support to set application clocks if built with <a class="reference internal" href="../install-guide/index.html#cuda-gpu-acceleration"><span class="std std-ref">NVML support</span></a>.
Note that application clocks are a global setting, hence affect the
performance of all applications that use the respective GPU(s).
For this reason, <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> sets application clocks at initialization
to the values optimal for GROMACS and it restores them before exiting
to the values found at startup, unless it detects that they were altered
during its runtime.</p>
<div class="section" id="types-of-gpu-tasks">
<span id="gmx-gpu-tasks"></span><h3>Types of GPU tasks<a class="headerlink" href="#types-of-gpu-tasks" title="Permalink to this headline">¶</a></h3>
<p>To better understand the later sections on different GPU use cases for
calculation of <a class="reference internal" href="#gmx-gpu-pp"><span class="std std-ref">short range</span></a> and <a class="reference internal" href="#gmx-gpu-pme"><span class="std std-ref">PME</span></a>,
we first introduce the concept of different GPU tasks. When thinking about
running a simulation, several different kinds of interactions between the atoms
have to be calculated (for more information please refer to the reference manual).
The calculation can thus be split into several distinct parts that are largely independent
of each other (hence can be calculated in any order, e.g. sequentially or concurrently),
with the information from each of them combined at the end of
time step to obtain the final forces on each atom and to propagate the system
to the next time point. For a better understanding also please see the section
on <a class="reference internal" href="#gmx-domain-decomp"><span class="std std-ref">domain decomposition</span></a>.</p>
<p>Of all calculations required for an MD step,
GROMACS aims to optimize performance bottom-up for each step
from the lowest level (SIMD unit, cores, sockets, accelerators, etc.).
Therefore much of the indivdual computation units are
highly tuned for the lowest level of hardware parallelism: the SIMD units.
Additionally, with GPU accelerators used as <em>co-processors</em>, some of the work
can be <em>offloaded</em>, that is calculated simultaneously/concurrently with the CPU
on the accelerator device, with the result being communicated to the CPU.
Right now, GROMACS supports GPU accelerator offload of two tasks:
the short-range <a class="reference internal" href="#gmx-gpu-pp"><span class="std std-ref">nonbonded interactions in real space</span></a>,
and <a class="reference internal" href="#gmx-gpu-pme"><span class="std std-ref">PME</span></a>.</p>
<p><strong>Please note that the solving of PME on GPU is still only the initial
version supporting this behaviour, and comes with a set of limitations
outlined further below.</strong></p>
<p>Right now, we generally support short-range nonbonded offload with and
without dynamic pruning on a wide range of GPU accelerators
(both NVIDIA and AMD). This is compatible with the grand majority of
the features and parallelization modes and can be used to scale to large machines.</p>
<p>Simultaneously offloading both short-range nonbonded and long-range
PME work to GPU accelerators is a new feature that that has some
restrictions in terms of feature and parallelization
compatibility (please see the <a class="reference internal" href="#gmx-pme-gpu-limitations"><span class="std std-ref">section below</span></a>).</p>
<div class="section" id="gpu-computation-of-short-range-nonbonded-interactions">
<span id="gmx-gpu-pp"></span><h4>GPU computation of short range nonbonded interactions<a class="headerlink" href="#gpu-computation-of-short-range-nonbonded-interactions" title="Permalink to this headline">¶</a></h4>
<p>Using the GPU for the short-ranged nonbonded interactions provides
the majority of the available speed-up compared to run using only the CPU.
Here, the GPU acts as an accelerator that can effectively parallelize
this problem and thus reduce the calculation time.</p>
</div>
<div class="section" id="gpu-accelerated-calculation-of-pme">
<span id="gmx-gpu-pme"></span><h4>GPU accelerated calculation of PME<a class="headerlink" href="#gpu-accelerated-calculation-of-pme" title="Permalink to this headline">¶</a></h4>
<p>Recent additions to GROMACS now also allow the off-loading of the PME calculation
to the GPU, to further reduce the load on the CPU and improve usage overlap between
CPU and GPU. Here, the solving of PME will be performed in addition to the calculation
of the short range interactions on the same GPU as the short range interactions.</p>
</div>
<div class="section" id="known-limitations">
<span id="gmx-pme-gpu-limitations"></span><h4>Known limitations<a class="headerlink" href="#known-limitations" title="Permalink to this headline">¶</a></h4>
<p><strong>Please note again the limitations outlined below!</strong></p>
<ul class="simple">
<li>Only compilation with CUDA is supported.</li>
<li>Only a PME order of 4 is supported on GPUs.</li>
<li>PME will run on a GPU only when exactly one rank has a
PME task, ie. decompositions with multiple ranks doing PME are not supported.</li>
<li>Only single precision is supported.</li>
<li>Free energy calculations where charges are perturbed are not supported,
because only single PME grids can be calculated.</li>
<li>Only dynamical integrators are supported (ie. leap-frog, Velocity Verlet,
stochastic dynamics)</li>
<li>LJ PME is not supported on GPUs.</li>
</ul>
</div>
<div class="section" id="assigning-tasks-to-gpus">
<h4>Assigning tasks to GPUs<a class="headerlink" href="#assigning-tasks-to-gpus" title="Permalink to this headline">¶</a></h4>
<p>Depending on which tasks should be performed on which hardware, different kinds of
calculations can be combined on the same or different GPUs, according to the information
provided for running <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">mdrun</span></a>.</p>
<p>It is possible to assign the calculation of the different computational tasks to the same GPU, meaning
that they will share the computational resources on the same device, or to different processing units
that will each perform one task each.</p>
<p>One overview over the possible task assignments is given below:</p>
<p>GROMACS version 2018:</p>
<blockquote>
<div><p>Two different types of GPU accelerated tasks are available, NB and PME.
Each PP rank has a NB task that can be offloaded to a GPU.
If there is only one rank with a PME task (including if that rank is a
PME-only rank), then that task can be offloaded to a GPU. Such a PME
task can run wholly on the GPU, or have its latter stages run only on the CPU.</p>
<p>Limitations are that PME on GPU does not support PME domain decomposition,
so that only one PME task can be offloaded to a single GPU
assigned to a separate PME rank, while NB can be decomposed and offloaded to multiple GPUs.</p>
</div></blockquote>
</div>
<div class="section" id="performance-considerations-for-gpu-tasks">
<h4>Performance considerations for GPU tasks<a class="headerlink" href="#performance-considerations-for-gpu-tasks" title="Permalink to this headline">¶</a></h4>
<ol class="arabic simple">
<li>The performace balance depends on how many (and how fast) CPU
cores you have, vs. how many and how fast the GPUs are that you have.</li>
<li>With slow/old GPUs and/or fast/modern CPUs with many
cores, it might make more sense to let the CPU do PME calculation,
with the GPUs focused on the calculation of the NB.</li>
<li>With fast/modern GPUs and/or slow/old CPUs with few cores,
it generally helps to have the GPU do PME.</li>
<li>It <em>is</em> possible to use multiple GPUs with PME offload
by letting e.g.
3 MPI ranks use one GPU each for short-range interactions,
while a fourth rank does the PME on its GPU.</li>
<li>The only way to know for sure what alternative is best for
your machine is to test and check performance.</li>
</ol>
</div>
</div>
<div class="section" id="reducing-overheads-in-gpu-accelerated-runs">
<h3>Reducing overheads in GPU accelerated runs<a class="headerlink" href="#reducing-overheads-in-gpu-accelerated-runs" title="Permalink to this headline">¶</a></h3>
<p>In order for CPU cores and GPU(s) to execute concurrently, tasks are
launched and executed asynchronously on the GPU(s) while the CPU cores
execute non-offloaded force computation (like long-range PME electrostatics).
Asynchronous task launches are handled by GPU device driver and
require CPU involvement. Therefore, the work of scheduling
GPU tasks will incur an overhead that can in some cases significantly
delay or interfere with the CPU execution.</p>
<p>Delays in CPU execution are caused by the latency of launching GPU tasks,
an overhead that can become significant as simulation ns/day increases
(i.e. with shorter wall-time per step).
The overhead is measured by <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> and reported in the performance
summary section of the log file (“Launch GPU ops” row).
A few percent of runtime spent in this category is normal,
but in fast-iterating and multi-GPU parallel runs 10% or larger overheads can be observed.
In general, there a user can do little to avoid such overheads, but there
are a few cases where tweaks can give performance benefits.
In single-rank runs timing of GPU tasks is by default enabled and,
while in most cases its impact is small, in fast runs performance can be affected.
The performance impact will be most significant on NVIDIA GPUs with CUDA,
less on AMD with OpenCL.
In these cases, when more than a few percent of “Launch GPU ops” time is observed,
it is recommended turning off timing by setting the <code class="docutils literal"><span class="pre">GMX_DISABLE_GPU_TIMING</span></code>
environment variable.
In parallel runs with with many ranks sharing a GPU
launch overheads can also be reduced by staring fewer thread-MPI
or MPI ranks per GPU; e.g. most often one rank per thread or core is not optimal.</p>
<p>The second type of overhead, interference of the GPU driver with CPU computation,
is caused by the scheduling and coordination of GPU tasks.
A separate GPU driver thread can require CPU resources
which may clash with the concurrently running non-offloaded tasks,
potentially degrading the performance of PME or bonded force computation.
This effect is most pronounced when using AMD GPUs with OpenCL with
older driver releases (e.g. fglrx 12.15).
To minimize the overhead it is recommended to
leave a CPU hardware thread unused when launching <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a>,
especially on CPUs with high core count and/or HyperThreading enabled.
E.g. on a machine with a 4-core CPU and eight threads (via HyperThreading) and an AMD GPU,
try <code class="docutils literal"><span class="pre">gmx</span> <span class="pre">mdrun</span> <span class="pre">-ntomp</span> <span class="pre">7</span> <span class="pre">-pin</span> <span class="pre">on</span></code>.
This will leave free CPU resources for the GPU task scheduling
reducing interference with CPU computation.
Note that assigning fewer resources to <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> CPU computation
involves a tradeoff which may outweigh the benefits of reduced GPU driver overhead,
in particular without HyperThreading and with few CPU cores.</p>
<p>TODO In future patch: any tips not covered above</p>
</div>
</div>
<div class="section" id="running-the-opencl-version-of-mdrun">
<h2>Running the OpenCL version of mdrun<a class="headerlink" href="#running-the-opencl-version-of-mdrun" title="Permalink to this headline">¶</a></h2>
<p>The current version works with GCN-based AMD GPUs, and NVIDIA CUDA
GPUs. Make sure that you have the latest drivers installed. For AMD GPUs,
the compute-oriented <a class="reference external" href="https://rocm.github.io/">ROCm</a> stack is recommended;
alternatively, the AMDGPU-PRO stack is also compatible; using the outdated
and unsupported <cite>fglrx</cite> proprietary driver and runtime is not recommended (but
for certain older hardware that may be the only way to obtain support).
In addition Mesa version 17.0 or newer with LLVM 4.0 or newer is also supported.
For NVIDIA GPUs, using the proprietary driver is
required as the open source nouveau driver (available in Mesa) does not
provide the OpenCL support.
The minimum OpenCL version required is 1.1. See
also the <a class="reference internal" href="#opencl-known-limitations"><span class="std std-ref">known limitations</span></a>.</p>
<p>Devices from the AMD GCN architectures (all series) are compatible
and regularly tested; NVIDIA Fermi and later (compute capability 2.0)
are known to work, but before doing production runs always make sure that the GROMACS tests
pass successfully on the hardware.</p>
<p>The OpenCL GPU kernels are compiled at run time. Hence,
building the OpenCL program can take a few seconds introducing a slight
delay in the <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> startup. This is not normally a
problem for long production MD, but you might prefer to do some kinds
of work, e.g. that runs very few steps, on just the CPU (e.g. see <code class="docutils literal"><span class="pre">-nb</span></code> above).</p>
<p>The same <code class="docutils literal"><span class="pre">-gpu_id</span></code> option (or <code class="docutils literal"><span class="pre">GMX_GPU_ID</span></code> environment variable)
used to select CUDA devices, or to define a mapping of GPUs to PP
ranks, is used for OpenCL devices.</p>
<p>Some other <a class="reference internal" href="environment-variables.html#opencl-management"><span class="std std-ref">OpenCL management</span></a> environment
variables may be of interest to developers.</p>
<div class="section" id="known-limitations-of-the-opencl-support">
<span id="opencl-known-limitations"></span><h3>Known limitations of the OpenCL support<a class="headerlink" href="#known-limitations-of-the-opencl-support" title="Permalink to this headline">¶</a></h3>
<p>Limitations in the current OpenCL support of interest to GROMACS users:</p>
<ul class="simple">
<li>PME GPU offload is not supported with OpenCL.</li>
<li>No Intel devices (CPUs, GPUs or Xeon Phi) are supported</li>
<li>Due to blocking behavior of some asynchronous task enqueuing functions
in the NVIDIA OpenCL runtime, with the affected driver versions there is
almost no performance gain when using NVIDIA GPUs.
The issue affects NVIDIA driver versions up to 349 series, but it
known to be fixed 352 and later driver releases.</li>
<li>On NVIDIA GPUs the OpenCL kernels achieve much lower performance
than the equivalent CUDA kernels due to limitations of the NVIDIA OpenCL
compiler.</li>
</ul>
<p>Limitations of interest to GROMACS developers:</p>
<ul class="simple">
<li>The current implementation is not compatible with OpenCL devices that are
not using warp/wavefronts or for which the warp/wavefront size is not a
multiple of 32</li>
</ul>
</div>
</div>
<div class="section" id="performance-checklist">
<h2>Performance checklist<a class="headerlink" href="#performance-checklist" title="Permalink to this headline">¶</a></h2>
<p>There are many different aspects that affect the performance of simulations in
GROMACS. Most simulations require a lot of computational resources, therefore
it can be worthwhile to optimize the use of those resources. Several issues
mentioned in the list below could lead to a performance difference of a factor
of 2. So it can be useful go through the checklist.</p>
<div class="section" id="gromacs-configuration">
<h3>GROMACS configuration<a class="headerlink" href="#gromacs-configuration" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Don’t use double precision unless you’re absolute sure you need it.</li>
<li>Compile the FFTW library (yourself) with the correct flags on x86 (in most
cases, the correct flags are automatically configured).</li>
<li>On x86, use gcc or icc as the compiler (not pgi or the Cray compiler).</li>
<li>On POWER, use gcc instead of IBM’s xlc.</li>
<li>Use a new compiler version, especially for gcc (e.g. from the version 5 to 6
the performance of the compiled code improved a lot).</li>
<li>MPI library: OpenMPI usually has good performance and causes little trouble.</li>
<li>Make sure your compiler supports OpenMP (some versions of Clang don’t).</li>
<li>If you have GPUs that support either CUDA or OpenCL, use them.<ul>
<li>Configure with <code class="docutils literal"><span class="pre">-DGMX_GPU=ON</span></code> (add <code class="docutils literal"><span class="pre">-DGMX_USE_OPENCL=ON</span></code> for OpenCL).</li>
<li>For CUDA, use the newest CUDA availabe for your GPU to take advantage of the
latest performance enhancements.</li>
<li>Use a recent GPU driver.</li>
<li>If compiling on a cluster head node, make sure that <code class="docutils literal"><span class="pre">GMX_SIMD</span></code>
is appropriate for the compute nodes.</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="run-setup">
<h3>Run setup<a class="headerlink" href="#run-setup" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>For an approximately spherical solute, use a rhombic dodecahedron unit cell.</li>
<li>When using a time-step of 2 fs, use <a class="reference internal" href="mdp-options.html#mdp-value-constraints=h-bonds"><code class="xref std std-mdp-value docutils literal"><span class="pre">constraints=h-bonds</span></code></a>
(and not <a class="reference internal" href="mdp-options.html#mdp-value-constraints=all-bonds"><code class="xref std std-mdp-value docutils literal"><span class="pre">constraints=all-bonds</span></code></a>), since this is faster, especially with GPUs,
and most force fields have been parametrized with only bonds involving
hydrogens constrained.</li>
<li>You can increase the time-step to 4 or 5 fs when using virtual interaction
sites (<code class="docutils literal"><span class="pre">gmx</span> <span class="pre">pdb2gmx</span> <span class="pre">-vsite</span> <span class="pre">h</span></code>).</li>
<li>For massively parallel runs with PME, you might need to try different numbers
of PME ranks (<code class="docutils literal"><span class="pre">gmx</span> <span class="pre">mdrun</span> <span class="pre">-npme</span> <span class="pre">???</span></code>) to achieve best performance;
<a class="reference internal" href="../onlinehelp/gmx-tune_pme.html#gmx-tune-pme"><span class="std std-ref">gmx tune_pme</span></a> can help automate this search.</li>
<li>For massively parallel runs (also <code class="docutils literal"><span class="pre">gmx</span> <span class="pre">mdrun</span> <span class="pre">-multidir</span></code>), or with a slow
network, global communication can become a bottleneck and you can reduce it
with <code class="docutils literal"><span class="pre">gmx</span> <span class="pre">mdrun</span> <span class="pre">-gcom</span></code> (note that this does affect the frequency of
temperature and pressure coupling).</li>
</ul>
</div>
<div class="section" id="checking-and-improving-performance">
<h3>Checking and improving performance<a class="headerlink" href="#checking-and-improving-performance" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Look at the end of the <code class="docutils literal"><span class="pre">md.log</span></code> file to see the performance and the cycle
counters and wall-clock time for different parts of the MD calculation. The
PP/PME load ratio is also printed, with a warning when a lot of performance is
lost due to imbalance.</li>
<li>Adjust the number of PME ranks and/or the cut-off and PME grid-spacing when
there is a large PP/PME imbalance. Note that even with a small reported
imbalance, the automated PME-tuning might have reduced the initial imbalance.
You could still gain performance by changing the mdp parameters or increasing
the number of PME ranks.</li>
<li>If the neighbor searching takes a lot of time, increase nstlist (with the
Verlet cut-off scheme, this automatically adjusts the size of the neighbour
list to do more non-bonded computation to keep energy drift constant).<ul>
<li>If <code class="docutils literal"><span class="pre">Comm.</span> <span class="pre">energies</span></code> takes a lot of time (a note will be printed in the log
file), increase nstcalcenergy or use <code class="docutils literal"><span class="pre">mdrun</span> <span class="pre">-gcom</span></code>.</li>
<li>If all communication takes a lot of time, you might be running on too many
cores, or you could try running combined MPI/OpenMP parallelization with 2
or 4 OpenMP threads per MPI process.</li>
</ul>
</li>
</ul>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Getting good performance from <code class="docutils literal"><span class="pre">mdrun</span></code></a><ul>
<li><a class="reference internal" href="#hardware-background-information">Hardware background information</a></li>
<li><a class="reference internal" href="#gromacs-background-information">GROMACS background information</a></li>
<li><a class="reference internal" href="#running-mdrun-within-a-single-node">Running <code class="docutils literal"><span class="pre">mdrun</span></code> within a single node</a><ul>
<li><a class="reference internal" href="#examples-for-mdrun-on-one-node">Examples for <code class="docutils literal"><span class="pre">mdrun</span></code> on one node</a></li>
</ul>
</li>
<li><a class="reference internal" href="#running-mdrun-on-more-than-one-node">Running <code class="docutils literal"><span class="pre">mdrun</span></code> on more than one node</a><ul>
<li><a class="reference internal" href="#examples-for-mdrun-on-more-than-one-node">Examples for <code class="docutils literal"><span class="pre">mdrun</span></code> on more than one node</a></li>
</ul>
</li>
<li><a class="reference internal" href="#controlling-the-domain-decomposition-algorithm">Controlling the domain decomposition algorithm</a></li>
<li><a class="reference internal" href="#finding-out-how-to-run-mdrun-better">Finding out how to run <code class="docutils literal"><span class="pre">mdrun</span></code> better</a></li>
<li><a class="reference internal" href="#running-mdrun-with-gpus">Running <code class="docutils literal"><span class="pre">mdrun</span></code> with GPUs</a><ul>
<li><a class="reference internal" href="#types-of-gpu-tasks">Types of GPU tasks</a><ul>
<li><a class="reference internal" href="#gpu-computation-of-short-range-nonbonded-interactions">GPU computation of short range nonbonded interactions</a></li>
<li><a class="reference internal" href="#gpu-accelerated-calculation-of-pme">GPU accelerated calculation of PME</a></li>
<li><a class="reference internal" href="#known-limitations">Known limitations</a></li>
<li><a class="reference internal" href="#assigning-tasks-to-gpus">Assigning tasks to GPUs</a></li>
<li><a class="reference internal" href="#performance-considerations-for-gpu-tasks">Performance considerations for GPU tasks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reducing-overheads-in-gpu-accelerated-runs">Reducing overheads in GPU accelerated runs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#running-the-opencl-version-of-mdrun">Running the OpenCL version of mdrun</a><ul>
<li><a class="reference internal" href="#known-limitations-of-the-opencl-support">Known limitations of the OpenCL support</a></li>
</ul>
</li>
<li><a class="reference internal" href="#performance-checklist">Performance checklist</a><ul>
<li><a class="reference internal" href="#gromacs-configuration">GROMACS configuration</a></li>
<li><a class="reference internal" href="#run-setup">Run setup</a></li>
<li><a class="reference internal" href="#checking-and-improving-performance">Checking and improving performance</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="mdrun-features.html"
                        title="previous chapter">Useful mdrun features</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="run-time-errors.html"
                        title="next chapter">Common errors when using GROMACS</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/user-guide/mdrun-performance.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="run-time-errors.html" title="Common errors when using GROMACS"
             >next</a> |</li>
        <li class="right" >
          <a href="mdrun-features.html" title="Useful mdrun features"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">GROMACS 2018.3</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >User guide</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, GROMACS development team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.1.
    </div>
  </body>
</html>